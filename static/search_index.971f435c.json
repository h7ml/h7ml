[{"id":1,"title":"== 和 ===区别，分别在什么情况使用","content":"#\n\n\n\n\n一、等于操作符#\n\n等于操作符用两个等于号（ == ）表示，如果操作数相等，则会返回 true\n\n前面文章，我们提到在JavaScript中存在隐式转换。等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等\n\n遵循以下规则：\n\n如果任一操作数是布尔值，则将其转换为数值再比较是否相等\n\n\n\n如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等\n\n\n\n如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较\n\n\n\nnull和undefined相等\n\n\n\n如果有任一操作数是 NaN ，则相等操作符返回 false\n\n\n\n如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true\n\n\n\n下面进一步做个小结：\n\n * 两个都为简单类型，字符串和布尔值都会转换成数值，再比较\n\n * 简单类型与引用类型比较，对象转化成其原始类型的值，再比较\n\n * 两个都为引用类型，则比较它们是否指向同一个对象\n\n * null 和 undefined 相等\n\n * 存在 NaN 则返回 false\n\n\n二、全等操作符#\n\n全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同\n\n\n\nundefined 和 null 与自身严格相等\n\n\n\n\n三、区别#\n\n相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换\n\n\n\nnull 和 undefined 比较，相等操作符（==）为true，全等为false\n\n\n\n\n小结#\n\n相等运算符隐藏的类型转换，会带来一些违反直觉的结果\n\n\n\n但在比较null的情况的时候，我们一般使用相等操作符==\n\n\n\n等同于下面写法\n\n\n\n使用相等操作符（==）的写法明显更加简洁了\n\n所以，除了在比较对象属性为null或者undefined的情况下，我们可以使用相等操作符（==），其他情况建议一律使用全等操作符（===）","routePath":"/interview/JavaScript/== _===","lang":"","toc":[{"text":"一、等于操作符","id":"一等于操作符","depth":2,"charIndex":5},{"text":"二、全等操作符","id":"二全等操作符","depth":2,"charIndex":525},{"text":"三、区别","id":"三区别","depth":2,"charIndex":628},{"text":"小结","id":"小结","depth":3,"charIndex":723}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-== 和 ===区别，分别在什么情况使用","footer":"== 和 ===区别，分别在什么情况使用","order":17,"star":17,"date":"2023-04-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-== 和 ===区别，分别在什么情况使用","isOriginal":false,"head":[["meta",{"name":"keywords","content":"== 和 ===区别，分别在什么情况使用"}]]},"version":""},{"id":2,"title":"说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？","content":"#\n\n\n\n\n一、是什么#\n\nBOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象\n\n其作用就是跟浏览器做一些交互效果,比如如何进行页面的后退，前进，刷新，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率\n\n浏览器的全部内容可以看成DOM，整个浏览器可以看成BOM。区别如下：\n\n\n\n\n二、window#\n\nBom的核心对象是window，它表示浏览器的一个实例\n\n在浏览器中，window对象有双重角色，即是浏览器窗口的一个接口，又是全局对象\n\n因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法\n\n\n\n关于窗口控制方法如下：\n\n * moveBy(x,y)：从当前位置水平移动窗体 x 个像素，垂直移动窗体 y 个像素，x 为负数，将向左移动窗体，y 为负数，将向上移动窗体\n * moveTo(x,y)：移动窗体左上角到相对于屏幕左上角的(x,y)点\n * resizeBy(w,h)：相对窗体当前的大小，宽度调整 w 个像素，高度调整 h 个像素。如果参数为负值，将缩小窗体，反之扩大窗体\n * resizeTo(w,h)：把窗体宽度调整为 w 个像素，高度调整为 h 个像素\n * scrollTo(x,y)：如果有滚动条，将横向滚动条移动到相对于窗体宽度为 x 个像素的位置，将纵向滚动条移动到相对于窗体高度为 y 个像素的位置\n * scrollBy(x,y)： 如果有滚动条，将横向滚动条向左移动 x 个像素，将纵向滚动条向下移动 y 个像素\n\nwindow.open() 既可以导航到一个特定的url，也可以打开一个新的浏览器窗口\n\n如果 window.open() 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的 URL\n\n\n\nwindow.open() 会返回新窗口的引用，也就是新窗口的 window 对象\n\n\n\nwindow.close() 仅用于通过 window.open() 打开的窗口\n\n新创建的 window 对象有一个 opener 属性，该属性指向打开他的原始窗口对象\n\n\n三、location#\n\nurl地址如下：\n\n\n\nlocation属性描述如下：\n\n属性名        例子                                                       说明\nhash       \"#contents\"                                              utl 中#后面的字符，没有则返回空串\nhost       www.wrox.com:80                                          服务器名称和端口号\nhostname   www.wrox.com                                             域名，不带端口号\nhref       http://www.wrox.com:80/WileyCDA/?q=javascript#contents   完整 url\npathname   \"/WileyCDA/\"                                             服务器下面的文件路径\nport       80                                                       url 的端口号，没有则为空\nprotocol   http:                                                    使用的协议\nsearch     ?q=javascript                                            url 的查询字符串，通常为？后面的内容\n\n除了 hash之外，只要修改location的一个属性，就会导致页面重新加载新URL\n\nlocation.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重\n新加载\n\n如果要强制从服务器中重新加载，传递一个参数true即可\n\n\n四、navigator#\n\nnavigator 对象主要用来获取浏览器的属性，区分浏览器类型。属性较多，且兼容性比较复杂\n\n下表列出了navigator对象接口定义的属性和方法：\n\n\n\n\n\n\n五、screen#\n\n保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度\n\n\n\n\n六、history#\n\nhistory对象主要用来操作浏览器URL的历史记录，可以通过参数向前，向后，或者向指定URL跳转\n\n常用的属性如下：\n\n * history.go()\n\n接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转，\n\n\n\n当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面\n\n\n\n * history.forward()：向前跳转一个页面\n * history.back()：向后跳转一个页面\n * history.length：获取历史记录数","routePath":"/interview/JavaScript/BOM","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、window","id":"二window","depth":2,"charIndex":191},{"text":"三、location","id":"三location","depth":2,"charIndex":939},{"text":"四、navigator","id":"四navigator","depth":2,"charIndex":1856},{"text":"五、screen","id":"五screen","depth":2,"charIndex":1952},{"text":"六、history","id":"六history","depth":2,"charIndex":2014}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？","footer":"说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？","order":33,"star":33,"date":"2023-05-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？"}]]},"version":""},{"id":3,"title":"DOM 常见的操作有哪些？","content":"Hello World!","routePath":"/interview/JavaScript/Dom","lang":"","toc":[{"text":"一、DOM","id":"一dom","depth":2,"charIndex":-1},{"text":"二、操作","id":"二操作","depth":2,"charIndex":-1},{"text":"创建节点","id":"创建节点","depth":3,"charIndex":-1},{"text":"createElement","id":"createelement","depth":4,"charIndex":-1},{"text":"createTextNode","id":"createtextnode","depth":4,"charIndex":-1},{"text":"createDocumentFragment","id":"createdocumentfragment","depth":4,"charIndex":-1},{"text":"createAttribute","id":"createattribute","depth":4,"charIndex":-1},{"text":"获取节点","id":"获取节点","depth":3,"charIndex":-1},{"text":"querySelector","id":"queryselector","depth":4,"charIndex":-1},{"text":"querySelectorAll","id":"queryselectorall","depth":4,"charIndex":-1},{"text":"更新节点","id":"更新节点","depth":3,"charIndex":-1},{"text":"innerHTML","id":"innerhtml","depth":4,"charIndex":-1},{"text":"innerText、textContent","id":"innertexttextcontent","depth":4,"charIndex":-1},{"text":"style","id":"style","depth":4,"charIndex":-1},{"text":"添加节点","id":"添加节点","depth":3,"charIndex":-1},{"text":"innerHTML","id":"innerhtml-1","depth":4,"charIndex":-1},{"text":"appendChild","id":"appendchild","depth":4,"charIndex":-1},{"text":"insertBefore","id":"insertbefore","depth":4,"charIndex":-1},{"text":"setAttribute","id":"setattribute","depth":4,"charIndex":-1},{"text":"删除节点","id":"删除节点","depth":3,"charIndex":-1},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-DOM 常见的操作有哪些？","footer":"DOM 常见的操作有哪些？","order":29,"star":29,"date":"2023-05-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-DOM 常见的操作有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"DOM 常见的操作有哪些？"}]]},"version":""},{"id":4,"title":"前端物语|面试物语-JavaScript","content":" * [ == 和 ===区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/==\n   _===)\n * 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？\n * DOM 常见的操作有哪些？\n * ajax 原理是什么？如何实现？\n * 数组的常用方法有哪些？\n * bind、call、apply 区别？如何实现一个 bind?\n * Javascript 本地存储的方式有哪些？区别及应用场景？\n * 说说你对闭包的理解？闭包使用场景\n * JavaScript 中执行上下文和执行栈是什么？\n * 大文件上传如何做断点续传？\n * 深拷贝浅拷贝的区别？如何实现一个深拷贝？\n * 说说 JavaScript 中的数据类型？存储上的差别？\n * 什么是防抖和节流？有什么区别？如何实现？\n * 说说 JavaScript 中的事件模型\n * 解释下什么是事件代理？应用场景？\n * 说说你对事件循环的理解\n * Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？\n * 说说你对函数式编程的理解？优缺点？\n * Javascript 如何实现继承？\n * 说说你了解的 js 数据结构？\n * 说说 Javascript 数字精度丢失的问题，如何解决？\n * 说说 JavaScript 中内存泄漏的几种情况？\n * 说说 new 操作符具体干了什么？\n * JavaScript 原型，原型链 ? 有什么特点？\n * 如何实现上拉加载，下拉刷新？\n * 说说你对正则表达式的理解？应用场景？\n * 说说你对作用域链的理解\n * web 常见的攻击方式有哪些？如何防御？\n * 什么是单点登录？如何实现？\n * JavaScript 字符串的常用方法有哪些？\n * 举例说明你对尾递归的理解，有哪些应用场景\n * 谈谈 this 对象的理解\n * 谈谈 JavaScript 中的类型转换机制\n * typeof 与 instanceof 区别\n * 如何判断一个元素是否在可视区域中？","routePath":"/interview/JavaScript/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"JavaScript","tag":"JavaScript","title":"前端物语|面试物语-JavaScript","index":false,"dir":{"order":1},"date":"2023-05-26T00:00:00.000Z"},"version":""},{"id":5,"title":"ajax 原理是什么？如何实现？","content":"#\n\n\n\n\n一、是什么#\n\nAJAX全称(Async Javascript and XML)\n\n即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页\n\nAjax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面\n\n流程图如下：\n\n\n\n下面举个例子：\n\n领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作\n\nAjax请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李\n\n浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作\n\n\n二、实现过程#\n\n实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤：\n\n * 创建 Ajax的核心对象 XMLHttpRequest对象\n\n * 通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接\n\n * 构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端\n\n * 通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态\n\n * 接受并处理服务端向客户端响应的数据结果\n\n * 将处理结果更新到 HTML页面中\n\n\n创建 XMLHttpRequest 对象#\n\n通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象\n\n\n\n\n与服务器建立连接#\n\n通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接\n\n\n\n参数说明：\n\n * method：表示当前的请求方式，常见的有GET、POST\n\n * url：服务端地址\n\n * async：布尔值，表示是否异步执行操作，默认为true\n\n * user: 可选的用户名用于认证用途；默认为`null\n\n * password: 可选的密码用于认证用途，默认为`null\n\n\n给服务端发送数据#\n\n通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端\n\n\n\nbody: 在 XHR 请求中要发送的数据体，如果不传递数据则为 null\n\n如果使用GET请求发送数据的时候，需要注意如下：\n\n * 将请求数据添加到open()方法中的url地址中\n * 发送请求数据中的send()方法中参数设置为null\n\n\n绑定 onreadystatechange 事件#\n\nonreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState ,\n\n关于XMLHttpRequest.readyState属性有五个状态，如下图显示\n\n\n\n只要 readyState属性值一变化，就会触发一次 readystatechange 事件\n\nXMLHttpRequest.responseText属性用于接收服务器端的响应结果\n\n举个例子：\n\n\n\n\n三、封装#\n\n通过上面对XMLHttpRequest对象的了解，下面来封装一个简单的ajax请求\n\n\n\n使用方式如下\n\n","routePath":"/interview/JavaScript/ajax","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现过程","id":"二实现过程","depth":2,"charIndex":394},{"text":"创建 XMLHttpRequest 对象","id":"创建-xmlhttprequest-对象","depth":3,"charIndex":678},{"text":"与服务器建立连接","id":"与服务器建立连接","depth":3,"charIndex":756},{"text":"给服务端发送数据","id":"给服务端发送数据","depth":3,"charIndex":966},{"text":"绑定 onreadystatechange 事件","id":"绑定-onreadystatechange-事件","depth":3,"charIndex":1153},{"text":"三、封装","id":"三封装","depth":2,"charIndex":1398}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-ajax 原理是什么？如何实现？","footer":"ajax 原理是什么？如何实现？","order":21,"star":21,"date":"2023-04-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-ajax 原理是什么？如何实现？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"ajax 原理是什么？如何实现？"}]]},"version":""},{"id":6,"title":"数组的常用方法有哪些？","content":"#\n\n\n\n\n一、操作方法#\n\n数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会\n\n下面对数组常用的操作方法做一个归纳\n\n\n增#\n\n下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响\n\n * push()\n * unshift()\n * splice()\n * concat()\n\npush()#\n\npush()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度\n\n\n\nunshift()#\n\nunshift()在数组开头添加任意多个值，然后返回新的数组长度\n\n\n\nsplice#\n\n传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组\n\n\n\nconcat()#\n\n首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组\n\n\n\n\n删#\n\n下面三种都会影响原数组，最后一项不影响原数组：\n\n * pop()\n * shift()\n * splice()\n * slice()\n\npop()#\n\npop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项\n\n\n\nshift()#\n\nshift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项\n\n\n\nsplice()#\n\n传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组\n\n\n\n\nslice()#\n\nslice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组\n\n\n\n改#\n\n即修改原来数组的内容，常用splice\n\nsplice()#\n\n传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响\n\n\n\n查#\n\n即查找元素，返回元素坐标或者元素值\n\n * indexOf()\n * includes()\n * find()\n\nindexOf()#\n\n返回要查找的元素在数组中的位置，如果没找到则返回 -1\n\n\n\nincludes()#\n\n返回要查找的元素在数组中的位置，找到返回true，否则false\n\n\n\nfind()#\n\n返回第一个匹配的元素\n\n\n\n\n二、排序方法#\n\n数组有两个方法可以用来对元素重新排序：\n\n * reverse()\n * sort()\n\n\nreverse()#\n\n顾名思义，将数组元素方向反转\n\n\n\n\nsort()#\n\nsort()方法接受一个比较函数，用于判断哪个值应该排在前面\n\n\n\n\n三、转换方法#\n\n常见的转换方法有：\n\n\njoin()#\n\njoin() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串\n\n\n\n\n四、迭代方法#\n\n常用来迭代数组的方法（都不改变原数组）有如下：\n\n * some()\n * every()\n * forEach()\n * filter()\n * map()\n\n\nsome()#\n\n对数组每一项都运行传入的测试函数，如果至少有 1 个元素返回 true ，则这个方法返回 true\n\n\n\n\nevery()#\n\n对数组每一项都运行传入的测试函数，如果所有元素都返回 true ，则这个方法返回 true\n\n\n\n\nforEach()#\n\n对数组每一项都运行传入的函数，没有返回值\n\n\n\n\nfilter()#\n\n对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回\n\n\n\n\nmap()#\n\n对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组\n\n","routePath":"/interview/JavaScript/array_api","lang":"","toc":[{"text":"一、操作方法","id":"一操作方法","depth":2,"charIndex":5},{"text":"增","id":"增","depth":3,"charIndex":82},{"text":"push()","id":"push","depth":4,"charIndex":170},{"text":"unshift()","id":"unshift","depth":4,"charIndex":222},{"text":"splice","id":"splice","depth":4,"charIndex":270},{"text":"concat()","id":"concat","depth":4,"charIndex":321},{"text":"删","id":"删","depth":3,"charIndex":389},{"text":"pop()","id":"pop","depth":4,"charIndex":462},{"text":"shift()","id":"shift","depth":4,"charIndex":517},{"text":"splice()","id":"splice","depth":4,"charIndex":574},{"text":"slice()","id":"slice","depth":3,"charIndex":624},{"text":"改","id":"改","depth":4,"charIndex":679},{"text":"splice()","id":"splice-1","depth":4,"charIndex":704},{"text":"查","id":"查","depth":4,"charIndex":772},{"text":"indexOf()","id":"indexof","depth":4,"charIndex":833},{"text":"includes()","id":"includes","depth":4,"charIndex":876},{"text":"find()","id":"find","depth":4,"charIndex":925},{"text":"二、排序方法","id":"二排序方法","depth":2,"charIndex":949},{"text":"reverse()","id":"reverse","depth":3,"charIndex":1004},{"text":"sort()","id":"sort","depth":3,"charIndex":1035},{"text":"三、转换方法","id":"三转换方法","depth":2,"charIndex":1079},{"text":"join()","id":"join","depth":3,"charIndex":1100},{"text":"四、迭代方法","id":"四迭代方法","depth":2,"charIndex":1149},{"text":"some()","id":"some","depth":3,"charIndex":1240},{"text":"every()","id":"every","depth":3,"charIndex":1303},{"text":"forEach()","id":"foreach","depth":3,"charIndex":1363},{"text":"filter()","id":"filter","depth":3,"charIndex":1400},{"text":"map()","id":"map","depth":3,"charIndex":1452}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-数组的常用方法有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>数组的常用方法有哪些？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-数组的常用方法有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"数组的常用方法有哪些？"}]]},"version":""},{"id":7,"title":"bind、call、apply 区别？如何实现一个 bind?","content":"#\n\n\n\n\n一、作用#\n\ncall、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向\n\n那么什么情况下需要改变this的指向呢？下面举个例子\n\n\n\n从上面可以看到，正常情况say方法输出martin\n\n但是我们把say放在setTimeout方法中，在定时器中是作为回调函数来执行的，因此回到主栈执行时是在全局执行上下文的环境中执行的，这时候this指向wind\now，所以输出lucy\n\n我们实际需要的是this指向obj对象，这时候就需要该改变this指向了\n\n\n\n\n二、区别#\n\n下面再来看看apply、call、bind的使用\n\n\napply#\n\napply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入\n\n改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次\n\n\n\n当第一个参数为null、undefined的时候，默认指向window(在浏览器中)\n\n\n\n\ncall#\n\ncall方法的第一个参数也是this的指向，后面传入的是一个参数列表\n\n跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次\n\n\n\n同样的，当第一个参数为null、undefined的时候，默认指向window(在浏览器中)\n\n\n\n\nbind#\n\nbind 方法和 call 很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)\n\n改变this指向后不会立即执行，而是返回一个永久改变this指向的函数\n\n\n\n\n小结#\n\n从上面可以看到，apply、call、bind三者的区别在于：\n\n * 三者都可以改变函数的this对象指向\n * 三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window\n * 三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入\n * bind是返回绑定 this 之后的函数，apply、call 则是立即执行\n\n\n三、实现#\n\n实现bind的步骤，我们可以分解成为三部分：\n\n * 修改this指向\n * 动态传递参数\n\n\n\n * 兼容new关键字\n\n整体实现代码如下：\n\n","routePath":"/interview/JavaScript/bind_call_apply","lang":"","toc":[{"text":"一、作用","id":"一作用","depth":2,"charIndex":5},{"text":"二、区别","id":"二区别","depth":2,"charIndex":256},{"text":"apply","id":"apply","depth":3,"charIndex":290},{"text":"call","id":"call","depth":3,"charIndex":435},{"text":"bind","id":"bind","depth":3,"charIndex":578},{"text":"小结","id":"小结","depth":3,"charIndex":689},{"text":"三、实现","id":"三实现","depth":2,"charIndex":926}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-bind、call、apply 区别？如何实现一个 bind?","footer":"bind、call、apply 区别？如何实现一个 bind?","order":19,"star":19,"date":"2023-04-18T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-bind、call、apply 区别？如何实现一个 bind?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"bind、call、apply 区别？如何实现一个 bind?"}]]},"version":""},{"id":8,"title":"Javascript 本地存储的方式有哪些？区别及应用场景？","content":"#\n\n\n\n\n一、方式#\n\njavaScript本地缓存的方法我们主要讲述以下四种：\n\n * cookie\n * sessionStorage\n * localStorage\n * indexedDB\n\n\ncookie#\n\nCookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。是为了解决 HTTP无状态导致的问题\n\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie有效期、安全性、使用范围的可选属性组成\n\n但是cookie在每次请求中都会被发送，如果不使用 HTTPS并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用\ncookie保持登录态的网站上，如果 cookie被窃取，他人很容易利用你的 cookie来假扮成你登录网站\n\n关于cookie常用的属性如下：\n\n * Expires 用于设置 Cookie 的过期时间\n\n\n\n * Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）\n\n\n\n * Domain指定了 Cookie 可以送达的主机名\n * Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部\n\n\n\n * 标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端\n\n通过上述，我们可以看到cookie又开始的作用并不是为了缓存而设计出来，只是借用了cookie的特性实现缓存\n\n关于cookie的使用如下：\n\n\n\n关于cookie的修改，首先要确定domain和path属性都是相同的才可以，其中有一个不同得时候都会创建出一个新的cookie\n\n\n\n最后cookie的删除，最常用的方法就是给cookie设置一个过期的事件，这样cookie过期后会被浏览器删除\n\n\nlocalStorage#\n\nHTML5新方法，IE8 及以上浏览器都兼容\n\n\n特点#\n\n * 生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的\n * 存储的信息在同一域中是共享的\n * 当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。\n * 大小：5M（跟浏览器厂商有关系）\n * localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡\n * 受同源策略的限制\n\n下面再看看关于localStorage的使用\n\n设置\n\n\n\n获取\n\n\n\n获取键名\n\n\n\n删除\n\n\n\n一次性清除所有存储\n\n\n\nlocalStorage 也不是完美的，它有两个缺点：\n\n * 无法像Cookie一样设置过期时间\n * 只能存入字符串，无法直接存对象\n\n\n\n\nsessionStorage#\n\nsessionStorage和 localStorage使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，sessionStorage 将会删除数据\n\n\n扩展的前端存储方式#\n\nindexedDB是一种低级 API，用于客户端存储大量结构化数据(包括, 文件/ blobs)。该 API 使用索引来实现对该数据的高性能搜索\n\n虽然 Web Storage对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。IndexedDB提供了一个解决方案\n\n优点#\n\n * 储存量理论上没有上限\n * 所有操作都是异步的，相比 LocalStorage 同步操作性能更高，尤其是数据量较大时\n * 原生支持储存JS的对象\n * 是个正经的数据库，意味着数据库能干的事它都能干\n\n缺点#\n\n * 操作非常繁琐\n * 本身有一定门槛\n\n关于indexedDB的使用基本使用步骤如下：\n\n * 打开数据库并且开始一个事务\n\n * 创建一个 object store\n\n * 构建一个请求来执行一些数据库操作，像增加或提取数据等。\n\n * 通过监听正确类型的 DOM 事件以等待操作完成。\n\n * 在操作结果上进行一些操作（可以在 request对象中找到）\n\n关于使用indexdb的使用会比较繁琐，大家可以通过使用Godb.js库进行缓存，最大化的降低操作难度\n\n\n二、区别#\n\n关于cookie、sessionStorage、localStorage三者的区别主要如下：\n\n * 存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到\n   5M 或更大\n\n * 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n   sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n * 数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端；\n   sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n\n三、应用场景#\n\n在了解了上述的前端的缓存方式后，我们可以看看针对不对场景的使用选择：\n\n * 标记用户与跟踪用户行为的情况，推荐使用cookie\n * 适合长期保存在本地的数据（令牌），推荐使用localStorage\n * 敏感账号一次性登录，推荐使用sessionStorage\n * 存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用indexedDB\n\n\n相关连接#\n\n * https://mp.weixin.qq.com/s/mROjtpoXarN--UDfEMqwhQ\n * https://github.com/chenstarx/GoDB.js","routePath":"/interview/JavaScript/cache","lang":"","toc":[{"text":"一、方式","id":"一方式","depth":2,"charIndex":5},{"text":"cookie","id":"cookie","depth":3,"charIndex":101},{"text":"localStorage","id":"localstorage","depth":3,"charIndex":819},{"text":"特点","id":"特点","depth":3,"charIndex":859},{"text":"sessionStorage","id":"sessionstorage","depth":3,"charIndex":1214},{"text":"扩展的前端存储方式","id":"扩展的前端存储方式","depth":3,"charIndex":1314},{"text":"优点","id":"优点","depth":4,"charIndex":1474},{"text":"缺点","id":"缺点","depth":4,"charIndex":1584},{"text":"二、区别","id":"二区别","depth":2,"charIndex":1826},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":2203},{"text":"相关连接","id":"相关连接","depth":2,"charIndex":2397}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Javascript 本地存储的方式有哪些？区别及应用场景？","footer":"Javascript 本地存储的方式有哪些？区别及应用场景？","order":7,"star":7,"date":"2023-03-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-Javascript 本地存储的方式有哪些？区别及应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Javascript 本地存储的方式有哪些？区别及应用场景？"}]]},"version":""},{"id":9,"title":"说说你对闭包的理解？闭包使用场景","content":"#\n\n\n\n\n一、是什么#\n\n一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）\n\n也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域\n\n在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁\n\n下面给出一个简单的例子\n\n\n\ndisplayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量\n\n\n二、使用场景#\n\n任何闭包的使用场景都离不开这两点：\n\n * 创建私有变量\n * 延长变量的生命周期\n\n> 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长\n> 变量的生命周期的目的\n\n下面举个例子：\n\n在页面上添加一些可以调整字号的按钮\n\n\n\n\n柯里化函数#\n\n柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用\n\n\n\n\n使用闭包模拟私有方法#\n\n在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法\n\n下面举个例子：\n\n\n\n上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式\n\n两个计数器 Counter1 和 Counter2\n是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量\n\n\n其他#\n\n例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期\n\n\n三、注意事项#\n\n如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响\n\n例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。\n\n原因在于每个对象的创建，方法都会被重新赋值\n\n\n\n上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：\n\n","routePath":"/interview/JavaScript/closure","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用场景","id":"二使用场景","depth":2,"charIndex":251},{"text":"柯里化函数","id":"柯里化函数","depth":3,"charIndex":429},{"text":"使用闭包模拟私有方法","id":"使用闭包模拟私有方法","depth":3,"charIndex":476},{"text":"其他","id":"其他","depth":3,"charIndex":677},{"text":"三、注意事项","id":"三注意事项","depth":2,"charIndex":728}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对闭包的理解？闭包使用场景","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对闭包的理解？闭包使用场景","order":4,"star":4,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对闭包的理解？闭包使用场景","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对闭包的理解？闭包使用场景"}]]},"version":""},{"id":10,"title":"JavaScript 中执行上下文和执行栈是什么？","content":"#\n\n\n\n\n一、执行上下文#\n\n简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中\n\n执行上下文的类型分为三种：\n\n * 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象\n * 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文\n * Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用\n\n下面给出全局上下文和函数上下文的例子：\n\n\n\n紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问\n\n可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问\n\n\n二、生命周期#\n\n执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段\n\n\n创建阶段#\n\n创建阶段即当函数被调用，但未执行任何其内部代码之前\n\n创建阶段做了三件事：\n\n * 确定 this 的值，也被称为 This Binding\n * LexicalEnvironment（词法环境） 组件被创建\n * VariableEnvironment（变量环境） 组件被创建\n\n伪代码如下：\n\n\n\nThis Binding#\n\n确定this的值我们前面讲到，this的值是在执行的时候才能确认，定义的时候不能确认\n\n词法环境#\n\n词法环境有两个组成部分：\n\n * 全局环境：是一个没有外部环境的词法环境，其外部环境引用为null，有一个全局对象，this 的值指向这个全局对象\n\n * 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境\n\n伪代码如下：\n\n\n\n变量环境#\n\n变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性\n\n在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定\n\n举个例子\n\n\n\n执行上下文如下：\n\n\n\n留意上面的代码，let和const定义的变量a和b在创建阶段没有被赋值，但var声明的变量从在创建阶段被赋值为undefined\n\n这是因为，创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中\n\n但变量会被初始化为undefined(var声明的情况下)和保持uninitialized(未初始化状态)(使用let和const声明的情况下)\n\n这就是变量提升的实际原因\n\n\n执行阶段#\n\n在这阶段，执行变量赋值、代码执行\n\n如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值\n\n\n回收阶段#\n\n执行上下文出栈等待虚拟机回收执行上下文\n\n\n二、执行栈#\n\n执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文\n\n\n\n当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中\n\n每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中\n\n引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文\n\n举个例子：\n\n\n\n转化成图的形式\n\n\n\n简单分析一下流程：\n\n * 创建全局上下文请压入执行栈\n * first函数被调用，创建函数执行上下文并压入栈\n * 执行first函数过程遇到second函数，再创建一个函数执行上下文并压入栈\n * second函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first函数\n * first函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文\n * 所有代码执行完毕，全局上下文也会被推出栈中，程序结束\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/107552264","routePath":"/interview/JavaScript/context_stack","lang":"","toc":[{"text":"一、执行上下文","id":"一执行上下文","depth":2,"charIndex":5},{"text":"二、生命周期","id":"二生命周期","depth":2,"charIndex":412},{"text":"创建阶段","id":"创建阶段","depth":3,"charIndex":459},{"text":"This Binding","id":"this-binding","depth":4,"charIndex":617},{"text":"词法环境","id":"词法环境","depth":4,"charIndex":676},{"text":"变量环境","id":"变量环境","depth":4,"charIndex":847},{"text":"执行阶段","id":"执行阶段","depth":3,"charIndex":1177},{"text":"回收阶段","id":"回收阶段","depth":3,"charIndex":1260},{"text":"二、执行栈","id":"二执行栈","depth":2,"charIndex":1289},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1770}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-JavaScript 中执行上下文和执行栈是什么？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>JavaScript 中执行上下文和执行栈是什么？","order":5,"star":5,"date":"2023-03-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-JavaScript 中执行上下文和执行栈是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"JavaScript 中执行上下文和执行栈是什么？"}]]},"version":""},{"id":11,"title":"大文件上传如何做断点续传？","content":"#\n\n\n\n\n一、是什么#\n\n不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂\n\n文件上传简单，文件变大就复杂\n\n上传大文件时，以下几个变量会影响我们的用户体验\n\n * 服务器处理数据的能力\n * 请求超时\n * 网络波动\n\n上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等\n\n为了解决上述问题，我们需要对大文件上传单独处理\n\n这里涉及到分片上传及断点续传两个概念\n\n分片上传#\n\n分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传\n\n如下图\n\n\n\n上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件\n\n大致流程如下：\n\n 1. 将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；\n 2. 初始化一个分片上传任务，返回本次分片上传唯一标识；\n 3. 按照一定的策略（串行或并行）发送各个分片数据块；\n 4. 发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件\n\n断点续传#\n\n断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分\n\n每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提\n高速度\n\n一般实现方式有两种：\n\n * 服务器端返回，告知从哪开始\n * 浏览器端自行处理\n\n上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可\n\n如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可\n\n\n二、实现思路#\n\n整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕\n\n\n\n下面的内容都是伪代码\n\n读取文件内容：\n\n\n\n可以使用md5实现文件的唯一性\n\n\n\n然后开始对文件进行分割\n\n\n\nh5 上传一个（一片）\n\n\n\n这里给出常见的图片和视频的文件类型判断\n\n\n\n调用方法如下\n\n\n\n上面上传文件的一步，可以改成：\n\n\n\n有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断\n\n后端主要做的内容为：根据前端传给后台的md5值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回\n数据告诉前端开始从第几节上传\n\n如果想要暂停切片的上传，可以使用XMLHttpRequest的 abort方法\n\n\n三、使用场景#\n\n * 大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度\n * 网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的 Part\n * 流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见\n\n\n小结#\n\n当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如\n\n * 切片上传失败怎么办\n * 上传过程中刷新页面怎么办\n * 如何进行并行上传\n * 切片什么时候按数量切，什么时候按大小切\n * 如何结合 Web Worker 处理大文件上传\n * 如何实现秒传\n\n人生又何尝不是如此，极致的人生体验有无限可能，越是后面才发现越是精彩 ~_~\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000009448892\n * https://baike.baidu.com/","routePath":"/interview/JavaScript/continue_to_upload","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"分片上传","id":"分片上传","depth":4,"charIndex":193},{"text":"断点续传","id":"断点续传","depth":4,"charIndex":441},{"text":"二、实现思路","id":"二实现思路","depth":2,"charIndex":741},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":1129},{"text":"小结","id":"小结","depth":2,"charIndex":1290},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1484}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-大文件上传如何做断点续传？","footer":"大文件上传如何做断点续传？","order":15,"star":15,"date":"2023-04-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-大文件上传如何做断点续传？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"大文件上传如何做断点续传？"}]]},"version":""},{"id":12,"title":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","content":"#\n\n\n\n\n一、数据类型存储#\n\n前面文章我们讲到，JavaScript中存在两大数据类型：\n\n * 基本类型\n * 引用类型\n\n基本类型数据保存在在栈内存中\n\n引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中\n\n\n二、浅拷贝#\n\n浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝\n\n如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址\n\n即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址\n\n下面简单实现一个浅拷贝\n\n\n\n在JavaScript中，存在浅拷贝的现象有：\n\n * Object.assign\n * Array.prototype.slice(), Array.prototype.concat()\n * 使用拓展运算符实现的复制\n\n\nObject.assign#\n\n\n\n\nslice()#\n\n\n\n\nconcat()#\n\n\n\n\n拓展运算符#\n\n\n\n\n三、深拷贝#\n\n深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性\n\n常见的深拷贝方式有：\n\n * _.cloneDeep()\n\n * jQuery.extend()\n\n * JSON.stringify()\n\n * 手写循环递归\n\n\n_.cloneDeep()#\n\n\n\n\njQuery.extend()#\n\n\n\n\nJSON.stringify()#\n\n\n\n但是这种方式存在弊端，会忽略undefined、symbol和函数\n\n\n\n\n循环递归#\n\n\n\n\n四、区别#\n\n下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别\n\n\n\n从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样\n\n浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象\n\n\n\n但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象\n\n\n\n\n小结#\n\n前提为拷贝类型为引用类型的情况下：\n\n * 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址\n\n * 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址","routePath":"/interview/JavaScript/copy","lang":"","toc":[{"text":"一、数据类型存储","id":"一数据类型存储","depth":2,"charIndex":5},{"text":"二、浅拷贝","id":"二浅拷贝","depth":2,"charIndex":127},{"text":"Object.assign","id":"objectassign","depth":3,"charIndex":369},{"text":"slice()","id":"slice","depth":3,"charIndex":388},{"text":"concat()","id":"concat","depth":3,"charIndex":401},{"text":"拓展运算符","id":"拓展运算符","depth":3,"charIndex":415},{"text":"三、深拷贝","id":"三深拷贝","depth":2,"charIndex":426},{"text":"_.cloneDeep()","id":"_clonedeep","depth":3,"charIndex":574},{"text":"jQuery.extend()","id":"jqueryextend","depth":3,"charIndex":593},{"text":"JSON.stringify()","id":"jsonstringify","depth":3,"charIndex":614},{"text":"循环递归","id":"循环递归","depth":3,"charIndex":673},{"text":"四、区别","id":"四区别","depth":2,"charIndex":683},{"text":"小结","id":"小结","depth":3,"charIndex":872}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-深拷贝浅拷贝的区别？如何实现一个深拷贝？","footer":"深拷贝浅拷贝的区别？如何实现一个深拷贝？","order":13,"star":13,"date":"2023-03-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-深拷贝浅拷贝的区别？如何实现一个深拷贝？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"深拷贝浅拷贝的区别？如何实现一个深拷贝？"}]]},"version":""},{"id":13,"title":"说说 JavaScript 中的数据类型？存储上的差别？","content":"#\n\n\n\n\n前言#\n\n在JavaScript中，我们可以分成两种类型：\n\n * 基本类型\n * 复杂类型\n\n两种类型的区别是：存储位置不同\n\n\n一、基本类型#\n\n基本类型主要为以下 6 种：\n\n * Number\n * String\n * Boolean\n * Undefined\n * null\n * symbol\n\n\nNumber#\n\n数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x 开头）\n\n\n\n浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示\n\n\n\n在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误）\n\n\n\n\nUndefined#\n\nUndefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值\n\n\n\n包含undefined 值的变量跟未定义变量是有区别的\n\n\n\n\nString#\n\n字符串可以使用双引号（\"）、单引号（'）或反引号（`）标示\n\n\n\n字符串是不可变的，意思是一旦创建，它们的值就不能变了\n\n\n\n\nNull#\n\nNull类型同样只有一个值，即特殊值 null\n\n逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 \"object\" 的原因\n\n\n\nundefined 值是由 null值派生而来\n\n\n\n只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量\n\n\nBoolean#\n\nBoolean（布尔值）类型有两个字面值： true 和false\n\n通过Boolean可以将其他类型的数据转化成布尔值\n\n规则如下：\n\n\n\n\nSymbol#\n\nSymbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险\n\n\n\n\n二、引用类型#\n\n复杂类型统称为Object，我们这里主要讲述下面三种：\n\n * Object\n * Array\n * Function\n\n\nObject#\n\n创建object常用方式为对象字面量表示法，属性名可以是字符串或数值\n\n\n\n\nArray#\n\nJavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长\n\n\n\n\nFunction#\n\n函数实际上是对象，每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样\n\n函数存在三种常见的表达方式：\n\n * 函数声明\n\n\n\n * 函数表达式\n\n\n\n * 箭头函数\n\n函数声明和函数表达式两种方式\n\n\n\n\n其他引用类型#\n\n除了上述说的三种之外，还包括Date、RegExp、Map、Set等......\n\n\n三、存储区别#\n\n基本数据类型和引用数据类型存储在内存中的位置不同：\n\n * 基本数据类型存储在栈中\n\n * 引用类型的对象存储于堆中\n\n当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值\n\n下面来举个例子\n\n\n基本类型#\n\n\n\na的值为一个基本类型，是存储在栈中，将a的值赋给b，虽然两个变量的值相等，但是两个变量保存了两个不同的内存地址\n\n下图演示了基本类型赋值的过程：\n\n\n\n\n引用类型#\n\n\n\n引用类型数据存放在堆中，每个堆内存对象都有对应的引用地址指向它，引用地址存放在栈中。\n\nobj1是一个引用类型，在赋值操作过程汇总，实际是将堆内存对象在栈内存的引用地址复制了一份给了obj2，实际上他们共同指向了同一个堆内存对象，所以更改obj2会\n对obj1产生影响\n\n下图演示这个引用类型赋值过程\n\n\n\n\n小结#\n\n * 声明变量时不同的内存地址分配：\n   * 简单类型的值存放在栈中，在栈中存放的是对应的值\n   * 引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址\n * 不同的类型数据导致赋值变量时的不同：\n   * 简单类型赋值，是生成相同的值，两个对象对应不同的地址\n   * 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象","routePath":"/interview/JavaScript/data_type","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":5},{"text":"一、基本类型","id":"一基本类型","depth":2,"charIndex":71},{"text":"Number","id":"number","depth":3,"charIndex":160},{"text":"Undefined","id":"undefined","depth":3,"charIndex":308},{"text":"String","id":"string","depth":3,"charIndex":436},{"text":"Null","id":"null","depth":3,"charIndex":509},{"text":"Boolean","id":"boolean","depth":3,"charIndex":670},{"text":"Symbol","id":"symbol","depth":3,"charIndex":752},{"text":"二、引用类型","id":"二引用类型","depth":2,"charIndex":827},{"text":"Object","id":"object","depth":3,"charIndex":898},{"text":"Array","id":"array","depth":3,"charIndex":946},{"text":"Function","id":"function","depth":3,"charIndex":1035},{"text":"其他引用类型","id":"其他引用类型","depth":3,"charIndex":1172},{"text":"三、存储区别","id":"三存储区别","depth":2,"charIndex":1224},{"text":"基本类型","id":"基本类型","depth":3,"charIndex":1347},{"text":"引用类型","id":"引用类型","depth":3,"charIndex":1433},{"text":"小结","id":"小结","depth":3,"charIndex":1597}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 JavaScript 中的数据类型？存储上的差别？","footer":"说说 JavaScript 中的数据类型？存储上的差别？","order":22,"star":22,"date":"2023-04-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说 JavaScript 中的数据类型？存储上的差别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 JavaScript 中的数据类型？存储上的差别？"}]]},"version":""},{"id":14,"title":"什么是防抖和节流？有什么区别？如何实现？","content":"#\n\n\n\n\n一、是什么#\n\n本质上是优化高频率执行代码的一种手段\n\n如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能\n\n为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率\n\n定义#\n\n * 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n * 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时\n\n一个经典的比喻:\n\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应\n\n假设电梯有两种运行策略 debounce 和 throttle，超时设定为 15 秒，不考虑容量限制\n\n电梯第一个人进来后，15 秒后准时运送一次，这是节流\n\n电梯第一个人进来后，等待 15 秒。如果过程中又有人进来，15 秒等待重新计时，直到 15 秒后开始运送，这是防抖\n\n\n代码实现#\n\n\n节流#\n\n完成节流可以使用时间戳与定时器的写法\n\n使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行\n\n\n\n使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行\n\n\n\n可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下\n\n\n\n\n防抖#\n\n简单版本的实现\n\n\n\n防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：\n\n\n\n\n二、区别#\n\n相同点：\n\n * 都可以通过使用 setTimeout 实现\n * 目的都是，降低回调执行频率。节省计算资源\n\n不同点：\n\n * 函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和\n   setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能\n * 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次\n\n例如，都设置时间频率为 500ms，在 2 秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在 2s 后，只会执行一次\n\n如下图所示：\n\n\n\n\n三、应用场景#\n\n防抖在连续的事件，只需触发一次回调的场景有：\n\n * 搜索框搜索输入。只需用户最后一次输入完，再发送请求\n * 手机号、邮箱验证输入检测\n * 窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。\n\n节流在间隔一段时间执行一次回调的场景有：\n\n * 滚动加载，加载更多或滚到底部监听\n * 搜索框，搜索联想功能","routePath":"/interview/JavaScript/debounce_throttle","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"定义","id":"定义","depth":4,"charIndex":189},{"text":"代码实现","id":"代码实现","depth":2,"charIndex":457},{"text":"节流","id":"节流","depth":3,"charIndex":465},{"text":"防抖","id":"防抖","depth":3,"charIndex":612},{"text":"二、区别","id":"二区别","depth":2,"charIndex":662},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":967}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-什么是防抖和节流？有什么区别？如何实现？","footer":"什么是防抖和节流？有什么区别？如何实现？","order":28,"star":28,"date":"2023-05-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-什么是防抖和节流？有什么区别？如何实现？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"什么是防抖和节流？有什么区别？如何实现？"}]]},"version":""},{"id":15,"title":"说说 JavaScript 中的事件模型","content":"Click Me","routePath":"/interview/JavaScript/event_Model","lang":"","toc":[{"text":"一、事件与事件流","id":"一事件与事件流","depth":2,"charIndex":-1},{"text":"二、事件模型","id":"二事件模型","depth":2,"charIndex":-1},{"text":"原始事件模型","id":"原始事件模型","depth":3,"charIndex":-1},{"text":"特性","id":"特性","depth":4,"charIndex":-1},{"text":"标准事件模型","id":"标准事件模型","depth":3,"charIndex":-1},{"text":"特性","id":"特性-1","depth":4,"charIndex":-1},{"text":"IE 事件模型","id":"ie-事件模型","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 JavaScript 中的事件模型","footer":"说说 JavaScript 中的事件模型","order":20,"star":20,"date":"2023-04-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说 JavaScript 中的事件模型","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 JavaScript 中的事件模型"}]]},"version":""},{"id":16,"title":"解释下什么是事件代理？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n事件代理，俗地来讲，就是把一个元素响应事件（click、keydown......）的函数委托到另一个元素\n\n前面讲到，事件流的都会经过三个阶段： 捕获阶段 -> 目标阶段 -> 冒泡阶段，而事件委托就是在冒泡阶段完成\n\n事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素\n\n当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数\n\n下面举个例子：\n\n比如一个宿舍的同学同时快递到了，一种笨方法就是他们一个个去领取\n\n较优方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个同学\n\n在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM元素，而出去统一领取快递的宿舍长就是代理的元素\n\n所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个\n\n\n二、应用场景#\n\n如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件\n\n\n\n如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的\n\n\n\n这时候就可以事件委托，把点击事件绑定在父级元素ul上面，然后执行事件的时候再去匹配目标元素\n\n\n\n还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件\n\n但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件\n\n如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的\n\n举个例子：\n\n下面html结构中，点击input可以动态添加元素\n\n\n\n使用事件委托\n\n\n\n可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的\n\n\n三、总结#\n\n适合事件委托的事件有：click，mousedown，mouseup，keydown，keyup，keypress\n\n从上面应用场景中，我们就可以看到使用事件委托存在两大优点：\n\n * 减少整个页面所需的内存，提升整体性能\n * 动态绑定，减少重复工作\n\n但是使用事件委托也是存在局限性：\n\n * focus、blur这些事件没有事件冒泡机制，所以无法进行委托绑定事件\n\n * mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的\n\n如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件","routePath":"/interview/JavaScript/event_agent","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、应用场景","id":"二应用场景","depth":2,"charIndex":453},{"text":"三、总结","id":"三总结","depth":2,"charIndex":845}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-解释下什么是事件代理？应用场景？","footer":"解释下什么是事件代理？应用场景？","order":16,"star":16,"date":"2023-04-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-解释下什么是事件代理？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"解释下什么是事件代理？应用场景？"}]]},"version":""},{"id":17,"title":"说说你对事件循环的理解","content":"#\n\n\n\n\n一、是什么#\n\n首先，JavaScript是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环\n\n在JavaScript中，所有的任务都可以分为\n\n * 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行\n\n * 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等\n\n同步任务与异步任务的运行流程图如下：\n\n\n\n从上面我们可以看到，同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断\n重复就事件循环\n\n\n二、宏任务与微任务#\n\n如果将任务划分为同步任务和异步任务并不是那么的准确，举个例子：\n\n\n\n如果按照上面流程图来分析代码，我们会得到下面的执行步骤：\n\n * console.log(1)，同步任务，主线程中执行\n * setTimeout() ，异步任务，放到 Event Table，0 毫秒后console.log(2)回调推入 Event Queue 中\n * new Promise ，同步任务，主线程直接执行\n * .then ，异步任务，放到 Event Table\n * console.log(3)，同步任务，主线程执行\n\n所以按照分析，它的结果应该是 1 => 'new Promise' => 3 => 2 => 'then'\n\n但是实际结果是：1=>'new Promise'=> 3 => 'then' => 2\n\n出现分歧的原因在于异步任务执行顺序，事件队列其实是一个“先进先出”的数据结构，排在前面的事件会优先被主线程读取\n\n例子中 setTimeout回调事件是先进入队列中的，按理说应该先于 .then 中的执行，但是结果却偏偏相反\n\n原因在于异步任务还可以细分为微任务与宏任务\n\n\n微任务#\n\n一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前\n\n常见的微任务有：\n\n * Promise.then\n\n * MutaionObserver\n\n * Object.observe（已废弃；Proxy 对象替代）\n\n * process.nextTick（Node.js）\n\n\n宏任务#\n\n宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合\n\n常见的宏任务有：\n\n * script (可以理解为外层同步代码)\n * setTimeout/setInterval\n * UI rendering/UI 事件\n * postMessage、MessageChannel\n * setImmediate、I/O（Node.js）\n\n这时候，事件循环，宏任务，微任务的关系如图所示\n\n\n\n按照这个流程，它的执行机制是：\n\n * 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中\n * 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完\n\n回到上面的题目\n\n\n\n流程如下\n\n\n\n\n三、async 与 await#\n\nasync 是异步的意思，await则可以理解为 async wait。所以可以理解async就是用来声明一个异步方法，而 await是用来等待异步方法执行\n\n\nasync#\n\nasync函数返回一个promise对象，下面两种方法是等效的\n\n\n\n\nawait#\n\n正常情况下，await命令后面是一个 Promise对象，返回该对象的结果。如果不是 Promise对象，就直接返回对应的值\n\n\n\n不管await后面跟着的是什么，await都会阻塞后面的代码\n\n\n\n上面的例子中，await 会阻塞下面的代码（即加入微任务队列），先执行 async外面的同步代码，同步代码执行完，再回到 async\n函数中，再执行之前阻塞的代码\n\n所以上述输出结果为：1，fn2，3，2\n\n\n四、流程分析#\n\n通过对上面的了解，我们对JavaScript对各种场景的执行顺序有了大致的了解\n\n这里直接上代码：\n\n\n\n分析过程：\n\n 1. 执行整段代码，遇到 console.log('script start') 直接打印结果，输出 script start\n 2. 遇到定时器了，它是宏任务，先放着不执行\n 3. 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到await怎么办？先执行 async2，打印\n    async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码\n 4. 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行\n 5. 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await下面的代码，打印 async1 end\n 6. 继续执行下一个微任务，即执行 then 的回调，打印 promise2\n 7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout\n\n所以最后的结果是：script start、async1 start、async2、promise1、script end、async1\nend、promise2、settimeout","routePath":"/interview/JavaScript/event_loop","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、宏任务与微任务","id":"二宏任务与微任务","depth":2,"charIndex":305},{"text":"微任务","id":"微任务","depth":3,"charIndex":814},{"text":"宏任务","id":"宏任务","depth":3,"charIndex":972},{"text":"三、async 与 await","id":"三async-与-await","depth":2,"charIndex":1306},{"text":"async","id":"async","depth":3,"charIndex":1405},{"text":"await","id":"await","depth":3,"charIndex":1449},{"text":"四、流程分析","id":"四流程分析","depth":2,"charIndex":1662}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对事件循环的理解","footer":"说说你对事件循环的理解","order":12,"star":12,"date":"2023-03-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对事件循环的理解","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对事件循环的理解"}]]},"version":""},{"id":18,"title":"Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n函数缓存，就是将函数运算过的结果进行缓存\n\n本质上就是用空间（缓存存储）换时间（计算过程）\n\n常用于缓存数据计算结果和缓存对象\n\n\n\n缓存只是一个临时的数据存储，它保存数据，以便将来对该数据的请求能够更快地得到处理\n\n\n二、如何实现#\n\n实现函数缓存主要依靠闭包、柯里化、高阶函数，这里再简单复习下：\n\n\n闭包#\n\n闭包可以理解成，函数 + 函数体内可访问的变量总和\n\n\n\nadd函数本身，以及其内部可访问的变量，即 a = 1，这两个组合在⼀起就形成了闭包\n\n\n柯里化#\n\n把接受多个参数的函数转换成接受一个单一参数的函数\n\n\n\n将一个二元函数拆分成两个一元函数\n\n\n高阶函数#\n\n通过接收其他函数作为参数或返回其他函数的函数\n\n\n\n函数 foo 如何返回另一个函数 bar，baz 现在持有对 foo 中定义的bar 函数的引用。由于闭包特性，a的值能够得到\n\n下面再看看如何实现函数缓存，实现原理也很简单，把参数和对应的结果数据存在一个对象中，调用时判断参数对应的数据是否存在，存在就返回对应的结果数据，否则就返回计算结\n果\n\n如下所示\n\n\n\n调用方式也很简单\n\n\n\n过程分析：\n\n * 在当前函数作用域定义了一个空对象，用于缓存运行结果\n * 运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到cache\n * 然后判断输入参数是不是在cache的中。如果已经存在，直接返回cache的内容，如果没有存在，使用函数func对输入参数求值，然后把结果存储在cache中\n\n\n三、应用场景#\n\n虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存\n\n以下几种情况下，适合使用缓存：\n\n * 对于昂贵的函数调用，执行复杂计算的函数\n * 对于具有有限且高度重复输入范围的函数\n * 对于具有重复输入值的递归函数\n * 对于纯函数，即每次使用特定输入调用时返回相同输出的函数\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/112505577","routePath":"/interview/JavaScript/function_cache","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":123},{"text":"闭包","id":"闭包","depth":3,"charIndex":166},{"text":"柯里化","id":"柯里化","depth":3,"charIndex":245},{"text":"高阶函数","id":"高阶函数","depth":3,"charIndex":298},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":657},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":826}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？","footer":"Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？","order":9,"star":9,"date":"2023-03-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？"}]]},"version":""},{"id":19,"title":"说说你对函数式编程的理解？优缺点？","content":"#\n\n\n\n\n一、是什么#\n\n函数式编程是一种\"编程范式\"（programming paradigm），一种编写程序的方法论\n\n主要的编程范式有三种：命令式编程，声明式编程和函数式编程\n\n相比命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程\n\n举个例子，将数组每个元素进行平方操作，命令式编程与函数式编程如下\n\n\n\n简单来讲，就是要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果\n\n即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值\n\n\n\n可以看到，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合\n\n\n二、概念#\n\n\n纯函数#\n\n函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用无副作用的函数，也就是纯函数\n\n纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数=无状态+数据不可变\n\n\n\n举一个简单的例子\n\n\n\n特性：\n\n * 函数内部传入指定的值，就会返回确定唯一的值\n * 不会造成超出作用域的变化，例如修改全局变量或引用传递的参数\n\n优势：\n\n * 使用纯函数，我们可以产生可测试的代码\n\n\n\n * 不依赖外部环境计算，不会产生副作用，提高函数的复用性\n\n * 可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读\n\n * 可以组装成复杂任务的可能性。符合模块化概念及单一职责原则\n\n\n高阶函数#\n\n在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数\n\n编程工作也就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据，如下图所示\n\n\n\n在这里，就是高阶函数的作用。高级函数，就是以函数作为输入或者输出的函数被称为高阶函数\n\n通过高阶函数抽象过程，注重结果，如下面例子\n\n\n\n上面通过高阶函数 forEach来抽象循环如何做的逻辑，直接关注做了什么\n\n高阶函数存在缓存的特性，主要是利用闭包作用\n\n\n\n\n柯里化#\n\n柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程\n\n一个二元函数如下：\n\n\n\n转化成柯里化函数如下：\n\n\n\n上面的curry函数只能处理二元情况，下面再来实现一个实现多参数的情况\n\n\n\n关于柯里化函数的意义如下：\n\n * 让纯函数更纯，每次接受一个参数，松散解耦\n * 惰性执行\n\n\n组合与管道#\n\n组合函数，目的是将多个函数组合成一个函数\n\n举个简单的例子：\n\n\n\n可以看到compose实现一个简单的功能：形成了一个新的函数，而这个函数就是一条从 bfn -> afn 的流水线\n\n下面再来看看如何实现一个多函数组合：\n\n\n\ncompose执行是从右到左的。而管道函数，执行顺序是从左到右执行的\n\n\n\n组合函数与管道函数的意义在于：可以把很多小函数组合起来完成更复杂的逻辑\n\n\n三、优缺点#\n\n优点#\n\n * 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况\n\n * 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响\n\n * 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性\n\n * 隐性好处。减少代码量，提高维护性\n\n缺点#\n\n * 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销\n\n * 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式\n\n * 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/81302150","routePath":"/interview/JavaScript/functional_programming","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、概念","id":"二概念","depth":2,"charIndex":367},{"text":"纯函数","id":"纯函数","depth":3,"charIndex":375},{"text":"高阶函数","id":"高阶函数","depth":3,"charIndex":701},{"text":"柯里化","id":"柯里化","depth":3,"charIndex":951},{"text":"组合与管道","id":"组合与管道","depth":3,"charIndex":1102},{"text":"三、优缺点","id":"三优缺点","depth":2,"charIndex":1301},{"text":"优点","id":"优点","depth":4,"charIndex":1309},{"text":"缺点","id":"缺点","depth":4,"charIndex":1526},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1694}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对函数式编程的理解？优缺点？","footer":"说说你对函数式编程的理解？优缺点？","order":34,"star":34,"date":"2023-05-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对函数式编程的理解？优缺点？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对函数式编程的理解？优缺点？"}]]},"version":""},{"id":20,"title":"前端物语|面试物语-JavaScript","content":" * [ == 和 ===区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/==\n   _===)\n * 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？\n * DOM 常见的操作有哪些？\n * ajax 原理是什么？如何实现？\n * 数组的常用方法有哪些？\n * bind、call、apply 区别？如何实现一个 bind?\n * Javascript 本地存储的方式有哪些？区别及应用场景？\n * 说说你对闭包的理解？闭包使用场景\n * JavaScript 中执行上下文和执行栈是什么？\n * 大文件上传如何做断点续传？\n * 深拷贝浅拷贝的区别？如何实现一个深拷贝？\n * 说说 JavaScript 中的数据类型？存储上的差别？\n * 什么是防抖和节流？有什么区别？如何实现？\n * 说说 JavaScript 中的事件模型\n * 解释下什么是事件代理？应用场景？\n * 说说你对事件循环的理解\n * Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？\n * 说说你对函数式编程的理解？优缺点？\n * Javascript 如何实现继承？\n * 说说你了解的 js 数据结构？\n * 说说 Javascript 数字精度丢失的问题，如何解决？\n * 说说 JavaScript 中内存泄漏的几种情况？\n * 说说 new 操作符具体干了什么？\n * JavaScript 原型，原型链 ? 有什么特点？\n * 如何实现上拉加载，下拉刷新？\n * 说说你对正则表达式的理解？应用场景？\n * 说说你对作用域链的理解\n * web 常见的攻击方式有哪些？如何防御？\n * 什么是单点登录？如何实现？\n * JavaScript 字符串的常用方法有哪些？\n * 举例说明你对尾递归的理解，有哪些应用场景\n * 谈谈 this 对象的理解\n * 谈谈 JavaScript 中的类型转换机制\n * typeof 与 instanceof 区别\n * 如何判断一个元素是否在可视区域中？","routePath":"/interview/JavaScript/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"JavaScript","tag":"JavaScript","title":"前端物语|面试物语-JavaScript","index":false,"dir":{"order":1},"date":"2023-05-26T00:00:00.000Z"},"version":""},{"id":21,"title":"Javascript 如何实现继承？","content":"#\n\n\n\n\n一、是什么#\n\n继承（inheritance）是面向对象软件技术当中的一个概念。\n\n如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”\n\n * 继承的优点\n\n继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码\n\n在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能\n\n虽然JavaScript并不是真正的面向对象语言，但它天生的灵活性，使应用场景更加丰富\n\n关于继承，我们举个形象的例子：\n\n定义一个类（Class）叫汽车，汽车的属性包括颜色、轮胎、品牌、速度、排气量等\n\n\n\n由汽车这个类可以派生出“轿车”和“货车”两个类，在汽车的基础属性上，为轿车添加一个后备厢、给货车添加一个大货箱\n\n\n\n这样轿车和货车就是不一样的，但是二者都属于汽车这个类，汽车、轿车继承了汽车的属性，而不需要再次在“轿车”中定义汽车已经有的属性\n\n在“轿车”继承“汽车”的同时，也可以重新定义汽车的某些属性，并重写或覆盖某些属性和方法，使其获得与“汽车”这个父类不同的属性和方法\n\n\n\n从这个例子中就能详细说明汽车、轿车以及卡车之间的继承关系\n\n\n二、实现方式#\n\n下面给出JavaScripy常见的继承方式：\n\n * 原型链继承\n\n * 构造函数继承（借助 call）\n\n * 组合继承\n\n * 原型式继承\n\n * 寄生式继承\n\n * 寄生组合式继承\n\n\n原型链继承#\n\n原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的\n指针，而实例则包含一个原型对象的指针\n\n举个例子\n\n\n\n上面代码看似没问题，实际存在潜在问题\n\n\n\n改变s1的play属性，会发现s2也跟着发生变化了，这是因为两个实例使用的是同一个原型对象，内存空间是共享的\n\n\n构造函数继承#\n\n借助 call调用Parent函数\n\n\n\n可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法\n\n相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法\n\n\n组合继承#\n\n前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来\n\n\n\n这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到Parent3 执行了两次，造成了多构造一次的性能开销\n\n\n原型式继承#\n\n这里主要借助Object.create方法实现普通对象的继承\n\n同样举个例子\n\n\n\n这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能\n\n\n寄生式继承#\n\n寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法\n\n\n\n其优缺点也很明显，跟上面讲的原型式继承一样\n\n\n寄生组合式继承#\n\n寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式\n\n\n\n可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题\n\n文章一开头，我们是使用ES6 中的extends关键字直接实现 JavaScript的继承\n\n\n\n利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式\n\n\n三、总结#\n\n下面以一张图作为总结：\n\n\n\n通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends\n的语法糖和寄生组合继承的方式基本类似\n\n\n相关链接#\n\nhttps://zh.wikipedia.org/wiki/%E7%BB%A7%E6%89%BF","routePath":"/interview/JavaScript/inherit","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":555},{"text":"原型链继承","id":"原型链继承","depth":3,"charIndex":660},{"text":"构造函数继承","id":"构造函数继承","depth":3,"charIndex":856},{"text":"组合继承","id":"组合继承","depth":3,"charIndex":1001},{"text":"原型式继承","id":"原型式继承","depth":3,"charIndex":1119},{"text":"寄生式继承","id":"寄生式继承","depth":3,"charIndex":1237},{"text":"寄生组合式继承","id":"寄生组合式继承","depth":3,"charIndex":1313},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1560},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":1671}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Javascript 如何实现继承？","footer":"Javascript 如何实现继承？","order":28,"star":28,"date":"2023-05-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-Javascript 如何实现继承？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Javascript 如何实现继承？"}]]},"version":""},{"id":22,"title":"说说你了解的 js 数据结构？","content":"#\n\n\n什么是数据结构？#\n\n数据结构是计算机存储、组织数据的方式。数据结构意味着接口或封装：一个数据结构可被视为两个函数之间的接口，或者是由数据类型联合组成的存储内容的访问方法封装。\n\n我们每天的编码中都会用到数据结构数组是最简单的内存数据结构下面是常见的数据结构：\n\n 1. 数组（Array）\n 2. 栈（Stack）\n 3. 队列（Queue）\n 4. 链表（Linked List）\n 5. 字典\n 6. 散列表（Hash table）\n 7. 树（Tree）\n 8. 图（Graph）\n 9. 堆（Heap）\n\n\n数组（Array）#\n\n数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。\n\n在日常生活中，人们经常使用列表：待办事项列表、购物清单等。\n\n而计算机程序也在使用列表，在下面的条件下，选择列表作为数据结构就显得尤为有用：数据结构较为简单不需要在一个长序列中查找元素，或者对其进行排序反之，如果数据结构非\n常复杂，列表的作用就没有那么大了。\n\n\n栈（Stack）#\n\n栈是一种遵循后进先出（LIFO）原则的有序集合在栈里，新元素都接近栈顶，旧元素都接近栈底。每次加入新的元素和拿走元素都在顶部操作\n\n\n队列（Queue）#\n\n队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项队列在尾部添加新元素，并从顶部移除元素最新添加的元素必须排在队列的末尾\n\n\n链表（Linked List）#\n\n链表也是一种列表，已经设计了数组，为什么还需要链表呢？ JavaScript 中数组的主要问题时，它们被实现成了对象，与其他语言（比如 C++和\nJava）的数组相对，效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。\n\n使用条件：链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。\n\n\n字典#\n\n字典是一种以键-值对存储数据的数据结构，js 中的 Object 类就是以字典的形式设计的。JavaScript\n可以通过实现字典类，让这种字典类型的对象使用起来更加简单，字典可以实现对象拥有的常见功能，并相应拓展自己想要的功能，而对象在 JavaScript\n编写中随处可见，所以字典的作用也异常明显了。\n\n\n散列表#\n\n也称为哈希表，特点是在散列表上插入、删除和取用数据都非常快。为什么要设计这种数据结构呢？用数组或链表存储数据，如果想要找到其中一个数据，需要从头进行遍历，因为不\n知道这个数据存储到了数组的哪个位置。\n\n散列表在 JavaScript\n中可以基础数组去进行设计。数组的长度是预先设定的，所有元素根据和该元素对应的键，保存在数组的特定位置，这里的键和对象的键是类型的概念。使用散列表存储数组时，通过\n一个散列函数将键映射为一个数字，这个数字的范围是 0 到散列表的长度。\n\n即使使用一个高效的散列函数，依然存在将两个键映射为同一个值得可能，这种现象叫做碰撞。常见碰撞的处理方法有：开链法和线性探测法（具体概念有兴趣的可以网上自信了解）\n使用条件：可以用于数据的插入、删除和取用，不适用于查找数据","routePath":"/interview/JavaScript/js_data_structure","lang":"","toc":[{"text":"什么是数据结构？","id":"什么是数据结构","depth":2,"charIndex":3},{"text":"数组（Array）","id":"数组array","depth":2,"charIndex":262},{"text":"栈（Stack）","id":"栈stack","depth":2,"charIndex":474},{"text":"队列（Queue）","id":"队列queue","depth":2,"charIndex":552},{"text":"链表（Linked List）","id":"链表linked-list","depth":2,"charIndex":635},{"text":"字典","id":"字典","depth":2,"charIndex":825},{"text":"散列表","id":"散列表","depth":2,"charIndex":986}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你了解的 js 数据结构？","footer":"说说你了解的 js 数据结构？","order":11,"star":11,"date":"2023-03-23T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你了解的 js 数据结构？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你了解的 js 数据结构？"}]]},"version":""},{"id":23,"title":"说说 Javascript 数字精度丢失的问题，如何解决？","content":"#\n\n\n\n\n一、场景复现#\n\n一个经典的面试题\n\n\n\n为什么是false呢?\n\n先看下面这个比喻\n\n比如一个数 1÷3=0.33333333......\n\n3 会一直无限循环，数学可以表示，但是计算机要存储，方便下次取出来再使用，但 0.333333......\n这个数无限循环，再大的内存它也存不下，所以不能存储一个相对于数学来说的值，只能存储一个近似值，当计算机存储后再取出时就会出现精度丢失问题\n\n\n二、浮点数#\n\n“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储\n\n我们也可以理解成，浮点数就是小数\n\n在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中 64 位双精度浮点数编码\n\n这样的存储结构优点是可以归一化处理整数和小数，节省存储空间\n\n对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固\n定了\n\n而计算机只能用二进制（0 或 1）表示，二进制转换为科学记数法的公式如下：\n\n\n\n其中，a的值为 0 或者 1，e 为小数点移动的位置\n\n举个例子：\n\n27.0 转化成二进制为 11011.0 ，科学计数法表示为：\n\n\n\n前面讲到，javaScript存储方式是双精度浮点数，其长度为 8 个字节，即 64 位比特\n\n64 位比特又可分为三个部分：\n\n * 符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数\n * 指数位 E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为 1023\n * 尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零\n\n如下图所示：\n\n\n\n举个例子：\n\n27.5 转换为二进制 11011.1\n\n11011.1 转换为科学记数法\n\n符号位为 1(正数)，指数位为 4+，1023+4，即 1027\n\n因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够 52 位即： 1011 1000 0000 0000 0000\n0000 0000 0000 0000 0000 0000 0000 0000`\n\n所以 27.5 存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示\n\n0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`\n\n\n二、问题分析#\n\n再回到问题上\n\n\n\n通过上面的学习，我们知道，在javascript语言中，0.1 和 0.2 都转化成二进制后再进行运算\n\n\n\n所以输出false\n\n再来一个问题，那么为什么x=0.1得到0.1？\n\n主要是存储二进制时小数点的偏移量最大为 52 位，最多可以表达的位数是2^53=9007199254740992，对应科学计数尾数是\n9.007199254740992，这也是 JS 最多能表示的精度\n\n它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理\n\n\n\n但看到的 0.1 实际上并不是 0.1。不信你可用更高的精度试试：\n\n\n\n如果整数大于 9007199254740992 会出现什么情况呢？\n\n由于指数位最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024\n开始就变成了 Infinity\n\n\n\n那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？\n\n * (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数\n * (2^54, 2^55) 之间的数会四个选一个，只能精确表示 4 个倍数\n * ... 依次跳过更多 2 的倍数\n\n要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生差很多\n\n\n小结#\n\n计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学\n记数法\n\n因为存储时有位数限制（64 位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0 舍 1\n入)，当再转换为十进制时就造成了计算误差\n\n\n三、解决方案#\n\n理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果\n\n当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：\n\n\n\n封装成方法就是：\n\n\n\n对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：\n\n\n\n最后还可以使用第三方库，如Math.js、BigDecimal.js\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/100353781\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Obje\n   cts/BigInt","routePath":"/interview/JavaScript/loss_accuracy","lang":"","toc":[{"text":"一、场景复现","id":"一场景复现","depth":2,"charIndex":5},{"text":"二、浮点数","id":"二浮点数","depth":2,"charIndex":202},{"text":"二、问题分析","id":"二问题分析","depth":2,"charIndex":1115},{"text":"小结","id":"小结","depth":3,"charIndex":1750},{"text":"三、解决方案","id":"三解决方案","depth":2,"charIndex":1927},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2177}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Javascript 数字精度丢失的问题，如何解决？","footer":"说说 Javascript 数字精度丢失的问题，如何解决？","order":23,"star":23,"date":"2023-04-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说 Javascript 数字精度丢失的问题，如何解决？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Javascript 数字精度丢失的问题，如何解决？"}]]},"version":""},{"id":24,"title":"说说 JavaScript 中内存泄漏的几种情况？","content":"#\n\n\n\n\n一、是什么#\n\n内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存\n\n并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费\n\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存\n\n对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃\n\n\n\n在C语言中，因为是手动管理内存，内存泄露是经常出现的事情。\n\n\n\n上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。\n\n这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"\n\n\n二、垃圾回收机制#\n\nJavascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存\n\n原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存\n\n通常情况下有两种实现方式：\n\n * 标记清除\n * 引用计数\n\n\n标记清除#\n\nJavaScript最常用的垃圾收回机制\n\n当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“\n\n垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉\n\n在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了\n\n随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存\n\n举个例子：\n\n\n\n\n引用计数#\n\n语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放\n\n如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏\n\n\n\n上面代码中，数组[1, 2, 3,\n4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存\n\n如果需要这块内存被垃圾回收机制释放，只需要设置如下：\n\n\n\n通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了\n\n\n小结#\n\n有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用\n\n\n三、常见内存泄露情况#\n\n意外的全局变量\n\n\n\n另一种意外的全局变量可能由 this 创建：\n\n\n\n上述使用严格模式，可以避免意外的全局变量\n\n定时器也常会造成内存泄露\n\n\n\n如果id为 Node\n的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放\n\n包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放\n\n\n\n没有清理对DOM元素的引用同样造成内存泄露\n\n\n\n包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听\n\n\n参考文献#\n\n * http://www.ruanyifeng.com/blog/2017/04/memory-leak.html\n * https://zh.wikipedia.org/wiki","routePath":"/interview/JavaScript/memory_leak","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、垃圾回收机制","id":"二垃圾回收机制","depth":2,"charIndex":360},{"text":"标记清除","id":"标记清除","depth":3,"charIndex":517},{"text":"引用计数","id":"引用计数","depth":3,"charIndex":769},{"text":"小结","id":"小结","depth":3,"charIndex":1065},{"text":"三、常见内存泄露情况","id":"三常见内存泄露情况","depth":2,"charIndex":1141},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1442}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 JavaScript 中内存泄漏的几种情况？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 JavaScript 中内存泄漏的几种情况？","order":6,"star":6,"date":"2023-03-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说 JavaScript 中内存泄漏的几种情况？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 JavaScript 中内存泄漏的几种情况？"}]]},"version":""},{"id":25,"title":"说说 new 操作符具体干了什么？","content":"#\n\n\n\n\n一、是什么#\n\n在JavaScript中，new操作符用于创建一个给定构造函数的实例对象\n\n例子\n\n\n\n从上面可以看到：\n\n * new 通过构造函数 Person 创建出来的实例可以访问到构造函数中的属性\n * new 通过构造函数 Person 创建出来的实例可以访问到构造函数原型链中的属性（即实例与构造函数通过原型链连接了起来）\n\n现在在构建函数中显式加上返回值，并且这个返回值是一个原始类型\n\n\n\n可以发现，构造函数中返回一个原始值，然而这个返回值并没有作用\n\n下面在构造函数中返回一个对象\n\n\n\n从上面可以发现，构造函数如果返回值为一个对象，那么这个返回值会被正常使用\n\n\n二、流程#\n\n从上面介绍中，我们可以看到new关键字主要做了以下的工作：\n\n * 创建一个新的对象obj\n\n * 将对象与构建函数通过原型链连接起来\n\n * 将构建函数中的this绑定到新建的对象obj上\n\n * 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理\n\n举个例子：\n\n\n\n流程图如下：\n\n\n\n\n三、手写 new 操作符#\n\n现在我们已经清楚地掌握了new的执行过程\n\n那么我们就动手来实现一下new\n\n\n\n测试一下\n\n\n\n可以发现，代码虽然很短，但是能够模拟实现new","routePath":"/interview/JavaScript/new","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":298},{"text":"三、手写 new 操作符","id":"三手写-new-操作符","depth":2,"charIndex":466}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 new 操作符具体干了什么？","footer":"说说 new 操作符具体干了什么？","order":31,"star":31,"date":"2023-05-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说 new 操作符具体干了什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 new 操作符具体干了什么？"}]]},"version":""},{"id":26,"title":"JavaScript 原型，原型链 ? 有什么特点？","content":"#\n\n\n\n\n一、原型#\n\nJavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象\n\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾\n\n准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身\n\n下面举个例子：\n\n函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype\n\n\n\n控制台输出\n\n\n\n上面这个对象，就是大家常说的原型对象\n\n可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示\n\n\n\n\n二、原型链#\n\n原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype\nchain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法\n\n在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方\n法\n\n下面举个例子：\n\n\n\n根据代码，我们可以得到下图\n\n\n\n下面分析一下：\n\n * 构造函数Person存在原型对象Person.prototype\n\n * 构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象\n\n * Person.prototype.__proto__ 指向内置对象，因为 Person.prototype 是个对象，默认是由\n   Object函数作为类创建的，而 Object.prototype 为内置对象\n\n * Person.__proto__ 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建\n\n * Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null\n\n\n三、总结#\n\n下面首先要看几个概念：\n\n__proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的\n\n\n\n每个对象的__proto__都是指向它的构造函数的原型对象prototype的\n\n\n\n构造函数是一个函数对象，是通过 Function构造器产生的\n\n\n\n原型对象本身是一个普通对象，而普通对象的构造函数都是Object\n\n\n\n刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的\n\n\n\nObject的原型对象也有__proto__属性指向null，null是原型链的顶端\n\n\n\n下面作出总结：\n\n * 一切对象都是继承自Object对象，Object 对象直接继承根源对象null\n\n * 一切的函数对象（包括 Object 对象），都是继承自 Function 对象\n\n * Object 对象直接继承自 Function 对象\n\n * Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象\n\n\n参考文献#\n\n * https://juejin.cn/post/6870732239556640775#heading-7\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_p\n   rototype_chain","routePath":"/interview/JavaScript/prototype","lang":"","toc":[{"text":"一、原型","id":"一原型","depth":2,"charIndex":5},{"text":"二、原型链","id":"二原型链","depth":2,"charIndex":340},{"text":"三、总结","id":"三总结","depth":2,"charIndex":920},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1366}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-JavaScript 原型，原型链 ? 有什么特点？","footer":"JavaScript 原型，原型链 ? 有什么特点？","order":35,"star":35,"date":"2023-05-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-JavaScript 原型，原型链 ? 有什么特点？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"JavaScript 原型，原型链 ? 有什么特点？"}]]},"version":""},{"id":27,"title":"如何实现上拉加载，下拉刷新？","content":"#\n\n\n\n\n一、前言#\n\n下拉刷新和上拉加载这两种交互方式通常出现在移动端中\n\n本质上等同于 PC 网页中的分页，只是交互形式不同\n\n开源社区也有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等\n\n这些第三方库使用起来非常便捷\n\n我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用\n\n\n二、实现原理#\n\n上拉加载及下拉刷新都依赖于用户交互\n\n最重要的是要理解在什么场景，什么时机下触发交互动作\n\n\n上拉加载#\n\n首先可以看一张图\n\n\n\n上拉加载的本质是页面触底，或者快要触底时的动作\n\n判断页面触底我们需要先了解一下下面几个属性\n\n * scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是 0，它是一个变化的值\n\n * clientHeight:它是一个定值，表示屏幕可视区域的高度；\n\n * scrollHeight：页面不能滚动时也是存在的,此时 scrollHeight 等于 clientHeight。scrollHeight\n   表示body所有元素的总长度(包括 body 元素自身的 padding)\n\n综上我们得出一个触底公式：\n\n\n\n简单实现\n\n\n\n\n下拉刷新#\n\n下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作\n\n关于下拉刷新的原生实现，主要分成三步：\n\n * 监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY；\n * 监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助 CSS3\n   的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；\n * 监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置\n\n举个例子：\n\nHtml结构如下：\n\n\n\n监听touchstart事件，记录初始的值\n\n\n\n监听touchmove移动事件，记录滑动差值\n\n\n\n最后，就是监听touchend离开的事件\n\n\n\n从上面可以看到，在下拉到松手的过程中，经历了三个阶段：\n\n * 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作\n * 下拉到一定值时，显示松手释放后的操作提示\n * 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作\n\n\n三、案例#\n\n在实际开发中，我们更多的是使用第三方库，下面以better-scroll进行举例：\n\nHTML 结构\n\n\n\n实例化上拉下拉插件，通过use来注册插件\n\n\n\n实例化BetterScroll，并传入相关的参数\n\n\n\n注意点：\n\n使用better-scroll实现下拉刷新、上拉加载时要注意以下几点：\n\n * wrapper里必须只有一个子元素\n * 子元素的高度要比wrapper要高\n * 使用的时候，要确定DOM元素是否已经生成，必须要等到DOM渲染完成后，再new BScroll()\n * 滚动区域的DOM元素结构有变化后，需要执行刷新 refresh()\n * 上拉或者下拉，结束后，需要执行finishPullUp()或者finishPullDown()，否则将不会执行下次操作\n * better-scroll，默认会阻止浏览器的原生click事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置click:true\n\n\n小结#\n\n下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000014423308\n * https://github.com/ustbhuangyi/better-scroll","routePath":"/interview/JavaScript/pull_up_loading_pull_down_refresh","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、实现原理","id":"二实现原理","depth":2,"charIndex":185},{"text":"上拉加载","id":"上拉加载","depth":3,"charIndex":241},{"text":"下拉刷新","id":"下拉刷新","depth":3,"charIndex":552},{"text":"三、案例","id":"三案例","depth":2,"charIndex":1063},{"text":"小结","id":"小结","depth":3,"charIndex":1489},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1546}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何实现上拉加载，下拉刷新？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>如何实现上拉加载，下拉刷新？","order":1,"star":1,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-如何实现上拉加载，下拉刷新？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何实现上拉加载，下拉刷新？"}]]},"version":""},{"id":28,"title":"说说你对正则表达式的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n正则表达式是一种用来匹配字符串的强有力的武器\n\n它的设计思想是用一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的\n\n在 JavaScript中，正则表达式也是对象，构建正则表达式有两种方式：\n\n 1. 字面量创建，其由包含在斜杠之间的模式组成\n\n\n\n 2. 调用RegExp对象的构造函数\n\n\n\n使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符\\需要使用\\\\进行转义\n\n\n二、匹配规则#\n\n常见的校验规则如下：\n\n规则        描述\n\\         转义\n^         匹配输入的开始\n$         匹配输入的结束\n*         匹配前一个表达式 0 次或多次\n+         匹配前面一个表达式 1 次或者多次。等价于 {1,}\n?         匹配前面一个表达式 0 次或者 1 次。等价于{0,1}\n.         默认匹配除换行符之外的任何单个字符\nx(?=y)    匹配'x'仅仅当'x'后面跟着'y'。这种叫做先行断言\n(?<=y)x   匹配'x'仅当'x'前面是'y'.这种叫做后行断言\nx(?!y)    仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找\n(?y)x     仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找\nx|y       匹配‘x’或者‘y’\n{n}       n 是一个正整数，匹配了前面一个字符刚好出现了 n 次\n{n,}      n 是一个正整数，匹配前一个字符至少出现了 n 次\n{n,m}     n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次\n[xyz]     一个字符集合。匹配方括号中的任意字符\n[^xyz]    匹配任何没有包含在方括号中的字符\n\\b        匹配一个词的边界，例如在字母和空格之间\n\\B        匹配一个非单词边界\n\\d        匹配一个数字\n\\D        匹配一个非数字字符\n\\f        匹配一个换页符\n\\n        匹配一个换行符\n\\r        匹配一个回车符\n\\s        匹配一个空白字符，包括空格、制表符、换页符和换行符\n\\S        匹配一个非空白字符\n\\w        匹配一个单字字符（字母、数字或者下划线）\n\\W        匹配一个非单字字符\n\n\n正则表达式标记#\n\n标志   描述\ng    全局搜索。\ni    不区分大小写搜索。\nm    多行搜索。\ns    允许 . 匹配换行符。\nu    使用unicode码的模式进行匹配。\ny    执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。\n\n使用方法如下：\n\n\n\n在了解下正则表达式基本的之外，还可以掌握几个正则表达式的特性：\n\n\n贪婪模式#\n\n在了解贪婪模式前，首先举个例子：\n\n\n\n在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。首先会尝试bbb，然后再看整个正则是否能匹配。不能匹配时，吐出一个b，即在bb的基础上，再继续尝试，以此重复\n\n如果多个贪婪量词挨着，则深度优先搜索\n\n\n\n其中，前面的\\d{1,3}匹配的是\"123\"，后面的\\d{1,3}匹配的是\"45\"\n\n\n懒惰模式#\n\n惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配\n\n\n\n其中\\d{1,3}?只匹配到一个字符\"1\"，而后面的\\d{1,3}匹配了\"234\"\n\n\n分组#\n\n分组主要是用过()进行实现，比如beyond{3}，是匹配d字母 3 次。而(beyond){3}是匹配beyond三次\n\n在()内使用|达到或的效果，如(abc | xxx)可以匹配abc或者xxx\n\n反向引用，巧用$分组捕获\n\n\n\n\n三、匹配方法#\n\n正则表达式常被用于某些方法，我们可以分成两类：\n\n * 字符串（str）方法：match、matchAll、search、replace、split\n * 正则对象下（regexp）的方法：test、exec\n\n方法         描述\nexec       一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。\ntest       一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。\nmatch      一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。\nmatchAll   一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。\nsearch     一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回-1。\nreplace    一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。\nsplit      一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。\n\n\nstr.match(regexp)#\n\nstr.match(regexp) 方法在字符串 str 中找到匹配 regexp 的字符\n\n如果 regexp 不带有 g 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 index（匹配项的位置）、input（输入字符串，等于 str）\n\n\n\n如果 regexp 带有 g 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息\n\n\n\n如果没有匹配项，则无论是否带有标记 g ，都将返回 null\n\n\n\n\nstr.matchAll(regexp)#\n\n返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器\n\n\n\n\nstr.search(regexp)#\n\n返回第一个匹配项的位置，如果未找到，则返回 -1\n\n\n\n这里需要注意的是，search 仅查找第一个匹配项\n\n\nstr.replace(regexp)#\n\n替换与正则表达式匹配的子串，并返回替换后的字符串。在不设置全局匹配g的时候，只替换第一个匹配成功的字符串片段\n\n\n\n\nstr.split(regexp)#\n\n使用正则表达式（或子字符串）作为分隔符来分割字符串\n\n\n\n\nregexp.exec(str)#\n\nregexp.exec(str) 方法返回字符串 str 中的 regexp 匹配项，与以前的方法不同，它是在正则表达式而不是字符串上调用的\n\n根据正则表达式是否带有标志 g，它的行为有所不同\n\n如果没有 g，那么 regexp.exec(str) 返回的第一个匹配与 str.match(regexp) 完全相同\n\n如果有标记 g，调用 regexp.exec(str) 会返回第一个匹配项，并将紧随其后的位置保存在属性regexp.lastIndex 中。\n下一次同样的调用会从位置 regexp.lastIndex 开始搜索，返回下一个匹配项，并将其后的位置保存在 regexp.lastIndex 中\n\n\n\n\nregexp.test(str)#\n\n查找匹配项，然后返回 true/false 表示是否存在\n\n\n\n\n四、应用场景#\n\n通过上面的学习，我们对正则表达式有了一定的了解\n\n下面再来看看正则表达式一些案例场景：\n\n验证 QQ 合法性（5~15 位、全是数字、不以 0 开头）：\n\n\n\n校验用户账号合法性（只能输入 5-20 个以字母开头、可带数字、“_”、“.”的字串）：\n\n\n\n将url参数解析为对象\n\n\n\n再将上面的search和hash进行解析\n\n\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Express\n   ions","routePath":"/interview/JavaScript/regexp","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、匹配规则","id":"二匹配规则","depth":2,"charIndex":230},{"text":"正则表达式标记","id":"正则表达式标记","depth":3,"charIndex":1043},{"text":"贪婪模式","id":"贪婪模式","depth":3,"charIndex":1224},{"text":"懒惰模式","id":"懒惰模式","depth":3,"charIndex":1399},{"text":"分组","id":"分组","depth":3,"charIndex":1481},{"text":"三、匹配方法","id":"三匹配方法","depth":2,"charIndex":1605},{"text":"str.match(regexp)","id":"strmatchregexp","depth":3,"charIndex":2149},{"text":"str.matchAll(regexp)","id":"strmatchallregexp","depth":3,"charIndex":2388},{"text":"str.search(regexp)","id":"strsearchregexp","depth":3,"charIndex":2444},{"text":"str.replace(regexp)","id":"strreplaceregexp","depth":2,"charIndex":2521},{"text":"str.split(regexp)","id":"strsplitregexp","depth":3,"charIndex":2602},{"text":"regexp.exec(str)","id":"regexpexecstr","depth":3,"charIndex":2652},{"text":"regexp.test(str)","id":"regexpteststr","depth":3,"charIndex":2980},{"text":"四、应用场景","id":"四应用场景","depth":2,"charIndex":3032},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":3209}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对正则表达式的理解？应用场景？","footer":"说说你对正则表达式的理解？应用场景？","order":8,"star":8,"date":"2023-03-19T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对正则表达式的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对正则表达式的理解？应用场景？"}]]},"version":""},{"id":29,"title":"说说你对作用域链的理解","content":"#\n\n\n\n\n一、作用域#\n\n作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合\n\n换句话说，作用域决定了代码区块中变量和其他资源的可见性\n\n举个例子\n\n\n\n上述例子中，函数myFunction内部创建一个inVariable变量，当我们在全局访问这个变量的时候，系统会报错\n\n这就说明我们在全局是无法获取到（闭包除外）函数内部的变量\n\n我们一般将作用域分成：\n\n * 全局作用域\n\n * 函数作用域\n\n * 块级作用域\n\n\n全局作用域#\n\n任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问\n\n\n\n\n函数作用域#\n\n函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问\n\n\n\n可见上述代码中在函数内部声明的变量或函数，在函数外部是无法访问的，这说明在函数内部定义的变量或者方法只是函数作用域\n\n\n块级作用域#\n\nES6 引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中。在大括号之外不能访问这些变量\n\n\n\n\n二、词法作用域#\n\n词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域\n\n\n\n上述代码改变成一张图\n\n\n\n由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出 2\n\n\n三、作用域链#\n\n当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到\n该变量或是已经到了全局作用域\n\n如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错\n\n这里拿《你不知道的 Javascript(上)》中的一张图解释：\n\n把作用域比喻成一个建筑，这份建筑代表程序中的嵌套作用域链，第一层代表当前的执行作用域，顶层代表全局作用域\n\n\n\n变量的引用会顺着当前楼层进行查找，如果找不到，则会往上一层找，一旦到达顶层，查找的过程都会停止\n\n下面代码演示下：\n\n\n\n上述代码主要主要做了以下工作：\n\n * student函数内部属于最内层作用域，找不到name，向上一层作用域person函数内部找，找到了输出“张三”\n * student内部输出sex时找不到，向上一层作用域person函数找，还找不到继续向上一层找，即全局作用域，找到了输出“男”\n * 在person函数内部输出age时找不到，向上一层作用域找，即全局作用域，还是找不到则报错","routePath":"/interview/JavaScript/scope","lang":"","toc":[{"text":"一、作用域","id":"一作用域","depth":2,"charIndex":5},{"text":"全局作用域","id":"全局作用域","depth":3,"charIndex":222},{"text":"函数作用域","id":"函数作用域","depth":3,"charIndex":287},{"text":"块级作用域","id":"块级作用域","depth":3,"charIndex":424},{"text":"二、词法作用域","id":"二词法作用域","depth":2,"charIndex":512},{"text":"三、作用域链","id":"三作用域链","depth":2,"charIndex":682}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对作用域链的理解","footer":"说说你对作用域链的理解","order":24,"star":24,"date":"2023-04-20T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-说说你对作用域链的理解","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对作用域链的理解"}]]},"version":""},{"id":30,"title":"web 常见的攻击方式有哪些？如何防御？","content":"#\n\n\n\n\n一、是什么#\n\nWeb 攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为\n\n如植入恶意代码，修改网站权限，获取网站用户隐私信息等等\n\nWeb 应用程序的安全性是任何基于 Web 业务的重要组成部分\n\n确保 Web 应用程序安全十分重要，即使是代码中很小的 bug 也有可能导致隐私信息被泄露\n\n站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践\n\n我们常见的 Web 攻击方式有\n\n * XSS (Cross Site Scripting) 跨站脚本攻击\n * CSRF（Cross-site request forgery）跨站请求伪造\n * SQL 注入攻击\n\n\n二、XSS#\n\nXSS，跨站脚本攻击，允许攻击者将恶意代码植入到提供给其它用户使用的页面中\n\nXSS涉及到三方，即攻击者、客户端与Web应用\n\nXSS的攻击目标是为了盗取存储在客户端的cookie或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交\n互\n\n举个例子：\n\n一个搜索页面，根据url参数决定关键词的内容\n\n\n\n这里看似并没有问题，但是如果不按套路出牌呢？\n\n用户输入\">，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：\n\n\n\n浏览器无法分辨出 是恶意代码，因而将其执行，试想一下，如果是获取cookie发送对黑客服务器呢？\n\n根据攻击的来源，XSS攻击可以分成：\n\n * 存储型\n * 反射型\n * DOM 型\n\n\n存储型#\n\n存储型 XSS 的攻击步骤：\n\n 1. 攻击者将恶意代码提交到目标网站的数据库中\n 2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器\n 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等\n\n\n反射型 XSS#\n\n反射型 XSS 的攻击步骤：\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码\n 2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器\n 3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行\n 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。\n\n由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\n\nPOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见\n\n\nDOM 型 XSS#\n\nDOM 型 XSS 的攻击步骤：\n\n 1. 攻击者构造出特殊的 URL，其中包含恶意代码\n 2. 用户打开带有恶意代码的 URL\n 3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行\n 4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作\n\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript\n自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞\n\n\nXSS 的预防#\n\n通过前面介绍，看到XSS攻击的两大要素：\n\n * 攻击者提交而恶意代码\n * 浏览器执行恶意代码\n\n针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了\n\n而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示\n\n例如：\n\n一个正常的用户输入了 5 < 7 这个内容，在写入数据库前，被转义，变成了 5 < 7\n\n在客户端中，一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 < 7 )\n\n在前端中，不同的位置所需的编码也不同。\n\n * 当 5 < 7 作为 HTML 拼接页面时，可以正常显示：\n\n\n\n * 当 5 < 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue\n   等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等\n\n可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：\n\n在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用\n.textContent、.setAttribute() 等\n\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免\ninnerHTML、outerHTML 的 XSS 隐患\n\nDOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等， 标签的 href\n属性，JavaScript 的 eval()、setTimeout()、setInterval()\n等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免\n\n\n\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作\n\n还有一种为使用a标签的，需要用户点击链接才会触发\n\n访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作\n\n\n\n\nCSRF 的特点#\n\n * 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生\n * 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据\n * 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”\n * 跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪\n\n\nCSRF 的预防#\n\nCSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性\n\n防止csrf常用方案如下：\n\n * 阻止不明外域的访问\n   * 同源检测\n   * Samesite Cookie\n * 提交时要求附加本域才能获取的信息\n   * CSRF Token\n   * 双重 Cookie 验证\n\n这里主要讲讲token这种形式，流程如下：\n\n * 用户打开页面的时候，服务器需要给这个用户生成一个 Token\n * 对于 GET 请求，Token 将附在请求地址之后。对于 POST 请求来说，要在 form 的最后加上\n\n\n\n * 当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性\n\n\n四、SQL 注入#\n\nSql 注入攻击，是通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击\n\n\n\n流程如下所示：\n\n * 找出 SQL 漏洞的注入点\n\n * 判断数据库的类型以及版本\n\n * 猜解用户名和密码\n\n * 利用工具查找 Web 后台管理入口\n\n * 入侵和破坏\n\n预防方式如下：\n\n * 严格检查输入变量的类型和格式\n * 过滤和转义特殊字符\n * 对访问数据库的 Web 应用程序采用 Web 应用防火墙\n\n上述只是列举了常见的web攻击方式，实际开发过程中还会遇到很多安全问题，对于这些问题， 切记不可忽视\n\n\n参考文献#\n\n * https://tech.meituan.com/2018/09/27/fe-security.html\n * https://developer.mozilla.org/zh-CN/docs/learn/Server-side/First_steps/Websit\n   e_security","routePath":"/interview/JavaScript/security","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、XSS","id":"二xss","depth":2,"charIndex":315},{"text":"存储型","id":"存储型","depth":3,"charIndex":663},{"text":"反射型 XSS","id":"反射型-xss","depth":3,"charIndex":887},{"text":"DOM 型 XSS","id":"dom-型-xss","depth":3,"charIndex":1301},{"text":"XSS 的预防","id":"xss-的预防","depth":3,"charIndex":1586},{"text":"三、CSRF","id":"三csrf","depth":2,"charIndex":-1},{"text":"CSRF 的特点","id":"csrf-的特点","depth":3,"charIndex":2570},{"text":"CSRF 的预防","id":"csrf-的预防","depth":3,"charIndex":2770},{"text":"四、SQL 注入","id":"四sql-注入","depth":2,"charIndex":3126},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":3416}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-web 常见的攻击方式有哪些？如何防御？","footer":"web 常见的攻击方式有哪些？如何防御？","order":14,"star":14,"date":"2023-03-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-web 常见的攻击方式有哪些？如何防御？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"web 常见的攻击方式有哪些？如何防御？"}]]},"version":""},{"id":31,"title":"什么是单点登录？如何实现？","content":"#\n\n\n\n\n一、是什么#\n\n单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一\n\nSSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统\n\nSSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作\n\n当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport\n授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证\n\n\n\n上图有四个系统，分别是Application1、Application2、Application3、和SSO，当Application1、Application\n2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了\n\n举个例子#\n\n淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录\n\n\n二、如何实现#\n\n\n同域名下的单点登录#\n\ncookie的domain属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径\n\n利用 Cookie 的这个特点，没错，我们只需要将Cookie的domain属性设置为父域的域名（主域名），同时将 Cookie的path属性设置为根路径，将\nSession ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个Cookie\n\n不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在\nbaidu.com这个主域名之下，那么它们就可以通过这种方式来实现单点登录\n\n\n不同域名下的单点登录(一)#\n\n如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web服务\n\n用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个\nCookie是认证中心的，应用系统是访问不到的）\n\n应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心\n\n由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了\n\n如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录\n\n如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL，并在跳转前生成一个 Token，拼接在目标URL 的后面，回传给目标应用系统\n\n应用系统拿到 Token之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将\nToken写入Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个\nToken，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了\n\n此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法\n\n\n不同域名下的单点登录(二)#\n\n可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage\n中，让前端在每次向后端发送请求时，主动将LocalStorage的数据传递给服务端\n\n这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID（或 Token）放在响应体中传递给前端\n\n单点登录完全可以在前端实现。前端拿到 Session ID（或 Token ）后，除了将它写入自己的 LocalStorage\n中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中\n\n关键代码如下：\n\n\n\n前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage\n中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取Token并在请求中携带，这样就实现了同一份Token 被多个域所共享\n\n此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域\n\n\n三、流程#\n\n单点登录的流程图如下所示：\n\n\n\n * 用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数\n\n * sso 认证中心发现用户未登录，将用户引导至登录页面\n\n * 用户输入用户名密码提交登录申请\n\n * sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌\n\n * sso 认证中心带着令牌跳转会最初的请求地址（系统 1）\n\n * 系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效\n\n * sso 认证中心校验令牌，返回有效，注册系统 1\n\n * 系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源\n\n * 用户访问系统 2 的受保护资源\n\n * 系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数\n\n * sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌\n\n * 系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效\n\n * sso 认证中心校验令牌，返回有效，注册系统 2\n\n * 系统 2 使用该令牌创建与用户的局部会话，返回受保护资源\n\n用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话\n\n用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心\n\n全局会话与局部会话有如下约束关系：\n\n * 局部会话存在，全局会话一定存在\n * 全局会话存在，局部会话不一定存在\n * 全局会话销毁，局部会话必须销毁\n\n\n参考文献#\n\n * https://blog.csdn.net/weixin_36380516/article/details/109006828\n * https://baike.baidu.com/item/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95\n * https://juejin.cn/post/6844903664985866253","routePath":"/interview/JavaScript/single_sign","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"举个例子","id":"举个例子","depth":4,"charIndex":433},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":496},{"text":"同域名下的单点登录","id":"同域名下的单点登录","depth":3,"charIndex":506},{"text":"不同域名下的单点登录(一)","id":"不同域名下的单点登录一","depth":3,"charIndex":824},{"text":"不同域名下的单点登录(二)","id":"不同域名下的单点登录二","depth":3,"charIndex":1423},{"text":"三、流程","id":"三流程","depth":2,"charIndex":1882},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2584}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-什么是单点登录？如何实现？","footer":"什么是单点登录？如何实现？","order":32,"star":32,"date":"2023-05-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-什么是单点登录？如何实现？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"什么是单点登录？如何实现？"}]]},"version":""},{"id":32,"title":"JavaScript 字符串的常用方法有哪些？","content":"#\n\n\n\n\n一、操作方法#\n\n我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道字符串的特点是一旦创建了，就不可变\n\n\n增#\n\n这里增的意思并不是说直接增添内容，而是创建字符串的一个副本，再进行操作\n\n除了常用+以及${}进行字符串拼接之外，还可通过concat\n\nconcat#\n\n用于将一个或多个字符串拼接成一个新字符串\n\n\n\n\n删#\n\n这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作\n\n常见的有：\n\n * slice()\n * substr()\n * substring()\n\n这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。\n\n\n\n\n改#\n\n这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作\n\n常见的有：\n\n * trim()、trimLeft()、trimRight()\n\n * repeat()\n\n * padStart()、padEnd()\n\n * toLowerCase()、 toUpperCase()\n\ntrim()、trimLeft()、trimRight()#\n\n删除前、后或前后所有空格符，再返回新的字符串\n\n\n\nrepeat()#\n\n接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果\n\n\n\npadEnd()#\n\n复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件\n\n\n\n\ntoLowerCase()、 toUpperCase()#\n\n大小写转化\n\n\n\n\n查#\n\n除了通过索引的方式获取字符串的值，还可通过：\n\n * chatAt()\n\n * indexOf()\n\n * startWith()\n\n * includes()\n\ncharAt()#\n\n返回给定索引位置的字符，由传给方法的整数参数指定\n\n\n\nindexOf()#\n\n从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）\n\n\n\nstartWith()、includes()#\n\n从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值\n\n\n\n\n二、转换方法#\n\n\nsplit#\n\n把字符串按照指定的分割符，拆分成数组中的每一项\n\n\n\n\n三、模板匹配方法#\n\n针对正则表达式，字符串设计了几个方法：\n\n * match()\n * search()\n * replace()\n\n\nmatch()#\n\n接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，返回数组\n\n\n\n\nsearch()#\n\n接收一个参数，可以是一个正则表达式字符串，也可以是一个RegExp对象，找到则返回匹配索引，否则返回 -1\n\n\n\n\nreplace()#\n\n接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数）\n\n","routePath":"/interview/JavaScript/string_api","lang":"","toc":[{"text":"一、操作方法","id":"一操作方法","depth":2,"charIndex":5},{"text":"增","id":"增","depth":3,"charIndex":64},{"text":"concat","id":"concat","depth":4,"charIndex":137},{"text":"删","id":"删","depth":3,"charIndex":171},{"text":"改","id":"改","depth":3,"charIndex":303},{"text":"trim()、trimLeft()、trimRight()","id":"trimtrimlefttrimright","depth":4,"charIndex":454},{"text":"repeat()","id":"repeat","depth":4,"charIndex":512},{"text":"padEnd()","id":"padend","depth":4,"charIndex":563},{"text":"toLowerCase()、 toUpperCase()","id":"tolowercase-touppercase","depth":3,"charIndex":613},{"text":"查","id":"查","depth":3,"charIndex":654},{"text":"charAt()","id":"charat","depth":4,"charIndex":740},{"text":"indexOf()","id":"indexof","depth":4,"charIndex":779},{"text":"startWith()、includes()","id":"startwithincludes","depth":4,"charIndex":831},{"text":"二、转换方法","id":"二转换方法","depth":2,"charIndex":890},{"text":"split","id":"split","depth":3,"charIndex":900},{"text":"三、模板匹配方法","id":"三模板匹配方法","depth":2,"charIndex":936},{"text":"match()","id":"match","depth":3,"charIndex":1006},{"text":"search()","id":"search","depth":3,"charIndex":1061},{"text":"replace()","id":"replace","depth":3,"charIndex":1130}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-JavaScript 字符串的常用方法有哪些？","footer":"JavaScript 字符串的常用方法有哪些？","order":25,"star":25,"date":"2023-04-20T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-JavaScript 字符串的常用方法有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"JavaScript 字符串的常用方法有哪些？"}]]},"version":""},{"id":33,"title":"举例说明你对尾递归的理解，有哪些应用场景","content":"#\n\n\n\n\n一、递归#\n\n递归（英语：Recursion）\n\n在数学与计算机科学中，是指在函数的定义中使用函数自身的方法\n\n在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数\n\n其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n\n一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回\n\n下面实现一个函数 pow(x, n)，它可以计算 x 的 n 次方\n\n使用迭代的方式，如下：\n\n\n\n使用递归的方式，如下：\n\n\n\npow(x, n) 被调用时，执行分为两个分支：\n\n\n\n也就是说pow 递归地调用自身 直到 n == 1\n\n\n\n为了计算 pow(2, 4)，递归变体经过了下面几个步骤：\n\n 1. pow(2, 4) = 2 * pow(2, 3)\n 2. pow(2, 3) = 2 * pow(2, 2)\n 3. pow(2, 2) = 2 * pow(2, 1)\n 4. pow(2, 1) = 2\n\n因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果\n\n\n二、尾递归#\n\n尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数\n\n尾递归在普通尾调用的基础上，多出了 2 个特征：\n\n * 在尾部调用的是函数自身\n * 可通过优化，使得计算仅占用常量栈空间\n\n在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出\n\n这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误\n\n实现一下阶乘，如果用普通的递归，如下：\n\n\n\n如果n等于 5，这个方法要执行 5 次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为O(n)\n\n如果我们使用尾递归，则如下：\n\n\n\n可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1)\n\n\n二、应用场景#\n\n数组求和\n\n\n\n使用尾递归优化求斐波那契数列\n\n\n\n数组扁平化\n\n\n\n数组对象格式化\n\n\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8","routePath":"/interview/JavaScript/tail_recursion","lang":"","toc":[{"text":"一、递归","id":"一递归","depth":2,"charIndex":5},{"text":"二、尾递归","id":"二尾递归","depth":2,"charIndex":520},{"text":"二、应用场景","id":"二应用场景","depth":2,"charIndex":971},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1027}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-举例说明你对尾递归的理解，有哪些应用场景","footer":"举例说明你对尾递归的理解，有哪些应用场景","order":27,"star":27,"date":"2023-05-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-举例说明你对尾递归的理解，有哪些应用场景","isOriginal":false,"head":[["meta",{"name":"keywords","content":"举例说明你对尾递归的理解，有哪些应用场景"}]]},"version":""},{"id":34,"title":"谈谈 this 对象的理解","content":"#\n\n\n\n\n一、定义#\n\n函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别\n\n在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）\n\nthis 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象\n\n举个例子：\n\n\n\n同时，this在函数执行过程中，this一旦被确定了，就不可以再更改\n\n\n\n\n二、绑定规则#\n\n根据不同的使用场合，this有不同的值，主要分为下面几种情况：\n\n * 默认绑定\n\n * 隐式绑定\n\n * new 绑定\n\n * 显示绑定\n\n\n默认绑定#\n\n全局环境中定义person函数，内部使用this关键字\n\n\n\n上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny\n\n注意：\n\n严格模式下，不能将全局对象用于默认绑定，this 会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象\n\n\n隐式绑定#\n\n函数还可以作为某个对象的方法调用，这时this就指这个上级对象\n\n\n\n这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象\n\n\n\n上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined\n\n这里再举一种特殊情况\n\n\n\n此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向\nwindow\n\n\nnew 绑定#\n\n通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象\n\n\n\n上述代码之所以能过输出 1，是因为new关键字改变了this的指向\n\n这里再列举一些特殊情况：\n\nnew过程遇到return一个对象，此时this指向为返回的对象\n\n\n\n如果返回一个简单类型的时候，则this指向实例对象\n\n\n\n注意的是null虽然也是对象，但是此时new仍然指向实例对象\n\n\n\n\n显示修改#\n\napply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是\n这第一个参数\n\n\n\n关于apply、call、bind三者的区别，我们后面再详细说\n\n\n三、箭头函数#\n\n在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）\n\n举个例子：\n\n\n\n虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑\n\n下面举个例子：\n\n绑定事件监听\n\n\n\n上述可以看到，我们其实是想要this为点击的button，但此时this指向了window\n\n包括在原型上添加方法时候，此时this指向window\n\n\n\n同样的，箭头函数不能作为构建函数\n\n\n四、优先级#\n\n\n隐式绑定 VS 显式绑定#\n\n\n\n显然，显示绑定的优先级更高\n\n\nnew 绑定 VS 隐式绑定#\n\n\n\n可以看到，new 绑定的优先级>隐式绑定\n\n\nnew绑定 VS 显式绑定#\n\n因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试\n\n\n\nbar被绑定到 obj1 上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为 3。但是，new修改了绑定调用bar()中的this\n\n我们可认为new绑定优先级>显式绑定\n\n综上，new 绑定优先级 > 显示绑定优先级 > 隐式绑定优先级 > 默认绑定优先级\n\n\n相关链接#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/t\n   his","routePath":"/interview/JavaScript/this","lang":"","toc":[{"text":"一、定义","id":"一定义","depth":2,"charIndex":5},{"text":"二、绑定规则","id":"二绑定规则","depth":2,"charIndex":202},{"text":"默认绑定","id":"默认绑定","depth":3,"charIndex":283},{"text":"隐式绑定","id":"隐式绑定","depth":3,"charIndex":456},{"text":"new 绑定","id":"new-绑定","depth":3,"charIndex":700},{"text":"显示修改","id":"显示修改","depth":3,"charIndex":897},{"text":"三、箭头函数","id":"三箭头函数","depth":2,"charIndex":1029},{"text":"四、优先级","id":"四优先级","depth":2,"charIndex":1259},{"text":"隐式绑定 VS 显式绑定","id":"隐式绑定-vs-显式绑定","depth":3,"charIndex":1268},{"text":"new 绑定 VS 隐式绑定","id":"new-绑定-vs-隐式绑定","depth":3,"charIndex":1301},{"text":"`new`绑定 VS 显式绑定","id":"new绑定-vs-显式绑定","depth":3,"charIndex":-1},{"text":"相关链接","id":"相关链接","depth":2,"charIndex":1549}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-谈谈 this 对象的理解","footer":"谈谈 this 对象的理解","order":30,"star":30,"date":"2023-05-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-谈谈 this 对象的理解","isOriginal":false,"head":[["meta",{"name":"keywords","content":"谈谈 this 对象的理解"}]]},"version":""},{"id":35,"title":"谈谈 JavaScript 中的类型转换机制","content":"#\n\n\n\n\n一、概述#\n\n前面我们讲到，JS中有六种简单数据类型：undefined、null、boolean、string、number、symbol，以及引用类型：object\n\n但是我们在声明的时候只有一种数据类型，只有到运行期间才会确定当前类型\n\n\n\n上面代码中，x的值在编译阶段是无法获取的，只有等到程序运行时才能知道\n\n虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的，如果运算子的类型与预期不符合，就会触发类型转换机制\n\n常见的类型转换有：\n\n * 强制转换（显示转换）\n * 自动转换（隐式转换）\n\n\n二、显示转换#\n\n显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：\n\n * Number()\n * parseInt()\n * String()\n * Boolean()\n\n\nNumber()#\n\n将任意类型的值转化为数值\n\n先给出类型转换规则：\n\n\n\n实践一下：\n\n\n\n从上面可以看到，Number转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为NaN\n\n\nparseInt()#\n\nparseInt相比Number，就没那么严格了，parseInt函数逐个解析字符，遇到不能转换的字符就停下来\n\n\n\n\nString()#\n\n可以将任意类型的值转化成字符串\n\n给出转换规则图：\n\n\n\n实践一下：\n\n\n\n\nBoolean()#\n\n可以将任意类型的值转为布尔值，转换规则如下：\n\n\n\n实践一下：\n\n\n\n\n三、隐式转换#\n\n在隐式转换中，我们可能最大的疑惑是 ：何时发生隐式转换？\n\n我们这里可以归纳为两种情况发生隐式转换的场景：\n\n * 比较运算（==、!=、>、<）、if、while需要布尔值地方\n * 算术运算（+、-、*、/、%）\n\n除了上面的场景，还要求运算符两边的操作数不是同一类型\n\n\n自动转换为布尔值#\n\n在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用Boolean函数\n\n可以得出个小结：\n\n * undefined\n * null\n * false\n * +0\n * -0\n * NaN\n * \"\"\n\n除了上面几种会被转化成false，其他都换被转化成true\n\n\n自动转换成字符串#\n\n遇到预期为字符串的地方，就会将非字符串的值自动转为字符串\n\n具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串\n\n常发生在+运算中，一旦存在字符串，则会进行字符串拼接操作\n\n\n\n\n自动转换成数值#\n\n除了+有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值\n\n\n\nnull转为数值时，值为0 。undefined转为数值时，值为NaN","routePath":"/interview/JavaScript/type_conversion","lang":"","toc":[{"text":"一、概述","id":"一概述","depth":2,"charIndex":5},{"text":"二、显示转换","id":"二显示转换","depth":2,"charIndex":266},{"text":"Number()","id":"number","depth":3,"charIndex":363},{"text":"parseInt()","id":"parseint","depth":3,"charIndex":466},{"text":"String()","id":"string","depth":3,"charIndex":539},{"text":"Boolean()","id":"boolean","depth":3,"charIndex":589},{"text":"三、隐式转换","id":"三隐式转换","depth":2,"charIndex":637},{"text":"自动转换为布尔值","id":"自动转换为布尔值","depth":3,"charIndex":785},{"text":"自动转换成字符串","id":"自动转换成字符串","depth":3,"charIndex":940},{"text":"自动转换成数值","id":"自动转换成数值","depth":3,"charIndex":1052}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-谈谈 JavaScript 中的类型转换机制","footer":"谈谈 JavaScript 中的类型转换机制","order":18,"star":18,"date":"2023-04-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-谈谈 JavaScript 中的类型转换机制","isOriginal":false,"head":[["meta",{"name":"keywords","content":"谈谈 JavaScript 中的类型转换机制"}]]},"version":""},{"id":36,"title":"typeof 与 instanceof 区别","content":"#\n\n\n\n\n一、typeof#\n\ntypeof 操作符返回一个字符串，表示未经计算的操作数的类型\n\n使用方法如下：\n\n\n\noperand表示对象或原始值的表达式，其类型将被返回\n\n举个例子\n\n\n\n从上面例子，前 6 个都是基础数据类型。虽然typeof null为object，但这只是JavaScript 存在的一个悠久\nBug，不代表null就是引用数据类型，并且null本身也不是对象\n\n所以，null在 typeof之后返回的是有问题的结果，不能作为判断null的方法。如果你需要在 if 语句中判断是否为\nnull，直接通过===null来判断就好\n\n同时，可以发现引用类型数据，用typeof来判断的话，除了function会被识别出来之外，其余的都输出object\n\n如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a)， 若a未声明，则报错)\n\n\n\n\n二、instanceof#\n\ninstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n使用如下：\n\n\n\nobject为实例对象，constructor为构造函数\n\n构造函数通过new可以实例对象，instanceof能判断这个对象是否是之前那个构造函数生成的对象\n\n\n\n关于instanceof的实现原理，可以参考下面：\n\n\n\n也就是顺着原型链去找，直到找到相同的原型对象，返回true，否则为false\n\n\n三、区别#\n\ntypeof与instanceof都是判断数据类型的方法，区别如下：\n\n * typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值\n\n * instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型\n\n * 而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断\n\n可以看到，上述两种方法都有弊端，并不能满足所有场景的需求\n\n如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串\n\n如下\n\n\n\n了解了toString的基本用法，下面就实现一个全局通用的数据类型判断方法\n\n\n\n使用如下\n\n","routePath":"/interview/JavaScript/typeof_instanceof","lang":"","toc":[{"text":"一、typeof","id":"一typeof","depth":2,"charIndex":5},{"text":"二、instanceof","id":"二instanceof","depth":2,"charIndex":395},{"text":"三、区别","id":"三区别","depth":2,"charIndex":626}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-typeof 与 instanceof 区别","footer":"typeof 与 instanceof 区别","order":26,"star":26,"date":"2023-05-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-typeof 与 instanceof 区别","isOriginal":false,"head":[["meta",{"name":"keywords","content":"typeof 与 instanceof 区别"}]]},"version":""},{"id":37,"title":"如何判断一个元素是否在可视区域中？","content":"#\n\n\n\n\n一、用途#\n\n可视区域即我们浏览网页的设备肉眼可见的区域，如下图\n\n\n\n在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：\n\n * 图片的懒加载\n * 列表的无限滚动\n * 计算广告元素的曝光情况\n * 可点击链接的预加载\n\n\n二、实现方式#\n\n判断一个元素是否在可视区域，我们常用的有三种办法：\n\n * offsetTop、scrollTop\n\n * getBoundingClientRect\n\n * Intersection Observer\n\n\noffsetTop、scrollTop#\n\noffsetTop，元素的上外边框至包含元素的上内边框之间的像素距离，其他offset属性如下图所示：\n\n\n\n下面再来了解下clientWidth、clientHeight：\n\n * clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding\n * clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding\n\n这里可以看到client元素都不包括外边距\n\n最后，关于scroll系列的属性如下：\n\n * scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小\n\n * scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置\n   \n   * * 垂直滚动 scrollTop > 0\n   * 水平滚动 scrollLeft > 0\n\n * 将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置\n\n注意#\n\n * 上述属性都是只读的，每次访问都要重新开始\n\n下面再看看如何实现判断：\n\n公式如下：\n\n\n\n代码实现：\n\n\n\n\ngetBoundingClientRect#\n\n返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性\n\n\n\n属性对应的关系图如下所示：\n\n\n\n当页面发生滚动的时候，top与left属性值都会随之改变\n\n如果一个元素在视窗之内的话，那么它一定满足下面四个条件：\n\n * top 大于等于 0\n * left 大于等于 0\n * bottom 小于等于视窗高度\n * right 小于等于视窗宽度\n\n实现代码如下：\n\n\n\n\nIntersection Observer#\n\nIntersection Observer\n即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多\n\n使用步骤主要分为两步：创建观察者和传入被观察者\n\n创建观察者#\n\n\n\n通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold\n时会被执行`\n\n关于callback回调函数常用属性如下：\n\n\n\n传入被观察者#\n\n通过 observer.observe(target) 这一行代码即可简单的注册被观察者\n\n\n\n\n三、案例分析#\n\n实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色\n\nHtml结构如下：\n\n\n\ncss样式如下：\n\n\n\n往container插入 1000 个元素\n\n\n\n这里，首先使用getBoundingClientRect方法进行判断元素是否在可视区域\n\n\n\n然后开始监听scroll事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为yellow\n\n\n\n通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了scroll事件，scroll事件伴随了大量的计算，会造成资源方\n面的浪费\n\n下面通过Intersection Observer的形式同样实现相同的功能\n\n首先创建一个观察者\n\n\n\ngetYellow回调函数实现对背景颜色改变，如下：\n\n\n\n最后传入观察者，即.target元素\n\n\n\n可以看到功能同样完成，并且页面不会出现卡顿的情况\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRec\n   t\n * https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API","routePath":"/interview/JavaScript/visible","lang":"","toc":[{"text":"一、用途","id":"一用途","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":160},{"text":"offsetTop、scrollTop","id":"offsettopscrolltop","depth":3,"charIndex":273},{"text":"注意","id":"注意","depth":4,"charIndex":770},{"text":"getBoundingClientRect","id":"getboundingclientrect","depth":3,"charIndex":833},{"text":"Intersection Observer","id":"intersection-observer","depth":3,"charIndex":1085},{"text":"创建观察者","id":"创建观察者","depth":4,"charIndex":1232},{"text":"传入被观察者","id":"传入被观察者","depth":4,"charIndex":1350},{"text":"三、案例分析","id":"三案例分析","depth":3,"charIndex":1408},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1832}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何判断一个元素是否在可视区域中？","footer":"如何判断一个元素是否在可视区域中？","order":10,"star":10,"date":"2023-03-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","JavaScript"],"tag":["interview","JavaScript"],"shortTitle":"前端物语|面试物语-如何判断一个元素是否在可视区域中？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何判断一个元素是否在可视区域中？"}]]},"version":""},{"id":38,"title":"说说对 Node 中的 Buffer 的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n在Node应用中，需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，要处理大量二进制数据，而Buffer就是在内存中开辟一片区域（\n初次初始化为 8KB），用来存放二进制数据\n\n在上述操作中都会存在数据流动，每个数据流动的过程中，都会有一个最小或最大数据量\n\n如果数据到达的速度比进程消耗的速度快，那么少数早到达的数据会处于等待区等候被处理。反之，如果数据到达的速度比进程消耗的数据慢，那么早先到达的数据需要等待一定量的\n数据到达之后才能被处理\n\n这里的等待区就指的缓冲区（Buffer），它是计算机中的一个小物理单位，通常位于计算机的 RAM 中\n\n简单来讲，Nodejs不能控制数据传输的速度和到达时间，只能决定何时发送数据，如果还没到发送时间，则将数据放在Buffer中，即在RAM中，直至将它们发送完毕\n\n上面讲到了Buffer是用来存储二进制数据，其的形式可以理解成一个数组，数组中的每一项，都可以保存 8 位二进制：00000000，也就是一个字节\n\n例如：\n\n\n\n其存储过程如下图所示：\n\n\n\n\n二、使用方法#\n\nBuffer 类在全局作用域中，无须require导入\n\n创建Buffer的方法有很多种，我们讲讲下面的两种常见的形式：\n\n * Buffer.from()\n\n * Buffer.alloc()\n\n\nBuffer.from()#\n\n\n\n\nBuffer.alloc()#\n\n\n\n在上面创建buffer后，则能够toString的形式进行交互，默认情况下采取utf8字符编码形式，如下\n\n\n\n如果编码与解码不是相同的格式则会出现乱码的情况，如下：\n\n\n\n当设定的范围导致字符串被截断的时候，也会存在乱码情况，如下：\n\n\n\n所支持的字符集有如下：\n\n * ascii：仅支持 7 位 ASCII 数据，如果设置去掉高位的话，这种编码是非常快的\n * utf8：多字节编码的 Unicode 字符，许多网页和其他文档格式都使用 UTF-8\n * utf16le：2 或 4 个字节，小字节序编码的 Unicode 字符，支持代理对（U+10000 至 U+10FFFF）\n * ucs2，utf16le 的别名\n * base64：Base64 编码\n * latin：一种把 Buffer 编码成一字节编码的字符串的方式\n * binary：latin1 的别名，\n * hex：将每个字节编码为两个十六进制字符\n\n\n三、应用场景#\n\nBuffer的应用场景常常与流的概念联系在一起，例如有如下：\n\n * I/O 操作\n * 加密解密\n * zlib.js\n\n\nI/O 操作#\n\n通过流的形式，将一个文件的内容读取到另外一个文件\n\n\n\n\n加解密#\n\n在一些加解密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 string 或 Buffer 类型\n\n\nzlib.js#\n\nzlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压功能\n\n\n参考文献#\n\n * http://nodejs.cn/api/buffer.html\n * https://segmentfault.com/a/1190000019894714","routePath":"/interview/NodeJS/Buffer","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方法","id":"二使用方法","depth":2,"charIndex":483},{"text":"Buffer.from()","id":"bufferfrom","depth":3,"charIndex":592},{"text":"Buffer.alloc()","id":"bufferalloc","depth":3,"charIndex":611},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1048},{"text":"I/O 操作","id":"io-操作","depth":3,"charIndex":1120},{"text":"加解密","id":"加解密","depth":3,"charIndex":1158},{"text":"zlib.js","id":"zlibjs","depth":3,"charIndex":1245},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1321}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Node 中的 Buffer 的理解？应用场景？","footer":"说说对 Node 中的 Buffer 的理解？应用场景？","order":12,"star":12,"date":"2023-04-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对 Node 中的 Buffer 的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Node 中的 Buffer 的理解？应用场景？"}]]},"version":""},{"id":39,"title":"说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?","content":"#\n\n\n\n\n一、是什么#\n\n我们了解到，Node采用了事件驱动机制，而EventEmitter就是Node实现事件驱动的基础\n\n在EventEmitter的基础上，Node几乎所有的模块都继承了这个类，这些模块拥有了自己的事件，可以绑定／触发监听器，实现了异步操作\n\nNode.js 里面的许多对象都会分发事件，比如 fs.readStream 对象会在文件被打开的时候触发一个事件\n\n这些产生事件的对象都是 events.EventEmitter 的实例，这些对象有一个 eventEmitter.on()\n函数，用于将一个或多个函数绑定到命名事件上\n\n\n二、使用方法#\n\nNode的events模块只提供了一个EventEmitter类，这个类实现了Node异步事件驱动架构的基本模式——观察者模式\n\n在这种模式中，被观察者(主体)维护着一组其他对象派来(注册)的观察者，有新的对象对主体感兴趣就注册观察者，不感兴趣就取消订阅，主体有更新的话就依次通知观察者们\n\n基本代码如下所示：\n\n\n\n通过实例对象的on方法注册一个名为event的事件，通过emit方法触发该事件，而removeListener用于取消事件的监听\n\n关于其常见的方法如下：\n\n * emitter.addListener/on(eventName, listener) ：添加类型为 eventName 的监听事件到事件数组尾部\n * emitter.prependListener(eventName, listener)：添加类型为 eventName 的监听事件到事件数组头部\n * emitter.emit(eventName[, ...args])：触发类型为 eventName 的监听事件\n * emitter.removeListener/off(eventName, listener)：移除类型为 eventName 的监听事件\n * emitter.once(eventName, listener)：添加类型为 eventName 的监听事件，以后只能执行一次并删除\n * emitter.removeAllListeners([eventName])： 移除全部类型为 eventName 的监听事件\n\n\n三、实现过程#\n\n通过上面的方法了解，EventEmitter是一个构造函数，内部存在一个包含所有事件的对象\n\n\n\n其中events存放的监听事件的函数的结构如下：\n\n\n\n然后开始一步步实现实例方法，首先是emit，第一个参数为事件的类型，第二个参数开始为触发事件函数的参数，实现如下：\n\n\n\n当实现了emit方法之后，然后实现on、addListener、prependListener这三个实例方法，都是添加事件监听触发函数，实现也是大同小异\n\n\n\n紧接着就是实现事件监听的方法removeListener/on\n\n\n\n最后再来实现once方法， 再传入事件监听处理函数的时候进行封装，利用闭包的特性维护当前状态，通过fired属性值判断事件函数是否执行过\n\n\n\n完整代码如下：\n\n\n\n测试代码如下：\n\n\n\n\n参考文献#\n\n * http://nodejs.cn/api/events.html#events_class_eventemitter\n * https://segmentfault.com/a/1190000015762318\n * https://juejin.cn/post/6844903781230968845","routePath":"/interview/NodeJS/EventEmitter","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方法","id":"二使用方法","depth":2,"charIndex":278},{"text":"三、实现过程","id":"三实现过程","depth":2,"charIndex":953},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1310}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?","order":1,"star":1,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?"}]]},"version":""},{"id":40,"title":"前端物语|面试物语-NodeJS","content":" * 说说对 Node 中的 Buffer 的理解？应用场景？\n * 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?\n * 说说对 Node 中的 Stream 的理解？应用场景？\n * 说说对 Nodejs 中的事件循环机制理解?\n * 如何实现文件上传？说说你的思路\n * 说说对 Node 中的 fs 模块的理解? 有哪些常用方法\n * 说说 Node. js 有哪些全局对象？\n * 如何实现 jwt 鉴权机制？说说你的思路\n * 说说对中间件概念的理解，如何封装 node 中间件？\n * 说说你对 Node.js 的理解？优缺点？应用场景？\n * 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?\n * Node 性能如何进行监控以及优化？\n * 说说对 Node 中的 process 的理解？有哪些常用方法？\n * 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","routePath":"/interview/NodeJS/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"NodeJS","tag":"NodeJS","title":"前端物语|面试物语-NodeJS","index":false,"dir":{"order":1},"date":"2023-04-08T00:00:00.000Z"},"version":""},{"id":41,"title":"说说对 Node 中的 Stream 的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n流（Stream），是一个数据传输手段，是端到端信息交换的一种方式，而且是有顺序的,是逐块读取数据、处理内容，用于顺序读取输入或写入输出\n\nNode.js中很多对象都实现了流，总之它是会冒数据（以 Buffer 为单位）\n\n它的独特之处在于，它不像传统的程序那样一次将一个文件读入内存，而是逐块读取数据、处理其内容，而不是将其全部保存在内存中\n\n流可以分成三部分：source、dest、pipe\n\n在source和dest之间有一个连接的管道pipe,它的基本语法是source.pipe(dest)，source和dest就是通过 pipe\n连接，让数据从source流向了dest，如下图所示：\n\n\n\n\n二、种类#\n\n在NodeJS，几乎所有的地方都使用到了流的概念，分成四个种类：\n\n * 可写流：可写入数据的流。例如 fs.createWriteStream() 可以使用流将数据写入文件\n\n * 可读流： 可读取数据的流。例如 fs.createReadStream() 可以从文件读取内容\n\n * 双工流： 既可读又可写的流。例如 net.Socket\n\n * 转换流： 可以在数据写入和读取时修改或转换数据的流。例如，在文件压缩操作中，可以向文件写入压缩数据，并从文件中读取解压数据\n\n在NodeJS中HTTP服务器模块中，request 是可读流，response 是可写流。还有fs 模块，能同时处理可读和可写文件流\n\n可读流和可写流都是单向的，比较容易理解，而另外两个是双向的\n\n\n双工流#\n\n之前了解过websocket通信，是一个全双工通信，发送方和接受方都是各自独立的方法，发送和接收都没有任何关系\n\n如下图所示：\n\n\n\n基本代码如下：\n\n\n\n\n双工流#\n\n双工流的演示图如下所示：\n\n\n\n除了上述压缩包的例子，还比如一个 babel，把es6转换为，我们在左边写入 es6，从右边读取 es5\n\n基本代码如下所示：\n\n\n\n\n三、应用场景#\n\nstream的应用场景主要就是处理IO操作，而http请求和文件操作都属于IO操作\n\n试想一下，如果一次IO操作过大，硬件的开销就过大，而将此次大的IO操作进行分段操作，让数据像水管一样流动，直到流动完成\n\n常见的场景有：\n\n * get 请求返回文件给客户端\n * 文件操作\n * 一些打包工具的底层操作\n\n\nget 请求返回文件给客户端#\n\n使用stream流返回文件，res也是一个stream对象，通过pipe管道将文件数据返回\n\n\n\n\n文件操作#\n\n创建一个可读数据流readStream，一个可写数据流writeStream，通过pipe管道把数据流转过去\n\n\n\n\n一些打包工具的底层操作#\n\n目前一些比较火的前端打包构建工具，都是通过node.js编写的，打包和构建的过程肯定是文件频繁操作的过程，离不来stream，如gulp\n\n\n参考文献#\n\n * https://xie.infoq.cn/article/1a9695020828460eb3c4ff1fa\n * https://juejin.cn/post/6844903891083984910","routePath":"/interview/NodeJS/Stream","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、种类","id":"二种类","depth":2,"charIndex":318},{"text":"双工流","id":"双工流","depth":3,"charIndex":665},{"text":"双工流","id":"双工流-1","depth":3,"charIndex":750},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":840},{"text":"get 请求返回文件给客户端","id":"get-请求返回文件给客户端","depth":3,"charIndex":1005},{"text":"文件操作","id":"文件操作","depth":3,"charIndex":1072},{"text":"一些打包工具的底层操作","id":"一些打包工具的底层操作","depth":3,"charIndex":1138},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1223}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Node 中的 Stream 的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 Node 中的 Stream 的理解？应用场景？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对 Node 中的 Stream 的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Node 中的 Stream 的理解？应用场景？"}]]},"version":""},{"id":42,"title":"说说对 Nodejs 中的事件循环机制理解?","content":"#\n\n\n\n\n一、是什么#\n\n在浏览器事件循环中，我们了解到javascript在浏览器中的事件循环机制，其是根据HTML5定义的规范来实现\n\n而在NodeJS中，事件循环是基于libuv实现，libuv是一个多平台的专注于异步 IO 的库，如下图最右侧所示：\n\n\n\n上图EVENT_QUEUE 给人看起来只有一个队列，但EventLoop存在 6 个阶段，每个阶段都有对应的一个先进先出的回调队列\n\n\n二、流程#\n\n上节讲到事件循环分成了六个阶段，对应如下：\n\n\n\n * timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调\n * 定时器检测阶段(timers)：本阶段执行 timer 的回调，即 setTimeout、setInterval 里面的回调函数\n * I/O 事件回调阶段(I/O callbacks)：执行延迟到下一个循环迭代的 I/O 回调，即上一轮循环中未被执行的一些 I/O 回调\n * 闲置阶段(idle, prepare)：仅系统内部使用\n * 轮询阶段(poll)：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate()\n   调度的之外），其余情况 node 将在适当的时候在此阻塞\n * 检查阶段(check)：setImmediate() 回调函数在这里执行\n * 关闭事件回调阶段(close callback)：一些关闭的回调函数，如：socket.on('close', ...)\n\n每个阶段对应一个队列，当事件循环进入某个阶段时, 将会在该阶段内执行回调，直到队列耗尽或者回调的最大数量已执行, 那么将进入下一个处理阶段\n\n除了上述 6 个阶段，还存在process.nextTick，其不属于事件循环的任何一个阶段，它属于该阶段与下阶段之间的过渡, 即本阶段执行结束,\n进入下一个阶段前, 所要执行的回调，类似插队\n\n流程图如下所示：\n\n\n\n在Node中，同样存在宏任务和微任务，与浏览器中的事件循环相似\n\n微任务对应有：\n\n * next tick queue：process.nextTick\n * other queue：Promise 的 then 回调、queueMicrotask\n\n宏任务对应有：\n\n * timer queue：setTimeout、setInterval\n * poll queue：IO 事件\n * check queue：setImmediate\n * close queue：close 事件\n\n其执行顺序为：\n\n * next tick microtask queue\n * other microtask queue\n * timer queue\n * poll queue\n * check queue\n * close queue\n\n\n三、题目#\n\n通过上面的学习，下面开始看看题目\n\n\n\n分析过程：\n\n * 先找到同步任务，输出 script start\n\n * 遇到第一个 setTimeout，将里面的回调函数放到 timer 队列中\n\n * 遇到第二个 setTimeout，300ms 后将里面的回调函数放到 timer 队列中\n\n * 遇到第一个 setImmediate，将里面的回调函数放到 check 队列中\n\n * 遇到第一个 nextTick，将其里面的回调函数放到本轮同步任务执行完毕后执行\n\n * 执行 async1 函数，输出 async1 start\n\n * 执行 async2 函数，输出 async2，async2 后面的输出 async1 end 进入微任务，等待下一轮的事件循环\n\n * 遇到第二个，将其里面的回调函数放到本轮同步任务执行完毕后执行\n\n * 遇到 new Promise，执行里面的立即执行函数，输出 promise1、promise2\n\n * then 里面的回调函数进入微任务队列\n\n * 遇到同步任务，输出 script end\n\n * 执行下一轮回到函数，先依次输出 nextTick 的函数，分别是 nextTick1、nextTick2\n\n * 然后执行微任务队列，依次输出 async1 end、promise3\n\n * 执行 timer 队列，依次输出 setTimeout0\n\n * 接着执行 check 队列，依次输出 setImmediate\n\n * 300ms 后，timer 队列存在任务，执行输出 setTimeout2\n\n执行结果如下：\n\n\n\n最后有一道是关于setTimeout与setImmediate的输出顺序\n\n\n\n输出情况如下：\n\n\n\n分析下流程：\n\n * 外层同步代码一次性全部执行完，遇到异步 API 就塞到对应的阶段\n * 遇到setTimeout，虽然设置的是 0 毫秒触发，但实际上会被强制改成 1ms，时间到了然后塞入times阶段\n * 遇到setImmediate塞入check阶段\n * 同步代码执行完毕，进入 Event Loop\n * 先进入times阶段，检查当前时间过去了 1 毫秒没有，如果过了 1 毫秒，满足setTimeout条件，执行回调，如果没过 1 毫秒，跳过\n * 跳过空的阶段，进入 check 阶段，执行setImmediate回调\n\n这里的关键在于这 1ms，如果同步代码执行时间较长，进入Event Loop的时候 1 毫秒已经过了，setTimeout先执行，如果 1\n毫秒还没到，就先执行了setImmediate\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000012258592\n * https://juejin.cn/post/6844904100195205133","routePath":"/interview/NodeJS/event_loop","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":200},{"text":"三、题目","id":"三题目","depth":2,"charIndex":1226},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2341}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Nodejs 中的事件循环机制理解?","footer":"说说对 Nodejs 中的事件循环机制理解?","order":10,"star":10,"date":"2023-03-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对 Nodejs 中的事件循环机制理解?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Nodejs 中的事件循环机制理解?"}]]},"version":""},{"id":43,"title":"如何实现文件上传？说说你的思路","content":"#\n\n\n\n\n一、是什么#\n\n文件上传在日常开发中应用很广泛，我们发微博、发微信朋友圈都会用到了图片上传功能\n\n因为浏览器限制，浏览器不能直接操作文件系统的，需要通过浏览器所暴露出来的统一接口，由用户主动授权发起来访问文件动作，然后读取文件内容进指定内存里，最后执行提交请\n求操作，将内存里的文件内容数据上传到服务端，服务端解析前端传来的数据信息后存入文件里\n\n对于文件上传，我们需要设置请求头为content-type:multipart/form-data\n\n> multipart 互联网上的混合资源，就是资源由多种元素组成，form-data 表示可以使用 HTML Forms 和 POST 方法上传文件\n\n结构如下：\n\n\n\nboundary表示分隔符，如果要上传多个表单项，就要使用boundary分割，每个表单项由———XXX开始，以———XXX结尾\n\n而xxx是即时生成的字符串，用以确保整个分隔符不会在文件或表单项的内容中出现\n\n每个表单项必须包含一个 Content-Disposition 头，其他的头信息则为可选项， 比如 Content-Type\n\nContent-Disposition 包含了 type和 一个名字为name的 parameter，type 是\nform-data，name参数的值则为表单控件（也即 field）的名字，如果是文件，那么还有一个 filename参数，值就是文件名\n\n\n\n至于使用multipart/form-data，是因为文件是以二进制的形式存在，其作用是专门用于传输大型二进制数据，效率高\n\n\n二、如何实现#\n\n关于文件的上传的上传，我们可以分成两步骤：\n\n * 文件的上传\n * 文件的解析\n\n\n文件上传#\n\n传统前端文件上传的表单结构如下：\n\n\n\naction 就是我们的提交到的接口，enctype=\"multipart/form-data\" 就是指定上传文件格式，input 的 name\n属性一定要等于file\n\n\n文件解析#\n\n在服务器中，这里采用koa2中间件的形式解析上传的文件数据，分别有下面两种形式：\n\n * koa-body\n * koa-multer\n\nkoa-body#\n\n安装依赖\n\n\n\n引入koa-body中间件\n\n\n\n获取上传的文件\n\n\n\n获取文件数据后，可以通过fs模块将文件保存到指定目录\n\n\n\nkoa-multer#\n\n安装依赖：\n\n\n\n使用 multer 中间件实现文件上传\n\n\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000037411957\n * https://www.jianshu.com/p/29e38bcc8a1d","routePath":"/interview/NodeJS/file_upload","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":3,"charIndex":680},{"text":"文件上传","id":"文件上传","depth":3,"charIndex":732},{"text":"文件解析","id":"文件解析","depth":3,"charIndex":846},{"text":"koa-body","id":"koa-body","depth":4,"charIndex":922},{"text":"koa-multer","id":"koa-multer","depth":4,"charIndex":999},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1045}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何实现文件上传？说说你的思路","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>如何实现文件上传？说说你的思路","order":4,"star":4,"date":"2023-03-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-如何实现文件上传？说说你的思路","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何实现文件上传？说说你的思路"}]]},"version":""},{"id":44,"title":"说说对 Node 中的 fs 模块的理解? 有哪些常用方法","content":"#\n\n\n\n\n一、是什么#\n\nfs（filesystem），该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装\n\n可以说，所有与文件的操作都是通过fs核心模块实现\n\n导入模块如下：\n\n\n\n这个模块对所有文件系统操作提供异步（不具有sync 后缀）和同步（具有 sync 后缀）两种操作方式，而供开发者选择\n\n\n二、文件知识#\n\n在计算机中有关于文件的知识：\n\n * 权限位 mode\n * 标识位 flag\n * 文件描述为 fd\n\n\n权限位 mode#\n\n\n\n针对文件所有者、文件所属组、其他用户进行权限分配，其中类型又分成读、写和执行，具备权限位 4、2、1，不具备权限为 0\n\n如在linux查看文件权限位：\n\n\n\n在开头前十位中，d为文件夹，-为文件，后九位就代表当前用户、用户所属组和其他用户的权限位，按每三位划分，分别代表读（r）、写（w）和执行（x），-\n代表没有当前位对应的权限\n\n\n标识位#\n\n标识位代表着对文件的操作方式，如可读、可写、即可读又可写等等，如下表所示：\n\n符号    含义\nr     读取文件，如果文件不存在则抛出异常。\nr+    读取并写入文件，如果文件不存在则抛出异常。\nrs    读取并写入文件，指示操作系统绕开本地文件系统缓存。\nw     写入文件，文件不存在会被创建，存在则清空后写入。\nwx    写入文件，排它方式打开。\nw+    读取并写入文件，文件不存在则创建文件，存在则清空后写入。\nwx+   和 w+ 类似，排他方式打开。\na     追加写入，文件不存在则创建文件。\nax    与 a 类似，排他方式打开。\na+    读取并追加写入，不存在则创建。\nax+   与 a+ 类似，排他方式打开。\n\n\n文件描述为 fd#\n\n操作系统会为每个打开的文件分配一个名为文件描述符的数值标识，文件操作使用这些文件描述符来识别与追踪每个特定的文件\n\nWindow系统使用了一个不同但概念类似的机制来追踪资源，为方便用户，NodeJS抽象了不同操作系统间的差异，为所有打开的文件分配了数值的文件描述符\n\n在 NodeJS中，每操作一个文件，文件描述符是递增的，文件描述符一般从 3 开始，因为前面有 0、1、2三个比较特殊的描述符，分别代表\nprocess.stdin（标准输入）、process.stdout（标准输出）和 process.stderr（错误输出）\n\n\n三、方法#\n\n下面针对fs模块常用的方法进行展开：\n\n * 文件读取\n * 文件写入\n * 文件追加写入\n * 文件拷贝\n * 创建目录\n\n\n文件读取#\n\nfs.readFileSync#\n\n同步读取，参数如下：\n\n * 第一个参数为读取文件的路径或文件描述符\n * 第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入\n   encoding\n\n结果为返回文件的内容\n\n\n\nfs.readFile#\n\n异步读取方法 readFile 与 readFileSync 的前两个参数相同，最后一个参数为回调函数，函数内有两个参数 err（错误）和\ndata（数据），该方法没有返回值，回调函数在读取文件成功后执行\n\n\n\n\n文件写入#\n\nwriteFileSync#\n\n同步写入，有三个参数：\n\n * 第一个参数为写入文件的路径或文件描述符\n\n * 第二个参数为写入的数据，类型为 String 或 Buffer\n\n * 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和\n   mode（权限位，默认为 0o666），也可直接传入 encoding\n\n\n\nwriteFile#\n\n异步写入，writeFile 与 writeFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数\nerr（错误），回调函数在文件写入数据成功后执行\n\n\n\n\n文件追加写入#\n\nappendFileSync#\n\n参数如下：\n\n * 第一个参数为写入文件的路径或文件描述符\n * 第二个参数为写入的数据，类型为 String 或 Buffer\n * 第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和\n   mode（权限位，默认为 0o666），也可直接传入 encoding\n\n\n\nappendFile#\n\n异步追加写入方法 appendFile 与 appendFileSync 的前三个参数相同，最后一个参数为回调函数，函数内有一个参数\nerr（错误），回调函数在文件追加写入数据成功后执行\n\n\n\n\n文件拷贝#\n\ncopyFileSync#\n\n同步拷贝\n\n\n\ncopyFile#\n\n异步拷贝\n\n\n\n\n创建目录#\n\nmkdirSync#\n\n同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常\n\n\n\nmkdir#\n\n异步创建，第二个参数为回调函数\n\n\n\n\n参考文献#\n\n * http://nodejs.cn/api/fs.html\n\n * https://segmentfault.com/a/1190000019913303","routePath":"/interview/NodeJS/fs","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、文件知识","id":"二文件知识","depth":3,"charIndex":163},{"text":"权限位 mode","id":"权限位-mode","depth":3,"charIndex":226},{"text":"标识位","id":"标识位","depth":3,"charIndex":408},{"text":"文件描述为 fd","id":"文件描述为-fd","depth":3,"charIndex":744},{"text":"三、方法","id":"三方法","depth":2,"charIndex":1023},{"text":"文件读取","id":"文件读取","depth":3,"charIndex":1094},{"text":"fs.readFileSync","id":"fsreadfilesync","depth":4,"charIndex":1101},{"text":"fs.readFile","id":"fsreadfile","depth":4,"charIndex":1259},{"text":"文件写入","id":"文件写入","depth":3,"charIndex":1380},{"text":"writeFileSync","id":"writefilesync","depth":4,"charIndex":1387},{"text":"writeFile","id":"writefile","depth":4,"charIndex":1590},{"text":"文件追加写入","id":"文件追加写入","depth":3,"charIndex":1692},{"text":"appendFileSync","id":"appendfilesync","depth":4,"charIndex":1701},{"text":"appendFile","id":"appendfile","depth":4,"charIndex":1897},{"text":"文件拷贝","id":"文件拷贝","depth":3,"charIndex":2008},{"text":"copyFileSync","id":"copyfilesync","depth":4,"charIndex":2015},{"text":"copyFile","id":"copyfile","depth":4,"charIndex":2038},{"text":"创建目录","id":"创建目录","depth":3,"charIndex":2058},{"text":"mkdirSync","id":"mkdirsync","depth":4,"charIndex":2065},{"text":"mkdir","id":"mkdir","depth":4,"charIndex":2140},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2168}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Node 中的 fs 模块的理解? 有哪些常用方法","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 Node 中的 fs 模块的理解? 有哪些常用方法","order":3,"star":3,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对 Node 中的 fs 模块的理解? 有哪些常用方法","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Node 中的 fs 模块的理解? 有哪些常用方法"}]]},"version":""},{"id":45,"title":"说说 Node. js 有哪些全局对象？","content":"#\n\n\n\n\n一、是什么#\n\n在浏览器 JavaScript 中，通常window 是全局对象， 而 Nodejs中的全局对象是 global\n\n在NodeJS里，是不可能在最外层定义一个变量，因为所有的用户代码都是当前模块的，只在当前模块里可用，但可以通过exports对象的使用将其传递给模块外部\n\n所以，在NodeJS中，用var声明的变量并不属于全局的变量，只在当前模块生效\n\n像上述的global全局对象则在全局作用域中，任何全局变量、函数、对象都是该对象的一个属性值\n\n\n二、有哪些#\n\n将全局对象分成两类：\n\n * 真正的全局对象\n\n * 模块级别的全局变量\n\n\n真正的全局对象#\n\n下面给出一些常见的全局对象：\n\n * Class:Buffer\n\n * process\n\n * console\n\n * clearInterval、setInterval\n\n * clearTimeout、setTimeout\n\n * global\n\nClass:Buffer#\n\n可以处理二进制以及非Unicode编码的数据\n\n在Buffer类实例化中存储了原始数据。Buffer类似于一个整数数组，在 V8 堆原始存储空间给它分配了内存\n\n一旦创建了Buffer实例，则无法改变大小\n\nprocess#\n\n进程对象，提供有关当前进程的信息和控制\n\n包括在执行node程序进程时，如果需要传递参数，我们想要获取这个参数需要在process内置对象中\n\n启动进程：\n\n\n\nindex.js 文件如下：\n\n\n\n输出如下：\n\n\n\n除此之外，还包括一些其他信息如版本、操作系统等\n\n\n\nconsole#\n\n用来打印stdout和stderr\n\n最常用的输入内容的方式：console.log\n\n\n\n清空控制台：console.clear\n\n\n\n打印函数的调用栈：console.trace\n\n\n\n\n\nclearInterval、setInterval#\n\n设置定时器与清除定时器\n\n\n\ncallback每delay毫秒重复执行一次\n\nclearInterval则为对应发取消定时器的方法\n\nclearTimeout、setTimeout#\n\n设置延时器与清除延时器\n\n\n\ncallback在delay毫秒后执行一次\n\nclearTimeout则为对应取消延时器的方法\n\nglobal#\n\n全局命名空间对象，墙面讲到的process、console、setTimeout等都有放到global中\n\n\n\n\n模块级别的全局对象#\n\n这些全局对象是模块中的变量，只是每个模块都有，看起来就像全局变量，像在命令交互中是不可以使用，包括：\n\n * __dirname\n * __filename\n * exports\n * module\n * require\n\n__dirname#\n\n获取当前文件所在的路径，不包括后面的文件名\n\n从 /Users/mjr 运行 node example.js：\n\n\n\n__filename#\n\n获取当前文件所在的路径和文件名称，包括后面的文件名称\n\n从 /Users/mjr 运行 node example.js：\n\n\n\nexports#\n\nmodule.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容\n\n\n\nmodule#\n\n对当前模块的引用，通过module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容\n\nrequire#\n\n用于引入模块、 JSON、或本地文件。 可以从 node_modules 引入模块。\n\n可以使用相对路径引入本地模块或JSON文件，路径会根据__dirname定义的目录名或当前工作目录进行处理\n\n\n参考文献#\n\n * http://nodejs.cn/api/globals.html","routePath":"/interview/NodeJS/global","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":240},{"text":"真正的全局对象","id":"真正的全局对象","depth":3,"charIndex":287},{"text":"Class:Buffer","id":"classbuffer","depth":4,"charIndex":423},{"text":"process","id":"process","depth":4,"charIndex":542},{"text":"console","id":"console","depth":4,"charIndex":687},{"text":"clearInterval、setInterval","id":"clearintervalsetinterval","depth":4,"charIndex":794},{"text":"clearTimeout、setTimeout","id":"cleartimeoutsettimeout","depth":4,"charIndex":889},{"text":"global","id":"global","depth":4,"charIndex":979},{"text":"模块级别的全局对象","id":"模块级别的全局对象","depth":3,"charIndex":1045},{"text":"__dirname","id":"__dirname","depth":4,"charIndex":1169},{"text":"__filename","id":"__filename","depth":4,"charIndex":1240},{"text":"exports","id":"exports","depth":4,"charIndex":1317},{"text":"module","id":"module","depth":4,"charIndex":1382},{"text":"require","id":"require","depth":4,"charIndex":1455},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1565}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Node. js 有哪些全局对象？","footer":"说说 Node. js 有哪些全局对象？","order":13,"star":13,"date":"2023-04-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说 Node. js 有哪些全局对象？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Node. js 有哪些全局对象？"}]]},"version":""},{"id":46,"title":"前端物语|面试物语-NodeJS","content":" * 说说对 Node 中的 Buffer 的理解？应用场景？\n * 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?\n * 说说对 Node 中的 Stream 的理解？应用场景？\n * 说说对 Nodejs 中的事件循环机制理解?\n * 如何实现文件上传？说说你的思路\n * 说说对 Node 中的 fs 模块的理解? 有哪些常用方法\n * 说说 Node. js 有哪些全局对象？\n * 如何实现 jwt 鉴权机制？说说你的思路\n * 说说对中间件概念的理解，如何封装 node 中间件？\n * 说说你对 Node.js 的理解？优缺点？应用场景？\n * 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?\n * Node 性能如何进行监控以及优化？\n * 说说对 Node 中的 process 的理解？有哪些常用方法？\n * 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","routePath":"/interview/NodeJS/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"NodeJS","tag":"NodeJS","title":"前端物语|面试物语-NodeJS","index":false,"dir":{"order":1},"date":"2023-04-08T00:00:00.000Z"},"version":""},{"id":47,"title":"如何实现 jwt 鉴权机制？说说你的思路","content":"#\n\n\n\n\n一、是什么#\n\nJWT（JSON Web Token），本质就是一个字符串书写规范，如下图，作用是用来在用户和服务器之间传递安全可靠的信息\n\n\n\n在目前前后端分离的开发过程中，使用token鉴权机制用于身份验证是最常见的方案，流程如下：\n\n * 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证\n * 后续访问会根据这个令牌判断用户时候有权限进行访问\n\nToken，分成了三部分，头部（Header）、载荷（Payload）、签名（Signature），并以.进行拼接。其中头部和载荷都是以JSON格式存放数据，只\n是进行了编码\n\n\n\n\nheader#\n\n每个 JWT 都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为 HS256\n\n\n\n因为 JWT 是字符串，所以我们还需要对以上内容进行 Base64 编码，编码后字符串如下：\n\n\n\n\npayload#\n\n载荷即消息体，这里会存放实际的内容，也就是Token的数据声明，例如用户的id和name，默认情况下也会携带令牌的签发时间iat，通过还可以设置过期时间，如下：\n\n\n\n同样进行 Base64 编码后，字符串如下：\n\n\n\n\nSignature#\n\n签名是对头部和载荷内容进行签名，一般情况，设置一个secretKey，对前两个的结果进行HMACSHA25算法，公式如下：\n\n\n\n一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致\n\n\n二、如何实现#\n\nToken的使用分成了两部分：\n\n * 生成 token：登录成功的时候，颁发 token\n * 验证 token：访问某些资源或者接口时，验证 token\n\n\n生成 token#\n\n借助第三方库jsonwebtoken，通过jsonwebtoken 的 sign 方法生成一个 token：\n\n * 第一个参数指的是 Payload\n\n * 第二个是秘钥，服务端特有\n\n * 第三个参数是 option，可以定义 token 过期时间\n\n\n\n在前端接收到token后，一般情况会通过localStorage进行缓存，然后将token放到HTTP请求头Authorization\n中，关于Authorization 的设置，前面要加上 Bearer ，注意后面带有空格\n\n\n\n\n校验 token#\n\n使用 koa-jwt 中间件进行验证，方式比较简单\n\n\n\n * secret 必须和 sign 时候保持一致\n * 可以通过 unless 配置接口白名单，也就是哪些 URL 可以不用经过校验，像登陆/注册都可以不用校验\n * 校验的中间件需要放在需要校验的路由前面，无法对前面的 URL 进行校验\n\n获取token用户的信息方法如下：\n\n\n\n注意：上述的HMA256加密算法为单秘钥的形式，一旦泄露后果非常的危险\n\n在分布式系统中，每个子系统都要获取到秘钥，那么这个子系统根据该秘钥可以发布和验证令牌，但有些服务器只需要验证令牌\n\n这时候可以采用非对称加密，利用私钥发布令牌，公钥验证令牌，加密算法可以选择RS256\n\n\n三、优缺点#\n\n优点：\n\n * json 具有通用性，所以可以跨语言\n * 组成简单，字节占用小，便于传输\n * 服务端无需保存会话信息，很容易进行水平扩展\n * 一处生成，多处使用，可以在分布式系统中，解决单点登录问题\n * 可防护 CSRF 攻击\n\n缺点：\n\n * payload 部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息\n * 需要保护好加密密钥，一旦泄露后果不堪设想\n * 为避免 token 被劫持，最好使用 https 协议\n\n\n参考文献#\n\n * http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\n * https://blog.wangjunfeng.com/post/golang-jwt/","routePath":"/interview/NodeJS/jwt","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"header","id":"header","depth":3,"charIndex":298},{"text":"payload","id":"payload","depth":3,"charIndex":438},{"text":"Signature","id":"signature","depth":3,"charIndex":559},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":684},{"text":"生成 token","id":"生成-token","depth":3,"charIndex":774},{"text":"校验 token","id":"校验-token","depth":3,"charIndex":1032},{"text":"三、优缺点","id":"三优缺点","depth":2,"charIndex":1355},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1586}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何实现 jwt 鉴权机制？说说你的思路","footer":"如何实现 jwt 鉴权机制？说说你的思路","order":11,"star":11,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-如何实现 jwt 鉴权机制？说说你的思路","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何实现 jwt 鉴权机制？说说你的思路"}]]},"version":""},{"id":48,"title":"说说对中间件概念的理解，如何封装 node 中间件？","content":"#\n\n\n\n\n一、是什么#\n\n中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到\n资源共享、功能共享的目的\n\n在NodeJS中，中间件主要是指封装http请求细节处理的方法\n\n例如在express、koa等web框架中，中间件的本质为一个回调函数，参数包含请求对象、响应对象和执行下一个中间件的函数\n\n\n\n在这些中间件函数中，我们可以执行业务逻辑代码，修改请求和响应对象、返回响应数据等操作\n\n\n二、封装#\n\nkoa是基于NodeJS当前比较流行的web框架，本身支持的功能并不多，功能都可以通过中间件拓展实现。通过添加不同的中间件，实现不同的需求，从而构建一个 Koa\n应用\n\nKoa 中间件采用的是洋葱圈模型，每次执行下一个中间件传入两个参数：\n\n * ctx ：封装了 request 和 response 的变量\n * next ：进入下一个要执行的中间件的函数\n\n\n\n下面就针对koa进行中间件的封装：\n\nKoa的中间件就是函数，可以是async 函数，或是普通函数\n\n\n\n下面则通过中间件封装http请求过程中几个常用的功能：\n\n\ntoken 校验#\n\n\n\n\n日志模块#\n\n\n\nKoa存在很多第三方的中间件，如koa-bodyparser、koa-static等\n\n下面再来看看它们的大体的简单实现：\n\n\nkoa-bodyparser#\n\nkoa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body\n上，方便我们在其他中间件或接口处取值\n\n\n\n\nkoa-static#\n\nkoa-static 中间件的作用是在服务器接到请求时，帮我们处理静态文件\n\n\n\n\n三、总结#\n\n在实现中间件时候，单个中间件应该足够简单，职责单一，中间件的代码编写应该高效，必要的时候通过缓存重复获取数据\n\nkoa本身比较简洁，但是通过中间件的机制能够实现各种所需要的功能，使得web应用具备良好的可拓展性和组合性\n\n通过将公共逻辑的处理编写在中间件中，可以不用在每一个接口回调中做相同的代码编写，减少了冗杂代码，过程就如装饰者模式\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000017897279\n * https://www.jianshu.com/p/81b6ebc0dd85\n * https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6","routePath":"/interview/NodeJS/middleware","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、封装","id":"二封装","depth":2,"charIndex":251},{"text":"token 校验","id":"token-校验","depth":3,"charIndex":525},{"text":"日志模块","id":"日志模块","depth":3,"charIndex":539},{"text":"koa-bodyparser","id":"koa-bodyparser","depth":3,"charIndex":612},{"text":"koa-static","id":"koa-static","depth":3,"charIndex":721},{"text":"三、总结","id":"三总结","depth":2,"charIndex":776},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":954}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对中间件概念的理解，如何封装 node 中间件？","footer":"说说对中间件概念的理解，如何封装 node 中间件？","order":5,"star":5,"date":"2023-03-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对中间件概念的理解，如何封装 node 中间件？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对中间件概念的理解，如何封装 node 中间件？"}]]},"version":""},{"id":49,"title":"说说你对 Node.js 的理解？优缺点？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\nNode.js 是一个开源与跨平台的 JavaScript 运行时环境\n\n在浏览器外运行 V8 JavaScript 引擎（Google Chrome 的内核），利用事件驱动、非阻塞和异步输入输出模型等技术提高性能\n\n可以理解为 Node.js 就是一个服务器端的、非阻塞式 I/O 的、事件驱动的JavaScript运行环境\n\n\n非阻塞异步#\n\nNodejs采用了非阻塞型I/O机制，在做I/O操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作\n\n例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率\n\n\n事件驱动#\n\n事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的\n处理代码，一般都是回调函数\n\n比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理\n\n\n\n\n二、优缺点#\n\n优点：\n\n * 处理高并发场景性能更佳\n * 适合 I/O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作\n\n因为Nodejs是单线程，带来的缺点有：\n\n * 不适合 CPU 密集型应用\n * 只支持单核 CPU，不能充分利用 CPU\n * 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n\n三、应用场景#\n\n借助Nodejs的特点和弊端，其应用场景分类如下：\n\n * 善于I/O，不善于计算。因为 Nodejs 是一个单线程，如果计算（同步）太多，则会阻塞这个线程\n * 大量并发的 I/O，应用程序内部并不需要进行非常复杂的处理\n * 与 websocket 配合，开发长连接的实时交互应用程序\n\n具体场景可以表现为如下：\n\n * 第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序\n * 第二大类：基于 web、canvas 等多人联网游戏\n * 第三大类：基于 web 的多人实时聊天客户端、聊天室、图文直播\n * 第四大类：单页面浏览器应用程序\n * 第五大类：操作数据库、为前端和移动端提供基于json的 API\n\n其实，Nodejs能实现几乎一切的应用，只考虑适不适合使用它\n\n\n参考文献#\n\n * http://nodejs.cn/\n * https://segmentfault.com/a/1190000019854308\n * https://segmentfault.com/a/1190000005173218","routePath":"/interview/NodeJS/nodejs","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"非阻塞异步","id":"非阻塞异步","depth":3,"charIndex":179},{"text":"事件驱动","id":"事件驱动","depth":3,"charIndex":313},{"text":"二、优缺点","id":"二优缺点","depth":2,"charIndex":464},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":648},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1026}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 Node.js 的理解？优缺点？应用场景？","footer":"说说你对 Node.js 的理解？优缺点？应用场景？","order":9,"star":9,"date":"2023-03-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说你对 Node.js 的理解？优缺点？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 Node.js 的理解？优缺点？应用场景？"}]]},"version":""},{"id":50,"title":"如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?","content":"#\n\n\n\n\n一、是什么#\n\n在我们做数据查询的时候，如果数据量很大，比如几万条数据，放在一个页面显示的话显然不友好，这时候就需要采用分页显示的形式，如每次只显示 10 条数据\n\n\n\n要实现分页功能，实际上就是从结果集中显示第 1~10 条记录作为第 1 页，显示第 11~20 条记录作为第 2 页，以此类推\n\n因此，分页实际上就是从结果集中截取出第 M~N 条记录\n\n\n二、如何实现#\n\n前端实现分页功能，需要后端返回必要的数据，如总的页数，总的数据量，当前页，当前的数据\n\n\n\n后端采用mysql作为数据的持久性存储\n\n前端向后端发送目标的页码page以及每页显示数据的数量pageSize，默认情况每次取 10 条数据，则每一条数据的起始位置start为：\n\n\n\n当确定了limit和start的值后，就能够确定SQL语句：\n\n\n\n上诉SQL语句表达的意思为：截取从start到start+pageSize之间（左闭右开）的数据\n\n关于查询数据总数的SQL语句为，record为表名：\n\n\n\n因此后端的处理逻辑为：\n\n * 获取用户参数页码数 page 和每页显示的数目 pageSize ，其中 page 是必须传递的参数，pageSize 为可选参数，默认为 10\n * 编写 SQL 语句，利用 limit 和 OFFSET 关键字进行分页查询\n * 查询数据库，返回总数据量、总页数、当前页、当前页数据给前端\n\n代码如下所示：\n\n\n\n\n三、总结#\n\n通过上面的分析，可以看到分页查询的关键在于，要首先确定每页显示的数量pageSize，然后根据当前页的索引pageIndex（从 1\n开始），确定LIMIT和OFFSET应该设定的值：\n\n * LIMIT 总是设定为 pageSize\n * OFFSET 计算公式为 pageSize * (pageIndex - 1)\n\n确定了这两个值，就能查询出第 N页的数据\n\n\n参考文献#\n\n * https://www.liaoxuefeng.com/wiki/1177760294764384/1217864791925600","routePath":"/interview/NodeJS/paging","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":185},{"text":"三、总结","id":"三总结","depth":2,"charIndex":624},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":816}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?","footer":"如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?","order":8,"star":8,"date":"2023-03-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?"}]]},"version":""},{"id":51,"title":"Node 性能如何进行监控以及优化？","content":"#\n\n\n\n\n一、 是什么#\n\nNode作为一门服务端语言，性能方面尤为重要，其衡量指标一般有如下：\n\n * CPU\n * 内存\n * I/O\n * 网络\n\n\nCPU#\n\n主要分成了两部分：\n\n * CPU 负载：在某个时间段内，占用以及等待 CPU 的进程总数\n * CPU 使用率：CPU 时间占用状况，等于 1 - 空闲 CPU 时间(idle time) / CPU 总时间\n\n这两个指标都是用来评估系统当前 CPU 的繁忙程度的量化指标\n\nNode应用一般不会消耗很多的CPU，如果CPU占用率高，则表明应用存在很多同步操作，导致异步任务回调被阻塞\n\n\n内存指标#\n\n内存是一个非常容易量化的指标。 内存占用率是评判一个系统的内存瓶颈的常见指标。 对于 Node 来说，内部内存堆栈的使用状态也是一个可以量化的指标\n\n\n\n * rss：表示 node 进程占用的内存总量。\n * heapTotal：表示堆内存的总量。\n * heapUsed：实际堆内存的使用量。\n * external ：外部程序的内存使用量，包含 Node 核心的 C++程序的内存使用量\n\n在Node中，一个进程的最大内存容量为 1.5GB。因此我们需要减少内存泄露\n\n\n磁盘 I/O#\n\n硬盘的IO 开销是非常昂贵的，硬盘 IO 花费的 CPU 时钟周期是内存的 164000 倍\n\n内存 IO比磁盘IO 快非常多，所以使用内存缓存数据是有效的优化方法。常用的工具如 redis、memcached等\n\n并不是所有数据都需要缓存，访问频率高，生成代价比较高的才考虑是否缓存，也就是说影响你性能瓶颈的考虑去缓存，并且而且缓存还有缓存雪崩、缓存穿透等问题要解决\n\n\n二、如何监控#\n\n关于性能方面的监控，一般情况都需要借助工具来实现\n\n这里采用Easy-Monitor 2.0，其是轻量级的 Node.js 项目内核性能监控 + 分析工具，在默认模式下，只需要在项目入口文件 require\n一次，无需改动任何业务代码即可开启内核级别的性能监控分析\n\n使用方法如下：\n\n在你的项目入口文件中按照如下方式引入，当然请传入你的项目名称：\n\n\n\n打开你的浏览器，访问 http://localhost:12333 ，即可看到进程界面\n\n关于定制化开发、通用配置项以及如何动态更新配置项详见官方文档\n\n\n三、如何优化#\n\n关于Node的性能优化的方式有：\n\n * 使用最新版本 Node.js\n * 正确使用流 Stream\n * 代码层面优化\n * 内存管理优化\n\n\n使用最新版本 Node.js#\n\n每个版本的性能提升主要来自于两个方面：\n\n * V8 的版本更新\n * Node.js 内部代码的更新优化\n\n\n正确使用流 Stream#\n\n在Node中，很多对象都实现了流，对于一个大文件可以通过流的形式发送，不需要将其完全读入内存\n\n\n\n\n代码层面优化#\n\n合并查询，将多次查询合并一次，减少数据库的查询次数\n\n\n\n\n内存管理优化#\n\n在 V8 中，主要将内存分为新生代和老生代两代：\n\n * 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象\n * 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象\n\n若新生代内存空间不够，直接分配到老生代\n\n通过减少内存占用，可以提高服务器的性能。如果有内存泄露，也会导致大量的对象存储到老生代中，服务器性能会大大降低\n\n如下面情况：\n\n\n\nleak的内存非常大，造成内存泄露，应当避免这样的操作，通过减少内存使用，是提高服务性能的手段之一\n\n而节省内存最好的方式是使用池，其将频用、可复用对象存储起来，减少创建和销毁操作\n\n例如有个图片请求接口，每次请求，都需要用到类。若每次都需要重新 new 这些类，并不是很合适，在大量请求时，频繁创建和销毁这些类，造成内存抖动\n\n使用对象池的机制，对这种频繁需要创建和销毁的对象保存在一个对象池中。每次用到该对象时，就取对象池空闲的对象，并对它进行初始化操作，从而提高框架的性能\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000039327565\n * https://zhuanlan.zhihu.com/p/50055740\n * https://segmentfault.com/a/1190000010231628","routePath":"/interview/NodeJS/performance","lang":"","toc":[{"text":"一、 是什么","id":"一-是什么","depth":2,"charIndex":5},{"text":"CPU","id":"cpu","depth":3,"charIndex":78},{"text":"内存指标","id":"内存指标","depth":3,"charIndex":280},{"text":"磁盘 I/O","id":"磁盘-io","depth":3,"charIndex":526},{"text":"二、如何监控","id":"二如何监控","depth":2,"charIndex":722},{"text":"三、如何优化","id":"三如何优化","depth":2,"charIndex":987},{"text":"使用最新版本 Node.js","id":"使用最新版本-nodejs","depth":3,"charIndex":1070},{"text":"正确使用流 Stream","id":"正确使用流-stream","depth":3,"charIndex":1143},{"text":"代码层面优化","id":"代码层面优化","depth":3,"charIndex":1209},{"text":"内存管理优化","id":"内存管理优化","depth":3,"charIndex":1248},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1681}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Node 性能如何进行监控以及优化？","footer":"Node 性能如何进行监控以及优化？","order":7,"star":7,"date":"2023-03-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-Node 性能如何进行监控以及优化？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Node 性能如何进行监控以及优化？"}]]},"version":""},{"id":52,"title":"说说对 Node 中的 process 的理解？有哪些常用方法？","content":"#\n\n\n\n\n一、是什么#\n\nprocess 对象是一个全局变量，提供了有关当前 Node.js进程的信息并对其进行控制，作为一个全局变量\n\n我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器\n\n当我们启动一个js文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程\n之间才可以数据共享\n\n由于JavaScript是一个单线程语言，所以通过node xxx启动一个文件后，只有一条主线程\n\n\n二、属性与方法#\n\n关于process常见的属性有如下：\n\n * process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息\n * process.nextTick：这个在谈及 EventLoop 时经常为会提到\n * process.pid：获取当前进程 id\n * process.ppid：当前进程对应的父进程\n * process.cwd()：获取当前进程工作目录，\n * process.platform：获取当前进程运行的操作系统平台\n * process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值\n * 进程事件： process.on(‘uncaughtException’,cb) 捕获异常信息、 process.on(‘exit’,cb）进程推出监听\n * 三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出\n * process.title 指定进程名称，有的时候需要给进程指定一个名称\n\n下面再稍微介绍下某些方法的使用：\n\n\nprocess.cwd()#\n\n返回当前 Node进程执行的目录\n\n一个Node 模块 A 通过 NPM 发布，项目 B 中使用了模块 A。在 A 中需要操作 B 项目下的文件时，就可以用 process.cwd() 来获取 B\n项目的路径\n\n\nprocess.argv#\n\n在终端通过 Node 执行命令的时候，通过 process.argv 可以获取传入的命令行参数，返回值是一个数组：\n\n * 0: Node 路径（一般用不到，直接忽略）\n * 1: 被执行的 JS 文件路径（一般用不到，直接忽略）\n * 2~n: 真实传入命令的参数\n\n所以，我们只要从 process.argv[2] 开始获取就好了\n\n\n\n\nprocess.env#\n\n返回一个对象，存储当前环境相关的所有信息，一般很少直接用到。\n\n一般我们会在 process.env 上挂载一些变量标识当前的环境。比如最常见的用 process.env.NODE_ENV 区分 development 和\nproduction\n\n在 vue-cli 的源码中也经常会看到 process.env.VUE_CLI_DEBUG 标识当前是不是 DEBUG 模式\n\n\nprocess.nextTick()#\n\n我们知道NodeJs是基于事件轮询，在这个过程中，同一时间只会处理一件事情\n\n在这种处理模式下，process.nextTick()就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行\n\n例如下面例子将一个foo函数在下一个时间点调用\n\n\n\n输出结果为bar、foo\n\n虽然下述方式也能实现同样效果：\n\n\n\n两者区别在于：\n\n * process.nextTick()会在这一次 event loop 的 call stack 清空后（下一次 event loop 开始前）再调用\n   callback\n * setTimeout()是并不知道什么时候 call stack 清空的，所以何时调用 callback 函数是不确定的\n\n\n参考文献#\n\n * http://nodejs.cn/api/process.html","routePath":"/interview/NodeJS/process","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、属性与方法","id":"二属性与方法","depth":2,"charIndex":259},{"text":"process.cwd()","id":"processcwd","depth":3,"charIndex":775},{"text":"process.argv","id":"processargv","depth":3,"charIndex":898},{"text":"process.env","id":"processenv","depth":3,"charIndex":1085},{"text":"process.nextTick()","id":"processnexttick","depth":3,"charIndex":1289},{"text":"参考文献","id":"参考文献","depth":3,"charIndex":1635}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Node 中的 process 的理解？有哪些常用方法？","footer":"说说对 Node 中的 process 的理解？有哪些常用方法？","order":6,"star":6,"date":"2023-03-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说对 Node 中的 process 的理解？有哪些常用方法？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Node 中的 process 的理解？有哪些常用方法？"}]]},"version":""},{"id":53,"title":"说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","content":"#\n\n\n\n\n一、模块规范#\n\nNodeJS对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：\n\n * 在 Node 中每一个 js 文件都是一个单独的模块\n * 模块中包括 CommonJS 规范的核心变量：exports、module.exports、require\n * 通过上述变量进行模块化开发\n\n而模块化的核心是导出与导入，在Node中通过exports与module.exports负责对模块中的内容进行导出，通过require函数导入其他模块（自定义模\n块、系统模块、第三方库模块）中的内容\n\n\n二、查找策略#\n\nrequire方法接收一下几种参数的传递：\n\n * 原生模块：http、fs、path 等\n * 相对路径的文件模块：./mod 或../mod\n * 绝对路径的文件模块：/pathtomodule/mod\n * 目录作为模块：./dirname\n * 非原生模块的文件模块：mod\n\nrequire参数较为简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同，如下图：\n\n\n\n从上图可以看见，文件模块存在缓存区，寻找模块路径的时候都会优先从缓存中加载已经存在的模块\n\n\n原生模块#\n\n而像原生模块这些，通过require方法在解析文件名之后，优先检查模块是否在原生模块列表中，如果在则从原生模块中加载\n\n\n绝对路径、相对路径#\n\n如果require绝对路径的文件，则直接查找对应的路径，速度最快\n\n相对路径的模块则相对于当前调用require的文件去查找\n\n如果按确切的文件名没有找到模块，则 NodeJs 会尝试带上 .js、.json或 .node拓展名再加载\n\n\n目录作为模块#\n\n默认情况是根据根目录中package.json文件的main来指定目录模块，如：\n\n\n\n如果这是在./some-library node_modules目录中，则 require('./some-library') 会试图加载\n./some-library/main.js\n\n如果目录里没有 package.json文件，或者 main入口不存在或无法解析，则会试图加载目录下的 index.js 或 index.node 文件\n\n\n非原生模块#\n\n在每个文件中都存在module.paths，表示模块的搜索路径，require就是根据其来寻找文件\n\n在window下输出如下：\n\n\n\n可以看出module\npath的生成规则为：从当前文件目录开始查找node_modules目录；然后依次进入父目录，查找父目录下的node_modules目录，依次迭代，直到根目录下\n的node_modules目录\n\n当都找不到的时候，则会从系统NODE_PATH环境变量查找\n\n举个例子#\n\n如果在/home/ry/projects/foo.js文件里调用了 require('bar.js')，则 Node.js 会按以下顺序查找：\n\n * /home/ry/projects/node_modules/bar.js\n * /home/ry/node_modules/bar.js\n * /home/node_modules/bar.js\n * /node_modules/bar.js\n\n这使得程序本地化它们的依赖，避免它们产生冲突\n\n\n三、总结#\n\n通过上面模块的文件查找策略之后，总结下文件查找的优先级：\n\n * 缓存的模块优先级最高\n\n * 如果是内置模块，则直接返回，优先级仅次缓存的模块\n\n * 如果是绝对路径 / 开头，则从根目录找\n\n * 如果是相对路径 ./开头，则从当前 require 文件相对位置找\n\n * 如果文件没有携带后缀，先从 js、json、node 按顺序查找\n\n * 如果是目录，则根据 package.json 的 main 属性值决定目录下入口文件，默认情况为 index.js\n\n * 如果文件为第三方模块，则会引入 node_modules 文件，如果不在当前仓库文件中，则自动从上级递归查找，直到根目录\n\n\n参考文献#\n\n * http://nodejs.cn/api/modules.html#modules_file_modules\n * https://blog.csdn.net/qq_36801250/article/details/106352686\n * https://www.cnblogs.com/samve/p/10805908.html","routePath":"/interview/NodeJS/require_order","lang":"","toc":[{"text":"一、模块规范","id":"一模块规范","depth":2,"charIndex":5},{"text":"二、查找策略","id":"二查找策略","depth":2,"charIndex":274},{"text":"原生模块","id":"原生模块","depth":3,"charIndex":522},{"text":"绝对路径、相对路径","id":"绝对路径相对路径","depth":3,"charIndex":590},{"text":"目录作为模块","id":"目录作为模块","depth":3,"charIndex":722},{"text":"非原生模块","id":"非原生模块","depth":3,"charIndex":948},{"text":"举个例子","id":"举个例子","depth":4,"charIndex":1164},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1396},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1704}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","footer":"说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","order":14,"star":14,"date":"2023-04-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","NodeJS"],"tag":["interview","NodeJS"],"shortTitle":"前端物语|面试物语-说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?"}]]},"version":""},{"id":54,"title":"面试物语","content":" * JavaScript\n\n * [ == 和 ===区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/==\n   _===)\n\n * 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？\n\n * DOM 常见的操作有哪些？\n\n * ajax 原理是什么？如何实现？\n\n * 数组的常用方法有哪些？\n\n * bind、call、apply 区别？如何实现一个 bind?\n\n * Javascript 本地存储的方式有哪些？区别及应用场景？\n\n * 说说你对闭包的理解？闭包使用场景\n\n * JavaScript 中执行上下文和执行栈是什么？\n\n * 大文件上传如何做断点续传？\n\n * 深拷贝浅拷贝的区别？如何实现一个深拷贝？\n\n * 说说 JavaScript 中的数据类型？存储上的差别？\n\n * 什么是防抖和节流？有什么区别？如何实现？\n\n * 说说 JavaScript 中的事件模型\n\n * 解释下什么是事件代理？应用场景？\n\n * 说说你对事件循环的理解\n\n * Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？\n\n * 说说你对函数式编程的理解？优缺点？\n\n * Javascript 如何实现继承？\n\n * 说说你了解的 js 数据结构？\n\n * 说说 Javascript 数字精度丢失的问题，如何解决？\n\n * 说说 JavaScript 中内存泄漏的几种情况？\n\n * 说说 new 操作符具体干了什么？\n\n * JavaScript 原型，原型链 ? 有什么特点？\n\n * 如何实现上拉加载，下拉刷新？\n\n * 说说你对正则表达式的理解？应用场景？\n\n * 说说你对作用域链的理解\n\n * web 常见的攻击方式有哪些？如何防御？\n\n * 什么是单点登录？如何实现？\n\n * JavaScript 字符串的常用方法有哪些？\n\n * 举例说明你对尾递归的理解，有哪些应用场景\n\n * 谈谈 this 对象的理解\n\n * 谈谈 JavaScript 中的类型转换机制\n\n * typeof 与 instanceof 区别\n\n * 如何判断一个元素是否在可视区域中？\n\n * NodeJS\n\n * 说说对 Node 中的 Buffer 的理解？应用场景？\n\n * 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?\n\n * 说说对 Node 中的 Stream 的理解？应用场景？\n\n * 说说对 Nodejs 中的事件循环机制理解?\n\n * 如何实现文件上传？说说你的思路\n\n * 说说对 Node 中的 fs 模块的理解? 有哪些常用方法\n\n * 说说 Node. js 有哪些全局对象？\n\n * 如何实现 jwt 鉴权机制？说说你的思路\n\n * 说说对中间件概念的理解，如何封装 node 中间件？\n\n * 说说你对 Node.js 的理解？优缺点？应用场景？\n\n * 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?\n\n * Node 性能如何进行监控以及优化？\n\n * 说说对 Node 中的 process 的理解？有哪些常用方法？\n\n * 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?\n\n * README.md\n\n * React\n\n * React 事件绑定的方式有哪些？区别？\n\n * React 构建组件的方式有哪些？区别？\n\n * 说说对 Fiber 架构的理解？解决了什么问题？\n\n * 说说对高阶组件的理解？应用场景?\n\n * 说说 React 性能优化的手段有哪些？\n\n * 说说 React Jsx 转换成真实 DOM 过程？\n\n * 说说对 React 的理解？有哪些特性？\n\n * 说说对 React Hooks 的理解？解决了什么问题？\n\n * 说说你对 React Router 的理解？常用的 Router 组件有哪些？\n\n * 说说 React Router 有几种模式？实现原理？\n\n * 说说对 React refs 的理解？应用场景？\n\n * [ 说说 Real DOM 和 Virtual DOM\n   的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM)\n\n * 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？\n\n * 说说 React 的事件机制？\n\n * 在 react 中组件间过渡动画如何实现？\n\n * 说说你在 React 项目是如何捕获错误的？\n\n * 说说对 React 中类组件和函数组件的理解？有什么区别？\n\n * React 中组件之间如何通信？\n\n * 说说对受控组件和非受控组件的理解？应用场景？\n\n * 说说 React diff 的原理是什么？\n\n * 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？\n\n * 说说你对 immutable 的理解？如何应用在 react 项目中？\n\n * 说说 react 中引入 css 的方式有哪几种？区别？\n\n * 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？\n\n * React 中的 key 有什么作用？\n\n * 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？\n\n * 说说你对 Redux 的理解？其工作原理？\n\n * 说说 React render 方法的原理？在什么时候会被触发？\n\n * 说说 React 服务端渲染怎么做？原理是什么？\n\n * 说说 React 中的 setState 执行机制\n\n * state 和 props 有什么区别？\n\n * 说说你在使用 React 过程中遇到的常见问题？如何解决?\n\n * super() 和 super(props) 有什么区别？\n\n * algorithm\n\n * 说说你对算法的理解？应用场景？\n\n * 说说你对二分查找的理解？如何实现？应用场景？\n\n * 说说你对堆的理解？如何实现？应用场景？\n\n * 说说你对链表的理解？常见的操作有哪些？\n\n * 说说你对冒泡排序的理解？如何实现？应用场景？\n\n * 说说你对分而治之、动态规划的理解？区别？\n\n * 说说你对贪心算法、回溯算法的理解？应用场景？\n\n * 说说你对图的理解？相关操作有哪些？\n\n * 说说你对插入排序的理解？如何实现？应用场景？\n\n * 说说你对归并排序的理解？如何实现？应用场景？\n\n * 说说你对快速排序的理解？如何实现？应用场景？\n\n * 说说你对选择排序的理解？如何实现？应用场景？\n\n * 说说你对集合的理解？常见的操作有哪些？\n\n * 说说常见的排序算法有哪些？区别？\n\n * 说说你对栈、队列的理解？应用场景？\n\n * 说说你对数据结构的理解？有哪些？区别？\n\n * 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？\n\n * 说说你对树的理解？相关的操作有哪些？\n\n * applet\n\n * 说说微信小程序的实现原理？\n\n * 说说你对微信小程序的理解？优缺点？\n\n * 说说微信小程序的生命周期函数有哪些？\n\n * 说说微信小程序的登录流程？\n\n * 说说微信小程序中路由跳转的方式有哪些？区别？\n\n * 说说提高微信小程序的应用速度的手段有哪些？\n\n * 说说微信小程序的发布流程？\n\n * 说说微信小程序的支付流程？\n\n * css\n\n * 谈谈你对 BFC 的理解？\n\n * css3 动画有哪些？\n\n * 说说你对盒子模型的理解?\n\n * 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？\n\n * 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？\n\n * CSS3 新增了哪些新特性？\n\n * 如果要做优化，CSS 提高性能的方法有哪些？\n\n * 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？\n\n * 说说 em/px/rem/vh/vw 区别?\n\n * 说说 flexbox（弹性盒布局模型）,以及适用场景？\n\n * 介绍一下 grid 网格布局\n\n * css 中，有哪些方式可以隐藏页面元素？区别?\n\n * 怎么理解回流跟重绘？什么场景下会触发？\n\n * 让 Chrome 支持小于 12px 的文字方式有哪些？区别？\n\n * 什么是响应式设计？响应式设计的基本原理是什么？如何做？\n\n * 说说对 Css 预编语言的理解？有哪些区别?\n\n * 如何实现单行／多行文本溢出的省略样式？\n\n * CSS 如何画一个三角形？原理是什么？\n\n * 如何使用 css 完成视差滚动效果?\n\n * design\n\n * 说说你对工厂模式的理解？应用场景？\n\n * 说说你对发布订阅、观察者模式的理解？区别？\n\n * 说说你对代理模式的理解？应用场景？\n\n * 说说你对单例模式的理解？如何实现？\n\n * 说说你对策略模式的理解？应用场景？\n\n * 说说对设计模式的理解？常见的设计模式有哪些？\n\n * es6\n\n * ES6 中数组新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Decorator 的？使用场景？\n\n * 对象新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Generator 的？使用场景？\n\n * 你是怎么理解 ES6 中 Module 的？使用场景？\n\n * 对象新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Promise 的？使用场景？\n\n * 你是怎么理解 ES6 中 Proxy 的？使用场景?\n\n * 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？\n\n * 说说 var、let、const 之间的区别\n\n * git\n\n * 说说你对 Git 的理解？\n\n * 说说 Git 中 HEAD、工作树和索引之间的区别？\n\n * 说说你对版本管理的理解？常用的版本管理工具有哪些？\n\n * 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?\n\n * [ 说说你对 git rebase 和 git merge\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge)\n\n * [ 说说对 git pull 和 git fetch\n   的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch)\n\n * [ 说说你对 git reset 和 git revert\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert)\n\n * 说说你对 git stash 的理解？应用场景？\n\n * http\n\n * 说说 HTTP1.0/1.1/2.0 的区别?\n\n * 如何理解 CDN？说说实现原理？\n\n * DNS 协议 是什么？说说 DNS 完整的查询过程?\n\n * 说一下 GET 和 POST 的区别？\n\n * 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？\n\n * 什么是 HTTP? HTTP 和 HTTPS 的区别?\n\n * 如何理解 OSI 七层模型?\n\n * 如何理解 TCP/IP 协议?\n\n * 如何理解 UDP 和 TCP? 区别? 应用场景?\n\n * 说说对 WebSocket 的理解？应用场景？\n\n * 说说地址栏输入 URL 敲下回车后发生了什么?\n\n * 说说 TCP 为什么需要三次握手和四次挥手？\n\n * 说说 HTTP 常见的请求头有哪些? 作用？\n\n * 说说 HTTP 常见的状态码有哪些，适用场景？\n\n * linux\n\n * 说说 linux 系统下 文件操作常用的命令有哪些？\n\n * [\n\n * typescript\n\n * 说说你对 TypeScript 中类的理解？应用场景？\n\n * 说说 typescript 的数据类型有哪些？\n\n * 说说你对 TypeScript 装饰器的理解？应用场景？\n\n * 说说你对 TypeScript 中枚举类型的理解？应用场景？\n\n * 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？\n\n * 说说你对 TypeScript 中泛型的理解？应用场景？\n\n * 说说你对 TypeScript 中高级类型的理解？有哪些？\n\n * 说说你对 TypeScript 中接口的理解？应用场景？\n\n * 说说对 TypeScript 中命名空间与模块的理解？区别？\n\n * 说说如何在 React 项目中应用 TypeScript？\n\n * 说说你对 TypeScript 的理解？与 JavaScript 的区别？\n\n * 说说如何在 Vue 项目中应用 TypeScript？\n\n * vue\n\n * vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？\n\n * Vue 项目中有封装过 axios 吗？主要是封装哪方面的？\n\n * 你了解 axios 的原理吗？有看过它的源码吗？\n\n * 双向数据绑定是什么\n\n * Vue 组件之间的通信方式都有哪些？\n\n * Vue 中组件和插件有什么区别？\n\n * Vue 项目中你是如何解决跨域的呢？\n\n * 为什么 data 属性是一个函数而不是一个对象？\n\n * 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？\n\n * 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？\n\n * Vue 中的过滤器了解吗？过滤器的应用场景有哪些？\n\n * SPA 首屏加载速度慢的怎么解决？\n\n * v-if 和 v-for 的优先级是什么？\n\n * 说说你对 keep-alive 的理解是什么？\n\n * 你知道 vue 中 key 的原理吗？说说你对它的理解\n\n * 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n\n * 说说你对 vue 的 mixin 的理解，有什么应用场景？\n\n * Vue 常用的修饰符有哪些有什么应用场景\n\n * Vue 实例挂载的过程\n\n * Vue 中的$nextTick 有什么作用？\n\n * Vue.observable 你有了解过吗？说说看\n\n * vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n\n * v-show 和 v-if 有什么区别？使用场景分别是什么？\n\n * 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢\n\n * SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？\n\n * 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？\n\n * 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路\n\n * vue3 有了解过吗？能说说跟 vue2 的区别吗？\n\n * vue3\n\n * Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\n * Vue3.0 的设计目标是什么？做了哪些优化\n\n * 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？\n\n * Vue3.0 性能提升主要是通过哪几方面体现的？\n\n * Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？\n\n * css 选择器有哪些？优先级？哪些属性可以继承？\n\n * 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？\n\n * webpack\n\n * 说说 webpack 的热更新是如何做到的？原理是什么？\n\n * 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？\n\n * 说说 webpack 中常见的 Plugin？解决了什么问题？\n\n * 与 webpack 类似的工具还有哪些？区别？\n\n * 说说 webpack 的构建流程?\n\n * 如何提高 webpack 的构建速度？\n\n * 说说如何借助 webpack 来优化前端性能？\n\n * 说说 webpack proxy 工作原理？为什么能解决跨域?\n\n * 说说你对 webpack 的理解？解决了什么问题？","routePath":"/interview/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"diagram","order":1,"author":"h7ml","category":"design","tag":"design","title":"面试物语","index":false,"dir":{"order":1},"date":"2023-02-24T00:00:00.000Z"},"version":""},{"id":55,"title":"React 事件绑定的方式有哪些？区别？","content":"#\n\n\n\n\n一、是什么#\n\n在react应用中，事件名都是用小驼峰格式进行书写，例如onclick要改写成onClick\n\n最简单的事件绑定如下：\n\n\n\n从上面可以看到，事件绑定的方法需要使用{}包住\n\n上述的代码看似没有问题，但是当将处理函数输出代码换成console.log(this)的时候，点击按钮，则会发现控制台输出undefined\n\n\n二、如何绑定#\n\n为了解决上面正确输出this的问题，常见的绑定方式有如下：\n\n * render 方法中使用 bind\n * render 方法中使用箭头函数\n * constructor 中 bind\n * 定义阶段使用箭头函数绑定\n\n\nrender 方法中使用 bind#\n\n如果使用一个类组件，在其中给某个组件/元素一个onClick属性，它现在并会自定绑定其this到当前组件，解决这个问题的方法是在事件函数后使用.bind(thi\ns)将this绑定到当前组件中\n\n\n\n这种方式在组件每次render渲染的时候，都会重新进行bind的操作，影响性能\n\n\nrender 方法中使用箭头函数#\n\n通过ES6的上下文来将this的指向绑定给当前组件，同样再每一次render的时候都会生成新的方法，影响性能\n\n\n\n\nconstructor 中 bind#\n\n在constructor中预先bind当前组件，可以避免在render操作中重复绑定\n\n\n\n\n定义阶段使用箭头函数绑定#\n\n跟上述方式三一样，能够避免在render操作中重复绑定，实现也非常的简单，如下：\n\n\n\n\n三、区别#\n\n上述四种方法的方式，区别主要如下：\n\n * 编写方面：方式一、方式二写法简单，方式三的编写过于冗杂\n * 性能方面：方式一和方式二在每次组件 render\n   的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例\n\n综合上述，方式四是最优的事件绑定方式\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000011317515","routePath":"/interview/React/Binding_events","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何绑定","id":"二如何绑定","depth":2,"charIndex":174},{"text":"render 方法中使用 bind","id":"render-方法中使用-bind","depth":3,"charIndex":295},{"text":"render 方法中使用箭头函数","id":"render-方法中使用箭头函数","depth":3,"charIndex":457},{"text":"constructor 中 bind","id":"constructor-中-bind","depth":2,"charIndex":535},{"text":"定义阶段使用箭头函数绑定","id":"定义阶段使用箭头函数绑定","depth":3,"charIndex":603},{"text":"三、区别","id":"三区别","depth":2,"charIndex":663},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":841}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-React 事件绑定的方式有哪些？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>React 事件绑定的方式有哪些？区别？","order":3,"star":3,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-React 事件绑定的方式有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"React 事件绑定的方式有哪些？区别？"}]]},"version":""},{"id":56,"title":"React 构建组件的方式有哪些？区别？","content":"#\n\n\n\n\n一、是什么#\n\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式\n\n在React中，一个类、一个函数都可以视为一个组件\n\n在之前文章中，我们了解到组件所存在的优势：\n\n * 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n * 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件\n   之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n * 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n\n二、如何构建#\n\n在React目前来讲，组件的创建主要分成了三种方式：\n\n * 函数式创建\n * 通过 React.createClass 方法创建\n * 继承 React.Component 创建\n\n\n函数式创建#\n\n在React Hooks出来之前，函数式组件可以视为无状态组件，只负责根据传入的props来展示视图，不涉及对state状态的操作\n\n大多数组件可以写为无状态组件，通过简单组合构建其他组件\n\n在React中，通过函数简单创建组件的示例如下：\n\n\n\n\n通过 React.createClass 方法创建#\n\nReact.createClass是 react 刚开始推荐的创建组件的方式，目前这种创建方式已经不怎么用了\n\n像上述通过函数式创建的组件的方式，最终会通过babel转化成React.createClass这种形式，转化成如下：\n\n\n\n由于上述的编写方式过于冗杂，目前基本上不使用上\n\n\n继承 React.Component 创建#\n\n同样在react hooks出来之前，有状态的组件只能通过继承React.Component这种形式进行创建\n\n有状态的组件也就是组件内部存在维护的数据，在类创建的方式中通过this.state进行访问\n\n当调用this.setState修改组件的状态时，组价会再次会调用render()方法进行重新渲染\n\n通过继承React.Component创建一个时钟示例如下：\n\n\n\n\n三、区别#\n\n由于React.createClass创建的方式过于冗杂，并不建议使用\n\n而像函数式创建和类组件创建的区别主要在于需要创建的组件是否需要为有状态组件：\n\n * 对于一些无状态的组件创建，建议使用函数式创建的方式\n\n * 由于react\n   hooks的出现，函数式组件创建的组件通过使用hooks方法也能使之成为有状态组件，再加上目前推崇函数式编程，所以这里建议都使用函数式的方式来创建组件\n\n在考虑组件的选择原则上，能用无状态组件则用无状态组件\n\n\n参考文献#\n\n * https://react.docschina.org/","routePath":"/interview/React/Building_components","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何构建","id":"二如何构建","depth":2,"charIndex":346},{"text":"函数式创建","id":"函数式创建","depth":3,"charIndex":448},{"text":"通过 React.createClass 方法创建","id":"通过-reactcreateclass-方法创建","depth":3,"charIndex":581},{"text":"继承 React.Component 创建","id":"继承-reactcomponent-创建","depth":3,"charIndex":753},{"text":"三、区别","id":"三区别","depth":2,"charIndex":966},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1200}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-React 构建组件的方式有哪些？区别？","footer":"React 构建组件的方式有哪些？区别？","order":14,"star":14,"date":"2023-03-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-React 构建组件的方式有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"React 构建组件的方式有哪些？区别？"}]]},"version":""},{"id":57,"title":"说说对 Fiber 架构的理解？解决了什么问题？","content":"#\n\n\n\n\n一、问题#\n\nJavaScript引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待\n\n如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿\n\n而这也正是 React 15 的 Stack Reconciler所面临的问题，当 React在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断\n\n如果组件较大，那么js线程会一直执行，然后等到整棵VDOM树计算完成后，才会交给渲染的线程\n\n这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况\n\n\n\n\n二、是什么#\n\nReact Fiber 是 Facebook 花费两年余时间对 React 做出的一个重大改变与优化，是对 React 核心算法的一次重新实现。从\nFacebook 在 React Conf 2017 会议上确认，React Fiber 在 React 16 版本发布\n\n在react中，主要做了以下的操作：\n\n * 为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务\n * 增加了异步任务，调用 requestIdleCallback api，浏览器空闲的时候执行\n * dom diff 树变成了链表，一个 dom 对应两个 fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行\n\n从架构角度来看，Fiber 是对 React核心算法（即调和过程）的重写\n\n从编码角度来看，Fiber是 React内部所定义的一种数据结构，它是 Fiber树结构的节点单位，也就是 React 16 新架构下的虚拟DOM\n\n一个 fiber就是一个 JavaScript对象，包含了元素的信息、该元素的更新操作队列、类型，其数据结构如下：\n\n\n\n\n三、如何解决#\n\nFiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线\n程不忙的时候在继续执行\n\n即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点\n\n实现的上述方式的是requestIdleCallback方法\n\nwindow.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响\n延迟关键事件，如动画和输入响应\n\n首先 React\n中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React\n未完成的任务，是一种合作式调度。\n\n该实现过程是基于 Fiber节点实现，作为静态的数据结构来说，每个 Fiber 节点对应一个 React\nelement，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。\n\n作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。\n\n每个 Fiber 节点有个对应的 React element，多个 Fiber节点根据如下三个属性构建一颗树：\n\n\n\n通过这些属性就能找到下一个执行目标\n\n\n参考文献#\n\n * https://juejin.cn/post/6926432527980691470\n * https://zhuanlan.zhihu.com/p/137234573","routePath":"/interview/React/Fiber","lang":"","toc":[{"text":"一、问题","id":"一问题","depth":2,"charIndex":5},{"text":"二、是什么","id":"二是什么","depth":2,"charIndex":307},{"text":"三、如何解决","id":"三如何解决","depth":2,"charIndex":817},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1469}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Fiber 架构的理解？解决了什么问题？","footer":"说说对 Fiber 架构的理解？解决了什么问题？","order":24,"star":24,"date":"2023-04-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 Fiber 架构的理解？解决了什么问题？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Fiber 架构的理解？解决了什么问题？"}]]},"version":""},{"id":58,"title":"说说对高阶组件的理解？应用场景?","content":"#\n\n\n\n\n一、是什么#\n\n高阶函数（Higher-order function），至少满足下列一个条件的函数\n\n * 接受一个或多个函数作为输入\n * 输出一个函数\n\n在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件\n\n\n\n上述代码中，该函数接受一个组件WrappedComponent作为参数，返回加工过的新组件EnhancedComponent\n\n高阶组件的这种实现方式，本质上是一个装饰者设计模式\n\n\n二、如何编写#\n\n最基本的高阶组件的编写模板如下：\n\n\n\n通过对传入的原始组件 WrappedComponent 做一些你想要的操作（比如操作 props，提取\nstate，给原始组件包裹其他元素等），从而加工出想要的组件 EnhancedComponent\n\n把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用\n\n所以，高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用\n\n但在使用高阶组件的同时，一般遵循一些约定，如下：\n\n * props 保持一致\n * 你不能在函数式（无状态）组件上使用 ref 属性，因为它没有实例\n * 不要以任何方式改变原始组件 WrappedComponent\n * 透传不相关 props 属性给被包裹的组件 WrappedComponent\n * 不要再 render() 方法中使用高阶组件\n * 使用 compose 组合高阶组件\n * 包装显示名字以便于调试\n\n这里需要注意的是，高阶组件可以传递所有的props，但是不能传递ref\n\n如果向一个高阶组件添加refe引用，那么ref\n指向的是最外层容器组件实例的，而不是被包裹的组件，如果需要传递refs的话，则使用React.forwardRef，如下：\n\n\n\n\n三、应用场景#\n\n通过上面的了解，高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统\n计上报等\n\n举个例子，存在一个组件，需要从缓存中获取数据，然后渲染。一般情况，我们会如下编写：\n\n\n\n上述代码当然可以实现该功能，但是如果还有其他组件也有类似功能的时候，每个组件都需要重复写componentWillMount中的代码，这明显是冗杂的\n\n下面就可以通过高价组件来进行改写，如下：\n\n\n\n再比如组件渲染性能监控，如下：\n\n\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/higher-order-components.html#gatsby-focus-wr\n   apper\n * https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\n * https://segmentfault.com/a/1190000010307650\n * https://zhuanlan.zhihu.com/p/61711492","routePath":"/interview/React/High_order_components","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何编写","id":"二如何编写","depth":2,"charIndex":232},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":784},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1045}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对高阶组件的理解？应用场景?","footer":"说说对高阶组件的理解？应用场景?","order":26,"star":26,"date":"2023-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对高阶组件的理解？应用场景?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对高阶组件的理解？应用场景?"}]]},"version":""},{"id":59,"title":"说说 React 性能优化的手段有哪些？","content":"') res.write('\n') res.write(renderToString()) res.write('","routePath":"/interview/React/Improve_performance","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":-1},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":-1},{"text":"避免使用内联函数","id":"避免使用内联函数","depth":4,"charIndex":-1},{"text":"使用 React Fragments 避免额外标记","id":"使用-react-fragments-避免额外标记","depth":4,"charIndex":-1},{"text":"事件绑定方式","id":"事件绑定方式","depth":3,"charIndex":-1},{"text":"使用 Immutable","id":"使用-immutable","depth":3,"charIndex":-1},{"text":"懒加载组件","id":"懒加载组件","depth":3,"charIndex":-1},{"text":"服务端渲染","id":"服务端渲染","depth":3,"charIndex":-1},{"text":"其他","id":"其他","depth":3,"charIndex":-1},{"text":"三、总结","id":"三总结","depth":3,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React 性能优化的手段有哪些？","footer":"说说 React 性能优化的手段有哪些？","order":25,"star":25,"date":"2023-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React 性能优化的手段有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React 性能优化的手段有哪些？"}]]},"version":""},{"id":60,"title":"说说 React Jsx 转换成真实 DOM 过程？","content":"#\n\n\n\n\n一、是什么#\n\nreact通过将组件编写的JSX映射到屏幕，以及组件中的状态发生了变化之后 React会将这些「变化」更新到屏幕上\n\n在前面文章了解中，JSX通过babel最终转化成React.createElement这种形式，例如：\n\n\n\n会被bebel转化成如下：\n\n\n\n在转化过程中，babel在编译时会判断 JSX 中组件的首字母：\n\n * 当首字母为小写时，其被认定为原生 DOM 标签，createElement 的第一个变量被编译为字符串\n\n * 当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象\n\n最终都会通过RenderDOM.render(...)方法进行挂载，如下：\n\n\n\n\n二、过程#\n\n在react中，节点大致可以分成四个类别：\n\n * 原生标签节点\n * 文本节点\n * 函数组件\n * 类组件\n\n如下所示：\n\n\n\n这些类别最终都会被转化成React.createElement这种形式\n\nReact.createElement其被调用时会传⼊标签类型type，标签属性props及若干子元素children，作用是生成一个虚拟Dom对象，如下所示：\n\n\n\ncreateElement会根据传入的节点信息进行一个判断：\n\n * 如果是原生标签节点， type 是字符串，如 div、span\n * 如果是文本节点， type 就没有，这里是 TEXT\n * 如果是函数组件，type 是函数名\n * 如果是类组件，type 是类名\n\n虚拟DOM会通过ReactDOM.render进行渲染成真实DOM，使用方法如下：\n\n\n\n当首次调用时，容器节点里的所有 DOM 元素都会被替换，后续的调用则会使用 React 的 diff算法进行高效的更新\n\n如果提供了可选的回调函数callback，该回调将在组件被渲染或更新之后被执行\n\nrender大致实现方法如下：\n\n\n\n\n三、总结#\n\n在react源码中，虚拟Dom转化成真实Dom整体流程如下图所示：\n\n\n\n其渲染流程如下所示：\n\n * 使用 React.createElement 或 JSX 编写 React 组件，实际上所有的 JSX 代码最后都会转换成\n   React.createElement(...) ，Babel 帮助我们完成了这个转换的过程。\n * createElement 函数对 key 和 ref 等特殊的 props 进行处理，并获取 defaultProps 对默认 props\n   进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟 DOM 对象\n * ReactDOM.render 将生成好的虚拟 DOM 渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实\n   DOM\n\n\n参考文献#\n\n * https://bbs.huaweicloud.com/blogs/265503)\n * https://huang-qing.github.io/react/2019/05/29/React-VirDom/\n * https://segmentfault.com/a/1190000018891454","routePath":"/interview/React/JSX_to_DOM","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、过程","id":"二过程","depth":2,"charIndex":327},{"text":"三、总结","id":"三总结","depth":2,"charIndex":826},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1199}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React Jsx 转换成真实 DOM 过程？","footer":"说说 React Jsx 转换成真实 DOM 过程？","order":22,"star":22,"date":"2023-04-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React Jsx 转换成真实 DOM 过程？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React Jsx 转换成真实 DOM 过程？"}]]},"version":""},{"id":61,"title":"前端物语|面试物语-React","content":" * React 事件绑定的方式有哪些？区别？\n * React 构建组件的方式有哪些？区别？\n * 说说对 Fiber 架构的理解？解决了什么问题？\n * 说说对高阶组件的理解？应用场景?\n * 说说 React 性能优化的手段有哪些？\n * 说说 React Jsx 转换成真实 DOM 过程？\n * 说说对 React 的理解？有哪些特性？\n * 说说对 React Hooks 的理解？解决了什么问题？\n * 说说你对 React Router 的理解？常用的 Router 组件有哪些？\n * 说说 React Router 有几种模式？实现原理？\n * 说说对 React refs 的理解？应用场景？\n * [ 说说 Real DOM 和 Virtual DOM\n   的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM)\n * 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？\n * 说说 React 的事件机制？\n * 在 react 中组件间过渡动画如何实现？\n * 说说你在 React 项目是如何捕获错误的？\n * 说说对 React 中类组件和函数组件的理解？有什么区别？\n * React 中组件之间如何通信？\n * 说说对受控组件和非受控组件的理解？应用场景？\n * 说说 React diff 的原理是什么？\n * 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？\n * 说说你对 immutable 的理解？如何应用在 react 项目中？\n * 说说 react 中引入 css 的方式有哪几种？区别？\n * 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？\n * React 中的 key 有什么作用？\n * 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？\n * 说说你对 Redux 的理解？其工作原理？\n * 说说 React render 方法的原理？在什么时候会被触发？\n * 说说 React 服务端渲染怎么做？原理是什么？\n * 说说 React 中的 setState 执行机制\n * state 和 props 有什么区别？\n * 说说你在使用 React 过程中遇到的常见问题？如何解决?\n * super() 和 super(props) 有什么区别？","routePath":"/interview/React/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"React","tag":"React","title":"前端物语|面试物语-React","index":false,"dir":{"order":1},"date":"2023-05-23T00:00:00.000Z"},"version":""},{"id":62,"title":"说说对 React 的理解？有哪些特性？","content":"#\n\n\n\n\n一、是什么#\n\nReact，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案\n\n遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效\n\n使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的单向数据流\n\n帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面\n\nreact 类组件使用一个名为 render() 的方法或者函数组件return，接收输入的数据并返回需要展示的内容\n\n\n\n上述这种类似 XML 形式就是 JSX，最终会被 babel 编译为合法的 JS 语句调用\n\n被传入的数据可在组件中通过 this.props 在 render() 访问\n\n\n二、特性#\n\nReact 特性有很多，如：\n\n * JSX 语法\n * 单向数据绑定\n * 虚拟 DOM\n * 声明式编程\n * Component\n\n着重介绍下声明式编程及 Component\n\n\n声明式编程#\n\n声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做\n\n它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件\n\n如实现一个标记的地图：\n\n通过命令式创建地图、创建标记、以及在地图上添加的标记的步骤如下：\n\n\n\n而用 React 实现上述功能则如下：\n\n\n\n声明式编程方式使得 React 组件很容易使用，最终的代码简单易于维护\n\n\nComponent#\n\n在 React 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件\n\n组件可以是一个函数或者是一个类，接受数据输入，处理它并返回在 UI 中呈现的 React 元素\n\n函数式组件如下：\n\n\n\n类组件（有状态组件）如下：\n\n\n\n一个组件该有的特点如下：\n\n * 可组合：每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部\n * 可重用：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景\n * 可维护：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护\n\n\n三、优势#\n\n通过上面的初步了解，可以感受到 React 存在的优势：\n\n * 高效灵活\n * 声明式的设计，简单使用\n * 组件式开发，提高代码复用率\n * 单向响应的数据流会比双向绑定的更安全，速度更快\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000015924762\n * https://react.docschina.org/","routePath":"/interview/React/React","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、特性","id":"二特性","depth":2,"charIndex":335},{"text":"声明式编程","id":"声明式编程","depth":3,"charIndex":435},{"text":"Component","id":"component","depth":3,"charIndex":626},{"text":"三、优势","id":"三优势","depth":2,"charIndex":894},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1000}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 React 的理解？有哪些特性？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 React 的理解？有哪些特性？","order":7,"star":7,"date":"2023-03-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 React 的理解？有哪些特性？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 React 的理解？有哪些特性？"}]]},"version":""},{"id":63,"title":"说说对 React Hooks 的理解？解决了什么问题？","content":"#\n\n\n\n\n一、是什么#\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n至于为什么引入hook，官方给出的动机是解决长时间使用和维护react过程中常遇到的问题，例如：\n\n * 难以重用和共享组件中的与状态相关的逻辑\n * 逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面\n * 类组件中的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题\n * 由于业务变动，函数组件不得不改为类组件等等\n\n在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作\n\n因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理\n\n\n二、有哪些#\n\n上面讲到，Hooks让我们的函数组件拥有了类组件的特性，例如组件内的状态、生命周期\n\n最常见的hooks有如下：\n\n * useState\n * useEffect\n * 其他\n\n\nuseState#\n\n首先给出一个例子，如下：\n\n\n\n在函数组件中通过useState实现函数内部维护state，参数为state默认的值，返回值是一个数组，第一个值为当前的state，第二个值为更新state的函\n数\n\n该函数组件等价于的类组件如下：\n\n\n\n从上述两种代码分析，可以看出两者区别：\n\n * state 声明方式：在函数组件中通过 useState 直接获取，类组件通过 constructor 构造函数中设置\n\n * state 读取方式：在函数组件中直接使用变量，类组件通过this.state.count的方式获取\n\n * state 更新方式：在函数组件中通过 setCount 更新，类组件通过 this.setState()\n\n总的来讲，useState 使用起来更为简洁，减少了this指向不明确的情况\n\n\nuseEffect#\n\nuseEffect可以让我们在函数组件中进行一些带有副作用的操作\n\n同样给出一个计时器示例：\n\n\n\n从上面可以看见，组件在加载和更新阶段都执行同样操作\n\n而如果使用useEffect后，则能够将相同的逻辑抽离出来，这是类组件不具备的方法\n\n对应的useEffect示例如下：\n\n\n\nuseEffect第一个参数接受一个回调函数，默认情况下，useEffect会在第一次渲染和更新之后都会执行，相当于在componentDidMount和com\nponentDidUpdate两个生命周期函数中执行回调\n\n如果某些特定值在两次重渲染之间没有发生变化，你可以跳过对 effect 的调用，这时候只需要传入第二个参数，如下：\n\n\n\n上述传入第二个参数后，如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的\n[5] 进行比较，如果是相等则跳过effects执行\n\n回调函数中可以返回一个清除函数，这是effect可选的清除机制，相当于类组件中componentwillUnmount生命周期函数，可做一些清除副作用的操作，如\n下：\n\n\n\n所以， useEffect相当于componentDidMount，componentDidUpdate 和 componentWillUnmount\n这三个生命周期函数的组合\n\n\n其它 hooks#\n\n在组件通信过程中可以使用useContext，refs学习中我们也用到了useRef获取DOM结构......\n\n还有很多额外的hooks，如：\n\n * useReducer\n * useCallback\n * useMemo\n * useRef\n\n\n三、解决什么#\n\n通过对上面的初步认识，可以看到hooks能够更容易解决状态相关的重用的问题：\n\n * 每调用 useHook 一次都会生成一份独立的状态\n\n * 通过自定义 hook 能够更好的封装我们的功能\n\n编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅\n\nhooks的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用hooks能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑h\nooks\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/hooks-state.html\n * https://zh-hans.reactjs.org/docs/hooks-effect.html\n * https://www.cnblogs.com/lalalagq/p/9898531.html","routePath":"/interview/React/React_Hooks","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":380},{"text":"useState","id":"usestate","depth":3,"charIndex":479},{"text":"useEffect","id":"useeffect","depth":3,"charIndex":848},{"text":"其它 hooks","id":"其它-hooks","depth":3,"charIndex":1459},{"text":"三、解决什么","id":"三解决什么","depth":2,"charIndex":1596},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1830}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 React Hooks 的理解？解决了什么问题？","footer":"说说对 React Hooks 的理解？解决了什么问题？","order":18,"star":18,"date":"2023-04-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 React Hooks 的理解？解决了什么问题？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 React Hooks 的理解？解决了什么问题？"}]]},"version":""},{"id":64,"title":"说说你对 React Router 的理解？常用的 Router 组件有哪些？","content":"#\n\n\n\n\n一、是什么#\n\nreact-router等前端路由的原理大致相同，可以实现无刷新的条件下切换显示不同的页面\n\n路由的本质就是页面的URL发生改变时，页面的显示结果可以根据URL的变化而变化，但是页面不会刷新\n\n因此，可以通过前端路由可以实现单页(SPA)应用\n\nreact-router主要分成了几个不同的包：\n\n * react-router: 实现了路由的核心功能\n\n * react-router-dom： 基于 react-router，加入了在浏览器运行环境下的一些功能\n\n * react-router-native：基于 react-router，加入了 react-native 运行环境下的一些功能\n\n * react-router-config: 用于配置静态路由的工具库\n\n\n二、有哪些#\n\n这里主要讲述的是react-router-dom的常用API，主要是提供了一些组件：\n\n * BrowserRouter、HashRouter\n * Route\n * Link、NavLink\n * switch\n * redirect\n\n\nBrowserRouter、HashRouter#\n\nRouter中包含了对路径改变的监听，并且会将相应的路径传递给子组件\n\nBrowserRouter是history模式，HashRouter模式\n\n使用两者作为最顶层组件包裹其他组件\n\n\n\n\nRoute#\n\nRoute用于路径的匹配，然后进行组件的渲染，对应的属性如下：\n\n * path 属性：用于设置匹配到的路径\n * component 属性：设置匹配到路径后，渲染的组件\n * render 属性：设置匹配到路径后，渲染的内容\n * exact 属性：开启精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件\n\n\n\n\nLink、NavLink#\n\n通常路径的跳转是使用Link组件，最终会被渲染成a元素，其中属性to代替a标题的href属性\n\nNavLink是在Link基础之上增加了一些样式属性，例如组件被选中时，发生样式变化，则可以设置NavLink的一下属性：\n\n * activeStyle：活跃时（匹配时）的样式\n * activeClassName：活跃时添加的 class\n\n如下：\n\n\n\n如果需要实现js实现页面的跳转，那么可以通过下面的形式：\n\n通过Route作为顶层组件包裹其他组件后,页面组件就可以接收到一些路由相关的东西，比如props.history\n\n\n\nprops中接收到的history对象具有一些方便的方法，如goBack，goForward,push\n\n\nredirect#\n\n用于路由的重定向，当这个组件出现时，就会执行跳转到对应的to路径中，如下例子：\n\n\n\n上述组件当接收到的路由参数name 不等于 tom 的时候，将会自动重定向到首页\n\n\nswitch#\n\nswich组件的作用适用于当匹配到第一个组件的时候，后面的组件就不应该继续匹配\n\n如下例子：\n\n\n\n如果不使用switch组件进行包裹\n\n除了一些路由相关的组件之外，react-router还提供一些hooks，如下：\n\n * useHistory\n * useParams\n * useLocation\n\n\nuseHistory#\n\nuseHistory可以让组件内部直接访问history，无须通过props获取\n\n\n\n\nuseParams#\n\n\n\n\nuseLocation#\n\nuseLocation 会返回当前 URL的 location对象\n\n\n\n\n三、参数传递#\n\n这些路由传递参数主要分成了三种形式：\n\n * 动态路由的方式\n * search 传递参数\n * to 传入对象\n\n\n动态路由#\n\n动态路由的概念指的是路由中的路径并不会固定\n\n例如将path在Route匹配时写成/detail/:id，那么 /detail/abc、/detail/123都可以匹配到该Route\n\n\n\n获取参数方式如下：\n\n\n\n\nsearch 传递参数#\n\n在跳转的路径中添加了一些 query 参数；\n\n\n\n获取形式如下：\n\n\n\n\nto 传入对象#\n\n传递方式如下：\n\n\n\n获取参数的形式如下：\n\n\n\n\n参考文献#\n\n * http://react-guide.github.io/react-router-cn/docs/API.html#route","routePath":"/interview/React/React_Router","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":354},{"text":"BrowserRouter、HashRouter","id":"browserrouterhashrouter","depth":3,"charIndex":483},{"text":"Route","id":"route","depth":3,"charIndex":606},{"text":"Link、NavLink","id":"linknavlink","depth":3,"charIndex":776},{"text":"redirect","id":"redirect","depth":3,"charIndex":1113},{"text":"switch","id":"switch","depth":3,"charIndex":1210},{"text":"useHistory","id":"usehistory","depth":3,"charIndex":1374},{"text":"useParams","id":"useparams","depth":3,"charIndex":1432},{"text":"useLocation","id":"uselocation","depth":3,"charIndex":1447},{"text":"三、参数传递","id":"三参数传递","depth":2,"charIndex":1499},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":1567},{"text":"search 传递参数","id":"search-传递参数","depth":3,"charIndex":1683},{"text":"to 传入对象","id":"to-传入对象","depth":3,"charIndex":1735},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1771}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 React Router 的理解？常用的 Router 组件有哪些？","footer":"说说你对 React Router 的理解？常用的 Router 组件有哪些？","order":23,"star":23,"date":"2023-04-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你对 React Router 的理解？常用的 Router 组件有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 React Router 的理解？常用的 Router 组件有哪些？"}]]},"version":""},{"id":65,"title":"说说 React Router 有几种模式？实现原理？","content":"#\n\n\n\n\n一、是什么#\n\n在单页应用中，一个web项目只有一个html页面，一旦页面加载完成之后，就不用因为用户的操作而进行页面的重新加载或者跳转，其特性如下：\n\n * 改变 url 且不让浏览器像服务器发送请求\n\n * 在不刷新页面的前提下动态改变浏览器地址栏中的 URL 地址\n\n其中主要分成了两种模式：\n\n * hash 模式：在 url 后面加上#，如http://127.0.0.1:5500/home/#/page1\n * history 模式：允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录\n\n\n二、使用#\n\nReact Router对应的hash模式和history模式对应的组件为：\n\n * HashRouter\n * BrowserRouter\n\n这两个组件的使用都十分的简单，作为最顶层组件包裹其他组件，如下所示\n\n\n\n\n三、实现原理#\n\n路由描述了 URL 与 UI之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）\n\n下面以hash模式为例子，改变hash值并不会导致浏览器向服务器发送请求，浏览器不发出请求，也就不会刷新页面\n\nhash 值改变，触发全局 window 对象上的 hashchange 事件。所以 hash 模式路由就是利用 hashchange 事件监听 URL\n的变化，从而进行 DOM 操作来模拟页面跳转\n\nreact-router也是基于这个特性实现路由的跳转\n\n下面以HashRouter组件分析进行展开：\n\n\nHashRouter#\n\nHashRouter包裹了整应用，\n\n通过window.addEventListener('hashChange',callback)监听hash值的变化，并传递给其嵌套的组件\n\n然后通过context将location数据往后代组件传递，如下：\n\n\n\n\nRouter#\n\nRouter组件主要做的是通过BrowserRouter传过来的当前值，通过props传进来的path与context传进来的pathname进行匹配，然后决定\n是否执行渲染组件\n\n\n\n\n参考文献#\n\n * https://juejin.cn/post/6870376090297171975#heading-9\n\n * https://segmentfault.com/a/1190000023560665","routePath":"/interview/React/React_Router_model","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用","id":"二使用","depth":2,"charIndex":260},{"text":"三、实现原理","id":"三实现原理","depth":2,"charIndex":377},{"text":"HashRouter","id":"hashrouter","depth":2,"charIndex":654},{"text":"Router","id":"router","depth":3,"charIndex":795},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":898}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React Router 有几种模式？实现原理？","footer":"说说 React Router 有几种模式？实现原理？","order":15,"star":15,"date":"2023-04-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React Router 有几种模式？实现原理？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React Router 有几种模式？实现原理？"}]]},"version":""},{"id":66,"title":"说说对 React refs 的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\nRefs 在计算机中称为弹性文件系统（英语：Resilient File System，简称 ReFS）\n\nReact 中的 Refs提供了一种方式，允许我们访问 DOM节点或在 render方法中创建的 React元素\n\n本质为ReactDOM.render()返回的组件实例，如果是渲染组件则返回的是组件实例，如果渲染dom则返回的是具体的dom节点\n\n\n二、如何使用#\n\n创建ref的形式有三种：\n\n * 传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素\n * 传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 current 属性就是对应的元素\n * 传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个 元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可\n * 传入 hook，hook 是通过 useRef() 方式创建，使用时通过生成 hook 对象的 current 属性就是对应的元素\n\n\n传入字符串#\n\n只需要在对应元素或组件中ref属性\n\n\n\n访问当前节点的方式如下：\n\n\n\n\n传入对象#\n\nrefs通过React.createRef()创建，然后将ref属性添加到React元素中，如下：\n\n\n\n当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中访问\n\n\n\n\n传入函数#\n\n当ref传入为一个函数的时候，在渲染过程中，回调函数参数会传入一个元素对象，然后通过实例将对象进行保存\n\n\n\n获取ref对象只需要通过先前存储的对象即可\n\n\n\n\n传入 hook#\n\n通过useRef创建一个ref，整体使用方式与React.createRef一致\n\n\n\n获取ref属性也是通过hook对象的current属性\n\n\n\n上述三种情况都是ref属性用于原生HTML元素上，如果ref设置的组件为一个类组件的时候，ref对象接收到的是组件的挂载实例\n\n注意的是，不能在函数组件上使用ref属性，因为他们并没有实例\n\n\n三、应用场景#\n\n在某些情况下，我们会通过使用refs来更新组件，但这种方式并不推荐，更多情况我们是通过props与state的方式进行去重新渲染子元素\n\n过多使用refs，会使组件的实例或者是DOM结构暴露，违反组件封装的原则\n\n例如，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性\n\n但下面的场景使用refs非常有用：\n\n * 对 Dom 元素的焦点控制、内容选择、控制\n * 对 Dom 元素的内容设置及媒体播放\n * 对 Dom 元素的操作和对组件实例的操作\n * 集成第三方 DOM 库\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/refs-and-the-dom.html\n * https://segmentfault.com/a/1190000020842342","routePath":"/interview/React/React_refs","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何使用","id":"二如何使用","depth":2,"charIndex":193},{"text":"传入字符串","id":"传入字符串","depth":3,"charIndex":470},{"text":"传入对象","id":"传入对象","depth":3,"charIndex":516},{"text":"传入函数","id":"传入函数","depth":3,"charIndex":635},{"text":"传入 hook","id":"传入-hook","depth":3,"charIndex":723},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":905},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1184}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 React refs 的理解？应用场景？","footer":"说说对 React refs 的理解？应用场景？","order":28,"star":28,"date":"2023-04-15T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 React refs 的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 React refs 的理解？应用场景？"}]]},"version":""},{"id":67,"title":"说说 Real DOM 和 Virtual DOM 的区别？优缺点？","content":"#\n\n\n\n\n一、是什么#\n\nReal DOM，真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM 结构，如下：\n\n\n\nVirtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述\n\n创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应\n\n在 React 中，JSX 是其一大特性，可以让你在 JS 中通过使用 XML 的方式去直接声明界面的 DOM 结构\n\n\n\n上述中，ReactDOM.render() 用于将你创建好的虚拟 DOM 节点插入到某个真实节点上，并渲染到页面上\n\nJSX 实际是一种语法糖，在使用过程中会被 babel 进行编译转化成 JS 代码，上述 VDOM 转化为如下：\n\n\n\n可以看到，JSX 就是为了简化直接调用 React.createElement() 方法：\n\n * 第一个参数是标签名，例如 h1、span、table...\n\n * 第二个参数是个对象，里面存着标签的一些属性，例如 id、class 等\n\n * 第三个参数是节点中的文本\n\n通过 console.log(VDOM)，则能够得到虚拟 VDOM 消息\n\n\n\n所以可以得到，JSX 通过 babel 的方式转化成 React.createElement 执行，返回值是一个对象，也就是虚拟 DOM\n\n\n二、区别#\n\n两者的区别如下：\n\n * 虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘\n * 虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”\n\n拿以前文章举过的例子：\n\n传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程\n\n当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9\n次更新操作，因此会马上执行流程，最终执行 10 次流程\n\n而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js\n对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算\n\n\n三、优缺点#\n\n真实 DOM 的优势：\n\n * 易用\n\n缺点：\n\n * 效率低，解析速度慢，内存占用量过高\n * 性能差：频繁操作真实 DOM，易于导致重绘与回流\n\n使用虚拟 DOM 的优势如下：\n\n * 简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难\n\n * 性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能\n\n * 跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行\n\n缺点：\n\n * 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化\n * 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢\n\n\n参考文献#\n\n * https://juejin.cn/post/6844904052971536391\n * https://www.html.cn/qa/other/22832.html","routePath":"/interview/React/Real_DOM_Virtual DOM","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、区别","id":"二区别","depth":2,"charIndex":622},{"text":"三、优缺点","id":"三优缺点","depth":2,"charIndex":1043},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1383}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Real DOM 和 Virtual DOM 的区别？优缺点？","footer":"说说 Real DOM 和 Virtual DOM 的区别？优缺点？","order":9,"star":9,"date":"2023-03-20T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 Real DOM 和 Virtual DOM 的区别？优缺点？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Real DOM 和 Virtual DOM 的区别？优缺点？"}]]},"version":""},{"id":68,"title":"说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？","content":"#\n\n\n\n\n一、是什么#\n\n中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到\n资源共享、功能共享的目的\n\n在上篇文章中，了解到了Redux整个工作流程，当action发出之后，reducer立即算出state，整个过程是一个同步的操作\n\n那么如果需要支持异步操作，或者支持错误处理、日志监控，这个过程就可以用上中间件\n\nRedux中，中间件就是放在就是在dispatch过程，在分发action进行拦截处理，如下图：\n\n\n\n其本质上一个函数，对store.dispatch方法进行了改造，在发出 Action和执行 Reducer这两步之间，添加了其他功能\n\n\n二、常用的中间件#\n\n有很多优秀的redux中间件，如：\n\n * redux-thunk：用于异步操作\n * redux-logger：用于日志记录\n\n上述的中间件都需要通过applyMiddlewares进行注册，作用是将所有的中间件组成一个数组，依次执行\n\n然后作为第二个参数传入到createStore中\n\n\n\n\nredux-thunk#\n\nredux-thunk是官网推荐的异步处理中间件\n\n默认情况下的dispatch(action)，action需要是一个JavaScript的对象\n\nredux-thunk中间件会判断你当前传进来的数据类型，如果是一个函数，将会给函数传入参数值（dispatch，getState）\n\n * dispatch 函数用于我们之后再次派发 action\n * getState 函数考虑到我们之后的一些操作需要依赖原来的状态，用于让我们可以获取之前的一些状态\n\n所以dispatch可以写成下述函数的形式：\n\n\n\n\nredux-logger#\n\n如果想要实现一个日志功能，则可以使用现成的redux-logger\n\n\n\n这样我们就能简单通过中间件函数实现日志记录的信息\n\n\n三、实现原理#\n\n首先看看applyMiddlewares的源码\n\n\n\n所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getSta\nte和dispatch这两个方法\n\n在上面的学习中，我们了解到了redux-thunk的基本使用\n\n内部会将dispatch进行一个判断，然后执行对应操作，原理如下：\n\n\n\n实现一个日志输出的原理也非常简单，如下：\n\n\n\n\n参考文献#\n\n * http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operatio\n   ns.html","routePath":"/interview/React/Redux_Middleware","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、常用的中间件","id":"二常用的中间件","depth":2,"charIndex":336},{"text":"redux-thunk","id":"redux-thunk","depth":3,"charIndex":496},{"text":"redux-logger","id":"redux-logger","depth":3,"charIndex":766},{"text":"三、实现原理","id":"三实现原理","depth":2,"charIndex":845},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1074}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？","order":6,"star":6,"date":"2023-03-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？"}]]},"version":""},{"id":69,"title":"说说 React 的事件机制？","content":"#\n\n\n\n\n一、是什么#\n\nReact基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等\n\n在React中这套事件机制被称之为合成事件\n\n合成事件（SyntheticEvent）#\n\n合成事件是 React模拟原生 DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器\n\n根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：\n\n\n\n如果想要获得原生DOM事件，可以通过e.nativeEvent属性获取\n\n\n\n从上面可以看到React事件和原生事件也非常的相似，但也有一定的区别：\n\n * 事件名称命名方式不同\n\n\n\n * 事件处理函数书写不同\n\n\n\n虽然onclick看似绑定到DOM元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听\n\n这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象\n\n当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升\n\n\n二、执行顺序#\n\n关于React合成事件与原生事件执行顺序，可以看看下面一个例子：\n\n\n\n输出顺序为：\n\n\n\n可以得出以下结论：\n\n * React 所有事件都挂载在 document 对象上\n * 当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件\n * 所以会先执行原生事件，然后处理 React 事件\n * 最后真正执行 document 上挂载的事件\n\n对应过程如图所示：\n\n\n\n所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：\n\n * 阻止合成事件间的冒泡，用 e.stopPropagation()\n\n * 阻止合成事件与最外层 document 上的事件间的冒泡，用 e.nativeEvent.stopImmediatePropagation()\n\n * 阻止合成事件与除最外层 document 上的原生事件上的冒泡，通过判断 e.target 来避免\n\n\n\n\n三、总结#\n\nReact事件机制总结如下：\n\n * React 上注册的事件最终会绑定在 document 这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在\n   document 上，其他节点没有绑定事件)\n * React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。\n * React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback\n * React 有一套自己的合成事件 SyntheticEvent\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/events.html\n * https://segmentfault.com/a/1190000015725214?utm_source=sf-similar-article\n * https://segmentfault.com/a/1190000038251163","routePath":"/interview/React/SyntheticEvent","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"合成事件（SyntheticEvent）","id":"合成事件syntheticevent","depth":4,"charIndex":88},{"text":"二、执行顺序","id":"二执行顺序","depth":2,"charIndex":538},{"text":"三、总结","id":"三总结","depth":2,"charIndex":956},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1242}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React 的事件机制？","footer":"说说 React 的事件机制？","order":13,"star":13,"date":"2023-03-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React 的事件机制？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React 的事件机制？"}]]},"version":""},{"id":70,"title":"在 react 中组件间过渡动画如何实现？","content":"#\n\n\n\n\n一、是什么#\n\n在日常开发中，页面切换时的转场动画是比较基础的一个场景\n\n当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验\n\n在react中实现过渡动画效果会有很多种选择，如react-transition-group，react-motion，Animated，以及原生的CSS都能完\n成切换动画\n\n\n二、如何实现#\n\n在react中，react-transition-group是一种很好的解决方案，其为元素添加enter，enter-active，exit，exit-acti\nve这一系列勾子\n\n可以帮助我们方便的实现组件的入场和离场动画\n\n其主要提供了三个主要的组件：\n\n * CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果\n * SwitchTransition：两个组件显示和隐藏切换时，使用该组件\n * TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画\n\n\nCSSTransition#\n\n其实现动画的原理在于，当CSSTransition的in属性置为true时，CSSTransition首先会给其子组件加上xxx-enter、xxx-enter\n-active的class执行动画\n\n当动画执行结束后，会移除两个class，并且添加-enter-done的class\n\n所以可以利用这一点，通过css的transition属性，让元素在两个状态之间平滑过渡，从而得到相应的动画效果\n\n当in属性置为false时，CSSTransition会给子组件加上xxx-exit和xxx-exit-active的class，然后开始执行动画，当动画结束后\n，移除两个class，然后添加-enter-done的class\n\n如下例子：\n\n\n\n对应css样式如下：\n\n\n\n\nSwitchTransition#\n\nSwitchTransition可以完成两个组件之间切换的炫酷动画\n\n比如有一个按钮需要在on和off之间切换，我们希望看到on先从左侧退出，off再从右侧进入\n\nSwitchTransition中主要有一个属性mode，对应两个值：\n\n * in-out：表示新组件先进入，旧组件再移除；\n * out-in：表示就组件先移除，新组建再进入\n\nSwitchTransition组件里面要有CSSTransition，不能直接包裹你想要切换的组件\n\n里面的CSSTransition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是key属性\n\n下面给出一个按钮入场和出场的示例，如下：\n\n\n\ncss文件对应如下：\n\n\n\n\nTransitionGroup#\n\n当有一组动画的时候，就可将这些CSSTransition放入到一个TransitionGroup中来完成动画\n\n同样CSSTransition里面没有in属性，用到了key属性\n\nTransitionGroup在感知children发生变化的时候，先保存移除的节点，当动画结束后才真正移除\n\n其处理方式如下：\n\n * 插入的节点，先渲染 dom，然后再做动画\n\n * 删除的节点，先做动画，然后再删除 dom\n\n如下：\n\n\n\n对应css如下：\n\n\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000018861018\n * https://mp.weixin.qq.com/s/14HneI7SpfrRHKtqgosIiA","routePath":"/interview/React/animation","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":166},{"text":"CSSTransition","id":"csstransition","depth":3,"charIndex":432},{"text":"SwitchTransition","id":"switchtransition","depth":3,"charIndex":787},{"text":"TransitionGroup","id":"transitiongroup","depth":3,"charIndex":1125},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1369}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-在 react 中组件间过渡动画如何实现？","footer":"在 react 中组件间过渡动画如何实现？","order":33,"star":33,"date":"2023-05-23T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-在 react 中组件间过渡动画如何实现？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"在 react 中组件间过渡动画如何实现？"}]]},"version":""},{"id":71,"title":"说说你在 React 项目是如何捕获错误的？","content":"#\n\n\n\n\n一、是什么#\n\n错误在我们日常编写代码是非常常见的\n\n举个例子，在react项目中去编写组件内JavaScript代码错误会导致 React 的内部状态被破坏，导致整个应用崩溃，这是不应该出现的现象\n\n作为一个框架，react也有自身对于错误的处理的解决方案\n\n\n二、如何做#\n\n为了解决出现的错误导致整个应用崩溃的问题，react16引用了错误边界新的概念\n\n错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级\nUI，而并不会渲染那些发生崩溃的子组件树\n\n错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误\n\n形成错误边界组件的两个条件：\n\n * 使用了 static getDerivedStateFromError()\n * 使用了 componentDidCatch()\n\n抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch()\n打印错误信息，如下：\n\n\n\n然后就可以把自身组件的作为错误边界的子组件，如下：\n\n\n\n下面这些情况无法捕获到异常：\n\n * 事件处理\n * 异步代码\n * 服务端渲染\n * 自身抛出来的错误\n\n在react 16版本之后，会把渲染期间发生的所有错误打印到控制台\n\n除了错误信息和 JavaScript 栈外，React 16 还提供了组件栈追踪。现在你可以准确地查看发生在组件树内的错误信息：\n\n\n\n可以看到在错误信息下方文字中存在一个组件栈，便于我们追踪错误\n\n对于错误边界无法捕获的异常，如事件处理过程中发生问题并不会捕获到，是因为其不会在渲染期间触发，并不会导致渲染时候问题\n\n这种情况可以使用js的try...catch...语法，如下：\n\n\n\n除此之外还可以通过监听onerror事件\n\n\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/error-boundaries.html","routePath":"/interview/React/capture_error","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":137},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":823}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你在 React 项目是如何捕获错误的？","footer":"说说你在 React 项目是如何捕获错误的？","order":27,"star":27,"date":"2023-04-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你在 React 项目是如何捕获错误的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你在 React 项目是如何捕获错误的？"}]]},"version":""},{"id":72,"title":"说说对 React 中类组件和函数组件的理解？有什么区别？","content":"#\n\n\n\n\n一、类组件#\n\n类组件，顾名思义，也就是通过使用ES6类的编写形式去编写组件，该类必须继承React.Component\n\n如果想要访问父组件传递过来的参数，可通过this.props的方式去访问\n\n在组件中必须实现render方法，在return中返回React对象，如下：\n\n\n\n\n二、函数组件#\n\n函数组件，顾名思义，就是通过函数编写的形式去实现一个React组件，是React中定义组件最简单的方式\n\n\n\n函数第一个参数为props用于接收父组件传递过来的参数\n\n\n三、区别#\n\n针对两种React组件，其区别主要分成以下几大方向：\n\n * 编写形式\n\n * 状态管理\n\n * 生命周期\n\n * 调用方式\n\n * 获取渲染的值\n\n\n编写形式#\n\n两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式\n\n函数组件：\n\n\n\n类组件：\n\n\n\n\n状态管理#\n\n在hooks出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用setState\n\n如果想要管理state状态，可以使用useState，如下：\n\n\n\n在使用hooks情况下，一般如果函数组件调用state，则需要创建一个类组件或者state提升到你的父组件中，然后通过props对象传递到子组件\n\n\n生命周期#\n\n在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的React.Component\n\n所以，如果用到生命周期，就只能使用类组件\n\n但是函数组件使用useEffect也能够完成替代生命周期的作用，这里给出一个简单的例子：\n\n\n\n上述简单的例子对应类组件中的componentDidMount生命周期\n\n如果在useEffect回调函数中return一个函数，则return函数会在组件卸载的时候执行，正如componentWillUnmount\n\n\n\n\n调用方式#\n\n如果是一个函数组件，调用则是执行函数即可：\n\n\n\n如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的render方法：\n\n\n\n\n获取渲染的值#\n\n首先给出一个示例\n\n函数组件对应如下：\n\n\n\n类组件对应如下：\n\n\n\n两者看起来实现功能是一致的，但是在类组件中，输出this.props.user，Props在 React中是不可变的所以它永远不会改变，但是 this\n总是可变的，以便您可以在 render 和生命周期函数中读取新版本\n\n因此，如果我们的组件在请求运行时更新。this.props 将会改变。showMessage方法从“最新”的 props 中读取 user\n\n而函数组件，本身就不存在this，props并不发生改变，因此同样是点击，alert的内容仍旧是之前的内容\n\n\n小结#\n\n两种组件都有各自的优缺点\n\n函数组件语法更短、更简单，这使得它更容易开发、理解和测试\n\n而类组件也会因大量使用 this而让人感到困惑\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/components-and-props.html#function-and-class\n   -components\n * https://juejin.cn/post/6844903806140973069","routePath":"/interview/React/class_function_component","lang":"","toc":[{"text":"一、类组件","id":"一类组件","depth":2,"charIndex":5},{"text":"二、函数组件","id":"二函数组件","depth":2,"charIndex":148},{"text":"三、区别","id":"三区别","depth":2,"charIndex":242},{"text":"编写形式","id":"编写形式","depth":3,"charIndex":325},{"text":"状态管理","id":"状态管理","depth":3,"charIndex":397},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":564},{"text":"调用方式","id":"调用方式","depth":3,"charIndex":806},{"text":"获取渲染的值","id":"获取渲染的值","depth":3,"charIndex":882},{"text":"小结","id":"小结","depth":3,"charIndex":1164},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1239}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 React 中类组件和函数组件的理解？有什么区别？","footer":"说说对 React 中类组件和函数组件的理解？有什么区别？","order":17,"star":17,"date":"2023-04-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对 React 中类组件和函数组件的理解？有什么区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 React 中类组件和函数组件的理解？有什么区别？"}]]},"version":""},{"id":73,"title":"React 中组件之间如何通信？","content":"#\n\n\n\n\n一、是什么#\n\n我们将组件间通信可以拆分为两个词：\n\n * 组件\n * 通信\n\n回顾Vue 系列的文章，组件是vue中最强大的功能之一，同样组件化是React的核心思想\n\n相比vue，React的组件更加灵活和多样，按照不同的方式可以分成很多类型的组件\n\n而通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的，广义上，任何信息的交通都是通信\n\n组件间通信即指组件通过某种方式来传递信息以达到某个目的\n\n\n二、如何通信#\n\n组件传递的方式有很多种，根据传送者和接收者可以分为如下：\n\n * 父组件向子组件传递\n * 子组件向父组件传递\n * 兄弟组件之间的通信\n * 父组件向后代组件传递\n * 非关系组件传递\n\n\n父组件向子组件传递#\n\n由于React的数据流动为单向的，父组件向子组件传递是最常见的方式\n\n父组件在调用子组件的时候，只需要在子组件标签内传递参数，子组件通过props属性就能接收父组件传递过来的参数\n\n\n\n\n子组件向父组件传递#\n\n子组件向父组件通信的基本思路是，父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值\n\n父组件对应代码如下：\n\n\n\n子组件对应代码如下：\n\n\n\n\n兄弟组件之间的通信#\n\n如果是兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递\n\n\n\n\n父组件向后代组件传递#\n\n父组件向后代组件传递数据是一件最普通的事情，就像全局数据一样\n\n使用context提供了组件之间通讯的一种方式，可以共享数据，其他数据都能读取对应的数据\n\n通过使用React.createContext创建一个context\n\n\n\ncontext创建成功后，其下存在Provider组件用于创建数据源，Consumer组件用于接收数据，使用实例如下：\n\nProvider组件通过value属性用于给后代组件传递数据：\n\n\n\n如果想要获取Provider传递的数据，可以通过Consumer组件或者或者使用contextType属性接收，对应分别如下：\n\n\n\nConsumer组件：\n\n\n\n\n非关系组件传递#\n\n如果组件之间关系类型比较复杂的情况，建议将数据进行一个全局资源管理，从而实现通信，例如redux。关于redux的使用后续再详细介绍\n\n\n三、总结#\n\n由于React是单向数据流，主要思想是组件不会改变接收的数据，只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值\n\n因此，可以看到通信过程中，数据的存储位置都是存放在上级位置中\n\n\n参考文献#\n\n * https://react.docschina.org/docs/context.html","routePath":"/interview/React/communication","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何通信","id":"二如何通信","depth":2,"charIndex":217},{"text":"父组件向子组件传递","id":"父组件向子组件传递","depth":3,"charIndex":322},{"text":"子组件向父组件传递","id":"子组件向父组件传递","depth":3,"charIndex":428},{"text":"兄弟组件之间的通信","id":"兄弟组件之间的通信","depth":3,"charIndex":522},{"text":"父组件向后代组件传递","id":"父组件向后代组件传递","depth":3,"charIndex":579},{"text":"非关系组件传递","id":"非关系组件传递","depth":3,"charIndex":887},{"text":"三、总结","id":"三总结","depth":2,"charIndex":966},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1079}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-React 中组件之间如何通信？","footer":"React 中组件之间如何通信？","order":11,"star":11,"date":"2023-03-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-React 中组件之间如何通信？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"React 中组件之间如何通信？"}]]},"version":""},{"id":74,"title":"说说对受控组件和非受控组件的理解？应用场景？","content":"#\n\n\n\n\n一、受控组件#\n\n受控组件，简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据\n\n举个简单的例子：\n\n\n\n这时候当我们在输入框输入内容的时候，会发现输入的内容并无法显示出来，也就是input标签是一个可读的状态\n\n这是因为value被this.state.username所控制住。当用户输入新的内容时，this.state.username并不会自动更新，这样的话inpu\nt内的内容也就不会变了\n\n如果想要解除被控制，可以为input标签设置onChange事件，输入的时候触发事件函数，在函数内部实现state的更新，从而导致input框的内容页发现改变\n\n因此，受控组件我们一般需要初始状态和一个状态更新事件函数\n\n\n二、非受控组件#\n\n非受控组件，简单来讲，就是不受我们控制的组件\n\n一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态\n\n当需要时，可以使用ref 查询 DOM并查找其当前值，如下：\n\n\n\n关于refs的详情使用可以参考之前文章\n\n\n三、应用场景#\n\n大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由React组件负责处理\n\n如果选择非受控组件的话，控制能力较弱，表单数据就由DOM本身处理，但更加方便快捷，代码量少\n\n针对两者的区别，其应用场景如下图所示：\n\n\n\n\n参考文献#\n\n * http://meloguo.com/2018/10/08/受控与非受控组件/\n * https://zhuanlan.zhihu.com/p/37579677","routePath":"/interview/React/controlled_Uncontrolled","lang":"","toc":[{"text":"一、受控组件","id":"一受控组件","depth":2,"charIndex":5},{"text":"二、非受控组件","id":"二非受控组件","depth":2,"charIndex":322},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":447},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":573}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对受控组件和非受控组件的理解？应用场景？","footer":"说说对受控组件和非受控组件的理解？应用场景？","order":20,"star":20,"date":"2023-04-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说对受控组件和非受控组件的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对受控组件和非受控组件的理解？应用场景？"}]]},"version":""},{"id":75,"title":"说说 React diff 的原理是什么？","content":"#\n\n\n\n\n一、是什么#\n\n跟Vue一致，React通过引入Virtual DOM的概念，极大地避免无效的Dom操作，使我们的页面的构建效率提到了极大的提升\n\n而diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处\n\n传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到\nO(n^3)，react将算法进行一个优化，复杂度姜维O(n)，两者效率差距如下图：\n\n\n\n\n二、原理#\n\nreact中diff算法主要遵循三个层级的策略：\n\n * tree 层级\n\n * conponent 层级\n\n * element 层级\n\n\ntree 层级#\n\nDOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较\n\n\n\n只有删除、创建操作，没有移动操作，如下图：\n\n\n\nreact发现新树中，R 节点下没有了 A，那么直接删除 A，在 D 节点下创建 A 以及下属节点\n\n上述操作中，只有删除和创建操作\n\n\nconponent 层级#\n\n如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的\n\n\n\n当component D换成了component G 后，即使两者的结构非常类似，也会将D删除再重新创建G\n\n\nelement 层级#\n\n对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识\n\n提供了 3 种节点操作，分别为 INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)\n\n如下场景：\n\n\n\n通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置\n\n流程如下表：\n\n\n\n * index： 新集合的遍历下标。\n * oldIndex：当前节点在老集合中的下标\n * maxIndex：在新集合访问过的节点中，其在老集合的最大下标\n\n如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动\n\n操作过程中只比较 oldIndex 和 maxIndex，规则如下：\n\n * 当 oldIndex>maxIndex 时，将 oldIndex 的值赋值给 maxIndex\n * 当 oldIndex=maxIndex 时，不操作\n * 当 oldIndex\n\ndiff过程如下：\n\n * 节点 B：此时 maxIndex=0，oldIndex=1；满足 maxIndex< oldIndex，因此 B 节点不动，此时 maxIndex=\n   Math.max(oldIndex, maxIndex)，就是 1\n * 节点 A：此时 maxIndex=1，oldIndex=0；不满足 maxIndex< oldIndex，因此 A 节点进行移动操作，此时\n   maxIndex= Math.max(oldIndex, maxIndex)，还是 1\n * 节点 D：此时 maxIndex=1, oldIndex=3；满足 maxIndex< oldIndex，因此 D 节点不动，此时 maxIndex=\n   Math.max(oldIndex, maxIndex)，就是 3\n * 节点 C：此时 maxIndex=3，oldIndex=2；不满足 maxIndex< oldIndex，因此 C 节点进行移动操作，当前已经比较完了\n\n当 ABCD 节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除\n\n\n三、注意事项#\n\n对于简单列表渲染而言，不使用key比使用key的性能，例如：\n\n将一个[1,2,3,4,5]，渲染成如下的样子：\n\n\n\n后续更改成[1,3,2,5,4]，使用key与不使用key作用如下：\n\n\n\n如果我们对这个集合进行增删的操作改成[1,3,2,5,6]\n\n\n\n由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/140489744\n\n * https://zhuanlan.zhihu.com/p/20346379","routePath":"/interview/React/diff","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、原理","id":"二原理","depth":2,"charIndex":210},{"text":"tree 层级","id":"tree-层级","depth":3,"charIndex":288},{"text":"conponent 层级","id":"conponent-层级","depth":3,"charIndex":426},{"text":"element 层级","id":"element-层级","depth":3,"charIndex":558},{"text":"三、注意事项","id":"三注意事项","depth":2,"charIndex":1539},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1723}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React diff 的原理是什么？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 React diff 的原理是什么？","order":5,"star":5,"date":"2023-03-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React diff 的原理是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React diff 的原理是什么？"}]]},"version":""},{"id":76,"title":"你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？","content":"#\n\n\n\n\n一、背景#\n\n在前面文章了解中，我们了解到redux是用于数据状态管理，而react是一个视图层面的库\n\n如果将两者连接在一起，可以使用官方推荐react-redux库，其具有高效且灵活的特性\n\nreact-redux将组件分成：\n\n * 容器组件：存在逻辑处理\n * UI 组件：只负责现显示和交互，内部不处理逻辑，状态由外部控制\n\n通过redux将整个应用状态存储到store中，组件可以派发dispatch行为action给store\n\n其他组件通过订阅store中的状态state来更新自身的视图\n\n\n二、如何做#\n\n使用react-redux分成了两大核心：\n\n * Provider\n * connection\n\n\nProvider#\n\n在redux中存在一个store用于存储state，如果将这个store存放在顶层元素中，其他组件都被包裹在顶层元素之上\n\n那么所有的组件都能够受到redux的控制，都能够获取到redux中的数据\n\n使用方式如下：\n\n\n\n\nconnection#\n\nconnect方法将store上的getState和 dispatch包装成组件的props\n\n导入conect如下：\n\n\n\n用法如下：\n\n\n\n可以传递两个参数：\n\n * mapStateToProps\n\n * mapDispatchToProps\n\n\nmapStateToProps#\n\n把redux中的数据映射到react中的props中去\n\n如下：\n\n\n\n组件内部就能够通过props获取到store中的数据\n\n\n\n\nmapDispatchToProps#\n\n将redux中的dispatch映射到组件内部的props中\n\n\n\n\n\n\n小结#\n\n整体流程图大致如下所示：\n\n\n\n\n三、项目结构#\n\n可以根据项目具体情况进行选择，以下列出两种常见的组织结构\n\n按角色组织（MVC）#\n\n角色如下：\n\n * reducers\n * actions\n * components\n * containers\n\n参考如下：\n\n\n\n按功能组织#\n\n使用redux使用功能组织项目，也就是把完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码\n\nRedux中，不同的角色就是reducer、actions和视图，而应用功能对应的就是用户界面的交互模块\n\n参考如下：\n\n\n\n每个功能模块对应一个目录，每个目录下包含同样的角色文件：\n\n * actionTypes.js 定义 action 类型\n * actions.js 定义 action 构造函数\n * reducer.js 定义这个功能模块如果响应 actions.js 定义的动作\n * views 包含功能模块中所有的 React 组件，包括展示组件和容器组件\n * index.js 把所有的角色导入，统一导出\n\n其中index模块用于导出对外的接口\n\n\n\n导入方法如下：\n\n\n\n\n参考文献#\n\n * https://www.redux.org.cn/docs/basics/UsageWithReact.html\n * https://segmentfault.com/a/1190000010384268","routePath":"/interview/React/how_to_use_redux","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":260},{"text":"Provider","id":"provider","depth":3,"charIndex":319},{"text":"connection","id":"connection","depth":3,"charIndex":442},{"text":"mapStateToProps","id":"mapstatetoprops","depth":3,"charIndex":582},{"text":"mapDispatchToProps","id":"mapdispatchtoprops","depth":3,"charIndex":667},{"text":"小结","id":"小结","depth":3,"charIndex":725},{"text":"三、项目结构","id":"三项目结构","depth":2,"charIndex":747},{"text":"按角色组织（MVC）","id":"按角色组织mvc","depth":4,"charIndex":786},{"text":"按功能组织","id":"按功能组织","depth":4,"charIndex":867},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1230}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？","order":1,"star":1,"date":"2023-02-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？"}]]},"version":""},{"id":77,"title":"说说你对 immutable 的理解？如何应用在 react 项目中？","content":"#\n\n\n\n\n一、是什么#\n\nImmutable，不可改变的，在计算机中，即指一旦创建，就不能再被更改的数据\n\n对 Immutable对象的任何修改或添加删除操作都会返回一个新的 Immutable对象\n\nImmutable 实现的原理是 Persistent Data Structure（持久化数据结构）:\n\n * 用一种数据结构来保存数据\n * 当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费\n\n也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 deepCopy把所有节点都复制一遍带来的性能损耗，Immutable 使用了\nStructural Sharing（结构共享）\n\n如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享\n\n如下图所示：\n\n\n\n\n二、如何使用#\n\n使用Immutable对象最主要的库是immutable.js\n\nimmutable.js 是一个完全独立的库，无论基于什么框架都可以用它\n\n其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing 来解决的性能问题\n\n内部提供了一套完整的 Persistent Data\nStructure，还有很多易用的数据类型，如Collection、List、Map、Set、Record、Seq，其中：\n\n * List: 有序索引集，类似 JavaScript 中的 Array\n\n * Map: 无序索引集，类似 JavaScript 中的 Object\n\n * Set: 没有重复值的集合\n\n主要的方法如下：\n\n * fromJS()：将一个 js 数据转换为 Immutable 类型的数据\n\n\n\n * toJS()：将一个 Immutable 数据转换为 JS 类型的数据\n * is()：对两个对象进行比较\n\n\n\n * get(key)：对数据或对象取值\n\n * getIn([]) ：对嵌套对象或数组取值，传参为数组，表示位置\n\n\n\n * \n\n如下例子：使用方法如下：\n\n\n\n如果换到原生的js，则对应如下：\n\n\n\n\n三、在 React 中应用#\n\n使用 Immutable可以给 React 应用带来性能的优化，主要体现在减少渲染的次数\n\n在做react性能优化的时候，为了避免重复渲染，我们会在shouldComponentUpdate()中做对比，当返回true执行render方法\n\nImmutable通过is方法则可以完成对比，而无需像一样通过深度比较的方式比较\n\n在使用redux过程中也可以结合Immutable，不使用Immutable前修改一个数据需要做一个深拷贝\n\n\n\n使用 Immutable 后：\n\n\n\n同理，在redux中也可以将数据进行fromJS处理\n\n\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/20295971?spm=a2c4e.11153940.blogcont69516.18.4f2\n   75a00EzBHjr&columnSlug=purerender\n * https://www.jianshu.com/p/7bf04638e82a","routePath":"/interview/React/immutable","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何使用","id":"二如何使用","depth":2,"charIndex":378},{"text":"三、在 React 中应用","id":"三在-react-中应用","depth":2,"charIndex":927},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1213}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 immutable 的理解？如何应用在 react 项目中？","footer":"说说你对 immutable 的理解？如何应用在 react 项目中？","order":16,"star":16,"date":"2023-04-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你对 immutable 的理解？如何应用在 react 项目中？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 immutable 的理解？如何应用在 react 项目中？"}]]},"version":""},{"id":78,"title":"说说 react 中引入 css 的方式有哪几种？区别？","content":"#\n\n\n\n\n一、是什么#\n\n组件式开发选择合适的css解决方案尤为重要\n\n通常会遵循以下规则：\n\n * 可以编写局部 css，不会随意污染其他组件内的原生；\n * 可以编写动态的 css，可以获取当前组件的一些状态，根据状态的变化生成不同的 css 样式；\n * 支持所有的 css 特性：伪类、动画、媒体查询等；\n * 编写起来简洁方便、最好符合一贯的 css 风格特点\n\n在这一方面，vue使用css起来更为简洁：\n\n * 通过 style 标签编写样式\n * scoped 属性决定编写的样式是否局部有效\n * lang 属性设置预处理器\n * 内联样式风格的方式来根据最新状态设置和改变 css\n\n而在react中，引入CSS就不如Vue方便简洁，其引入css的方式有很多种，各有利弊\n\n\n二、方式#\n\n常见的CSS引入方式有以下：\n\n * 在组件内直接使用\n * 组件中引入 .css 文件\n * 组件中引入 .module.css 文件\n * CSS in JS\n\n\n在组件内直接使用#\n\n直接在组件中书写css样式，通过style属性直接引入，如下：\n\n\n\n上面可以看到，css属性需要转换成驼峰写法\n\n这种方式优点：\n\n * 内联样式, 样式之间不会有冲突\n * 可以动态获取当前 state 中的状态\n\n缺点：\n\n * 写法上都需要使用驼峰标识\n\n * 某些样式没有提示\n\n * 大量的样式, 代码混乱\n\n * 某些样式无法编写(比如伪类/伪元素)\n\n\n组件中引入 css 文件#\n\n将css单独写在一个css文件中，然后在组件中直接引入\n\nApp.css文件：\n\n\n\n组件中引入：\n\n\n\n这种方式存在不好的地方在于样式是全局生效，样式之间会互相影响\n\n\n组件中引入 .module.css 文件#\n\n将css文件作为一个模块引入，这个模块中的所有css，只作用于当前组件。不会影响当前组件的后代组件\n\n这种方式是webpack特工的方案，只需要配置webpack配置文件中modules:true即可\n\n\n\n这种方式能够解决局部作用域问题，但也有一定的缺陷：\n\n * 引用的类名，不能使用连接符(.xxx-xx)，在 JavaScript 中是不识别的\n * 所有的 className 都必须使用 {style.className} 的形式来编写\n * 不方便动态来修改某些样式，依然需要使用内联样式的方式；\n\n\nCSS in JS#\n\nCSS-in-JS， 是指一种模式，其中CSS由 JavaScript生成而不是在外部文件中定义\n\n此功能并不是 React 的一部分，而是由第三方库提供，例如：\n\n * styled-components\n * emotion\n * glamorous\n\n下面主要看看styled-components的基本使用\n\n本质是通过函数的调用，最终创建出一个组件：\n\n * 这个组件会被自动添加上一个不重复的 class\n * styled-components 会给该 class 添加相关的样式\n\n基本使用如下：\n\n创建一个style.js文件用于存放样式组件：\n\n\n\n引入样式组件也很简单：\n\n\n\n\n三、区别#\n\n通过上面四种样式的引入，可以看到：\n\n * 在组件内直接使用css该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱\n\n * 组件中引入 .css 文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠\n\n * 引入.module.css 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写\n\n * 通过 css in js 这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等\n\n至于使用react用哪种方案引入css，并没有一个绝对的答案，可以根据各自情况选择合适的方案\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/faq-styling.html#gatsby-focus-wrapper\n * https://mp.weixin.qq.com/s/oywTpNKEikMXn8QTBgITow","routePath":"/interview/React/import_css","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、方式","id":"二方式","depth":2,"charIndex":348},{"text":"在组件内直接使用","id":"在组件内直接使用","depth":3,"charIndex":439},{"text":"组件中引入 css 文件","id":"组件中引入-css-文件","depth":3,"charIndex":635},{"text":"组件中引入 .module.css 文件","id":"组件中引入-modulecss-文件","depth":3,"charIndex":736},{"text":"CSS in JS","id":"css-in-js","depth":3,"charIndex":1017},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1330},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1629}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 react 中引入 css 的方式有哪几种？区别？","footer":"说说 react 中引入 css 的方式有哪几种？区别？","order":8,"star":8,"date":"2023-03-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 react 中引入 css 的方式有哪几种？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 react 中引入 css 的方式有哪几种？区别？"}]]},"version":""},{"id":79,"title":"说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？","content":"#\n\n\n\n\n一、是什么#\n\nreact 基于虚拟 DOM 和高效 Diff算法的完美配合，实现了对 DOM最小粒度的更新，大多数情况下，React对 DOM的渲染效率足以我们的业务日常\n\n复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，避免不必要的渲染则是业务中常见的优化手段之一\n\n\n二、如何做#\n\n在之前文章中，我们了解到render的触发时机，简单来讲就是类组件通过调用setState方法，\n就会导致render，父组件一旦发生render渲染，子组件一定也会执行render渲染\n\n从上面可以看到，父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：\n\n * shouldComponentUpdate\n * PureComponent\n * React.memo\n\n\nshouldComponentUpdate#\n\n通过shouldComponentUpdate生命周期函数来比对 state和 props，确定是否要重新渲染\n\n默认情况下返回true表示重新渲染，如果不希望组件重新渲染，返回 false 即可\n\n\nPureComponent#\n\n跟shouldComponentUpdate原理基本一致，通过对 props 和 state的浅比较结果来实现\nshouldComponentUpdate，源码大致如下：\n\n\n\nshallowEqual对应方法大致如下：\n\n\n\n当对象包含复杂的数据结构时，对象深层的数据已改变却没有触发 render\n\n注意：在react中，是不建议使用深层次结构的数据\n\n\nReact.memo#\n\nReact.memo用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似。但不同的是， React.memo\n只能用于函数组件\n\n\n\n如果需要深层次比较，这时候可以给memo第二个参数传递比较函数\n\n\n\n\n三、总结#\n\n在实际开发过程中，前端性能问题是一个必须考虑的问题，随着业务的复杂，遇到性能问题的概率也在增高\n\n除此之外，建议将页面进行更小的颗粒化，如果一个过大，当状态发生修改的时候，就会导致整个大组件的渲染，而对组件进行拆分后，粒度变小了，也能够减少子组件不必要的渲染\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903781679759367#heading-12","routePath":"/interview/React/improve_render","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":156},{"text":"shouldComponentUpdate","id":"shouldcomponentupdate","depth":3,"charIndex":379},{"text":"PureComponent","id":"purecomponent","depth":3,"charIndex":504},{"text":"React.memo","id":"reactmemo","depth":3,"charIndex":700},{"text":"三、总结","id":"三总结","depth":2,"charIndex":840},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":979}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？","footer":"说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？","order":30,"star":30,"date":"2023-04-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？"}]]},"version":""},{"id":80,"title":"前端物语|面试物语-React","content":" * React 事件绑定的方式有哪些？区别？\n * React 构建组件的方式有哪些？区别？\n * 说说对 Fiber 架构的理解？解决了什么问题？\n * 说说对高阶组件的理解？应用场景?\n * 说说 React 性能优化的手段有哪些？\n * 说说 React Jsx 转换成真实 DOM 过程？\n * 说说对 React 的理解？有哪些特性？\n * 说说对 React Hooks 的理解？解决了什么问题？\n * 说说你对 React Router 的理解？常用的 Router 组件有哪些？\n * 说说 React Router 有几种模式？实现原理？\n * 说说对 React refs 的理解？应用场景？\n * [ 说说 Real DOM 和 Virtual DOM\n   的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM)\n * 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？\n * 说说 React 的事件机制？\n * 在 react 中组件间过渡动画如何实现？\n * 说说你在 React 项目是如何捕获错误的？\n * 说说对 React 中类组件和函数组件的理解？有什么区别？\n * React 中组件之间如何通信？\n * 说说对受控组件和非受控组件的理解？应用场景？\n * 说说 React diff 的原理是什么？\n * 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？\n * 说说你对 immutable 的理解？如何应用在 react 项目中？\n * 说说 react 中引入 css 的方式有哪几种？区别？\n * 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？\n * React 中的 key 有什么作用？\n * 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？\n * 说说你对 Redux 的理解？其工作原理？\n * 说说 React render 方法的原理？在什么时候会被触发？\n * 说说 React 服务端渲染怎么做？原理是什么？\n * 说说 React 中的 setState 执行机制\n * state 和 props 有什么区别？\n * 说说你在使用 React 过程中遇到的常见问题？如何解决?\n * super() 和 super(props) 有什么区别？","routePath":"/interview/React/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"React","tag":"React","title":"前端物语|面试物语-React","index":false,"dir":{"order":1},"date":"2023-05-23T00:00:00.000Z"},"version":""},{"id":81,"title":"React 中的 key 有什么作用？","content":"#\n\n\n\n\n一、是什么#\n\n首先，先给出react组件中进行列表渲染的一个示例：\n\n\n\n然后在输出就可以看到react所提示的警告信息：\n\n\n\n根据意思就可以得到渲染列表的每一个子元素都应该需要一个唯一的key值\n\n在这里可以使用列表的id属性作为key值以解决上面这个警告\n\n\n\n\n二、作用#\n\n跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染\n\n因此key的值需要为每一个元素赋予一个确定的标识\n\n如果列表数据渲染中，在数据后面插入一条数据，key作用并不大，如下：\n\n\n\n前面的元素在diff算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的DOM树中\n\n因此，在这种情况下，元素有无key属性意义并不大\n\n下面再来看看在前面插入数据时，使用key与不使用key的区别：\n\n\n\n当拥有key的时候，react根据key属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将 000 元素插入到最前面位置\n\n当没有key的时候，所有的li标签都需要进行修改\n\n同样，并不是拥有key值代表性能越高，如果说只是文本内容改变了，不写key反而性能和效率更高\n\n主要是因为不写key是将所有的文本内容替换一下，节点不会发生变化\n\n而写key则涉及到了节点的增和删，发现旧key不存在了，则将其删除，新key在之前没有，则插入，这就增加性能的开销\n\n\n三、总结#\n\n良好使用key属性是性能优化的非常关键的一步，注意事项为：\n\n * key 应该是唯一的\n\n * key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）\n\n * 使用 index 作为 key 值，对性能没有优化\n\nreact判断key的流程具体如下图：\n\n\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper\n * https://segmentfault.com/a/1190000017511836","routePath":"/interview/React/key","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、作用","id":"二作用","depth":2,"charIndex":141},{"text":"三、总结","id":"三总结","depth":2,"charIndex":646},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":797}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-React 中的 key 有什么作用？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>React 中的 key 有什么作用？","order":4,"star":4,"date":"2023-03-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-React 中的 key 有什么作用？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"React 中的 key 有什么作用？"}]]},"version":""},{"id":82,"title":"说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？","content":"#\n\n\n\n\n一、是什么#\n\n在以前文章中，我们了解到生命周期定义\n\n生命周期（Life\nCycle）的概念应用很广泛，特别是在经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整\n个过程\n\n跟Vue一样，React整个组件生命周期包括从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程\n\n\n二、流程#\n\n这里主要讲述react16.4之后的生命周期，可以分成三个阶段：\n\n * 创建阶段\n * 更新阶段\n * 卸载阶段\n\n\n创建阶段#\n\n创建阶段主要分成了以下几个生命周期方法：\n\n * constructor\n * getDerivedStateFromProps\n * render\n * componentDidMount\n\nconstructor#\n\n实例过程中自动调用的方法，在方法内部通过super关键字获取来自父组件的props\n\n在该方法中，通常的操作为初始化state状态或者在this上挂载方法\n\n\ngetDerivedStateFromProps#\n\n该方法是新增的生命周期方法，是一个静态的方法，因此不能访问到组件的实例\n\n执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用\n\n在每次render方法前调用，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和\nstate来加一些限制条件，防止无用的 state 更新\n\n该方法需要返回一个新的对象作为新的state或者返回null表示state状态不需要更新\n\n\nrender#\n\n类组件必须实现的方法，用于渲染DOM结构，可以访问组件state与prop属性\n\n注意： 不要在 render 里面 setState, 否则会触发死循环导致内存崩溃\n\n\ncomponentDidMount#\n\n组件挂载到真实DOM节点后执行，其在render方法之后执行\n\n此方法多用于执行一些数据获取，事件监听等操作\n\n\n更新阶段#\n\n该阶段的函数主要为如下方法：\n\n * getDerivedStateFromProps\n * shouldComponentUpdate\n * render\n * getSnapshotBeforeUpdate\n * componentDidUpdate\n\n\ngetDerivedStateFromProps#\n\n该方法介绍同上\n\n\nshouldComponentUpdate#\n\n用于告知组件本身基于当前的props和state是否需要重新渲染组件，默认情况返回true\n\n执行时机：到新的 props 或者 state 时都会调用，通过返回 true 或者 false 告知组件更新与否\n\n一般情况，不建议在该周期方法中进行深层比较，会影响效率\n\n同时也不能调用setState，否则会导致无限循环调用更新\n\n\nrender#\n\n介绍如上\n\n\ngetSnapshotBeforeUpdate#\n\n该周期函数在render后执行，执行之时DOM元素还没有被更新\n\n该方法返回的一个Snapshot值，作为componentDidUpdate第三个参数传入\n\n\n\n此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些 UI 视觉上的状态\n\n\ncomponentDidUpdate#\n\n执行时机：组件更新结束后触发\n\n在该方法中，可以根据前后的props和state的变化做相应的操作，如获取数据，修改DOM样式等\n\n\n卸载阶段#\n\n\ncomponentWillUnmount#\n\n此方法用于组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等\n\n一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建\n\n\n三、总结#\n\n新版生命周期整体流程如下图所示：\n\n\n\n旧的生命周期流程图如下：\n\n\n\n通过两个图的对比，可以发现新版的生命周期减少了以下三种方法：\n\n * componentWillMount\n * componentWillReceiveProps\n * componentWillUpdate\n\n其实这三个方法仍然存在，只是在前者加上了UNSAFE_前缀，如UNSAFE_componentWillMount，并不像字面意思那样表示不安全，而是表示这些生命\n周期的代码可能在未来的 react版本可能废除\n\n同时也新增了两个生命周期函数：\n\n * getDerivedStateFromProps\n * getSnapshotBeforeUpdate\n\n\n参考文献#\n\n * https://github.com/pomelovico/keep/issues/23\n * https://segmentfault.com/a/1190000020268993","routePath":"/interview/React/life_cycle","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":196},{"text":"创建阶段","id":"创建阶段","depth":3,"charIndex":263},{"text":"constructor","id":"constructor","depth":4,"charIndex":367},{"text":"getDerivedStateFromProps","id":"getderivedstatefromprops","depth":3,"charIndex":461},{"text":"render","id":"render","depth":3,"charIndex":705},{"text":"componentDidMount","id":"componentdidmount","depth":3,"charIndex":800},{"text":"更新阶段","id":"更新阶段","depth":3,"charIndex":877},{"text":"getDerivedStateFromProps","id":"getderivedstatefromprops-1","depth":3,"charIndex":1014},{"text":"shouldComponentUpdate","id":"shouldcomponentupdate","depth":2,"charIndex":1051},{"text":"render","id":"render-1","depth":3,"charIndex":1242},{"text":"getSnapshotBeforeUpdate","id":"getsnapshotbeforeupdate","depth":3,"charIndex":1258},{"text":"componentDidUpdate","id":"componentdidupdate","depth":3,"charIndex":1431},{"text":"卸载阶段","id":"卸载阶段","depth":3,"charIndex":1519},{"text":"componentWillUnmount","id":"componentwillunmount","depth":2,"charIndex":1527},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1621},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1951}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"}]]},"version":""},{"id":83,"title":"说说你对 Redux 的理解？其工作原理？","content":"#\n\n\n\n\n一、是什么#\n\nReact是用于构建用户界面的，帮助我们解决渲染DOM的过程\n\n而在整个应用中会存在很多个组件，每个组件的state是由自身进行管理，包括组件定义自身的state、组件之间的通信通过props传递、使用Context实现数据\n共享\n\n如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程\n\n这种情况下，如果将所有的状态进行集中管理，当需要更新状态的时候，仅需要对这个管理集中处理，而不用去关心状态是如何分发到每一个组件内部的\n\nredux就是一个实现上述集中管理的容器，遵循三大基本原则：\n\n * 单一数据源\n * state 是只读的\n * 使用纯函数来执行修改\n\n注意的是，redux并不是只应用在react中，还与其他界面库一起使用，如Vue\n\n\n二、工作原理#\n\nredux要求我们把数据都放在 store公共存储空间\n\n一个组件改变了 store 里的数据内容，其他组件就能感知到 store的变化，再来取数据，从而间接的实现了这些数据传递的功能\n\n工作流程图如下所示：\n\n\n\n根据流程图，可以想象，React Components 是借书的用户， Action Creactor 是借书时说的话(借什么书)， Store\n是图书馆管理员，Reducer 是记录本(借什么书，还什么书，在哪儿，需要查一下)， state 是书籍信息\n\n整个流程就是借书的用户需要先存在，然后需要借书，需要一句话来描述借什么书，图书馆管理员听到后需要查一下记录本，了解图书的位置，最后图书馆管理员会把这本书给到这个\n借书人\n\n转换为代码是，React Components 需要获取一些数据, 然后它就告知 Store 需要获取数据，这就是就是 Action Creactor ,\nStore 接收到之后去 Reducer 查一下， Reducer 会告诉 Store 应该给这个组件什么数据\n\n\n三、如何使用#\n\n创建一个store的公共数据区域\n\n\n\n还需要创建一个记录本去辅助管理数据，也就是reduecer，本质就是一个函数，接收两个参数state，action，返回state\n\n\n\n然后就可以将记录本传递给store，两者建立连接。如下：\n\n\n\n如果想要获取store里面的数据，则通过store.getState()来获取当前state\n\n\n\n下面再看看如何更改store里面数据，是通过dispatch来派发action，通常action中都会有type属性，也可以携带其他的数据\n\n\n\n下面再来看看修改reducer中的处理逻辑：\n\n\n\n注意，reducer是一个纯函数，不需要直接修改state\n\n这样派发action之后，既可以通过store.subscribe监听store的变化，如下：\n\n\n\n在React项目中，会搭配react-redux进行使用\n\n完整代码如下：\n\n\n\n\n小结#\n\n * createStore 可以帮助创建 store\n * store.dispatch 帮助派发 action , action 会传递给 store\n * store.getState 这个方法可以帮助获取 store 里边所有的数据内容\n * store.subscrible 方法订阅 store 的改变，只要 store 发生改变， store.subscrible\n   这个函数接收的这个回调函数就会被执行\n\n\n参考文献#\n\n * https://cn.redux.js.org/docs/introduction/\n * https://www.redux.org.cn/docs/basics/Actions.html\n * https://lulujianglab.com/posts/大白话解析 Redux 、 redux-thunk 、redux-saga 和\n   react-redux","routePath":"/interview/React/redux","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、工作原理","id":"二工作原理","depth":2,"charIndex":378},{"text":"三、如何使用","id":"三如何使用","depth":2,"charIndex":846},{"text":"小结","id":"小结","depth":3,"charIndex":1249},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1468}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 Redux 的理解？其工作原理？","footer":"说说你对 Redux 的理解？其工作原理？","order":31,"star":31,"date":"2023-05-20T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你对 Redux 的理解？其工作原理？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 Redux 的理解？其工作原理？"}]]},"version":""},{"id":84,"title":"说说 React render 方法的原理？在什么时候会被触发？","content":"#\n\n\n\n\n一、原理#\n\n首先，render函数在react中有两种形式：\n\n在类组件中，指的是render方法：\n\n\n\n在函数组件中，指的是函数组件本身：\n\n\n\n在render中，我们会编写jsx，jsx通过babel编译后就会转化成我们熟悉的js格式，如下：\n\n\n\nbabel编译后：\n\n\n\n从名字上来看，createElement方法用来元素的\n\n在react中，这个元素就是虚拟DOM树的节点，接收三个参数：\n\n * type：标签\n\n * attributes：标签属性，若无则为 null\n\n * children：标签的子节点\n\n这些虚拟DOM树最终会渲染成真实DOM\n\n在render过程中，React 将新调用的 render函数返回的树与旧版本的树进行比较，这一步是决定如何更新 DOM 的必要步骤，然后进行 diff\n比较，更新 DOM树\n\n\n二、触发时机#\n\nrender的执行时机主要分成了两部分：\n\n * 类组件调用 setState 修改状态\n\n\n\n点击按钮，则调用setState方法，无论count发生变化辩护，控制台都会输出Foo render，证明render执行了\n\n * 函数组件通过useState hook修改状态\n\n\n\n函数组件通过useState这种形式更新数据，当数组的值不发生改变了，就不会触发render\n\n * 类组件重新渲染\n\n\n\n只要点击了 App 组件内的 Change name 按钮，不管 Foo 具体实现是什么，都会被重新render渲染\n\n * 函数组件重新渲染\n\n\n\n可以发现，使用useState来更新状态的时候，只有首次会触发Foo render，后面并不会导致Foo render\n\n\n三、总结#\n\nrender函数里面可以编写JSX，转化成createElement这种形式，用于生成虚拟DOM，最终转化成真实DOM\n\n在React 中，类组件只要执行了 setState 方法，就一定会触发 render 函数执行，函数组件使用useState更改状态不一定导致重新render\n\n组件的props 改变了，不一定触发 render 函数的执行，但是如果 props 的值来自于父组件或者祖先组件的 state\n\n在这种情况下，父组件或者祖先组件的 state 发生了改变，就会导致子组件的重新渲染\n\n所以，一旦执行了setState就会执行render方法，useState\n会判断当前值有无发生改变确定是否执行render方法，一旦父组件发生渲染，子组件也会渲染\n\n\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/45091185\n * https://juejin.cn/post/6844904181493415950","routePath":"/interview/React/render","lang":"","toc":[{"text":"一、原理","id":"一原理","depth":2,"charIndex":5},{"text":"二、触发时机","id":"二触发时机","depth":2,"charIndex":382},{"text":"三、总结","id":"三总结","depth":2,"charIndex":732},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1079}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React render 方法的原理？在什么时候会被触发？","footer":"说说 React render 方法的原理？在什么时候会被触发？","order":19,"star":19,"date":"2023-04-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React render 方法的原理？在什么时候会被触发？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React render 方法的原理？在什么时候会被触发？"}]]},"version":""},{"id":85,"title":"说说 React 服务端渲染怎么做？原理是什么？","content":"Hello world ${content} ${content}\n${content}","routePath":"/interview/React/server_side_rendering","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":-1},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":-1},{"text":"三、原理","id":"三原理","depth":2,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React 服务端渲染怎么做？原理是什么？","footer":"说说 React 服务端渲染怎么做？原理是什么？","order":10,"star":10,"date":"2023-03-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React 服务端渲染怎么做？原理是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React 服务端渲染怎么做？原理是什么？"}]]},"version":""},{"id":86,"title":"说说 React 中的 setState 执行机制","content":"#\n\n\n\n\n一、是什么#\n\n一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state\n\n当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用\n\n如下例子：\n\n\n\n通过点击按钮触发onclick事件，执行this.setState方法更新state状态，然后重新执行render函数，从而导致页面的视图更新\n\n如果直接修改state的状态，如下：\n\n\n\n我们会发现页面并不会有任何反应，但是state的状态是已经发生了改变\n\n这是因为React并不像vue2中调用Object.defineProperty数据响应式或者Vue3调用Proxy监听数据的变化\n\n必须通过setState方法来告知react组件state已经发生了改变\n\n关于state方法的定义是从React.Component中继承，定义的源码如下：\n\n\n\n从上面可以看到setState第一个参数可以是一个对象，或者是一个函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据\n\n\n二、更新类型#\n\n在使用setState更新数据的时候，setState的更新类型分成：\n\n * 异步更新\n * 同步更新\n\n\n异步更新#\n\n先举出一个例子：\n\n\n\n从上面可以看到，最终打印结果为Hello world，并不能在执行完setState之后立马拿到最新的state的结果\n\n如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行\n\n\n\n\n同步更新#\n\n同样先给出一个在setTimeout中更新的例子：\n\n\n\n上面的例子中，可以看到更新是同步\n\n再来举一个原生DOM事件的例子：\n\n\n\n\n小结#\n\n * 在组件生命周期或 React 合成事件中，setState 是异步\n * 在 setTimeout 或者原生 dom 事件中，setState 是同步\n\n\n三、批量更新#\n\n同样先给出一个例子：\n\n\n\n点击按钮触发事件，打印的都是 1，页面显示 count 的值为 2\n\n对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果\n\n上述的例子，实际等价于如下：\n\n\n\n由于后面的数据会覆盖前面的更改，所以最终只加了一次\n\n如果是下一个state依赖前一个state的话，推荐给setState一个参数传入一个function，如下：\n\n\n\n而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903667426918408\n * https://juejin.cn/post/6844903636749778958\n * https://segmentfault.com/a/1190000039077904","routePath":"/interview/React/setState","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、更新类型","id":"二更新类型","depth":2,"charIndex":459},{"text":"异步更新","id":"异步更新","depth":3,"charIndex":523},{"text":"同步更新","id":"同步更新","depth":3,"charIndex":638},{"text":"小结","id":"小结","depth":3,"charIndex":713},{"text":"三、批量更新","id":"三批量更新","depth":3,"charIndex":799},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1063}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 React 中的 setState 执行机制","footer":"说说 React 中的 setState 执行机制","order":12,"star":12,"date":"2023-03-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说 React 中的 setState 执行机制","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 React 中的 setState 执行机制"}]]},"version":""},{"id":87,"title":"state 和 props 有什么区别？","content":"#\n\n\n\n\n一、state#\n\n一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 state，一般在 constructor 中初始化\n\n当需要修改里面的值的状态需要通过调用 setState 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 render 方法，如下面的例子：\n\n\n\nsetState 还可以接受第二个参数，它是一个函数，会在 setState 调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成\n\n\n\n\n二、props#\n\nReact 的核心思想就是组件化思想，页面会被切分成一些独立的、可复用的组件\n\n组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是 props，所以可以把 props 理解为从外部传入组件内部的数据\n\nreact 具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据\n\nprops 除了可以传字符串，数字，还可以传递对象，数组甚至是回调函数，如下：\n\n\n\n上述 name 属性与 onNameChanged 方法都能在子组件的 props 变量中访问\n\n在子组件中，props 在内部不可变的，如果想要改变它看，只能通过外部组件传入新的 props 来重新渲染子组件，否则子组件的 props 和展示形式不会改变\n\n\n三、区别#\n\n相同点：\n\n * 两者都是 JavaScript 对象\n * 两者都是用于保存信息\n * props 和 state 都能触发渲染更新\n\n区别：\n\n * props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化\n * props 在组件内部是不可修改的，但 state 在组件内部可以进行修改\n * state 是多变的、可以修改\n\n\n参考文献#\n\n * https://lucybain.com/blog/2016/react-state-vs-pros/\n * https://juejin.cn/post/6844904009203974158","routePath":"/interview/React/state_props","lang":"","toc":[{"text":"一、state","id":"一state","depth":2,"charIndex":5},{"text":"二、props","id":"二props","depth":2,"charIndex":229},{"text":"三、区别","id":"三区别","depth":2,"charIndex":564},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":769}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-state 和 props 有什么区别？","footer":"state 和 props 有什么区别？","order":29,"star":29,"date":"2023-04-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-state 和 props 有什么区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"state 和 props 有什么区别？"}]]},"version":""},{"id":88,"title":"说说你在使用 React 过程中遇到的常见问题？如何解决?","content":"#\n\n\n\n\n一、前言#\n\n在使用react开发项目过程中，每个人或多或少都会遇到一些\"奇怪\"的问题，本质上都是我们对其理解的不够透彻\n\nreact 系列，33 个工作日，33 次凌晨还在亮起的台灯，到今天就圆满画上句号了，比心\n\n在系列中我们列出了很多比较经典的考题，工作中遇到的问题也往往就藏中其中，只是以不同的表现形式存在罢了\n\n今天的题解不算题解，准确来说是对整个系列的一次贯穿，总结\n\n目录:\n\n * react 有什么特性\n * 生命周期有哪些不同阶段？每个阶段对应的方法是？\n * state 和 props 有什么区别？\n * super()和 super(props)有什么区别？\n * setState 执行机制？\n * React 的事件机制？\n * 事件绑定的方式有哪些？\n * 构建组件的方式有哪些？区别？\n * 组件之间如何通信？\n * key 有什么作用？\n * refs 的理解？应用场景？\n * Hooks 的理解？解决了什么问题？\n * 如何引入 css？\n * redux 工作原理？\n * redux 中间件有哪些？\n * react-router 组件有哪些？\n * render 触发时机？\n * 如何减少 render？\n * JSX 转化 DOM 过程？\n * 性能优化手段有哪些\n * 如何做服务端渲染？\n\n\nreact 有什么特性#\n\n主要的特性分为：\n\n * JSX 语法\n * 单向数据绑定\n * 虚拟 DOM\n * 声明式编程\n * Component\n\n借助这些特性，react整体使用起来更加简单高效，组件式开发提高了代码的复用率\n\n\n生命周期有哪些不同阶段？每个阶段对应的方法是？#\n\n主要分成了新的生命周期和旧的生命周期：\n\n * 新版生命周期整体流程如下图所示：\n   \n   \n   \n   旧的生命周期流程图如下：\n   \n   \n\n\nstate 和 props 有什么区别？#\n\n两者相同点：\n\n * 两者都是 JavaScript 对象\n * 两者都是用于保存信息\n * props 和 state 都能触发渲染更新\n\n区别：\n\n * props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化\n * props 在组件内部是不可修改的，但 state 在组件内部可以进行修改\n * state 是多变的、可以修改\n\n\nsuper()和 super(props)有什么区别？#\n\n在React中，类组件基于ES6，所以在constructor中必须使用super\n\n在调用super过程，无论是否传入props，React内部都会将porps赋值给组件实例porps属性中\n\n如果只调用了super()，那么this.props在super()和构造函数结束之间仍是undefined\n\n\nsetState 执行机制？#\n\n在react类组件的状态需要通过setState进行更改，在不同场景下对应不同的执行顺序：\n\n * 在组件生命周期或 React 合成事件中，setState 是异步\n * 在 setTimeout 或者原生 dom 事件中，setState 是同步\n\n当我们批量更改state的值的时候，react内部会将其进行覆盖，只取最后一次的执行结果\n\n当需要下一个state依赖当前state的时候，则可以在setState中传递一个回调函数进行下次更新\n\n\nReact 的事件机制？#\n\nReact基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等\n\n组件注册的事件最终会绑定在document这个 DOM上，而不是 React组件对应的 DOM，从而节省内存开销\n\n自身实现了一套事件冒泡机制，阻止不同时间段的冒泡行为，需要对应使用不同的方法\n\n\n事件绑定的方式有哪些？#\n\nreact常见的绑定方式有如下：\n\n * render 方法中使用 bind\n * render 方法中使用箭头函数\n * constructor 中 bind\n * 定义阶段使用箭头函数绑定\n\n前两种方式在每次组件render的时候都会生成新的方法实例，性能问题欠缺\n\n\n构建组件的方式有哪些？区别？#\n\n组件的创建主要分成了三种方式：\n\n * 函数式创建\n * 继承 React.Component 创建\n * 通过 React.createClass 方法创建\n\n如今一般都是前两种方式，对于一些无状态的组件创建，建议使用函数式创建的方式，再比如hooks的机制下，函数式组件能做类组件对应的事情，所以建议都使用函数式的方式\n来创建组件\n\n\n组件之间如何通信？#\n\n组件间通信可以通过props、传递回调函数、context、redux等形式进行组件之间通讯\n\n\nkey 有什么作用？#\n\n使用key是react性能优化的手段，在一系列数据最前面插入元素，如果没有key的值，则所有的元素都需要进行更换，而有key的情况只需要将最新元素插入到前面，不\n涉及删除操作\n\n在使用key的时候应保证：\n\n * key 应该是唯一的\n * key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）\n * 避免使用 index 作为 key\n\n\nrefs 的理解？应用场景？#\n\nRefs允许我们访问 DOM节点或在 render方法中创建的 React元素\n\n下面的场景使用refs非常有用：\n\n * 对 Dom 元素的焦点控制、内容选择、控制\n * 对 Dom 元素的内容设置及媒体播放\n * 对 Dom 元素的操作和对组件实例的操作\n * 集成第三方 DOM 库\n\n\nHooks 的理解？解决了什么问题？#\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性\n\n解决问题如下：\n\n * 难以重用和共享组件中的与状态相关的逻辑\n * 逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面\n * 类组件中的 this 增加学习成本，类组件在基于现有工具的优化上存在些许问题\n * 由于业务变动，函数组件不得不改为类组件等等\n\n\n如何引入 css？#\n\n常见的CSS引入方式有以下：\n\n * 在组件内直接使用\n * 组件中引入 .css 文件\n * 组件中引入 .module.css 文件\n * CSS in JS\n\n组件内直接使用css会导致大量的代码，而文件中直接引入css文件是全局作用域，发生层叠\n\n引入.module.css文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写\n\ncss in js这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、修改状态等\n\n\nredux 工作原理？#\n\nredux要求我们把数据都放在 store公共存储空间\n\n一个组件改变了 store 里的数据内容，其他组件就能感知到 store的变化，再来取数据，从而间接的实现了这些数据传递的功能\n\n工作流程图如下所示：\n\n\n\n\nredux 中间件有哪些？#\n\n市面上有很多优秀的redux中间件，如：\n\n * redux-thunk：用于异步操作\n * redux-logger：用于日志记录\n\n\nreact-router 组件有哪些？#\n\n常见的组件有：\n\n * BrowserRouter、HashRouter\n * Route\n * Link、NavLink\n * switch\n * redirect\n\n\nrender 触发时机？#\n\n在React 中，类组件只要执行了 setState 方法，就一定会触发 render 函数执行\n\n函数组件useState 会判断当前值有无发生改变确定是否执行render方法，一旦父组件发生渲染，子组件也会渲染\n\n\n如何减少 render？#\n\n父组件渲染导致子组件渲染，子组件并没有发生任何改变，这时候就可以从避免无谓的渲染，具体实现的方式有如下：\n\n * shouldComponentUpdate\n * PureComponent\n * React.memo\n\n\nJSX 转化 DOM 过程？#\n\njsx首先会转化成React.createElement这种形式，React.createElement作用是生成一个虚拟Dom对象，然后会通过ReactDOM\n.render进行渲染成真实DOM\n\n\n性能优化手段有哪些#\n\n除了减少render的渲染之外，还可以通过以下手段进行优化：\n\n除此之外， 常见性能优化常见的手段有如下：\n\n * 避免使用内联函数\n * 使用 React Fragments 避免额外标记\n * 使用 Immutable\n * 懒加载组件\n * 事件绑定方式\n * 服务端渲染\n\n\n如何做服务端渲染？#\n\nnode server 接收客户端请求，得到当前的请求url 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为\nprops、context或者store 形式传入组件\n\n然后基于 react 内置的服务端渲染方法 renderToString()把组件渲染为 html字符串在把最终的 html进行输出前需要将数据注入到浏览器端\n\n浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 html 节点，整个流程结束\n\n","routePath":"/interview/React/summary","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"react 有什么特性","id":"react-有什么特性","depth":3,"charIndex":578},{"text":"生命周期有哪些不同阶段？每个阶段对应的方法是？","id":"生命周期有哪些不同阶段每个阶段对应的方法是","depth":3,"charIndex":697},{"text":"state 和 props 有什么区别？","id":"state-和-props-有什么区别","depth":3,"charIndex":802},{"text":"super()和 super(props)有什么区别？","id":"super和-superprops有什么区别","depth":3,"charIndex":1025},{"text":"setState 执行机制？","id":"setstate-执行机制","depth":3,"charIndex":1210},{"text":"React 的事件机制？","id":"react-的事件机制","depth":3,"charIndex":1454},{"text":"事件绑定的方式有哪些？","id":"事件绑定的方式有哪些","depth":3,"charIndex":1620},{"text":"构建组件的方式有哪些？区别？","id":"构建组件的方式有哪些区别","depth":3,"charIndex":1771},{"text":"组件之间如何通信？","id":"组件之间如何通信","depth":3,"charIndex":1958},{"text":"key 有什么作用？","id":"key-有什么作用","depth":3,"charIndex":2019},{"text":"refs 的理解？应用场景？","id":"refs-的理解应用场景","depth":3,"charIndex":2216},{"text":"Hooks 的理解？解决了什么问题？","id":"hooks-的理解解决了什么问题","depth":3,"charIndex":2380},{"text":"如何引入 css？","id":"如何引入-css","depth":3,"charIndex":2649},{"text":"redux 工作原理？","id":"redux-工作原理","depth":3,"charIndex":2900},{"text":"redux 中间件有哪些？","id":"redux-中间件有哪些","depth":3,"charIndex":3023},{"text":"react-router 组件有哪些？","id":"react-router-组件有哪些","depth":3,"charIndex":3108},{"text":"render 触发时机？","id":"render-触发时机","depth":3,"charIndex":3216},{"text":"如何减少 render？","id":"如何减少-render","depth":3,"charIndex":3341},{"text":"JSX 转化 DOM 过程？","id":"jsx-转化-dom-过程","depth":3,"charIndex":3468},{"text":"性能优化手段有哪些","id":"性能优化手段有哪些","depth":3,"charIndex":3586},{"text":"如何做服务端渲染？","id":"如何做服务端渲染","depth":3,"charIndex":3740}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你在使用 React 过程中遇到的常见问题？如何解决?","footer":"说说你在使用 React 过程中遇到的常见问题？如何解决?","order":32,"star":32,"date":"2023-05-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-说说你在使用 React 过程中遇到的常见问题？如何解决?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你在使用 React 过程中遇到的常见问题？如何解决?"}]]},"version":""},{"id":89,"title":"super() 和 super(props) 有什么区别？","content":"#\n\n\n\n\n一、ES6 类#\n\n在 ES6 中，通过 extends 关键字实现类的继承，方式如下：\n\n\n\n在上面的例子中，可以看到通过 super 关键字实现调用父类，super 代替的是父类的构建函数，使用 super(name) 相当于调用\nsup.prototype.constructor.call(this,name)\n\n如果在子类中不使用 super，关键字，则会引发报错，如下：\n\n\n\n报错的原因是 子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工\n\n而 super() 就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象\n\n如果先调用 this，再初始化 super()，同样是禁止的行为\n\n\n\n所以在子类 constructor 中，必须先代用 super 才能引用 this\n\n\n二、类组件#\n\n在 React 中，类组件是基于 ES6 的规范实现的，继承 React.Component，因此如果用到 constructor 就必须写 super()\n才初始化 this\n\n这时候，在调用 super() 的时候，我们一般都需要传入 props 作为参数，如果不传进去，React 内部也会将其定义在组件实例中\n\n\n\n所以无论有没有 constructor，在 render 中 this.props 都是可以使用的，这是 React 自动附带的，是可以不写的：\n\n\n\n但是也不建议使用 super() 代替 super(props)\n\n因为在 React 会在类组件构造函数生成实例后再给 this.props 赋值，所以在不传递 props 在 super 的情况下，调用 this.props\n为 undefined，如下情况：\n\n\n\n而传入 props 的则都能正常访问，确保了 this.props 在构造函数执行完毕之前已被赋值，更符合逻辑，如下：\n\n\n\n\n三、总结#\n\n在 React 中，类组件基于 ES6，所以在 constructor 中必须使用 super\n\n在调用 super 过程，无论是否传入 props，React 内部都会将 porps 赋值给组件实例 porps 属性中\n\n如果只调用了 super()，那么 this.props 在 super() 和构造函数结束之间仍是 undefined\n\n\n参考文献#\n\n * https://overreacted.io/zh-hans/why-do-we-write-super-props/\n * https://segmentfault.com/q/1010000008340434","routePath":"/interview/React/super()_super(props)","lang":"","toc":[{"text":"一、ES6 类","id":"一es6-类","depth":2,"charIndex":5},{"text":"二、类组件","id":"二类组件","depth":2,"charIndex":391},{"text":"三、总结","id":"三总结","depth":2,"charIndex":837},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1019}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-super() 和 super(props) 有什么区别？","footer":"super() 和 super(props) 有什么区别？","order":21,"star":21,"date":"2023-04-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","React"],"tag":["interview","React"],"shortTitle":"前端物语|面试物语-super() 和 super(props) 有什么区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"super() 和 super(props) 有什么区别？"}]]},"version":""},{"id":90,"title":"说说你对算法的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制\n\n也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出\n\n如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题\n\n一个程序=算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割\n\n因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构\n\n针对上述，可以得出一个总结：不同的算法可能用不同的时间、空间或效率来完成同样的任务\n\n\n二、特性#\n\n关于算法的五大特性，有如下：\n\n * 有限性（Finiteness）：一个算法必须保证执行有限步之后结束\n * 确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义\n * 输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件\n * 输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义\n * 可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性\n   ）\n\n\n三、应用场景#\n\n在前端领域中，数据结构与算法无法不在，例如现在的vue或者react项目，实现虚拟DOM或者Fiber结构，本质就是一种数据结构，如下一个简单的虚拟DOM：\n\n\n\nvue与react都能基于基于对应的数据结构实现diff算法，提高了整个框架的性能以及拓展性\n\n包括在前端javascript编译的时候，都会生成对应的抽象语法树AST，其本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法，\n也是babel， PostCSS, prettier， typescript\n\n除了这些框架或者工具底层用到算法与数据结构之外，日常业务也无处不在，例如实现一个输入框携带联想功能，如下：\n\n\n\n如果我们要实现这个功能， 则可以使用前缀树，如下：\n\n\n\n包括前端可能会做一些对字符串进行相似度检测，例如\"每日一题\"和\"js\n每日一题\"两个字符串进行相似度对比，这种情况可以通过“最小编辑距离”算法，如果a和b的编辑距离越小，我们认为越相似\n\n日常在编写任何代码的都需要一个良好的算法思维，选择好的算法或者数据结构，能让整个程序效率更高\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025\n * https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/","routePath":"/interview/algorithm/Algorithm","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、特性","id":"二特性","depth":2,"charIndex":326},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":612},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1101}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对算法的理解？应用场景？","footer":"说说你对算法的理解？应用场景？","order":17,"star":17,"date":"2023-04-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对算法的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对算法的理解？应用场景？"}]]},"version":""},{"id":91,"title":"说说你对二分查找的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法\n\n想要应用二分查找法，则这一堆数应有如下特性：\n\n * 存储在数组中\n * 有序排序\n\n搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束\n\n如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较\n\n如果在某一步骤数组为空，则代表找不到\n\n这种搜索算法每一次比较都使搜索范围缩小一半\n\n如下图所示：\n\n\n\n相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：\n\n\n\n\n二、如何实现#\n\n基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：\n\n\n\n如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：\n\n\n\n实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组\n\n有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得\n\n例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组\n\n该数组的特性是存在一个分界点用来分界两个有序数组，如下：\n\n\n\n分界点有如下特性：\n\n * 分界点元素 >= 第一个元素\n * 分界点元素 < 第一个元素\n\n代码实现如下：\n\n\n\n对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件\n\n\n三、应用场景#\n\n二分查找法的O(logn)让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：\n\n * 有序：我们很难保证我们的数组都是有序的\n * 数组：数组读取效率是 O(1)，可是它的插入和删除某个元素的效率却是 O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况\n\n关于二分查找的应用场景，主要如下：\n\n * 不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单\n * 每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数\n * 不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E\n   7%AE%97%E6%B3%95#javascript_%E7%89%88%E6%9C%AC\n * https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html","routePath":"/interview/algorithm/BinarySearch","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":302},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":641},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":990}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对二分查找的理解？如何实现？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对二分查找的理解？如何实现？应用场景？","order":3,"star":3,"date":"2023-02-27T04:29:21.779Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对二分查找的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对二分查找的理解？如何实现？应用场景？"}]]},"version":""},{"id":92,"title":"说说你对堆的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n堆(Heap)是计算机科学中一类特殊的数据结构的统称\n\n堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：\n\n\n\n总是满足下列性质：\n\n * 堆中某个结点的值总是不大于或不小于其父结点的值\n * 堆总是一棵完全二叉树\n\n堆又可以分成最大堆和最小堆：\n\n * 最大堆：每个根结点，都有根结点的值大于两个孩子结点的值\n * 最小堆：每个根结点，都有根结点的值小于孩子结点的值\n\n\n二、操作#\n\n堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：\n\n\n\n用一维数组存储则如下：\n\n\n\n根据完全二叉树的特性，可以得到如下特性：\n\n * 数组零坐标代码的是堆顶元素\n * 一个节点的父亲节点的坐标等于其坐标除以 2 整数部分\n * 一个节点的左节点等于其本身节点坐标 * 2 + 1\n * 一个节点的右节点等于其本身节点坐标 * 2 + 2\n\n根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：\n\n\n\n涉及到堆的操作有：\n\n * 插入\n * 删除\n\n\n插入#\n\n将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作\n\n将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为k的堆中插入元素的时间复杂度为O(logk)\n\n如下图所示，22 节点是新插入的元素，然后进行上移操作：\n\n\n\n相关代码如下：\n\n\n\n\n删除#\n\n常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构\n\n然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为O(logk)\n\n整体如下图操作：\n\n\n\n相关代码如下：\n\n\n\n\n时间复杂度#\n\n关于堆的插入和删除时间复杂度都是Olog(n)，原因在于包含 n 个节点的完全二叉树，树的高度不会超过log2n\n\n堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是Olog(n)，插入数据和删除堆顶元素的主要逻辑就是堆化\n\n\n三、总结#\n\n * 堆是一个完全二叉树\n * 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值\n * 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”\n * 对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”\n * 根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E5%A0%86/20606834\n * https://xlbpowder.cn/2021/02/26/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F\n   /","routePath":"/interview/algorithm/Heap","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、操作","id":"二操作","depth":2,"charIndex":204},{"text":"插入","id":"插入","depth":3,"charIndex":455},{"text":"删除","id":"删除","depth":3,"charIndex":616},{"text":"时间复杂度","id":"时间复杂度","depth":3,"charIndex":758},{"text":"三、总结","id":"三总结","depth":3,"charIndex":897},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1070}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对堆的理解？如何实现？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对堆的理解？如何实现？应用场景？","order":4,"star":4,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对堆的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对堆的理解？如何实现？应用场景？"}]]},"version":""},{"id":93,"title":"说说你对链表的理解？常见的操作有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n链表（Linked\nList）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成\n\n每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\n\n\n\n节点用代码表示，则如下：\n\n\n\n * data 表示节点存放的数据\n * next 表示下一个节点指向的内存空间\n\n相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节\n点则需要 O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)\n\n链表的结构也十分多，常见的有四种形式：\n\n * 单链表：除了头节点和尾节点，其他节点只包含一个后继指针\n * 循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环\n * 双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地\n   址 NULL\n * 双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点\n\n\n二、操作#\n\n关于链表的操作可以主要分成如下：\n\n * 遍历\n * 插入\n * 删除\n\n\n遍历#\n\n遍历很好理解，就是根据next指针遍历下去，直到为null，如下：\n\n\n\n\n插入#\n\n向链表中间插入一个元素，可以如下图所示：\n\n\n\n可以看到，插入节点可以分成如下步骤：\n\n * 存储插入位置的前一个节点\n\n * 存储插入位置的后一个节点\n\n * 将插入位置的前一个节点的 next 指向插入节点\n\n * 将插入节点的 next 指向前面存储的 next 节点\n\n相关代码如下所示：\n\n\n\n如果在头节点进行插入操作的时候，会实现previousNode节点为undefined，不适合上述方式\n\n解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致\n\n\n删除#\n\n向链表任意位置删除节点，如下图操作：\n\n\n\n从上图可以看到删除节点的步骤为如下：\n\n * 获取删除节点的前一个节点\n * 获取删除节点的后一个节点\n * 将前一个节点的 next 指向后一个节点\n * 向删除节点的 next 指向为 null\n\n如果想要删除制定的节点，示意代码如下：\n\n\n\n同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点\n\n\n三、应用场景#\n\n缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等\n\n当缓存空间被用满时，我们可能会使用LRU最近最好使用策略去清楚，而实现LRU算法的数据结构是链表，思路如下：\n\n维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表\n\n * 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部\n * 如果此数据没在缓存链表中\n   * 如果此时缓存未满，可直接在链表头部插入新节点存储此数据\n   * 如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点\n\n由于链表插入删除效率极高，达到 O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表\n\n\n参考文献#\n\n * https://zh.wikipedia.org/zh-hans/%E9%93%BE%E8%A1%A8\n * https://mah93.github.io/2019/07/19/js-linked/","routePath":"/interview/algorithm/LinkedList","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、操作","id":"二操作","depth":2,"charIndex":575},{"text":"遍历","id":"遍历","depth":3,"charIndex":620},{"text":"插入","id":"插入","depth":3,"charIndex":663},{"text":"删除","id":"删除","depth":3,"charIndex":907},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1095},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1490}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对链表的理解？常见的操作有哪些？","footer":"说说你对链表的理解？常见的操作有哪些？","order":16,"star":16,"date":"2023-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对链表的理解？常见的操作有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对链表的理解？常见的操作有哪些？"}]]},"version":""},{"id":94,"title":"前端物语|面试物语-algorithm","content":" * 说说你对算法的理解？应用场景？\n * 说说你对二分查找的理解？如何实现？应用场景？\n * 说说你对堆的理解？如何实现？应用场景？\n * 说说你对链表的理解？常见的操作有哪些？\n * 说说你对冒泡排序的理解？如何实现？应用场景？\n * 说说你对分而治之、动态规划的理解？区别？\n * 说说你对贪心算法、回溯算法的理解？应用场景？\n * 说说你对图的理解？相关操作有哪些？\n * 说说你对插入排序的理解？如何实现？应用场景？\n * 说说你对归并排序的理解？如何实现？应用场景？\n * 说说你对快速排序的理解？如何实现？应用场景？\n * 说说你对选择排序的理解？如何实现？应用场景？\n * 说说你对集合的理解？常见的操作有哪些？\n * 说说常见的排序算法有哪些？区别？\n * 说说你对栈、队列的理解？应用场景？\n * 说说你对数据结构的理解？有哪些？区别？\n * 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？\n * 说说你对树的理解？相关的操作有哪些？","routePath":"/interview/algorithm/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"algorithm","tag":"algorithm","title":"前端物语|面试物语-algorithm","index":false,"dir":{"order":1},"date":"2023-04-16T00:00:00.000Z"},"version":""},{"id":95,"title":"说说你对冒泡排序的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法\n\n冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）\n\n如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”\n\n假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面\n\n思路如下：\n\n * 从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18\n * 接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序\n * 接着比较 99 和 35，发现 99 比 35 大，交换顺序\n * 接着比较 99 和 12，发现 99 比 12 大，交换顺序\n\n最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：\n\n\n\n上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的 4 个元素进行排序，如下图所示：\n\n\n\n经过第 2 趟排序，结果为 99、76、12、35、18\n\n然后开始第 3 趟的排序，结果为 99、76、35、12、18\n\n然后第四趟排序结果为 99、76、35、18、12\n\n经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成\n\n\n二、如何实现#\n\n如果要实现一个从小到大的排序，算法原理如下：\n\n * 首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们\n * 针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数\n * 针对所有的元素重复以上的步骤，除了最后一个\n * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较\n\n\n\n用代码表示则如下：\n\n\n\n可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序\n\n而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为O(n^2)\n\n\n优化#\n\n对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换\n\n如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程\n\n可以设置一标志性变量pos，用于记录每趟排序中最后一次进行交换的位置，由于pos位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到pos位置即可，如下：\n\n\n\n在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为O(n)\n\n并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对\n位置是不会改变的，因此， 冒泡排序是稳定的\n\n\n三、应用场景#\n\n冒泡排的核心部分是双重嵌套循环，时间复杂度是 O(N 2\n)，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306\n * https://www.runoob.com/w3cnote/bubble-sort.html\n * http://data.biancheng.net/view/116.html\n * https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1\n   %E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/","routePath":"/interview/algorithm/bubbleSort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":608},{"text":"优化","id":"优化","depth":3,"charIndex":914},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1260},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1371}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对冒泡排序的理解？如何实现？应用场景？","footer":"说说你对冒泡排序的理解？如何实现？应用场景？","order":9,"star":9,"date":"2023-03-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对冒泡排序的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对冒泡排序的理解？如何实现？应用场景？"}]]},"version":""},{"id":96,"title":"说说你对分而治之、动态规划的理解？区别？","content":"#\n\n\n\n\n一、分而治之#\n\n分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并\n\n关于分而治之的实现，都会经历三个步骤：\n\n * 分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题\n * 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题\n * 合并：将各子问题的解合并为原问题的解\n\n实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：\n\n * 分解：把数组从中间一分为二\n\n * 解决：递归地对两个子数组进行归并排序\n\n * 合并：将两个字数组合并称有序数组\n\n同样关于快速排序的实现，亦如此：\n\n * 分：选基准，按基准把数组分成两个字数组\n * 解：递归地对两个字数组进行快速排序\n * 合：对两个字数组进行合并\n\n同样二分搜索也能使用分而治之的思想去实现，代码如下：\n\n\n\n\n二、动态规划#\n\n动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法\n\n常常适用于有重叠子问题和最优子结构性质的问题\n\n简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决\n\n然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。\n\n一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2 的时候，F(n) = F(n-1) + F(n-2) ，\n\nf(10)= f(9)+f(8),f(9) = f(8) + f(7)...是重叠子问题，当 n = 1、2 的时候，对应的值为\n2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算\n\n\n适用场景#\n\n如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划\n\n比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景\n\n关于动态规划题目解决的步骤，一般如下：\n\n * 描述最优解的结构\n * 递归定义最优解的值\n * 按自底向上的方式计算最优解的值\n * 由计算出的结果构造一个最优解\n\n\n三、区别#\n\n动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解\n\n与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，而分而治之的子问题是相互独立的\n\n若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次\n\n如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间\n\n综上，可得：\n\n * 动态规划：有最优子结构和重叠子问题\n\n * 分而治之：各子问题独立\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408\n * https://juejin.cn/post/6951922898638471181","routePath":"/interview/algorithm/design1","lang":"","toc":[{"text":"一、分而治之","id":"一分而治之","depth":2,"charIndex":5},{"text":"二、动态规划","id":"二动态规划","depth":2,"charIndex":438},{"text":"适用场景","id":"适用场景","depth":3,"charIndex":840},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1040},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1311}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对分而治之、动态规划的理解？区别？","footer":"说说你对分而治之、动态规划的理解？区别？","order":12,"star":12,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对分而治之、动态规划的理解？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对分而治之、动态规划的理解？区别？"}]]},"version":""},{"id":97,"title":"说说你对贪心算法、回溯算法的理解？应用场景？","content":"#\n\n\n\n\n一、贪心算法#\n\n贪心算法，又称贪婪算法，是算法设计中的一种思想\n\n其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的\n\n举个零钱兑换的例子，如果你有 1 元、2 元、5 元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少\n\n如果现在你要兑换 11 元，按照贪心算法的思想，先选择面额最大的 5 元钱币进行兑换，那么就得到 11 = 5 + 5 + 1 的选择，这种情况是最优的\n\n但是如果你手上钱币的面额为 1、3、4，想要兑换 6 元，按照贪心算法的思路，我们会 6 = 4 + 1 + 1 这样选择，这种情况结果就不是最优的选择\n\n从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：\n\n一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法\n\n至于是否选择贪心算法，主要看是否有如下两大特性：\n\n * 贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择\n * 最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在\n\n\n二、回溯算法#\n\n回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略\n\n回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决\n\n使用回溯算法的问题，有如下特性：\n\n * 有很多路，例如一个矩阵的方向或者树的路径\n * 在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合\n * 通常使用递归来模拟所有的路\n\n常见的伪代码如下：\n\n\n\n重点解决三个问题：\n\n * 路径：也就是已经做出的选择\n * 选择列表\n * 结束条件\n\n例如经典使用回溯算法为解决全排列的问题，如下：\n\n一个不含重复数字的数组 nums ，我们要返回其所有可能的全排列，解决这个问题的思路是：\n\n * 用递归模拟所有的情况\n * 遇到包含重复元素的情况则回溯\n * 收集到所有到达递归终点的情况，并返回、\n\n\n\n用代码表示则如下：\n\n\n\n\n三、总结#\n\n前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法\n\n其中关于分而治之、动态规划、贪心策略三者的求解思路如下：\n\n\n\n其中三者对应的经典问题如下图：\n\n\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95\n * https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-da\n   i-ni-xue-tou-hui-s-mfrp/\n * https://cloud.tencent.com/developer/article/1767046","routePath":"/interview/algorithm/design2","lang":"","toc":[{"text":"一、贪心算法","id":"一贪心算法","depth":2,"charIndex":5},{"text":"二、回溯算法","id":"二回溯算法","depth":2,"charIndex":553},{"text":"三、总结","id":"三总结","depth":2,"charIndex":948},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1042}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对贪心算法、回溯算法的理解？应用场景？","footer":"说说你对贪心算法、回溯算法的理解？应用场景？","order":10,"star":10,"date":"2023-03-29T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对贪心算法、回溯算法的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对贪心算法、回溯算法的理解？应用场景？"}]]},"version":""},{"id":98,"title":"说说你对图的理解？相关操作有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，V是所有顶点的集合，E是所有边的集合\n\n如果两个顶点v,w，只能由v向w，而不能由w向v，那么我们就把这种情况叫做一个从 v 到 w 的有向边。v也被称做初始点，w也被称为终点。这种图就被称做有向图\n\n如果v和w是没有顺序的，从v到达w和从w到达v是完全相同的，这种图就被称为无向图\n\n图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系\n\n常见表达图的方式有如下：\n\n * 邻接矩阵\n\n * 邻接表\n\n\n邻接矩阵#\n\n通过使用一个二维数组G[N][N]进行表示N个点到N-1编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行i和列j是否是非零值，对于无\n向图，邻接矩阵是对称的\n\n\n\n\n邻接表#\n\n存储方式如下图所示：\n\n\n\n在javascript中，可以使用Object进行表示，如下：\n\n\n\n图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）\n\n\n二、操作#\n\n关于的图的操作常见的有：\n\n * 深度优先遍历\n * 广度优先遍历\n\n首先构建一个图的邻接矩阵表示，如下面的图：\n\n\n\n用代码表示则如下：\n\n\n\n\n深度优先遍历#\n\n也就是尽可能的往深处的搜索图的分支\n\n实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历\n\n确定以 0 为根节点，然后进行深度遍历，然后遍历 1，接着遍历 2，然后 3，此时完成一条分支0 - 1- 2- 3的遍历，换一条分支，也就是 4，4 后面因为\n3 已经遍历过了，所以就不访问了\n\n用代码表示则如下：\n\n\n\n\n广度优先遍历#\n\n先访问离根节点最近的节点，然后进行入队操作，解决思路如下：\n\n * 新建一个队列，把根节点入队\n * 把队头出队并访问\n * 把队头的没访问过的相邻节点入队\n * 重复二、三步骤，知道队列为空\n\n用代码标识则如下：\n\n\n\n\n三、总结#\n\n通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图\n\n图的表达形式可以分成邻接矩阵和邻接表两种形式，在javascript中，则可以通过二维数组和对象的形式进行表达\n\n图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：\n\n\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\n   )\n * https://www.kancloud.cn/imnotdown1019/java_core_full/2159607","routePath":"/interview/algorithm/graph","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"邻接矩阵","id":"邻接矩阵","depth":3,"charIndex":279},{"text":"邻接表","id":"邻接表","depth":3,"charIndex":383},{"text":"二、操作","id":"二操作","depth":2,"charIndex":510},{"text":"深度优先遍历","id":"深度优先遍历","depth":3,"charIndex":591},{"text":"广度优先遍历","id":"广度优先遍历","depth":3,"charIndex":776},{"text":"三、总结","id":"三总结","depth":2,"charIndex":897},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1051}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对图的理解？相关操作有哪些？","footer":"说说你对图的理解？相关操作有哪些？","order":18,"star":18,"date":"2023-04-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对图的理解？相关操作有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对图的理解？相关操作有哪些？"}]]},"version":""},{"id":99,"title":"前端物语|面试物语-algorithm","content":" * 说说你对算法的理解？应用场景？\n * 说说你对二分查找的理解？如何实现？应用场景？\n * 说说你对堆的理解？如何实现？应用场景？\n * 说说你对链表的理解？常见的操作有哪些？\n * 说说你对冒泡排序的理解？如何实现？应用场景？\n * 说说你对分而治之、动态规划的理解？区别？\n * 说说你对贪心算法、回溯算法的理解？应用场景？\n * 说说你对图的理解？相关操作有哪些？\n * 说说你对插入排序的理解？如何实现？应用场景？\n * 说说你对归并排序的理解？如何实现？应用场景？\n * 说说你对快速排序的理解？如何实现？应用场景？\n * 说说你对选择排序的理解？如何实现？应用场景？\n * 说说你对集合的理解？常见的操作有哪些？\n * 说说常见的排序算法有哪些？区别？\n * 说说你对栈、队列的理解？应用场景？\n * 说说你对数据结构的理解？有哪些？区别？\n * 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？\n * 说说你对树的理解？相关的操作有哪些？","routePath":"/interview/algorithm/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"algorithm","tag":"algorithm","title":"前端物语|面试物语-algorithm","index":false,"dir":{"order":1},"date":"2023-04-16T00:00:00.000Z"},"version":""},{"id":100,"title":"说说你对插入排序的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法\n\n其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据\n\n插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下\n\n然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较\n\n例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：\n\n一开始有序表中无数据，直接插入 3\n\n从第二个数开始，插入一个元素 1，然后和有序表中记录 3 比较，1<3，所以插入到记录 3 的左侧\n\n\n\n向有序表插入记录 7 时，同有序表中记录 3 进行比较，3<7，所以插入到记录 3 的右侧\n\n\n\n向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5<7，同时 5>3，所以插入到 3 和 7 中间\n\n\n\n照此规律，依次将无序表中的记录 4，9 和 6 插入到有序表中\n\n\n\n\n二、如何实现#\n\n将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n\n从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置\n\n如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面\n\n\n\n用代码表示则如下：\n\n\n\n在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)\n\n最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(n^2)\n\n通过上面了解，可以看到插入排序是一种稳定的排序方式\n\n\n三、应用场景#\n\n插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992\n * http://data.biancheng.net/view/65.html","routePath":"/interview/algorithm/insertionSort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":478},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":795},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":857}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对插入排序的理解？如何实现？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对插入排序的理解？如何实现？应用场景？","order":7,"star":7,"date":"2023-03-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对插入排序的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对插入排序的理解？如何实现？应用场景？"}]]},"version":""},{"id":101,"title":"说说你对归并排序的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用\n\n将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序\n\n例如对于含有 n 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）\n\n然后进行两两合并，使 n 个有序表变为n/2 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）\n\n通过不断地进行两两合并，直到得到一个长度为 n 的有序表为止\n\n例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：\n\n如下图所示：\n\n\n\n归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表\n\n上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推\n\n\n二、如何实现#\n\n关于归并排序的算法思路如下：\n\n * 分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字\n\n * 合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组\n   \n   * 合并操作可以新建一个数组，用于存放排序后的数组\n   * 比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中\n   * 如果两个数组还有值，则重复上述第二步\n   * 如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中\n\n\n\n用代码表示则如下图所示：\n\n\n\n上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为 2 乘T(n/2)，合的操作时间复杂度则为O(n)，因此可以得到以下公式：\n\n总的执行时间 = 2 × 输入长度为n/2的sort函数的执行时间 + merge函数的执行时间O(n)\n\n当只有一个元素时，T(1) = O(1)\n\n如果对T(n) = 2 * T(n/2) + O(n)进行左右 / n 的操作，得到 T(n) / n = (n / 2) * T(n/2) + O(1)\n\n现在令 S(n) = T(n)/n，则S(1) = O(1)，然后利用表达式带入得到S(n) = S(n/2) + O(1)\n\n所以可以得到：S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) =\nS(1) + O(logn) = O(logn)\n\n综上可得，T(n) = n * log(n) = nlogn\n\n关于归并排序的稳定性，在进行合并过程，在 1 个或 2 个元素时，1 个元素不会交换，2 个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法\n\n\n三、应用场景#\n\n在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：\n\n * 排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件\n * 归并阶段：将这些临时文件组合为大的有序文件\n\n例如，使用 100m 内存对 900m 的数据进行排序，过程如下：\n\n * 读入 100m 数据内存，用常规方式排序\n * 将排序后的数据写入磁盘\n * 重复前两个步骤，得到 9 个 100m 的临时文件\n * 将 100m 的内存划分为 10 份，将 9 份为输入缓冲区，第 10 份为输出缓冲区\n * 进行九路归并排序，将结果输出到缓冲区\n   * 若输出缓冲区满，将数据写到目标文件，清空缓冲区\n   * 若缓冲区空，读入相应文件的下一份数据\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015\n * https://chowdera.com/2021/09/20210920201630258d.html#_127\n * https://juejin.cn/post/6844904007899561998","routePath":"/interview/algorithm/mergeSort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":388},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1162},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1552}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对归并排序的理解？如何实现？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对归并排序的理解？如何实现？应用场景？","order":6,"star":6,"date":"2023-03-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对归并排序的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对归并排序的理解？如何实现？应用场景？"}]]},"version":""},{"id":102,"title":"说说你对快速排序的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一\n\n实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小\n\n然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列\n\n例如，对无序表 49，38，65，97，76，13，27，49 进行快速排序，大致过程为：\n\n * 首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49\n\n * 将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}\n\n * 以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序\n\n * 前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}\n\n * 此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}\n\n * 通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，9\n   7}\n\n\n二、如何实现#\n\n可以分成以下步骤：\n\n * 分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边\n * 递归：递归地对基准前后的子数组进行分区\n\n\n\n用代码表示则如下：\n\n\n\n快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序\n\n这种情况时间复杂度就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n，也就是O(n^2)\n\n最好情况下是O(nlogn)，其中递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)，推导如下所示：\n\n\n\n关于上述代码实现的快速排序，可以看到是稳定的\n\n\n三、应用场景#\n\n快速排序时间复杂度为O(nlogn)，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6\n   %B3%95/369842\n * https://www.cnblogs.com/l199616j/p/10597245.html","routePath":"/interview/algorithm/quickSort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":711},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1023},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1099}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对快速排序的理解？如何实现？应用场景？","footer":"说说你对快速排序的理解？如何实现？应用场景？","order":12,"star":12,"date":"2023-03-31T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对快速排序的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对快速排序的理解？如何实现？应用场景？"}]]},"version":""},{"id":103,"title":"说说你对选择排序的理解？如何实现？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 O(n²)的时间复杂度，所以用到它的时候，数据规模越小越好\n\n其基本思想是：首先在未排序的数列中找到最小(or 最大)元素，然后将其存放到数列的起始位置\n\n然后再从剩余未排序的元素中继续寻找最小(or 最大)元素，然后放到已排序序列的末尾\n\n以此类推，直到所有元素均排序完毕\n\n举个例子，一个数组为 56、12、80、91、29，其排序过程如下：\n\n * 第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为\n   12、56、80、91、20\n\n\n\n * 第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为 12、20、80、91、56\n\n\n\n * 第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80\n\n\n\n * 第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组\n\n\n\n\n二、如何实现#\n\n从上面可以看到，对于具有 n 个记录的无序表遍历 n-1 次，第i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上\n\n直至到从第n个和第n-1个元素中选出最小的放在第n-1个位置\n\n如下动画所示：\n\n\n\n用代码表示则如下：\n\n\n\n第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较 1 次共比较的次数是 (N - 1) + (N - 2) + ... +\n1，求等差数列和，得 (N - 1 + 1)* N / 2 = N^2 / 2，舍去最高项系数，其时间复杂度为 O(N^2)\n\n从上述也可以看到，选择排序是一种稳定的排序\n\n\n三、应用场景#\n\n和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用\n\n但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418\n * https://zhuanlan.zhihu.com/p/29889599\n * http://data.biancheng.net/view/72.html","routePath":"/interview/algorithm/selectionSort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":2,"charIndex":559},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":869},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":962}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对选择排序的理解？如何实现？应用场景？","footer":"说说你对选择排序的理解？如何实现？应用场景？","order":11,"star":11,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对选择排序的理解？如何实现？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对选择排序的理解？如何实现？应用场景？"}]]},"version":""},{"id":104,"title":"说说你对集合的理解？常见的操作有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素\n\n在数学中，我们经常会遇到集合的概念：\n\n * 有限集合：例如一个班集所有的同学构成的集合\n * 无限集合：例如全体自然数集合\n\n在计算机中集合道理也基本一致，具有三大特性：\n\n * 确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一\n * 无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合\n * 互异性：集合中任意两个元素都是不同的\n\n\n二、操作#\n\n在ES6中，集合本身是一个构建函数Set，用来生成 Set 数据结构，如下：\n\n\n\n关于集合常见的方法有：\n\n * add()：增\n * delete()：删\n * has()：改\n * clear()：查\n\n\nadd()#\n\n添加某个值，返回 Set 结构本身\n\n当添加实例中已经存在的元素，set不会进行处理添加\n\n\n\n体现了集合的互异性特性\n\n\ndelete()#\n\n删除某个值，返回一个布尔值，表示删除是否成功\n\n\n\n\nhas()#\n\n返回一个布尔值，判断该值是否为Set的成员\n\n\n\n\nclear()#\n\n清除所有成员，没有返回值\n\n\n\n关于多个集合常见的操作有：\n\n * 并集\n * 交集\n * 差集\n\n\n并集#\n\n两个集合的共同元素，如下图所示：\n\n\n\n代码实现方式如下：\n\n\n\n\n交集#\n\n两个集合A 和 B，即属于A又属于B的元素，如下图所示：\n\n\n\n用代码标识则如下：\n\n\n\n\n差集#\n\n两个集合A 和 B，属于A的元素但不属于B的元素称为A相对于B的差集，如下图所示：\n\n\n\n代码标识则如下：\n\n\n\n\n三、应用场景#\n\n一般情况下，使用数组的概率会比集合概率高很多\n\n使用set集合的场景一般是借助其确定性，其本身只包含不同的元素\n\n所以，可以利用Set的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86\n * https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86","routePath":"/interview/algorithm/set","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、操作","id":"二操作","depth":2,"charIndex":264},{"text":"add()","id":"add","depth":3,"charIndex":377},{"text":"delete()","id":"delete","depth":3,"charIndex":447},{"text":"has()","id":"has","depth":3,"charIndex":485},{"text":"clear()","id":"clear","depth":3,"charIndex":519},{"text":"并集","id":"并集","depth":3,"charIndex":580},{"text":"交集","id":"交集","depth":3,"charIndex":619},{"text":"差集","id":"差集","depth":3,"charIndex":670},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":733},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":845}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对集合的理解？常见的操作有哪些？","footer":"说说你对集合的理解？常见的操作有哪些？","order":8,"star":8,"date":"2023-03-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对集合的理解？常见的操作有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对集合的理解？常见的操作有哪些？"}]]},"version":""},{"id":105,"title":"说说常见的排序算法有哪些？区别？","content":"#\n\n\n\n\n一、是什么#\n\n排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列\n\n排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的\n\n对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性\n\n时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义\n\n稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变\n\n即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j]\n之前，则称这种排序算法是稳定的；否则称为不稳定的\n\n\n二、有哪些#\n\n常见的算法排序算法有：\n\n * 冒泡排序\n * 选择排序\n * 插入排序\n * 归并排序\n * 快速排序\n\n\n冒泡排序#\n\n一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来\n\n思路如下：\n\n * 比较相邻的元素，如果第一个比第二个大，就交换它们两个\n\n * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n\n * 针对所有的元素重复以上的步骤，除了最后一个\n\n * 重复上述步骤，直到没有任何一堆数字需要比较\n\n\n\n\n选择排序#\n\n选择排序是一种简单直观的排序算法，它也是一种交换排序算法\n\n无论什么数据进去都是 O(n²)的时间复杂度。所以用到它的时候，数据规模越小越好\n\n唯一的好处是不占用额外的内存存储空间\n\n思路如下：\n\n * 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n * 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n * 重复第二步，直到所有元素均排序完毕\n\n\n\n\n插入排序#\n\n插入排序是一种简单直观的排序算法\n\n它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入\n\n解决思路如下：\n\n * 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的\n * 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。\n   ）\n * 重复上述过程直到最后一个元素被插入有序子数组中\n\n\n\n\n归并排序#\n\n归并排序是建立在归并操作上的一种有效的排序算法\n\n该算法是采用分治法的一个非常典型的应用\n\n将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序\n\n解决思路如下：\n\n * 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n * 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n * 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n * 重复步骤 3 直到某一指针到达序列尾\n * 将另一序列剩下的所有元素直接复制到合并序列尾\n\n\n\n\n快速排序#\n\n快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小\n\n再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列\n\n解决思路如下：\n\n * 从数列中挑出一个元素，称为\"基准\"（pivot）\n * 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位\n   置。这个称为分区（partition）操作\n * 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序\n\n\n\n\n三、区别#\n\n除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......\n\n区别如下图所示：\n\n\n\n\n参考文献#\n\n * https://www.runoob.com/w3cnote/bubble-sort.html\n * http://www.x-lab.info/post/sort-algorithm/\n * https://zhuanlan.zhihu.com/p/42586566","routePath":"/interview/algorithm/sort","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":326},{"text":"冒泡排序","id":"冒泡排序","depth":3,"charIndex":389},{"text":"选择排序","id":"选择排序","depth":3,"charIndex":594},{"text":"插入排序","id":"插入排序","depth":3,"charIndex":796},{"text":"归并排序","id":"归并排序","depth":3,"charIndex":1039},{"text":"快速排序","id":"快速排序","depth":3,"charIndex":1308},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1626},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1689}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说常见的排序算法有哪些？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说常见的排序算法有哪些？区别？","order":5,"star":5,"date":"2023-03-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说常见的排序算法有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说常见的排序算法有哪些？区别？"}]]},"version":""},{"id":106,"title":"说说你对栈、队列的理解？应用场景？","content":"#\n\n\n\n\n一、栈#\n\n栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表\n\n表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈\n\n所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用\n\n关于栈的简单实现，如下：\n\n\n\n关于栈的操作主要的方法如下：\n\n * push：入栈操作\n * pop：出栈操作\n\n\n二、队列#\n\n跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作\n\n进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列\n\n在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队\n列又称为先进先出\n\n简单实现一个队列的方式，如下：\n\n\n\n上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用\n\n当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为\"假溢\"\n\n在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：\n\n无论插入或删除，一旦rear指针增 1 或front指针增 1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列\n\n下面实现一个循环队列，如下：\n\n\n\n上述通过求余的形式代表首尾指针增 1 时超出了所分配的队列空间\n\n\n三、应用场景#\n\n\n栈#\n\n借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出\n\n包括编译器的在对输入的语法进行分析的时候，例如\"()\"、\"{}\"、\"[]\"这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括\n号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错\n\n包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值\n\n生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型\n\n\n队列#\n\n当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题\n\n队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）\n\n生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E6%A0%88/12808149\n * https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481","routePath":"/interview/algorithm/stack_queue","lang":"","toc":[{"text":"一、栈","id":"一栈","depth":2,"charIndex":5},{"text":"二、队列","id":"二队列","depth":2,"charIndex":237},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":737},{"text":"栈","id":"栈","depth":3,"charIndex":747},{"text":"队列","id":"队列","depth":3,"charIndex":1054},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1208}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对栈、队列的理解？应用场景？","footer":"说说你对栈、队列的理解？应用场景？","order":15,"star":15,"date":"2023-04-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对栈、队列的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对栈、队列的理解？应用场景？"}]]},"version":""},{"id":107,"title":"说说你对数据结构的理解？有哪些？区别？","content":"#\n\n\n\n\n一、是什么#\n\n数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合\n\n前面讲到，一个程序 = 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率\n\n数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：\n\n * 集合结构：该结构的数据元素间的关系是“属于同一个集合”\n * 线性结构：该结构的数据元素之间存在着一对一的关系\n * 树型结构：该结构的数据元素之间存在着一对多的关系\n * 图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构\n\n由于数据结构种类太多，逻辑结构可以再分成为：\n\n * 线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的\n * 非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联\n\n\n\n\n二、有哪些#\n\n常见的数据结构有如下：\n\n * 数组\n * 栈\n * 队列\n * 链表\n * 树\n * 图\n * 堆\n * 散列表\n\n\n数组#\n\n在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组\n\n\n栈#\n\n一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据\n\n先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据\n\n\n队列#\n\n跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作\n\n\n链表#\n\n是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的\n\n链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成\n\n一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域\n\n\n树#\n\n树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点\n\n\n图#\n\n一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系\n\n\n堆#\n\n堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆\n\n\n散列表#\n\n若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上，不需比较便可直接取得所查记录\n\n\n三、区别#\n\n上述的数据结构，之前的区别可以分成线性结构和非线性结构：\n\n * 线性结构有：数组、栈、队列、链表等\n * 非线性结构有：树、图、堆等\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\n * https://baike.baidu.com/item/数据结构/1450","routePath":"/interview/algorithm/structure","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":440},{"text":"数组","id":"数组","depth":3,"charIndex":508},{"text":"栈","id":"栈","depth":3,"charIndex":578},{"text":"队列","id":"队列","depth":3,"charIndex":665},{"text":"链表","id":"链表","depth":3,"charIndex":727},{"text":"树","id":"树","depth":3,"charIndex":871},{"text":"图","id":"图","depth":3,"charIndex":952},{"text":"堆","id":"堆","depth":3,"charIndex":1026},{"text":"散列表","id":"散列表","depth":3,"charIndex":1087},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1142},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1219}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对数据结构的理解？有哪些？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对数据结构的理解？有哪些？区别？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对数据结构的理解？有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对数据结构的理解？有哪些？区别？"}]]},"version":""},{"id":108,"title":"说说你对算法中时间复杂度，空间复杂度的理解？如何计算？","content":"#\n\n\n\n\n一、前言#\n\n算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有\n很大的区别\n\n衡量不同算法之间的优劣主要是通过时间和空间两个维度去考量：\n\n * 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。\n * 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述\n\n通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的\n\n一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况\n\n最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差\n\n\n二、时间复杂度#\n\n时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否\n\n一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多\n\n算法的复杂度通常用大 O 符号表述，定义为T(n) = O(f(n))，常见的时间复杂度有：O(1)常数型、O(log\nn)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k 次方型、O(2^n)指数型，如下图所示：\n\n\n\n从上述可以看到，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：\n\n\n\n注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长\n\n关于如何计算时间复杂度，可以看看如下简单例子：\n\n\n\n该函数算法需要执行的运算次数用输入大小n的函数表示，即 T(n) = 2 + n + 1，那么时间复杂度为O(n +\n3)，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为O(n)\n\n又比如下面的例子：\n\n\n\n循环里面嵌套循环，外面的循环执行一次，里面的循环执行n次，因此时间复杂度为 O(n*n*1 + 2) = O(n^2)\n\n对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：\n\n\n\n上述第一部分复杂度为O(n)，第二部分复杂度为O(n^2)，总复杂度为max(O(n^2), O(n)) = O(n^2)\n\n又如下一个例子：\n\n\n\n循环语句中以 2 的倍数来逼近n，每次都乘以 2。如果用公式表示就是 1 2 2 2 … 2 <=n，也就是说 2 的x次方小于等于n时会执行循环体，记作2^x\n<= n，于是得出x<=logn\n\n因此循环在执行logn次之后，便结束，因此时间复杂度为O(logn)\n\n同理，如果一个O(n)循环里面嵌套O(logn)的循环，则时间复杂度为O(nlogn)，像O(n^3)无非也就是嵌套了三层O(n)循环\n\n\n三、空间复杂度#\n\n空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量\n\n除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间\n\n下面给出空间复杂度为O(1)的示例，如下\n\n\n\n上述代码的临时空间不会随着n的变化而变化，因此空间复杂度为O(1)\n\n\n\n上述可以看到，随着n的增加，数组的占用的内存空间越大\n\n通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为O(1)，一个一维数组a[n]，空间复杂度O(n)，二维数组为O(n^2)\n\n\n参考文献#\n\n * https://juejin.cn/post/6844904167824162823#heading-7\n\n * https://zhuanlan.zhihu.com/p/50479555\n\n * https://cloud.tencent.com/developer/article/1769988","routePath":"/interview/algorithm/time_space","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、时间复杂度","id":"二时间复杂度","depth":2,"charIndex":352},{"text":"三、空间复杂度","id":"三空间复杂度","depth":2,"charIndex":1267},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1547}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对算法中时间复杂度，空间复杂度的理解？如何计算？","footer":"说说你对算法中时间复杂度，空间复杂度的理解？如何计算？","order":13,"star":13,"date":"2023-04-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对算法中时间复杂度，空间复杂度的理解？如何计算？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对算法中时间复杂度，空间复杂度的理解？如何计算？"}]]},"version":""},{"id":109,"title":"说说你对树的理解？相关的操作有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构\n\n二叉树满足以下两个条件：\n\n * 本身是有序树\n * 树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2\n\n如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过 2，因此不属于二叉树：\n\n\n\n同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：\n\n * 满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2\n\n\n\n * 完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布\n\n\n\n\n二、操作#\n\n关于二叉树的遍历，常见的有：\n\n * 前序遍历\n\n * 中序遍历\n\n * 后序遍历\n\n * 层序遍历\n\n\n前序遍历#\n\n前序遍历的实现思想是：\n\n * 访问根节点\n * 访问当前节点的左子树\n * 若当前节点无左子树，则访问当前节点的右子\n\n根据遍历特性，递归版本用代码表示则如下：\n\n\n\n如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：\n\n\n\n\n中序遍历#\n\n前序遍历的实现思想是：\n\n * 访问当前节点的左子树\n * 访问根节点\n * 访问当前节点的右子\n\n递归版本很好理解，用代码表示则如下：\n\n\n\n非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：\n\n\n\n\n后序遍历#\n\n前序遍历的实现思想是：\n\n * 访问当前节点的左子树\n * 访问当前节点的右子\n * 访问根节点\n\n递归版本，用代码表示则如下：\n\n\n\n后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：\n\n\n\n\n层序遍历#\n\n按照二叉树中的层次从左到右依次遍历每层中的结点\n\n借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先\n后顺序就是层次遍历的最终结果\n\n用代码表示则如下：\n\n\n\n\n三、总结#\n\n树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历\n\n同时，二叉树又分成了完成二叉树和满二叉树\n\n\n参考文献#\n\n * https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91\n * http://data.biancheng.net/view/27.html","routePath":"/interview/algorithm/tree","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、操作","id":"二操作","depth":2,"charIndex":305},{"text":"前序遍历","id":"前序遍历","depth":3,"charIndex":365},{"text":"中序遍历","id":"中序遍历","depth":3,"charIndex":521},{"text":"后序遍历","id":"后序遍历","depth":3,"charIndex":678},{"text":"层序遍历","id":"层序遍历","depth":3,"charIndex":799},{"text":"三、总结","id":"三总结","depth":2,"charIndex":942},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1028}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对树的理解？相关的操作有哪些？","footer":"说说你对树的理解？相关的操作有哪些？","order":14,"star":14,"date":"2023-04-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","algorithm"],"tag":["interview","algorithm"],"shortTitle":"前端物语|面试物语-说说你对树的理解？相关的操作有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对树的理解？相关的操作有哪些？"}]]},"version":""},{"id":110,"title":"前端物语|面试物语-applet","content":" * 说说微信小程序的实现原理？\n * 说说你对微信小程序的理解？优缺点？\n * 说说微信小程序的生命周期函数有哪些？\n * 说说微信小程序的登录流程？\n * 说说微信小程序中路由跳转的方式有哪些？区别？\n * 说说提高微信小程序的应用速度的手段有哪些？\n * 说说微信小程序的发布流程？\n * 说说微信小程序的支付流程？","routePath":"/interview/applet/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"applet","tag":"applet","title":"前端物语|面试物语-applet","index":false,"dir":{"order":1},"date":"2023-03-26T00:00:00.000Z"},"version":""},{"id":111,"title":"说说微信小程序的实现原理？","content":"#\n\n\n\n\n一、背景#\n\n网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 JS 是单线程的\n\n而在小程序中，选择了 Hybrid 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 WebView 进行渲染，逻辑层运行在 JSCore\n中\n\n\n\n * 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程\n * 逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码\n\n\n二、通信#\n\n小程序在渲染层，宿主环境会把wxml转化成对应的JS对象\n\n在逻辑层发生数据变更的时候，通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的视图\n\n\n\n当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户\n\n对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给JavaScript进行处理\n\n\n\n由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作\n\n异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来\n\n如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作\n\n因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信\n\n\n\n\n三、运行机制#\n\n小程序启动运行两种情况：\n\n * 冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动\n * 热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动\n\n需要注意#\n\n> 1.小程序没有重启的概念 2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁\n> 3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了\n\n\n\n开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户\n\n每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上\n\n\n参考文献#\n\n * https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30\n   fe3eb863b2750813\n * https://juejin.cn/post/6976805521407868958#heading-5\n * https://juejin.cn/post/6844903805675388942\n * https://juejin.cn/post/6844903999863259144#heading-1","routePath":"/interview/applet/WebView_jscore","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、通信","id":"二通信","depth":2,"charIndex":285},{"text":"三、运行机制","id":"三运行机制","depth":2,"charIndex":756},{"text":"需要注意","id":"需要注意","depth":4,"charIndex":911},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1182}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序的实现原理？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说微信小程序的实现原理？","order":3,"star":3,"date":"2023-03-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序的实现原理？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序的实现原理？"}]]},"version":""},{"id":112,"title":"说说你对微信小程序的理解？优缺点？","content":"#\n\n\n\n\n一、是什么#\n\n2017 年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务\n\n截至目前，小程序已经成为国内前端的一个重要业务，跟 Web 和手机 App 有着同等的重要性\n\n\n\n小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用\n\n也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载\n\n注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序\n\n\n二、背景#\n\n⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 WebView 逐渐成为移动 Web的⼀个重要⼊⼝时，微信就有相关的 JS-SDK\n\nJS-SDK 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 Web\n开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，JS-SDK的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题\n\n因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：\n\n * 快速的加载\n * 更强⼤的能⼒\n * 原⽣的体验\n * 易⽤且安全的微信数据开放\n * ⾼效和简单的开发\n\n这些是JS-SDK做不到的，需要设计一个全新的小程序系统\n\n对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者开发出具有原生体验的服务\n\n其中相比H5，小程序与其的区别有如下：\n\n * 运⾏环境：⼩程序基于浏览器内核重构的内置解析器\n * 系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等\n * 渲染机制：⼩程序的逻辑层和渲染层是分开的\n\n小程序可以视为只能用微信打开和浏览的H5，小程序和网页的技术模型是一样的，用到的 JavaScript 语言和 CSS 样式也是一样的，只是网页的 HTML\n标签被稍微修改成了 WXML 标签\n\n因此可以说，小程序页面本质上就是网页\n\n其中关于微信小程序的实现原理，我们在后面的文章讲到\n\n\n三、优缺点#\n\n优点：\n\n * 随搜随用，用完即走：使得小程序可以代替许多 APP，或是做 APP 的整体嫁接，或是作为阉割版功能的承载体\n * 流量大，易接受：小程序借助自身平台更加容易引入更多的流量\n * 安全\n * 开发门槛低\n * 降低兼容性限制\n\n缺点：\n\n * 用户留存：及相关数据显示，小程序的平均次日留存在 13%左右，但是双周留存骤降到仅有 1%\n * 体积限制：微信小程序只有 2M 的大小，这样导致无法开发大型一些的小程序\n * 受控微信：比起 APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控\n\n\n参考文献#\n\n * https://developers.weixin.qq.com/miniprogram/dev/framework/\n * https://www.zhihu.com/question/263816362","routePath":"/interview/applet/applet","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、背景","id":"二背景","depth":2,"charIndex":285},{"text":"三、优缺点","id":"三优缺点","depth":2,"charIndex":889},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1181}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对微信小程序的理解？优缺点？","footer":"说说你对微信小程序的理解？优缺点？","order":6,"star":6,"date":"2023-03-20T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说你对微信小程序的理解？优缺点？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对微信小程序的理解？优缺点？"}]]},"version":""},{"id":113,"title":"前端物语|面试物语-applet","content":" * 说说微信小程序的实现原理？\n * 说说你对微信小程序的理解？优缺点？\n * 说说微信小程序的生命周期函数有哪些？\n * 说说微信小程序的登录流程？\n * 说说微信小程序中路由跳转的方式有哪些？区别？\n * 说说提高微信小程序的应用速度的手段有哪些？\n * 说说微信小程序的发布流程？\n * 说说微信小程序的支付流程？","routePath":"/interview/applet/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"applet","tag":"applet","title":"前端物语|面试物语-applet","index":false,"dir":{"order":1},"date":"2023-03-26T00:00:00.000Z"},"version":""},{"id":114,"title":"说说微信小程序的生命周期函数有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n跟vue、react框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数\n\n小程序中，生命周期主要分成了三部分：\n\n * 应用的生命周期\n * 页面的生命周期\n * 组件的生命周期\n\n\n应用的生命周期#\n\n小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调\n\n\n页面的生命周期#\n\n页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过App(Object)函数用来注册一个页面\n\n\n组件的生命周期#\n\n组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件\n\n\n二、有哪些#\n\n\n应用的生命周期#\n\n生命周期                     说明\nonLaunch                 小程序初始化完成时触发，全局只触发一次\nonShow                   小程序启动，或从后台进入前台显示时触发\nonHide                   小程序从前台进入后台时触发\nonError                  小程序发生脚本错误或 API 调用报错时触发\nonPageNotFound           小程序要打开的页面不存在时触发\nonUnhandledRejection()   小程序有未处理的 Promise 拒绝时触发\nonThemeChange            系统切换主题时触发\n\n\n页面的生命周期#\n\n生命周期       说明                  作用\nonLoad     生命周期回调—监听页面加载       发送请求获取数据\nonShow     生命周期回调—监听页面显示       请求数据\nonReady    生命周期回调—监听页面初次渲染完成   获取页面元素（少用）\nonHide     生命周期回调—监听页面隐藏       终止任务，如定时器或者播放音乐\nonUnload   生命周期回调—监听页面卸载       终止任务\n\n\n组件的生命周期#\n\n生命周期       说明\ncreated    生命周期回调—监听页面加载\nattached   生命周期回调—监听页面显示\nready      生命周期回调—监听页面初次渲染完成\nmoved      生命周期回调—监听页面隐藏\ndetached   生命周期回调—监听页面卸载\nerror      每当组件方法抛出错误时执行\n\n注意的是：\n\n * 组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data ，\n   此时不能调用 setData\n * 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data\n   已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行\n * 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发\n\n还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在\npageLifetimes 定义段中定义，如下：\n\n生命周期   说明\nshow   组件所在的页面被展示时执行\nhide   组件所在的页面被隐藏时执行\n\n代码如下：\n\n\n\n\n三、执行过程#\n\n\n应⽤的⽣命周期执行过程#\n\n * ⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）\n\n * ⼩程序初始化完成后，触发 onShow ⽅法，监听⼩程序显示\n\n * ⼩程序从前台进⼊后台，触发 onHide ⽅法\n\n * ⼩程序从后台进⼊前台显示，触发 onShow ⽅法\n\n * ⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁\n\n\n⻚⾯⽣命周期的执行过程#\n\n * ⼩程序注册完成后，加载⻚⾯，触发 onLoad ⽅法\n * ⻚⾯载⼊后触发 onShow ⽅法，显示⻚⾯\n * ⾸次显示⻚⾯，会触发 onReady ⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次\n * 当⼩程序后台运⾏或跳转到其他⻚⾯时，触发 onHide ⽅法\n * 当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发 onShow ⽅法\n * 当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚ wx.navigateBack()，触发 onUnload\n\n当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：\n\n * 打开小程序：(App)onLaunch --> (App)onShow --> (Pages)onLoad --> (Pages)onShow -->\n   (pages)onRead\n\n * 进入下一个页面：(Pages)onHide --> (Next)onLoad --> (Next)onShow --> (Next)onReady\n\n * 返回上一个页面：(curr)onUnload --> (pre)onShow\n\n * 离开小程序：(App)onHide\n\n * 再次进入：小程序未销毁 --> (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch 重新开始执行.\n\n\n参考文献#\n\n * https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLau\n   nch-Object-object\n * https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLo\n   ad-Object-query\n * https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLau\n   nch-Object-object","routePath":"/interview/applet/lifecycle","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"应用的生命周期","id":"应用的生命周期","depth":3,"charIndex":117},{"text":"页面的生命周期","id":"页面的生命周期","depth":3,"charIndex":192},{"text":"组件的生命周期","id":"组件的生命周期","depth":3,"charIndex":271},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":360},{"text":"应用的生命周期","id":"应用的生命周期-1","depth":3,"charIndex":369},{"text":"页面的生命周期","id":"页面的生命周期-1","depth":3,"charIndex":710},{"text":"组件的生命周期","id":"组件的生命周期-1","depth":3,"charIndex":957},{"text":"三、执行过程","id":"三执行过程","depth":2,"charIndex":1572},{"text":"应⽤的⽣命周期执行过程","id":"应的命周期执行过程","depth":3,"charIndex":1582},{"text":"⻚⾯⽣命周期的执行过程","id":"命周期的执行过程","depth":3,"charIndex":1756},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2358}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序的生命周期函数有哪些？","footer":"说说微信小程序的生命周期函数有哪些？","order":7,"star":7,"date":"2023-03-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序的生命周期函数有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序的生命周期函数有哪些？"}]]},"version":""},{"id":115,"title":"说说微信小程序的登录流程？","content":"#\n\n\n\n\n一、背景#\n\n传统的web开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录\n\n服务端校验用户信息通过之后，下发一个代表登录态的 token 给客户端，以便进行后续的交互,每当token过期，用户都需要重新登录\n\n而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能\n\n实现小程序用户体系主要涉及到openid和code的概念：\n\n * 调用wx.login()方法会生成code，将code作为参数传递给微信服务器指定接口，就可以获取用户的openid\n\n对于每个小程序，微信都会将用户的微信ID映射出一个小程序 openid，作为这个用户在这个小程序的唯一标识\n\n\n二、流程#\n\n微信小程序登陆具体实现的逻辑如下图所示：\n\n\n\n * 通过 wx.login() 获取到用户的 code 判断用户是否授权读取用户信息，调用 wx.getUserInfo 读取用户数据\n * 由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息\n * 通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和\n   appsecret 都是微信提供的，可以在管理员后台找到\n * 微信服务器返回了 openid 及本次登录的会话密钥 session_key\n * 后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走\n * session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输\n * 然后生成 session 并返回给小程序\n * 小程序把 session 存到 storage 里面\n * 下次请求时，先从 storage 里面读取，然后带给服务端\n * 服务端对比 session 对应的记录，然后校验有效期\n\n更加详细的功能图如下所示：\n\n\n\n\n三、扩展#\n\n实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间\n或时间服务器上的标准时间）做对比\n\n这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程\n\n另一种方式可以通过调用wx.checkSession检查微信登陆态是否过期：\n\n * 如果过期，则发起完整的登录流程\n * 如果不过期，则继续使用本地保存的自定义登录态\n\n这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用 AP，流程如下所示：\n\n\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000016750340\n * https://juejin.cn/post/6955754095860776973\n * https://www.cnblogs.com/zwh0910/p/13977278.html","routePath":"/interview/applet/login","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":341},{"text":"三、扩展","id":"三扩展","depth":2,"charIndex":892},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1190}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序的登录流程？","footer":"说说微信小程序的登录流程？","order":4,"star":4,"date":"2023-03-15T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序的登录流程？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序的登录流程？"}]]},"version":""},{"id":116,"title":"说说微信小程序中路由跳转的方式有哪些？区别？","content":"#\n\n\n\n\n一、是什么#\n\n微信小程序拥有web网页和Application共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能\n\n在微信小程序中，每个页面可以看成是一个pageModel，pageModel全部以栈的形式进行管理\n\n\n二、有哪些#\n\n常见的微信小程序页面跳转方式有如下：\n\n * wx.navigateTo(Object)\n * wx.redirectTo(Object)\n * wx.switchTab(Object)\n * wx.navigateBack(Object)\n * wx.reLaunch(Object)\n\n\nwx.navigateTo(Object)#\n\nwx.navigateTo()用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面\n\n对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用\n\n参数表如下所示：\n\n\n\n流程图如下：\n\n\n\n\nwx.redirectTo(Object)#\n\n重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 wx.redirectTo\n\nwx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面\n\n这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间\n\n参数表如下所示：\n\n\n\n流程图如下所示：\n\n\n\n\nwx.switchTab(Object)#\n\n跳转到 tabBar页面，并关闭其他所有非 tabBar 页面\n\n参数表如下所示：\n\n\n\n\nwx.navigateBack(Object)#\n\nwx.navigateBack() 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 getCurrentPages()\n获取当前的页面栈，决定需要返回几层则设置对象的delta属性即可\n\n参数表如下：\n\n\n\n\nwx.reLaunch(Object)#\n\n关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页\n\n流程图如下所示：\n\n\n\n参数表如下所示：\n\n\n\n\n三、总结#\n\n关于上述五种跳转方式，做下总结：\n\n * navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页\n * redirectTo 关闭当前页面，跳转到应用内的某个页面\n * switchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面\n * navigateBack 返回上一页面\n * reLanch 关闭所有页面，打开到应用内的某个页面\n\n其中关于它们的页面栈的关系如下：\n\n * avigateTo 新页面入栈\n\n * redirectTo 当前页面出栈，新页面入栈\n\n * navigateBack 页面不断出栈，直到目标返回页，新页面入栈\n\n * switchTab 页面全部出栈，只留下新的 Tab 页面\n\n * reLanch 页面全部出栈，只留下新的页面\n\n\n参考文献#\n\n * https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.ht\n   ml","routePath":"/interview/applet/navigate","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":135},{"text":"wx.navigateTo(Object)","id":"wxnavigatetoobject","depth":3,"charIndex":289},{"text":"wx.redirectTo(Object)","id":"wxredirecttoobject","depth":3,"charIndex":472},{"text":"wx.switchTab(Object)","id":"wxswitchtabobject","depth":3,"charIndex":685},{"text":"wx.navigateBack(Object)","id":"wxnavigatebackobject","depth":3,"charIndex":754},{"text":"wx.reLaunch(Object)","id":"wxrelaunchobject","depth":3,"charIndex":890},{"text":"三、总结","id":"三总结","depth":2,"charIndex":967},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1350}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序中路由跳转的方式有哪些？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说微信小程序中路由跳转的方式有哪些？区别？","order":1,"star":1,"date":"2023-02-25T05:08:15.341Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序中路由跳转的方式有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序中路由跳转的方式有哪些？区别？"}]]},"version":""},{"id":117,"title":"说说提高微信小程序的应用速度的手段有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n小程序启动会常常遇到如下图场景：\n\n\n\n这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化\n\n然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：\n\n * 下载小程序代码包\n * 加载小程序代码包\n * 初始化小程序首页\n\n下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包\n\n整体流程如下图：\n\n\n\n\n二、手段#\n\n围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：\n\n\n加载#\n\n提升体验最直接的方法是控制小程序包的大小，常见手段有如下：\n\n * 代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项\n\n * 及时清理无用的代码和资源文件\n\n * 减少资源包中的图片等资源的数量和大小（理论上除了小 icon，其他图片资源从网络下载），图片资源压缩率有限\n\n并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载\n\n当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包\n页面后在下载子包\n\n\n\n\n渲染#\n\n关于微信小程序首屏渲染优化的手段如下：\n\n * 请求可以在页面 onLoad 就加载，不需要等页面 ready 后在异步请求数据\n * 尽量减少不必要的 https 请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地\n * 可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位\n\n在微信小程序中，提高页面的多次渲染效率主要在于正确使用setData：\n\n * 不要过于频繁调用 setData，应考虑将多次 setData 合并成一次 setData 调用\n * 数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据\n * 与界面渲染无关的数据最好不要设置在 data 中，可以考虑设置在 page 对象的其他字段下\n\n除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新\n\n各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用\n\n\n三、总结#\n\n小程序启动加载性能：\n\n * 控制代码包的大小\n * 分包加载\n * 首屏体验（预请求，利用缓存，避免白屏，及时反馈\n\n小程序渲染性能：\n\n * 避免不当的使用 setData\n * 使用自定义组件\n\n\n参考文献#\n\n * https://juejin.cn/post/6969779451177484296\n * https://segmentfault.com/a/1190000008925450\n * https://juejin.cn/post/6844903638226173965\n * https://juejin.cn/post/6844903726939897869","routePath":"/interview/applet/optimization","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、手段","id":"二手段","depth":2,"charIndex":243},{"text":"加载","id":"加载","depth":3,"charIndex":286},{"text":"渲染","id":"渲染","depth":3,"charIndex":582},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1105},{"text":"参考文献","id":"参考文献","depth":3,"charIndex":1214}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说提高微信小程序的应用速度的手段有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说提高微信小程序的应用速度的手段有哪些？","order":3,"star":3,"date":"2023-02-26T10:08:48.415Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说提高微信小程序的应用速度的手段有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说提高微信小程序的应用速度的手段有哪些？"}]]},"version":""},{"id":118,"title":"说说微信小程序的发布流程？","content":"#\n\n\n\n\n一、背景#\n\n在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个\n团队的协同工作\n\n\n\n以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问\n\n在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序\n\n\n\n\n二、流程#\n\n关于发布的流程，主要分成了三个部分：\n\n * 上传代码\n * 提交审核\n * 发布版本\n\n\n上传代码#\n\n在开发者工具中，可以点击代码上传功能：\n\n\n\n然后就可以填写版本信息：\n\n\n\n然后点击上传，编译器则会提示上传代码成功\n\n\n提交审核#\n\n代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：\n\n\n\n提交审核过程需要填写审核信息，如下图：\n\n\n\n提交审核成功之后如下图：\n\n\n\n\n发布版本#\n\n当审核通过之后，即可提交发布\n\n\n\n发布成功之后则如下：\n\n\n\n\n三、扩展#\n\n上述是最简单的小程序代码发布的流程，通常的流程如下：\n\n * 代码管理服务器上新建分支\n * 开发测试新需求\n * 测试完成后，将本地分支合并到 master 分支\n * 拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件\n * 开发者工具点击“上传”\n * 提审\n * 发布\n\n但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到master的情况\n\n因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：\n\n\n\n\n参考文献#\n\n * https://juejin.cn/post/6994414162700927012\n * https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html","routePath":"/interview/applet/publish","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":203},{"text":"上传代码","id":"上传代码","depth":3,"charIndex":256},{"text":"提交审核","id":"提交审核","depth":3,"charIndex":325},{"text":"发布版本","id":"发布版本","depth":3,"charIndex":415},{"text":"三、扩展","id":"三扩展","depth":2,"charIndex":455},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":742}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序的发布流程？","footer":"说说微信小程序的发布流程？","order":8,"star":8,"date":"2023-03-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序的发布流程？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序的发布流程？"}]]},"version":""},{"id":119,"title":"说说微信小程序的支付流程？","content":"#\n\n\n\n\n一、前言#\n\n微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能\n\n在小程序内可调用微信的API完成支付功能，方便、快捷\n\n场景如下图所示：\n\n\n\n\n\n * 用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程\n * 调起微信支付控件，用户开始输入支付密码\n * 密码验证通过，支付成功。商户后台得到支付成功的通知\n * 返回商户小程序，显示购买成功\n * 微信支付公众号下发支付凭证\n\n\n二、流程#\n\n以电商小程序为例\n\n支付流程图如下所示：\n\n\n\n具体的做法：\n\n * 打开某小程序，点击直接下单\n * wx.login 获取用户临时登录凭证 code，发送到后端服务器换取 openId\n * 在下单时，小程序需要将购买的商品 Id，商品数量，以及用户的 openId 传送到服务器\n * 服务器在接收到商品 Id、商品数量、openId\n   后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序\n   端响应必要的信息\n * 小程序端在获取对应的参数后，调用 wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付\n * 接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付\n * 鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示\n * 推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态\n\n其中后端响应数据必要的信息则是wx.requestPayment方法所需要的参数，大致如下：\n\n\n\n参数表如下所示：\n\n\n\n\n三、结束#\n\n小程序支付和以往的网页、APP 微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作\n\n\n参考文献#\n\n * https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml\n * https://juejin.cn/post/6844903895970349064","routePath":"/interview/applet/requestPayment","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、流程","id":"二流程","depth":2,"charIndex":213},{"text":"三、结束","id":"三结束","depth":2,"charIndex":776},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":844}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说微信小程序的支付流程？","footer":"说说微信小程序的支付流程？","order":5,"star":5,"date":"2023-03-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","applet"],"tag":["interview","applet"],"shortTitle":"前端物语|面试物语-说说微信小程序的支付流程？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说微信小程序的支付流程？"}]]},"version":""},{"id":120,"title":"谈谈你对 BFC 的理解？","content":"Haha\n\nHehe\n\nHaha\n\nHehe\n\n\n\n","routePath":"/interview/css/BFC","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":-1},{"text":"二、触发条件","id":"二触发条件","depth":2,"charIndex":-1},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":-1},{"text":"防止 margin 重叠（塌陷）","id":"防止-margin-重叠塌陷","depth":4,"charIndex":-1},{"text":"清除内部浮动","id":"清除内部浮动","depth":4,"charIndex":-1},{"text":"自适应多栏布局","id":"自适应多栏布局","depth":4,"charIndex":-1},{"text":"小结","id":"小结","depth":3,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-谈谈你对 BFC 的理解？","footer":"谈谈你对 BFC 的理解？","order":18,"star":18,"date":"2023-04-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-谈谈你对 BFC 的理解？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"谈谈你对 BFC 的理解？"}]]},"version":""},{"id":121,"title":"前端物语|面试物语-css","content":" * 谈谈你对 BFC 的理解？\n * css3 动画有哪些？\n * 说说你对盒子模型的理解?\n * 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？\n * 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？\n * CSS3 新增了哪些新特性？\n * 如果要做优化，CSS 提高性能的方法有哪些？\n * 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？\n * 说说 em/px/rem/vh/vw 区别?\n * 说说 flexbox（弹性盒布局模型）,以及适用场景？\n * 介绍一下 grid 网格布局\n * css 中，有哪些方式可以隐藏页面元素？区别?\n * 怎么理解回流跟重绘？什么场景下会触发？\n * 让 Chrome 支持小于 12px 的文字方式有哪些？区别？\n * 什么是响应式设计？响应式设计的基本原理是什么？如何做？\n * 说说对 Css 预编语言的理解？有哪些区别?\n * 如何实现单行／多行文本溢出的省略样式？\n * CSS 如何画一个三角形？原理是什么？\n * 如何使用 css 完成视差滚动效果?","routePath":"/interview/css/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"css","tag":"css","title":"前端物语|面试物语-css","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":122,"title":"css3 动画有哪些？","content":"#\n\n\n\n\n一、是什么#\n\nCSS 动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用 CSS 的动画的模块\n\n即指元素从一种样式逐渐过渡为另一种样式的过程\n\n常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合\n\ncss实现动画的方式，有如下几种：\n\n * transition 实现渐变动画\n * transform 转变动画\n * animation 实现自定义动画\n\n\n二、实现方式#\n\n\ntransition 实现渐变动画#\n\ntransition的属性如下：\n\n * property:填写需要变化的 css 属性\n * duration:完成过渡效果需要的时间单位(s 或者 ms)\n * timing-function:完成效果的速度曲线\n * delay: 动画效果的延迟触发时间\n\n其中timing-function的值有如下：\n\n值                       描述\nlinear                  匀速（等于 cubic-bezier(0,0,1,1)）\nease                    从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)）\nease-in                 慢慢变快（等于 cubic-bezier(0.42,0,1,1)）\nease-out                慢慢变慢（等于 cubic-bezier(0,0,0.58,1)）\nease-in-out             先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果\ncubic-bezier(n,n,n,n)   在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值\n\n注意：并不是所有的属性都能使用过渡的，如display:none<->display:block\n\n举个例子，实现鼠标移动上去发生变化动画效果\n\n\n\n\ntransform 转变动画#\n\n包含四个常用的功能：\n\n * translate：位移\n * scale：缩放\n * rotate：旋转\n * skew：倾斜\n\n一般配合transition过度使用\n\n注意的是，transform不支持inline元素，使用前把它变成block\n\n举个例子\n\n\n\n可以看到盒子发生了旋转，倾斜，平移，放大\n\n\nanimation 实现自定义动画#\n\nanimation是由 8 个属性的简写，分别如下：\n\n属性                              描述                                    属性值\nanimation-duration              指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0   \nanimation-timing-function       指定动画计时函数，即动画的速度曲线，默认是 \"ease\"          linear、ease、ease-in、ease-out、ease-in-out\nanimation-delay                 指定动画延迟时间，即动画何时开始，默认是 0                \nanimation-iteration-count       指定动画播放的次数，默认是 1                       \nanimation-direction 指定动画播放的方向   默认是 normal                            normal、reverse、alternate、alternate-reverse\nanimation-fill-mode             指定动画填充模式。默认是 none                     forwards、backwards、both\nanimation-play-state            指定动画播放状态，正在运行或暂停。默认是 running          running、pauser\nanimation-name                  指定 @keyframes 动画的名称                   \n\nCSS 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来，\n\n通过 @keyframes 来定义关键帧\n\n因此，如果我们想要让元素旋转一圈，只需要定义开始和结束两帧即可：\n\n\n\nfrom 表示最开始的那一帧，to 表示结束时的那一帧\n\n也可以使用百分比刻画生命周期\n\n\n\n定义好了关键帧后，下来就可以直接用它了：\n\n\n\n\n三、总结#\n\n属性               含义\ntransition（过度）   用于设置元素的样式过度，和 animation 有着类似的效果，但细节上有很大的不同\ntransform（变形）    用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于 color 一样用来设置元素的“外表”\ntranslate（移动）    只是 transform 的一个属性值，即移动\nanimation（动画）    用于设置动画属性，他是一个简写的属性，包含 6 个属性\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000022540857\n * https://zh.m.wikipedia.org/wiki/CSS%E5%8A%A8%E7%94%BB","routePath":"/interview/css/animation","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":221},{"text":"transition 实现渐变动画","id":"transition-实现渐变动画","depth":3,"charIndex":231},{"text":"transform 转变动画","id":"transform-转变动画","depth":3,"charIndex":881},{"text":"animation 实现自定义动画","id":"animation-实现自定义动画","depth":3,"charIndex":1054},{"text":"三、总结","id":"三总结","depth":2,"charIndex":2037},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2288}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-css3 动画有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>css3 动画有哪些？","order":3,"star":3,"date":"2023-02-26T00:47:56.517Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-css3 动画有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"css3 动画有哪些？"}]]},"version":""},{"id":123,"title":"说说你对盒子模型的理解?","content":"#\n\n\n\n\n一、是什么#\n\n当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box\nmodel），将所有元素表示为一个个矩形的盒子（box）\n\n一个盒子由四个部分组成：content、padding、border、margin\n\n\n\ncontent，即实际内容，显示文本和图像\n\nboreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成\n\npadding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响\n\nmargin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域\n\n上述是一个从二维的角度观察盒子，下面再看看看三维图：\n\n\n\n下面来段代码：\n\n\n\n当我们在浏览器查看元素时，却发现元素的大小变成了240px\n\n这是因为，在CSS中，盒子模型可以分成：\n\n * W3C 标准盒子模型\n * IE 怪异盒子模型\n\n默认情况下，盒子模型为W3C 标准盒子模型\n\n\n二、标准盒子模型#\n\n标准盒子模型，是浏览器默认的盒子模型\n\n下面看看标准盒子模型的模型图：\n\n\n\n从上图可以看到：\n\n * 盒子总宽度 = width + padding + border + margin;\n\n * 盒子总高度 = height + padding + border + margin\n\n也就是，width/height 只是内容高度，不包含 padding 和 border值\n\n所以上面问题中，设置width为 200px，但由于存在padding，但实际上盒子的宽度有 240px\n\n\n三、IE 怪异盒子模型#\n\n同样看看 IE 怪异盒子模型的模型图：\n\n\n\n从上图可以看到：\n\n * 盒子总宽度 = width + margin;\n\n * 盒子总高度 = height + margin;\n\n也就是，width/height 包含了 padding和 border值\n\n\nBox-sizing#\n\nCSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度\n\n语法：\n\n\n\n * content-box 默认值，元素的 width/height 不包含 padding，border，与标准盒子模型表现一致\n * border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致\n * inherit 指定 box-sizing 属性的值，应该从父元素继承\n\n回到上面的例子里，设置盒子为 border-box 模型\n\n\n\n这时候，就可以发现盒子的所占据的宽度为 200px\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Introduction_t\n   o_the_CSS_box_model\n * https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing","routePath":"/interview/css/box","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、标准盒子模型","id":"二标准盒子模型","depth":2,"charIndex":466},{"text":"三、IE 怪异盒子模型","id":"三ie-怪异盒子模型","depth":2,"charIndex":722},{"text":"Box-sizing","id":"box-sizing","depth":2,"charIndex":866},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1159}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对盒子模型的理解?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对盒子模型的理解?","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说你对盒子模型的理解?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对盒子模型的理解?"}]]},"version":""},{"id":124,"title":"元素水平垂直居中的方法有哪些？如果元素不定宽高呢？","content":"#\n\n\n\n\n一、背景#\n\n在开发中经常遇到这个问题，即让某个元素的内容在水平和垂直方向上都居中，内容不仅限于文字，可能是图片或其他元素\n\n居中是一个非常基础但又是非常重要的应用场景，实现居中的方法存在很多，可以将这些方法分成两个大类：\n\n * 居中元素（子元素）的宽高已知\n * 居中元素宽高未知\n\n\n二、实现方式#\n\n实现元素水平垂直居中的方式：\n\n * 利用定位+margin:auto\n\n * 利用定位+margin:负值\n\n * 利用定位+transform\n\n * table 布局\n\n * flex 布局\n\n * grid 布局\n\n\n利用定位+margin:auto#\n\n先上代码：\n\n\n\n父级设置为相对定位，子级绝对定位 ，并且四个定位属性的值都设置了 0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样宽高\n\n这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给它一个margin：auto它就可以上下左右都居中了\n\n\n利用定位+margin:负值#\n\n绝大多数情况下，设置父元素为相对定位， 子元素移动自身 50%实现水平垂直居中\n\n\n\n整个实现思路如下图所示：\n\n\n\n * 初始位置为方块 1 的位置\n * 当设置 left、top 为 50%的时候，内部子元素为方块 2 的位置\n * 设置 margin 为负数时，使内部子元素到方块 3 的位置，即中间位置\n\n这种方案不要求父元素的高度，也就是即使父元素的高度变化了，仍然可以保持在父元素的垂直居中位置，水平方向上是一样的操作\n\n但是该方案需要知道子元素自身的宽高，但是我们可以通过下面transform属性进行移动\n\n\n利用定位+transform#\n\n实现代码如下：\n\n\n\ntranslate(-50%, -50%)将会将元素位移自己宽度和高度的-50%\n\n这种方法其实和最上面被否定掉的 margin 负值用法一样，可以说是margin负值的替代方案，并不需要知道自身元素的宽高\n\n\ntable 布局#\n\n设置父元素为display:table-cell，子元素设置 display:\ninline-block。利用vertical和text-align可以让所有的行内块级元素水平垂直居中\n\n\n\n\nflex 弹性布局#\n\n还是看看实现的整体代码：\n\n\n\ncss3中了flex布局，可以非常简单实现垂直水平居中\n\n这里可以简单看看flex布局的关键属性作用：\n\n * display: flex 时，表示该容器内部的元素将按照 flex 进行布局\n\n * align-items: center 表示这些元素将相对于本容器水平居中\n\n * justify-content: center 也是同样的道理垂直居中\n\n\ngrid 网格布局#\n\n\n\n这里看到，gird网格布局和flex弹性布局都简单粗暴\n\n\n小结#\n\n上述方法中，不知道元素宽高大小仍能实现水平垂直居中的方法有：\n\n * 利用定位+margin:auto\n * 利用定位+transform\n * flex 布局\n * grid 布局\n\n\n三、总结#\n\n根据元素标签的性质，可以分为：\n\n * 内联元素居中布局\n * 块级元素居中布局\n\n\n内联元素居中布局#\n\n水平居中\n\n * 行内元素可设置：text-align: center\n * flex 布局设置父元素：display: flex; justify-content: center\n\n垂直居中\n\n * 单行文本父元素确认高度：height === line-height\n * 多行文本父元素确认高度：display: table-cell; vertical-align: middle\n\n\n块级元素居中布局#\n\n水平居中\n\n * 定宽: margin: 0 auto\n * 绝对定位+left:50%+margin:负自身一半\n\n垂直居中\n\n * position: absolute 设置 left、top、margin-left、margin-top(定高)\n * display: table-cell\n * transform: translate(x, y)\n * flex(不定高，不定宽)\n * grid(不定高，不定宽)，兼容性相对比较差\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903982960214029#heading-10","routePath":"/interview/css/center","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":150},{"text":"利用定位+margin:auto","id":"利用定位marginauto","depth":3,"charIndex":272},{"text":"利用定位+margin:负值","id":"利用定位margin负值","depth":3,"charIndex":449},{"text":"利用定位+transform","id":"利用定位transform","depth":3,"charIndex":729},{"text":"table 布局","id":"table-布局","depth":3,"charIndex":863},{"text":"flex 弹性布局","id":"flex-弹性布局","depth":3,"charIndex":971},{"text":"grid 网格布局","id":"grid-网格布局","depth":3,"charIndex":1179},{"text":"小结","id":"小结","depth":3,"charIndex":1223},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1322},{"text":"内联元素居中布局","id":"内联元素居中布局","depth":3,"charIndex":1372},{"text":"块级元素居中布局","id":"块级元素居中布局","depth":3,"charIndex":1580},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1815}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>元素水平垂直居中的方法有哪些？如果元素不定宽高呢？","order":8,"star":8,"date":"2023-03-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"}]]},"version":""},{"id":125,"title":"如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？","content":"#\n\n\n\n\n一、背景#\n\n在日常布局中，无论是两栏布局还是三栏布局，使用的频率都非常高\n\n\n两栏布局#\n\n两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满，\n\n比如 Ant Design 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器\n\n> 这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器\n\n\n\n这种布局适用于内容上具有明显主次关系的网页\n\n\n三栏布局#\n\n三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之\n\n大家最常见的就是github：\n\n\n\n\n二、两栏布局#\n\n两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在\n\n实现思路也非常的简单：\n\n * 使用 float 左浮左边栏\n * 右边模块使用 margin-left 撑出内容块做内容展示\n * 为父级元素添加 BFC，防止下方元素飞到上方内容\n\n代码如下：\n\n\n\n还有一种更为简单的使用则是采取：flex 弹性布局\n\n\nflex 弹性布局#\n\n\n\nflex可以说是最好的方案了，代码少，使用简单\n\n注意的是，flex容器的一个默认属性值:align-items: stretch;\n\n这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start\n\n\n三、三栏布局#\n\n实现三栏布局中间自适应的布局方式有：\n\n * 两边使用 float，中间使用 margin\n * 两边使用 absolute，中间使用 margin\n * 两边使用 float 和负 margin\n * display: table 实现\n * flex 实现\n * grid 网格布局\n\n\n两边使用 float，中间使用 margin#\n\n需要将中间的内容放在html结构最后，否则右侧会臣在中间内容的下方\n\n实现代码如下：\n\n\n\n原理如下：\n\n * 两边固定宽度，中间宽度自适应。\n * 利用中间元素的 margin 值控制两边的间距\n * 宽度小于左右部分宽度之和时，右侧部分会被挤下去\n\n这种实现方式存在缺陷：\n\n * 主体内容是最后加载的。\n\n * 右边在主体内容之前，如果是响应式设计，不能简单的换行展示\n\n\n两边使用 absolute，中间使用 margin#\n\n基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑 HTML 中结构的顺序\n\n\n\n实现流程：\n\n * 左右两边使用绝对定位，固定在两侧。\n * 中间占满一行，但通过 margin 和左右两边留出 10px 的间隔\n\n\n两边使用 float 和负 margin#\n\n\n\n实现过程：\n\n * 中间使用了双层标签，外层是浮动的，以便左中右能在同一行展示\n * 左边通过使用负 margin-left:-100%，相当于中间的宽度，所以向上偏移到左侧\n * 右边通过使用负 margin-left:-100px，相当于自身宽度，所以向上偏移到最右侧\n\n缺点：\n\n * 增加了 .main-wrapper 一层，结构变复杂\n * 使用负 margin，调试也相对麻烦\n\n\n使用 display: table 实现#\n\n标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果\n\n\n\n实现原理：\n\n * 层通过 display: table 设置为表格，设置 table-layout: fixed`表示列宽自身宽度决定，而不是自动计算。\n * 内层的左中右通过 display: table-cell 设置为表格单元。\n * 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度\n\n\n使用 flex 实现#\n\n利用flex弹性布局，可以简单实现中间自适应\n\n代码如下：\n\n\n\n实现过程：\n\n * 仅需将容器设置为display:flex;，\n * 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白\n * 盒内元素的高度撑开容器的高度\n\n优点：\n\n * 结构简单直观\n * 可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间\n\n\ngrid 网格布局#\n\n代码如下：\n\n\n\n跟flex弹性布局一样的简单\n\n\n参考文献#\n\n * https://zhuqingguang.github.io/2017/08/16/adapting-two-layout/\n\n * https://segmentfault.com/a/1190000008705541","routePath":"/interview/css/column_layout","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"两栏布局","id":"两栏布局","depth":3,"charIndex":45},{"text":"三栏布局","id":"三栏布局","depth":3,"charIndex":216},{"text":"二、两栏布局","id":"二两栏布局","depth":2,"charIndex":276},{"text":"flex 弹性布局","id":"flex-弹性布局","depth":3,"charIndex":449},{"text":"三、三栏布局","id":"三三栏布局","depth":2,"charIndex":590},{"text":"两边使用 float，中间使用 margin","id":"两边使用-float中间使用-margin","depth":3,"charIndex":745},{"text":"两边使用 absolute，中间使用 margin","id":"两边使用-absolute中间使用-margin","depth":3,"charIndex":960},{"text":"两边使用 float 和负 margin","id":"两边使用-float-和负-margin","depth":3,"charIndex":1123},{"text":"使用 display: table 实现","id":"使用-display-table-实现","depth":3,"charIndex":1345},{"text":"使用 flex 实现","id":"使用-flex-实现","depth":3,"charIndex":1579},{"text":"grid 网格布局","id":"grid-网格布局","depth":3,"charIndex":1801},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1839}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？","order":1,"star":1,"date":"2023-02-25T10:08:14.666Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"}]]},"version":""},{"id":126,"title":"CSS3 新增了哪些新特性？","content":"#\n\n\n\n\n一、是什么#\n\ncss，即层叠样式表（Cascading Style Sheets）的简称，是一种标记语言，由浏览器解释执行用来使页面变得更美观\n\ncss3是css的最新标准，是向后兼容的，CSS1/2的特性在CSS3 里都是可以使用的\n\n而CSS3 也增加了很多新特性，为开发带来了更佳的开发体验\n\n\n二、选择器#\n\ncss3中新增了一些选择器，主要为如下图所示：\n\n\n\n\n三、新样式#\n\n\n边框#\n\ncss3新增了三个边框属性，分别是：\n\n * border-radius：创建圆角边框\n\n * box-shadow：为元素添加阴影\n\n * border-image：使用图片来绘制边框\n\nbox-shadow#\n\n设置元素阴影，设置属性如下：\n\n * 水平阴影\n * 垂直阴影\n * 模糊距离(虚实)\n * 阴影尺寸(影子大小)\n * 阴影颜色\n * 内/外阴影\n\n其中水平阴影和垂直阴影是必须设置的\n\n\n背景#\n\n新增了几个关于背景的属性，分别是background-clip、background-origin、background-size和background-bre\nak\n\nbackground-clip#\n\n用于确定背景画区，有以下几种可能的属性：\n\n * background-clip: border-box; 背景从 border 开始显示\n * background-clip: padding-box; 背景从 padding 开始显示\n * background-clip: content-box; 背景显 content 区域开始显示\n * background-clip: no-clip; 默认属性，等同于 border-box\n\n通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围\n\nbackground-origin#\n\n当我们设置背景图片时，图片是会以左上角对齐，但是是以border的左上角对齐还是以padding的左上角或者content的左上角对齐?\nborder-origin正是用来设置这个的\n\n * background-origin: border-box; 从 border 开始计算 background-position\n * background-origin: padding-box; 从 padding 开始计算 background-position\n * background-origin: content-box; 从 content 开始计算 background-position\n\n默认情况是padding-box，即以padding的左上角为原点\n\nbackground-size#\n\nbackground-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：\n\n * background-size: contain; 缩小图片以适合元素（维持像素长宽比）\n * background-size: cover; 扩展元素以填补元素（维持像素长宽比）\n * background-size: 100px 100px; 缩小图片至指定的大小\n * background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸\n\n\nbackground-break#\n\n元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示\n\n * background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）\n * background-break: bounding-box; 把盒之间的距离计算在内；\n * background-break: each-box; 为每个盒子单独重绘背景\n\n\n文字#\n\n\nword-wrap#\n\n语法：word-wrap: normal|break-word\n\n * normal：使用浏览器默认的换行\n * break-all：允许在单词内换行\n\n\ntext-overflow#\n\ntext-overflow设置或检索当当前行超过指定容器的边界时如何显示，属性有两个值选择：\n\n * clip：修剪文本\n * ellipsis：显示省略符号来代表被修剪的文本\n\n\ntext-shadow#\n\ntext-shadow可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色\n\n\ntext-decoration#\n\nCSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：\n\n * text-fill-color: 设置文字内部填充颜色\n\n * text-stroke-color: 设置文字边界填充颜色\n\n * text-stroke-width: 设置文字边界宽度\n\n\n颜色#\n\ncss3新增了新的颜色表示方式rgba与hsla\n\n * rgba 分为两部分，rgb 为颜色值，a 为透明度\n * hala 分为四部分，h 为色相，s 为饱和度，l 为亮度，a 为透明度\n\n\n四、transition 过渡#\n\ntransition属性可以被指定为一个或多个CSS属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：\n\n * 过度效果\n * 持续时间\n\n语法如下：\n\n\n\n上面为简写模式，也可以分开写各个属性\n\n\n\n\n五、transform 转换#\n\ntransform属性允许你旋转，缩放，倾斜或平移给定元素\n\ntransform-origin：转换元素的位置（围绕那个点进行转换），默认值为(x,y,z):(50%,50%,0)\n\n使用方式：\n\n * transform: translate(120px, 50%)：位移\n * transform: scale(2, 0.5)：缩放\n * transform: rotate(0.5turn)：旋转\n * transform: skew(30deg, 20deg)：倾斜\n\n\n六、animation 动画#\n\n动画这个平常用的也很多，主要是做一个预设的动画。和一些页面交互的动画效果，结果和过渡应该一样，让页面不会那么生硬\n\nanimation 也有很多的属性\n\n * animation-name：动画名称\n * animation-duration：动画持续时间\n * animation-timing-function：动画时间函数\n * animation-delay：动画延迟时间\n * animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为 infinite，意思是无限循环\n * animation-direction：动画执行方向\n * animation-paly-state：动画播放状态\n * animation-fill-mode：动画填充模式\n\n\n七、渐变#\n\n颜色渐变是指在两个颜色之间平稳的过渡，css3渐变包括\n\n * linear-gradient：线性渐变\n\n> background-image: linear-gradient(direction, color-stop1, color-stop2, ...);\n\n * radial-gradient：径向渐变\n\n> linear-gradient(0deg, red, green);\n\n\n八、其他#\n\n关于css3其他的新特性还包括flex弹性布局、Grid栅格布局，这两个布局在以前就已经讲过，这里就不再展示\n\n除此之外，还包括多列布局、媒体查询、混合模式等等......\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903518520901639#heading-1\n\n * https://www.w3school.com.cn/css/index.asp","routePath":"/interview/css/css3_features","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、选择器","id":"二选择器","depth":2,"charIndex":157},{"text":"三、新样式","id":"三新样式","depth":2,"charIndex":193},{"text":"边框","id":"边框","depth":3,"charIndex":202},{"text":"box-shadow","id":"box-shadow","depth":4,"charIndex":302},{"text":"背景","id":"背景","depth":3,"charIndex":411},{"text":"background-clip","id":"background-clip","depth":4,"charIndex":501},{"text":"background-origin","id":"background-origin","depth":4,"charIndex":782},{"text":"background-size","id":"background-size","depth":4,"charIndex":1139},{"text":"background-break","id":"background-break","depth":3,"charIndex":1406},{"text":"文字","id":"文字","depth":3,"charIndex":1663},{"text":"word-wrap","id":"word-wrap","depth":3,"charIndex":1669},{"text":"text-overflow","id":"text-overflow","depth":3,"charIndex":1759},{"text":"text-shadow","id":"text-shadow","depth":3,"charIndex":1866},{"text":"text-decoration","id":"text-decoration","depth":3,"charIndex":1929},{"text":"颜色","id":"颜色","depth":3,"charIndex":2083},{"text":"四、transition 过渡","id":"四transition-过渡","depth":2,"charIndex":2186},{"text":"五、transform 转换","id":"五transform-转换","depth":3,"charIndex":2312},{"text":"六、animation 动画","id":"六animation-动画","depth":3,"charIndex":2569},{"text":"七、渐变","id":"七渐变","depth":2,"charIndex":2940},{"text":"八、其他","id":"八其他","depth":2,"charIndex":3145},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":3241}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-CSS3 新增了哪些新特性？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>CSS3 新增了哪些新特性？","order":4,"star":4,"date":"2023-02-26T05:07:54.428Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-CSS3 新增了哪些新特性？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"CSS3 新增了哪些新特性？"}]]},"version":""},{"id":127,"title":"如果要做优化，CSS 提高性能的方法有哪些？","content":"#\n\n\n\n\n一、前言#\n\n每一个网页都离不开css，但是很多人又认为，css主要是用来完成页面布局的，像一些细节或者优化，就不需要怎么考虑，实际上这种想法是不正确的\n\n作为页面渲染和内容展现的重要环节，css影响着用户对整个网站的第一体验\n\n因此，在整个产品研发过程中，css性能优化同样需要贯穿全程\n\n\n二、实现方式#\n\n实现方式有很多种，主要有如下：\n\n * 内联首屏关键 CSS\n * 异步加载 CSS\n * 资源压缩\n * 合理使用选择器\n * 减少使用昂贵的属性\n * 不要使用@import\n\n\n内联首屏关键 CSS#\n\n在打开一个页面，页面首要内容出现在屏幕的时间影响着用户的体验，而通过内联css关键代码能够使浏览器在下载完html后就能立刻渲染\n\n而如果外部引用css代码，在解析html结构过程中遇到外部css文件，才会开始下载css代码，再渲染\n\n所以，CSS内联使用使渲染时间提前\n\n注意：但是较大的css代码并不合适内联（初始拥塞窗口、没有缓存），而其余代码则采取外部引用方式\n\n\n异步加载 CSS#\n\n在CSS文件请求、下载、解析完成之前，CSS会阻塞渲染，浏览器将不会渲染任何已处理的内容\n\n前面加载内联代码后，后面的外部引用css则没必要阻塞浏览器渲染。这时候就可以采取异步加载的方案，主要有如下：\n\n * 使用 javascript 将 link 标签插到 head 标签最后\n\n\n\n * 设置 link 标签 media 属性为\n   noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览\n   器开始解析 CSS\n\n\n\n * 通过 rel 属性将 link 元素标记为 alternate 可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将 rel 设回\n   stylesheet\n\n\n\n\n资源压缩#\n\n利用webpack、gulp/grunt、rollup等模块化工具，将css代码进行压缩，使文件变小，大大降低了浏览器的加载时间\n\n\n合理使用选择器#\n\ncss匹配的规则是从右往左开始匹配，例如#markdown .content h3匹配规则如下：\n\n * 先找到 h3 标签元素\n * 然后去除祖先不是.content 的元素\n * 最后去除祖先不是#markdown 的元素\n\n如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高\n\n所以我们在编写选择器的时候，可以遵循以下规则：\n\n * 不要嵌套使用过多复杂选择器，最好不要三层以上\n * 使用 id 选择器就没必要再进行嵌套\n * 通配符和属性选择器效率最低，避免使用\n\n\n减少使用昂贵的属性#\n\n在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能\n\n\n不要使用@import#\n\ncss 样式文件有两种引入方式，一种是link元素，另一种是@import\n\n@import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时\n\n而且多个@import可能会导致下载顺序紊乱\n\n比如一个 css 文件index.css包含了以下内容：@import url(\"reset.css\")\n\n那么浏览器就必须先把index.css下载、解析和执行后，才下载、解析和执行第二个文件reset.css\n\n\n其他#\n\n * 减少重排操作，以及减少不必要的重绘\n * 了解哪些属性可以继承而来，避免对这些属性重复编写\n * cssSprite，合成所有 icon 图片，用宽高加上 backgroud-position 的背景图方式显现出我们要的 icon 图，减少了 http\n   请求\n * 把小的 icon 图片转成 base64 编码\n * CSS3 动画或者过渡尽量使用 transform 和 opacity 来实现动画，不要使用 left 和 top 属性\n\n\n三、总结#\n\ncss实现性能的方式可以从选择器嵌套、属性特性、减少http这三面考虑，同时还要注意css代码的加载顺序\n\n\n参考文献#\n\n * https://www.zhihu.com/question/19886806\n * https://juejin.cn/post/6844903649605320711#heading-1","routePath":"/interview/css/css_performance","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":152},{"text":"内联首屏关键 CSS","id":"内联首屏关键-css","depth":3,"charIndex":253},{"text":"异步加载 CSS","id":"异步加载-css","depth":3,"charIndex":453},{"text":"资源压缩","id":"资源压缩","depth":3,"charIndex":821},{"text":"合理使用选择器","id":"合理使用选择器","depth":3,"charIndex":895},{"text":"减少使用昂贵的属性","id":"减少使用昂贵的属性","depth":3,"charIndex":1155},{"text":"不要使用@import","id":"不要使用import","depth":3,"charIndex":1245},{"text":"其他","id":"其他","depth":3,"charIndex":1478},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1712},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1774}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如果要做优化，CSS 提高性能的方法有哪些？","footer":"如果要做优化，CSS 提高性能的方法有哪些？","order":15,"star":15,"date":"2023-03-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-如果要做优化，CSS 提高性能的方法有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如果要做优化，CSS 提高性能的方法有哪些？"}]]},"version":""},{"id":128,"title":"说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？","content":"#\n\n\n\n\n一、背景#\n\n在css中我们通常使用 px 作为单位，在 PC 浏览器中css的 1 个像素都是对应着电脑屏幕的 1 个物理像素\n\n这会造成一种错觉，我们会认为css中的像素就是设备的物理像素\n\n但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的 1px 所代表的设备物理像素是不同的\n\n当我们做移动端开发时，同为 1px 的设置，在不同分辨率的移动设备上显示效果却有很大差异\n\n这背后就涉及了 css 像素、设备像素、设备独立像素、dpr、ppi 的概念\n\n\n二、介绍#\n\n\nCSS 像素#\n\nCSS 像素（css pixel, px）: 适用于 web 编程，在 CSS 中以 px 为后缀，是一个长度单位\n\n在 CSS 规范中，长度单位可以分为两类，绝对单位以及相对单位\n\npx 是一个相对单位，相对的是设备像素（device pixel）\n\n一般情况，页面缩放比为 1，1 个 CSS 像素等于 1 个设备独立像素\n\nCSS像素又具有两个方面的相对性：\n\n * 在同一个设备上，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如调整屏幕的分辨率）\n * 在不同的设备之间，每 1 个 CSS 像素所代表的设备像素是可以变化的（比如两个不同型号的手机）\n\n在页面进行缩放操作也会 引起css中px的变化，假设页面放大一倍，原来的 1px 的东西变成 2px，在实际宽度不变的情况下 1px 变得跟原来的 2px\n的长度（长宽）一样了（元素会占据更多的设备像素）\n\n假设原来需要 320px 才能填满的宽度现在只需要 160px\n\npx 会受到下面的因素的影响而变化：\n\n * 每英寸像素（PPI）\n * 设备像素比（DPR）\n\n\n设备像素#\n\n设备像素（device pixels），又称为物理像素\n\n指设备能控制显示的最小物理单位，不一定是一个小正方形区块，也没有标准的宽高，只是用于显示丰富色彩的一个“点”而已\n\n可以参考公园里的景观变色彩灯，一个彩灯(物理像素)由红、蓝、绿小灯组成，三盏小灯不同的亮度混合出各种色彩\n\n\n\n从屏幕在工厂生产出的那天起，它上面设备像素点就固定不变了，单位为pt\n\n\n设备独立像素#\n\n设备独立像素（Device Independent Pixel）：与设备无关的逻辑像素，代表可以通过程序控制使用的虚拟像素，是一个总体概念，包括了 CSS 像素\n\n在javaScript中可以通过window.screen.width/ window.screen.height 查看\n\n比如我们会说“电脑屏幕在 2560x1600 分辨率下不适合玩游戏，我们把它调为 1440x900”，这里的“分辨率”（非严谨说法）指的就是设备独立像素\n\n一个设备独立像素里可能包含 1 个或者多个物理像素点，包含的越多则屏幕看起来越清晰\n\n至于为什么出现设备独立像素这种虚拟像素单位概念，下面举个例子：\n\niPhone 3GS 和 iPhone 4/4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是 320x480，iPhone 4/4s\n的分辨率是 640x960\n\n这意味着，iPhone 3GS 有 320 个物理像素，iPhone 4/4s 有 640 个物理像素\n\n如果我们按照真实的物理像素进行布局，比如说我们按照 320 物理像素进行布局，到了 640\n物理像素的手机上就会有一半的空白，为了避免这种问题，就产生了虚拟像素单位\n\n我们统一 iPhone 3GS 和 iPhone 4/4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1\n个物理像素，在 iphone 4s 中，1 个虚拟像素最终换算成 2 个物理像素\n\n至于 1 个虚拟像素被换算成几个物理像素，这个数值我们称之为设备像素比，也就是下面介绍的dpr\n\n\ndpr#\n\ndpr（device pixel ratio），设备像素比，代表设备独立像素到设备像素的转换关系，在JavaScript中可以通过\nwindow.devicePixelRatio 获取\n\n计算公式如下：\n\n\n\n当设备像素比为 1:1 时，使用 1（1×1）个设备像素显示 1 个 CSS 像素\n\n当设备像素比为 2:1 时，使用 4（2×2）个设备像素显示 1 个 CSS 像素\n\n当设备像素比为 3:1 时，使用 9（3×3）个设备像素显示 1 个 CSS 像素\n\n如下图所示：\n\n\n\n当dpr为 3，那么1px的CSS像素宽度对应3px的物理像素的宽度，1px 的CSS像素高度对应3px的物理像素高度\n\n\nppi#\n\nppi （pixel per inch），每英寸像素，表示每英寸所包含的像素点数目，更确切的说法应该是像素密度。数值越高，说明屏幕能以更高密度显示图像\n\n计算公式如下：\n\n\n\n\n三、总结#\n\n无缩放情况下，1 个 CSS 像素等于 1 个设备独立像素\n\n设备像素由屏幕生产之后就不发生改变，而设备独立像素是一个虚拟单位会发生改变\n\nPC 端中，1 个设备独立像素 = 1 个设备像素 （在 100%，未缩放的情况下）\n\n在移动端中，标准屏幕（160ppi）下 1 个设备独立像素 = 1 个设备像素\n\n设备像素比（dpr） = 设备像素 / 设备独立像素\n\n每英寸像素（ppi），值越大，图像越清晰\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Glossary/CSS_pixel\n * https://hijiangtao.github.io/2017/07/09/Device-Viewport-and-Pixel-Introductio\n   n/","routePath":"/interview/css/dp_px_dpr_ppi","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、介绍","id":"二介绍","depth":2,"charIndex":258},{"text":"CSS 像素","id":"css-像素","depth":3,"charIndex":266},{"text":"设备像素","id":"设备像素","depth":3,"charIndex":749},{"text":"设备独立像素","id":"设备独立像素","depth":3,"charIndex":936},{"text":"dpr","id":"dpr","depth":3,"charIndex":1639},{"text":"ppi","id":"ppi","depth":3,"charIndex":1951},{"text":"三、总结","id":"三总结","depth":2,"charIndex":2046},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2259}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？","footer":"说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？","order":19,"star":19,"date":"2023-04-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"}]]},"version":""},{"id":129,"title":"说说 em/px/rem/vh/vw 区别?","content":"#\n\n\n\n\n一、介绍#\n\n传统的项目开发中，我们只会用到px、%、em这几个单位，它可以适用于大部分的项目开发，且拥有比较良好的兼容性\n\n从CSS3开始，浏览器对计量单位的支持又提升到了另外一个境界，新增了rem、vh、vw、vm等一些新的计量单位\n\n利用这些新的单位开发出比较良好的响应式页面，适应多种不同分辨率的终端，包括移动设备等\n\n\n二、单位#\n\n在css单位中，可以分为长度单位、绝对单位，如下表所指示\n\nCSS 单位   \n相对长度单位   em、ex、ch、rem、vw、vh、vmin、vmax、%\n绝对长度单位   cm、mm、in、px、pt、pc\n\n这里我们主要讲述 px、em、rem、vh、vw\n\n\npx#\n\npx，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中\n\n有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的\n\n这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关\n\n\nem#\n\nem 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）\n\n为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5%\n= 10px\n\n这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的px 数值除以 10，然后换上 em作为单位就行了\n\n特点：\n\n * em 的值并不是固定的\n * em 会继承父级元素的字体大小\n * em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸\n * 任意浏览器的默认字体高都是 16px\n\n举个例子\n\n\n\n样式为\n\n\n\n这时候.big元素的font-size为 14px，而.small元素的font-size为 12px\n\n\nrem#\n\nrem，相对单位，相对的只是 HTML 根元素font-size的值\n\n同理，如果想要简化font-size的转化，我们可以在根元素html中加入font-size: 62.5%\n\n\n\n这样页面中 1rem=10px、1.2rem=12px、1.4rem=14px、1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助\n\n特点：\n\n * rem 单位可谓集相对大小和绝对大小的优点于一身\n * 和 em 不同的是 rem 总是相对于根元素，而不像 em 一样使用级联的方式来计算尺寸\n\n\nvh、vw#\n\nvw ，就是根据窗口的宽度，分成 100 等份，100vw 就表示满宽，50vw 就表示一半宽。（vw 始终是针对窗口的宽），同理，vh则为窗口的高度\n\n这里的窗口分成几种情况：\n\n * 在桌面端，指的是浏览器的可视区域\n\n * 移动端指的就是布局视口\n\n像vw、vh，比较容易混淆的一个单位是%，不过百分比宽泛的讲是相对于父元素：\n\n * 对于普通定位元素就是我们理解的父元素\n * 对于 position: absolute;的元素是相对于已定位的父元素\n * 对于 position: fixed;的元素是相对于 ViewPort（可视窗口）\n\n\n三、总结#\n\npx：绝对单位，页面按精确像素展示\n\nem：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算，整个页面内1em不是一个固定的值\n\nrem：相对单位，可理解为root em, 相对根节点html的字体大小来计算\n\nvh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单","routePath":"/interview/css/em_px_rem_vh_vw","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"二、单位","id":"二单位","depth":2,"charIndex":170},{"text":"px","id":"px","depth":3,"charIndex":312},{"text":"em","id":"em","depth":3,"charIndex":465},{"text":"rem","id":"rem","depth":3,"charIndex":898},{"text":"vh、vw","id":"vhvw","depth":3,"charIndex":1153},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1438}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 em/px/rem/vh/vw 区别?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 em/px/rem/vh/vw 区别?","order":6,"star":6,"date":"2023-02-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说 em/px/rem/vh/vw 区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 em/px/rem/vh/vw 区别?"}]]},"version":""},{"id":130,"title":"说说 flexbox（弹性盒布局模型）,以及适用场景？","content":"#\n\n\n\n\n一、是什么#\n\nFlexible Box 简称 flex，意为”弹性布局”，可以简便、完整、响应式地实现各种页面布局\n\n采用 Flex 布局的元素，称为flex容器container\n\n它的所有子元素自动成为容器成员，称为flex项目item\n\n\n\n容器中默认存在两条轴，主轴和交叉轴，呈 90 度关系。项目默认沿主轴排列，通过flex-direction来决定主轴的方向\n\n每根轴都有起点和终点，这对于元素的对齐非常重要\n\n\n二、属性#\n\n关于flex常用的属性，我们可以划分为容器属性和容器成员属性\n\n容器属性有：\n\n * flex-direction\n * flex-wrap\n * flex-flow\n * justify-content\n * align-items\n * align-content\n\n\nflex-direction#\n\n决定主轴的方向(即项目的排列方向)\n\n\n\n属性对应如下：\n\n * row（默认值）：主轴为水平方向，起点在左端\n * row-reverse：主轴为水平方向，起点在右端\n * column：主轴为垂直方向，起点在上沿。\n * column-reverse：主轴为垂直方向，起点在下沿\n\n如下图所示：\n\n\n\n\nflex-wrap#\n\n弹性元素永远沿主轴排列，那么如果主轴排不下，通过flex-wrap决定容器内项目是否可换行\n\n\n\n属性对应如下：\n\n * nowrap（默认值）：不换行\n * wrap：换行，第一行在下方\n * wrap-reverse：换行，第一行在上方\n\n默认情况是不换行，但这里也不会任由元素直接溢出容器，会涉及到元素的弹性伸缩\n\n\nflex-flow#\n\n是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n\n\n\n\njustify-content#\n\n定义了项目在主轴上的对齐方式\n\n\n\n属性对应如下：\n\n * flex-start（默认值）：左对齐\n * flex-end：右对齐\n * center：居中\n * space-between：两端对齐，项目之间的间隔都相等\n * space-around：两个项目两侧间隔相等\n\n效果图如下：\n\n\n\n\nalign-items#\n\n定义项目在交叉轴上如何对齐\n\n\n\n属性对应如下：\n\n * flex-start：交叉轴的起点对齐\n * flex-end：交叉轴的终点对齐\n * center：交叉轴的中点对齐\n * baseline: 项目的第一行文字的基线对齐\n * stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度\n\n\nalign-content#\n\n定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n\n\n属性对应如吓：\n\n * flex-start：与交叉轴的起点对齐\n * flex-end：与交叉轴的终点对齐\n * center：与交叉轴的中点对齐\n * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n * stretch（默认值）：轴线占满整个交叉轴\n\n效果图如下：\n\n\n\n容器成员属性如下：\n\n * order\n * flex-grow\n * flex-shrink\n * flex-basis\n * flex\n * align-self\n\n\norder#\n\n定义项目的排列顺序。数值越小，排列越靠前，默认为 0\n\n\n\n\nflex-grow#\n\n上面讲到当容器设为flex-wrap: nowrap;不换行的时候，容器宽度有不够分的情况，弹性元素会根据flex-grow来决定\n\n定义项目的放大比例（容器宽度>元素总宽度时如何伸展）\n\n默认为0，即如果存在剩余空间，也不放大\n\n\n\n如果所有项目的flex-grow属性都为 1，则它们将等分剩余空间（如果有的话）\n\n\n\n如果一个项目的flex-grow属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍\n\n\n\n弹性容器的宽度正好等于元素宽度总和，无多余宽度，此时无论flex-grow是什么值都不会生效\n\n\nflex-shrink#\n\n定义了项目的缩小比例（容器宽度<元素总宽度时如何收缩），默认为 1，即如果空间不足，该项目将缩小\n\n\n\n如果所有项目的flex-shrink属性都为 1，当空间不足时，都将等比例缩小\n\n如果一个项目的flex-shrink属性为 0，其他项目都为 1，则空间不足时，前者不缩小\n\n\n\n在容器宽度有剩余时，flex-shrink也是不会生效的\n\n\nflex-basis#\n\n设置的是元素在主轴上的初始尺寸，所谓的初始尺寸就是元素在flex-grow和flex-shrink生效前的尺寸\n\n浏览器根据这个属性，计算主轴是否有多余空间，默认值为auto，即项目的本来大小，如设置了width则元素尺寸由width/height决定（主轴方向），没有设置\n则由内容决定\n\n\n\n当设置为 0 的是，会根据内容撑开\n\n它可以设为跟width或height属性一样的值（比如 350px），则项目将占据固定空间\n\n\nflex#\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，也是比较难懂的一个复合属性\n\n\n\n一些属性有：\n\n * flex: 1 = flex: 1 1 0%\n * flex: 2 = flex: 2 1 0%\n * flex: auto = flex: 1 1 auto\n * flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩\n\nflex:1 和 flex:auto 的区别，可以归结于flex-basis:0和flex-basis:auto的区别\n\n当设置为 0 时（绝对弹性元素），此时相当于告诉flex-grow和flex-shrink在伸缩的时候不需要考虑我的尺寸\n\n当设置为auto时（相对弹性元素），此时则需要在伸缩时将元素尺寸纳入考虑\n\n注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值\n\n\nalign-self#\n\n允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性\n\n默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch\n\n\n\n效果图如下：\n\n\n\n\n三、应用场景#\n\n在以前的文章中，我们能够通过flex简单粗暴的实现元素水平垂直方向的居中，以及在两栏三栏自适应布局中通过flex完成，这里就不再展开代码的演示\n\n包括现在在移动端、小程序这边的开发，都建议使用flex进行布局\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex\n * http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html","routePath":"/interview/css/flexbox","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、属性","id":"二属性","depth":2,"charIndex":219},{"text":"flex-direction","id":"flex-direction","depth":3,"charIndex":363},{"text":"flex-wrap","id":"flex-wrap","depth":3,"charIndex":534},{"text":"flex-flow","id":"flex-flow","depth":3,"charIndex":708},{"text":"justify-content","id":"justify-content","depth":3,"charIndex":774},{"text":"align-items","id":"align-items","depth":3,"charIndex":943},{"text":"align-content","id":"align-content","depth":3,"charIndex":1120},{"text":"order","id":"order","depth":3,"charIndex":1459},{"text":"flex-grow","id":"flex-grow","depth":3,"charIndex":1498},{"text":"flex-shrink","id":"flex-shrink","depth":3,"charIndex":1774},{"text":"flex-basis","id":"flex-basis","depth":3,"charIndex":1961},{"text":"flex","id":"flex","depth":3,"charIndex":2189},{"text":"align-self","id":"align-self","depth":3,"charIndex":2609},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":2726},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2842}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 flexbox（弹性盒布局模型）,以及适用场景？","order":5,"star":5,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说 flexbox（弹性盒布局模型）,以及适用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 flexbox（弹性盒布局模型）,以及适用场景？"}]]},"version":""},{"id":131,"title":"介绍一下 grid 网格布局","content":"#\n\n\n\n\n一、是什么#\n\nGrid 布局即网格布局，是一个二维的布局方式，由纵横相交的两组网格线形成的框架性布局结构，能够同时处理行与列\n\n擅长将一个页面划分为几个主要区域，以及定义这些区域的大小、位置、层次等关系\n\n\n\n这与之前讲到的flex一维布局不相同\n\n设置display:grid/inline-grid的元素就是网格布局容器，这样就能出发浏览器渲染引擎的网格布局算法\n\n\n\n上述代码实例中，.container元素就是网格布局容器，.item元素就是网格的项目，由于网格元素只能是容器的顶层子元素，所以p元素并不是网格元素\n\n这里提一下，网格线概念，有助于下面对grid-column系列属性的理解\n\n网格线，即划分网格的线，如下图所示：\n\n\n\n上图是一个 2 x 3 的网格，共有 3 根水平网格线和 4 根垂直网格线\n\n\n二、属性#\n\n同样，Grid 布局属性可以分为两大类：\n\n * 容器属性，\n * 项目属性\n\n关于容器属性有如下：\n\n\ndisplay 属性#\n\n文章开头讲到，在元素上设置display：grid 或 display：inline-grid 来创建一个网格容器\n\n * display：grid 则该容器是一个块级元素\n\n * display: inline-grid 则容器元素为行内元素\n\n\ngrid-template-columns 属性，grid-template-rows 属性#\n\ngrid-template-columns 属性设置列宽，grid-template-rows 属性设置行高\n\n\n\n以上表示固定列宽为 200px 200px 200px，行高为 50px 50px\n\n上述代码可以看到重复写单元格宽高，通过使用repeat()函数，可以简写重复的值\n\n * 第一个参数是重复的次数\n * 第二个参数是重复的值\n\n所以上述代码可以简写成\n\n\n\n除了上述的repeact关键字，还有：\n\n * auto-fill：示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格\n\n> grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200\n> px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n\n * fr：片段，为了方便表示比例关系\n\n> grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的\n> 1/3 和 2/3\n\n * minmax：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值\n\n> minmax(100px, 1fr)表示列宽不小于100px，不大于1fr\n\n * auto：由浏览器自己决定长度\n\n> grid-template-columns: 100px auto 100px 表示第一第三列为 100px，中间由浏览器决定长度\n\n\ngrid-row-gap 属性， grid-column-gap 属性， grid-gap 属性#\n\ngrid-row-gap 属性、grid-column-gap 属性分别设置行间距和列间距。grid-gap 属性是两者的简写形式\n\ngrid-row-gap: 10px 表示行间距是 10px\n\ngrid-column-gap: 20px 表示列间距是 20px\n\ngrid-gap: 10px 20px 等同上述两个属性\n\n\ngrid-template-areas 属性#\n\n用于定义区域，一个区域由一个或者多个单元格组成\n\n\n\n上面代码先划分出 9 个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。\n\n多个单元格合并成一个区域的写法如下\n\n\n\n上面代码将 9 个单元格分成a、b、c三个区域\n\n如果某些区域不需要利用，则使用\"点\"（.）表示\n\n\ngrid-auto-flow 属性#\n\n划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。\n\n顺序就是由grid-auto-flow决定，默认为行，代表\"先行后列\"，即先填满第一行，再开始放入第二行\n\n\n\n当修改成column后，放置变为如下：\n\n\n\n\njustify-items 属性， align-items 属性， place-items 属性#\n\njustify-items 属性设置单元格内容的水平位置（左中右），align-items 属性设置单元格的垂直位置（上中下）\n\n两者属性的值完成相同\n\n\n\n属性对应如下：\n\n * start：对齐单元格的起始边缘\n * end：对齐单元格的结束边缘\n * center：单元格内部居中\n * stretch：拉伸，占满单元格的整个宽度（默认值）\n\nplace-items属性是align-items属性和justify-items属性的合并简写形式\n\n\njustify-content 属性， align-content 属性， place-content 属性#\n\njustify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）\n\n\n\n两个属性的写法完全相同，都可以取下面这些值：\n\n * start - 对齐容器的起始边框\n * end - 对齐容器的结束边框\n * center - 容器内部居中\n\n\n\n * space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍\n\n * space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔\n\n * space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔\n\n * stretch - 项目大小没有指定时，拉伸占据整个网格容器\n\n\n\n\ngrid-auto-columns 属性和 grid-auto-rows 属性#\n\n有时候，一些项目的指定位置，在现有网格的外部，就会产生显示网格和隐式网格\n\n比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。超出的部分就是隐式网格\n\n而grid-auto-rows与grid-auto-columns就是专门用于指定隐式网格的宽高\n\n关于项目属性，有如下：\n\n\ngrid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及 grid-row-end 属性#\n\n指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置\n\n * grid-column-start 属性：左边框所在的垂直网格线\n * grid-column-end 属性：右边框所在的垂直网格线\n * grid-row-start 属性：上边框所在的水平网格线\n * grid-row-end 属性：下边框所在的水平网格线\n\n举个例子：\n\n\n\n通过设置grid-column属性，指定 1 号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线\n\n\n\n\ngrid-area 属性#\n\ngrid-area 属性指定项目放在哪一个区域\n\n\n\n意思为将 1 号项目位于e区域\n\n与上述讲到的grid-template-areas搭配使用\n\n\njustify-self 属性、align-self 属性以及 place-self 属性#\n\njustify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。\n\nalign-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目\n\n\n\n这两个属性都可以取下面四个值。\n\n * start：对齐单元格的起始边缘。\n * end：对齐单元格的结束边缘。\n * center：单元格内部居中。\n * stretch：拉伸，占满单元格的整个宽度（默认值）\n\n\n三、应用场景#\n\n文章开头就讲到，Grid是一个强大的布局，如一些常见的 CSS\n布局，如居中，两列布局，三列布局等等是很容易实现的，在以前的文章中，也有使用Grid布局完成对应的功能\n\n关于兼容性问题，结果如下：\n\n\n\n总体兼容性还不错，但在 IE 10 以下不支持\n\n目前，Grid布局在手机端支持还不算太友好\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout\n * https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n * https://juejin.cn/post/6854573220306255880#heading-2","routePath":"/interview/css/grid","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、属性","id":"二属性","depth":2,"charIndex":369},{"text":"display 属性","id":"display-属性","depth":3,"charIndex":429},{"text":"grid-template-columns 属性，grid-template-rows 属性","id":"grid-template-columns-属性grid-template-rows-属性","depth":3,"charIndex":567},{"text":"grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性","id":"grid-row-gap-属性-grid-column-gap-属性-grid-gap-属性","depth":3,"charIndex":1276},{"text":"grid-template-areas 属性","id":"grid-template-areas-属性","depth":3,"charIndex":1492},{"text":"grid-auto-flow 属性","id":"grid-auto-flow-属性","depth":3,"charIndex":1661},{"text":"justify-items 属性， align-items 属性， place-items 属性","id":"justify-items-属性-align-items-属性-place-items-属性","depth":3,"charIndex":1793},{"text":"justify-content 属性， align-content 属性， place-content 属性","id":"justify-content-属性-align-content-属性-place-content-属性","depth":3,"charIndex":2072},{"text":"grid-auto-columns 属性和 grid-auto-rows 属性","id":"grid-auto-columns-属性和-grid-auto-rows-属性","depth":3,"charIndex":2479},{"text":"grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及 grid-row-end 属性","id":"grid-column-start-属性grid-column-end-属性grid-row-start-属性以及-grid-row-end-属性","depth":3,"charIndex":2687},{"text":"grid-area 属性","id":"grid-area-属性","depth":3,"charIndex":3002},{"text":"justify-self 属性、align-self 属性以及 place-self 属性","id":"justify-self-属性align-self-属性以及-place-self-属性","depth":3,"charIndex":3093},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":3383},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":3543}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-介绍一下 grid 网格布局","footer":"介绍一下 grid 网格布局","order":14,"star":14,"date":"2023-03-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-介绍一下 grid 网格布局","isOriginal":false,"head":[["meta",{"name":"keywords","content":"介绍一下 grid 网格布局"}]]},"version":""},{"id":132,"title":"css 中，有哪些方式可以隐藏页面元素？区别?","content":"#\n\n\n\n\n一、前言#\n\n在平常的样式排版中，我们经常遇到将某个模块隐藏的场景\n\n通过css隐藏元素的方法有很多种，它们看起来实现的效果是一致的\n\n但实际上每一种方法都有一丝轻微的不同，这些不同决定了在一些特定场合下使用哪一种方法\n\n\n二、实现方式#\n\n通过css实现隐藏元素方法有如下：\n\n * display:none\n * visibility:hidden\n * opacity:0\n * 设置 height、width 模型属性为 0\n * position:absolute\n * clip-path\n\n\ndisplay:none#\n\n设置元素的display为none是最常用的隐藏元素的方法\n\n\n\n将元素设置为display:none后，元素在页面上将彻底消失\n\n元素本身占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘\n\n消失后，自身绑定的事件不会触发，也不会有过渡效果\n\n特点：元素不可见，不占据空间，无法响应点击事件\n\n\nvisibility:hidden#\n\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法\n\n从页面上仅仅是隐藏该元素，DOM 结果均会存在，只是当时在一个不可见的状态，不会触发重排，但是会触发重绘\n\n\n\n给人的效果是隐藏了，所以他自身的事件不会触发\n\n特点：元素不可见，占据页面空间，无法响应点击事件\n\n\nopacity:0#\n\nopacity属性表示元素的透明度，将元素的透明度设置为 0 后，在我们用户眼中，元素也是隐藏的\n\n不会引发重排，一般情况下也会引发重绘\n\n> 如果利用 animation 动画，对 opacity 做变化（animation 会默认触发 GPU 加速），则只会触发 GPU 层面的\n> composite，不会触发重绘\n\n\n\n由于其仍然是存在于页面上的，所以他自身的的事件仍然是可以触发的，但被他遮挡的元素是不能触发其事件的\n\n需要注意的是：其子元素不能设置 opacity 来达到显示的效果\n\n特点：改变元素透明度，元素不可见，占据页面空间，可以响应点击事件\n\n\n设置 height、width 属性为 0#\n\n将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成\n0，如果元素内有子元素或内容，还应该设置其overflow:hidden来隐藏其子元素\n\n\n\n特点：元素不可见，不占据页面空间，无法响应点击事件\n\n\nposition:absolute#\n\n将元素移出可视区域\n\n\n\n特点：元素不可见，不影响页面布局\n\n\nclip-path#\n\n通过裁剪的形式\n\n\n\n特点：元素不可见，占据页面空间，无法响应点击事件\n\n\n小结#\n\n最常用的还是display:none和visibility:hidden，其他的方式只能认为是奇招，它们的真正用途并不是用于隐藏元素，所以并不推荐使用它们\n\n\n三、区别#\n\n关于display: none、visibility: hidden、opacity: 0的区别，如下表所示：\n\n              DISPLAY: NONE   VISIBILITY: HIDDEN   OPACITY: 0\n页面中           不存在             存在                   存在\n重排            会               不会                   不会\n重绘            会               会                    不一定\n自身绑定事件        不触发             不触发                  可触发\ntransition    不支持             支持                   支持\n子元素可复原        不能              能                    不能\n被遮挡的元素可触发事件   能               能                    不能\n\n\n参考文献#\n\n * https://www.cnblogs.com/a-cat/p/9039962.html","routePath":"/interview/css/hide_attributes","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":117},{"text":"display:none","id":"displaynone","depth":3,"charIndex":258},{"text":"visibility:hidden","id":"visibilityhidden","depth":3,"charIndex":429},{"text":"opacity:0","id":"opacity0","depth":3,"charIndex":594},{"text":"设置 height、width 属性为 0","id":"设置-heightwidth-属性为-0","depth":3,"charIndex":890},{"text":"position:absolute","id":"positionabsolute","depth":3,"charIndex":1042},{"text":"clip-path","id":"clip-path","depth":3,"charIndex":1094},{"text":"小结","id":"小结","depth":3,"charIndex":1144},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1229},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1737}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-css 中，有哪些方式可以隐藏页面元素？区别?","footer":"css 中，有哪些方式可以隐藏页面元素？区别?","order":16,"star":16,"date":"2023-03-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-css 中，有哪些方式可以隐藏页面元素？区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"css 中，有哪些方式可以隐藏页面元素？区别?"}]]},"version":""},{"id":133,"title":"前端物语|面试物语-css","content":" * 谈谈你对 BFC 的理解？\n * css3 动画有哪些？\n * 说说你对盒子模型的理解?\n * 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？\n * 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？\n * CSS3 新增了哪些新特性？\n * 如果要做优化，CSS 提高性能的方法有哪些？\n * 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？\n * 说说 em/px/rem/vh/vw 区别?\n * 说说 flexbox（弹性盒布局模型）,以及适用场景？\n * 介绍一下 grid 网格布局\n * css 中，有哪些方式可以隐藏页面元素？区别?\n * 怎么理解回流跟重绘？什么场景下会触发？\n * 让 Chrome 支持小于 12px 的文字方式有哪些？区别？\n * 什么是响应式设计？响应式设计的基本原理是什么？如何做？\n * 说说对 Css 预编语言的理解？有哪些区别?\n * 如何实现单行／多行文本溢出的省略样式？\n * CSS 如何画一个三角形？原理是什么？\n * 如何使用 css 完成视差滚动效果?","routePath":"/interview/css/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"css","tag":"css","title":"前端物语|面试物语-css","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":134,"title":"怎么理解回流跟重绘？什么场景下会触发？","content":"#\n\n\n\n\n一、是什么#\n\n在HTML中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：\n\n * 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置\n\n * 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制\n\n具体的浏览器解析渲染机制如下所示：\n\n\n\n * 解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树\n\n * 将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)\n\n * Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）\n\n * Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素\n\n * Display:将像素发送给 GPU，展示在页面上\n\n在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变\n\n当我们对 DOM 的修改引发了 DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来\n\n当我们对\nDOM的修改导致了样式的变化（color或background-color），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式\n，这里就仅仅触发了重绘\n\n\n二、如何触发#\n\n要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的\n\n\n回流触发时机#\n\n回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：\n\n * 添加或删除可见的 DOM 元素\n * 元素的位置发生变化\n * 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）\n * 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代\n * 页面一开始渲染的时候（这避免不了）\n * 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）\n\n还有一些容易被忽略的操作：获取一些特定属性的值\n\n> offsetTop、offsetLeft、\n> offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientT\n> op、clientLeft、clientWidth、clientHeight\n\n这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流\n\n除此还包括getComputedStyle方法，原理是一样的\n\n\n重绘触发时机#\n\n触发回流一定会触发重绘\n\n可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）\n\n除此之外还有一些其他引起重绘行为：\n\n * 颜色的修改\n\n * 文本方向的修改\n\n * 阴影的修改\n\n\n浏览器优化机制#\n\n由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一\n个阈值，才清空队列\n\n当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据\n\n因此浏览器不得不清空队列，触发回流重绘来返回正确的值\n\n\n三、如何减少#\n\n我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：\n\n * 如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)\n * 避免设置多项内联样式\n * 应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)\n * 避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算\n * 对于那些复杂的动画，对其设置 position: fixed/absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响\n * 使用 css3 硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘\n * 避免使用 CSS 的 JavaScript 表达式\n\n在使用 JavaScript 动态插入多个节点时, 可以使用DocumentFragment. 创建后一次插入. 就能避免多次的渲染性能\n\n但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们\n\n例如，多次修改一个把元素布局的时候，我们很可能会如下操作\n\n\n\n每次循环都需要获取多次offset属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求\n\n\n\n我们还可避免改变样式，使用类名去合并样式\n\n\n\n使用类名去合并样式\n\n\n\n前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），\n\n都去触发一次渲染树更改，从而导致相应的回流与重绘过程\n\n合并之后，等于我们将所有的更改一次性发出\n\n我们还可以通过通过设置元素属性display: none，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作\n\n\n\n离线操作后\n\n\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903942137053192\n\n * https://segmentfault.com/a/1190000017329980","routePath":"/interview/css/layout_painting","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何触发","id":"二如何触发","depth":2,"charIndex":600},{"text":"回流触发时机","id":"回流触发时机","depth":3,"charIndex":641},{"text":"重绘触发时机","id":"重绘触发时机","depth":3,"charIndex":1119},{"text":"浏览器优化机制","id":"浏览器优化机制","depth":3,"charIndex":1275},{"text":"三、如何减少","id":"三如何减少","depth":2,"charIndex":1459},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2237}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-怎么理解回流跟重绘？什么场景下会触发？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>怎么理解回流跟重绘？什么场景下会触发？","order":9,"star":9,"date":"2023-03-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-怎么理解回流跟重绘？什么场景下会触发？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"怎么理解回流跟重绘？什么场景下会触发？"}]]},"version":""},{"id":135,"title":"让 Chrome 支持小于 12px 的文字方式有哪些？区别？","content":"测试10px 测试12px 测试10px 测试12px","routePath":"/interview/css/less_12px","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":-1},{"text":"二、解决方案","id":"二解决方案","depth":2,"charIndex":-1},{"text":"Zoom","id":"zoom","depth":3,"charIndex":-1},{"text":"-webkit-transform:scale()","id":"-webkit-transformscale","depth":3,"charIndex":-1},{"text":"-webkit-text-size-adjust:none","id":"-webkit-text-size-adjustnone","depth":3,"charIndex":-1},{"text":"三、总结","id":"三总结","depth":2,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-让 Chrome 支持小于 12px 的文字方式有哪些？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>让 Chrome 支持小于 12px 的文字方式有哪些？区别？","order":12,"star":12,"date":"2023-03-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-让 Chrome 支持小于 12px 的文字方式有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"让 Chrome 支持小于 12px 的文字方式有哪些？区别？"}]]},"version":""},{"id":136,"title":"什么是响应式设计？响应式设计的基本原理是什么？如何做？","content":"#\n\n\n\n\n一、是什么#\n\n响应式网站设计（Responsive Web\ndesign）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整\n\n描述响应式界面最著名的一句话就是“Content is like water”\n\n大白话便是“如果将屏幕看作容器，那么内容就像水一样”\n\n响应式网站常见特点：\n\n * 同时适配 PC + 平板 + 手机等\n\n * 标签导航在接近手持终端设备时改变为经典的抽屉式导航\n\n * 网站的布局会根据视口来调整模块的大小和位置\n\n\n\n\n二、实现方式#\n\n响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有meta声明viewport\n\n","routePath":"/interview/css/responsive_layout","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":269},{"text":"媒体查询","id":"媒体查询","depth":3,"charIndex":-1},{"text":"百分比","id":"百分比","depth":3,"charIndex":-1},{"text":"vw/vh","id":"vwvh","depth":3,"charIndex":-1},{"text":"rem","id":"rem","depth":3,"charIndex":-1},{"text":"小结","id":"小结","depth":3,"charIndex":-1},{"text":"三、总结","id":"三总结","depth":2,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-什么是响应式设计？响应式设计的基本原理是什么？如何做？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>什么是响应式设计？响应式设计的基本原理是什么？如何做？","order":7,"star":7,"date":"2023-03-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-什么是响应式设计？响应式设计的基本原理是什么？如何做？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"什么是响应式设计？响应式设计的基本原理是什么？如何做？"}]]},"version":""},{"id":137,"title":"说说对 Css 预编语言的理解？有哪些区别?","content":"#\n\n\n\n\n一、是什么#\n\nCss 作为一门标记性语言，语法相对简单，对使用者的要求较低，但同时也带来一些问题\n\n需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 Css 编写经验而很难写出组织良好且易于维护的\nCss 代码\n\nCss预处理器便是针对上述问题的解决方案\n\n预处理语言#\n\n扩充了 Css 语言，增加了诸如变量、混合（mixin）、函数等功能，让 Css 更易维护、方便\n\n本质上，预处理是Css的超集\n\n包含一套自定义的语法及一个解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 Css 文件\n\n\n二、有哪些#\n\nCss预编译语言在前端里面有三大优秀的预编处理器，分别是：\n\n * sass\n * less\n * stylus\n\n\nsass#\n\n2007 年诞生，最早也是最成熟的 Css预处理器，拥有 Ruby 社区的支持和 Compass 这一最强大的 Css框架，目前受 LESS\n影响，已经进化到了全面兼容 Css 的 Scss\n\n文件后缀名为.sass与scss，可以严格按照 sass 的缩进方式省去大括号和分号\n\n\nless#\n\n2009 年出现，受SASS的影响较大，但又使用 Css 的语法，让大部分开发者和设计师更容易上手，在 Ruby社区之外支持者远超过 SASS\n\n其缺点是比起 SASS来，可编程功能不够，不过优点是简单和兼容 Css，反过来也影响了 SASS演变到了Scss 的时代\n\n\nstylus#\n\nStylus是一个Css的预处理框架，2010 年产生，来自 Node.js社区，主要用来给 Node 项目进行 Css 预处理支持\n\n所以Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的Css。比较年轻，其本质上做的事情与SASS/LESS等类似\n\n\n三、区别#\n\n虽然各种预处理器功能强大，但使用最多的，还是以下特性：\n\n * 变量（variables）\n * 作用域（scope）\n * 代码混合（ mixins）\n * 嵌套（nested rules）\n * 代码模块化（Modules）\n\n因此，下面就展开这些方面的区别\n\n\n基本使用#\n\nless 和 scss\n\n\n\nsass\n\n\n\nstylus\n\n\n\n\n嵌套#\n\n三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 & 也相同\n\n区别只是 Sass 和 Stylus 可以用没有大括号的方式书写\n\nless\n\n\n\n\n变量#\n\n变量无疑为 Css 增加了一种有效的复用方式，减少了原来在 Css 中无法避免的重复「硬编码」\n\nless声明的变量必须以@开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号:分隔开\n\n\n\nsass声明的变量跟less十分的相似，只是变量名前面使用@开头\n\n\n\nstylus声明的变量没有任何的限定，可以使用$开头，结尾的分号;可有可无，但变量与变量值之间需要使用=\n\n在stylus中我们不建议使用@符号开头声明变量\n\n\n\n\n作用域#\n\nCss 预编译器把变量赋予作用域，也就是存在生命周期。就像 js一样，它会先从局部作用域查找变量，依次向上级作用域查找\n\nsass中不存在全局变量\n\n\n\n编译后\n\n\n\n所以，在sass中最好不要定义相同的变量名\n\nless与stylus的作用域跟javascript十分的相似，首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止\n\n\n\n编译后：\n\n\n\n\n混入#\n\n混入（mixin）应该说是预处理器最精髓的功能之一了，简单点来说，Mixins可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用\n\n可以在Mixins中定义变量或者默认参数\n\n在less中，混合的用法是指将定义好的ClassA中引入另一个已经定义的Class，也能使用够传递参数，参数变量为@声明\n\n\n\n编译后\n\n\n\nSass声明mixins时需要使用@mixinn，后面紧跟mixin的名，也可以设置参数，参数名为变量$声明的形式\n\n\n\nstylus中的混合和前两款Css预处理器语言的混合略有不同，他可以不使用任何符号，就是直接声明Mixins名，然后在定义参数和默认值之间用等号（=）来连接\n\n\n\n\n代码模块化#\n\n模块化就是将Css代码分成一个个模块\n\nscss、less、stylus三者的使用方法都如下所示\n\n\n\n\n参考文献#\n\n * https://jelly.jd.com/article/5dcb9c73641a030153732a89\n * https://zhuanlan.zhihu.com/p/23382462\n * https://baike.baidu.com/item/Less/17570158","routePath":"/interview/css/sass_less_stylus","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"预处理语言","id":"预处理语言","depth":4,"charIndex":164},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":301},{"text":"sass","id":"sass","depth":3,"charIndex":368},{"text":"less","id":"less","depth":3,"charIndex":517},{"text":"stylus","id":"stylus","depth":3,"charIndex":660},{"text":"三、区别","id":"三区别","depth":2,"charIndex":805},{"text":"基本使用","id":"基本使用","depth":3,"charIndex":946},{"text":"嵌套","id":"嵌套","depth":3,"charIndex":987},{"text":"变量","id":"变量","depth":3,"charIndex":1069},{"text":"作用域","id":"作用域","depth":3,"charIndex":1293},{"text":"混入","id":"混入","depth":3,"charIndex":1492},{"text":"代码模块化","id":"代码模块化","depth":3,"charIndex":1806},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1867}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 Css 预编语言的理解？有哪些区别?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 Css 预编语言的理解？有哪些区别?","order":11,"star":11,"date":"2023-03-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-说说对 Css 预编语言的理解？有哪些区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 Css 预编语言的理解？有哪些区别?"}]]},"version":""},{"id":138,"title":"如何实现单行／多行文本溢出的省略样式？","content":"这是一段很长的文本","routePath":"/interview/css/single_multi_line","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":-1},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":-1},{"text":"单行文本溢出省略","id":"单行文本溢出省略","depth":3,"charIndex":-1},{"text":"多行文本溢出省略","id":"多行文本溢出省略","depth":3,"charIndex":-1},{"text":"基于高度截断","id":"基于高度截断","depth":4,"charIndex":-1},{"text":"伪元素 + 定位","id":"伪元素--定位","depth":4,"charIndex":-1},{"text":"基于行数截断","id":"基于行数截断","depth":4,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何实现单行／多行文本溢出的省略样式？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>如何实现单行／多行文本溢出的省略样式？","order":10,"star":10,"date":"2023-03-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-如何实现单行／多行文本溢出的省略样式？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何实现单行／多行文本溢出的省略样式？"}]]},"version":""},{"id":139,"title":"CSS 如何画一个三角形？原理是什么？","content":"#\n\n\n\n\n一、前言#\n\n在前端开发的时候，我们有时候会需要用到一个三角形的形状，比如地址选择或者播放器里面播放按钮\n\n\n\n通常情况下，我们会使用图片或者svg去完成三角形效果图，但如果单纯使用css如何完成一个三角形呢？\n\n实现过程似乎也并不困难，通过边框就可完成\n\n\n二、实现过程#\n\n在以前也讲过盒子模型，默认情况下是一个矩形，实现也很简单\n\n\n\n效果如下图所示：\n\n\n\n将border设置50px，效果图如下所示：\n\n\n\n白色区域则为width、height，这时候只需要你将白色区域部分宽高逐渐变小，最终变为 0，则变成如下图所示：\n\n\n\n这时候就已经能够看到 4 个不同颜色的三角形，如果需要下方三角形，只需要将上、左、右边框设置为 0 就可以得到下方的红色三角形\n\n\n\n但这种方式，虽然视觉上是实现了三角形，但实际上，隐藏的部分任然占据部分高度，需要将上方的宽度去掉\n\n最终实现代码如下：\n\n\n\n如果想要实现一个只有边框是空心的三角形，由于这里不能再使用border属性，所以最直接的方法是利用伪类新建一个小一点的三角形定位上去\n\n\n\n效果图如下所示：\n\n\n\n伪类元素定位参照对象的内容区域宽高都为 0，则内容区域即可以理解成中心一点，所以伪元素相对中心这点定位\n\n将元素定位进行微调以及改变颜色，就能够完成下方效果图：\n\n\n\n最终代码如下：\n\n\n\n\n三、原理分析#\n\n可以看到，边框是实现三角形的部分，边框实际上并不是一个直线，如果我们将四条边设置不同的颜色，将边框逐渐放大，可以得到每条边框都是一个梯形\n\n\n\n当分别取消边框的时候，发现下面几种情况：\n\n * 取消一条边的时候，与这条边相邻的两条边的接触部分会变成直的\n * 当仅有邻边时， 两个边会变成对分的三角\n * 当保留边没有其他接触时，极限情况所有东西都会消失\n\n\n\n通过上图的变化规则，利用旋转、隐藏，以及设置内容宽高等属性，就能够实现其他类型的三角形\n\n如设置直角三角形，如上图倒数第三行实现过程，我们就能知道整个实现原理\n\n实现代码如下：\n\n\n\n\n参考文献#\n\n * https://www.cnblogs.com/echolun/p/11888612.html\n * https://juejin.cn/post/6844903567795421197","routePath":"/interview/css/triangle","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、实现过程","id":"二实现过程","depth":2,"charIndex":135},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":582},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":865}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-CSS 如何画一个三角形？原理是什么？","footer":"CSS 如何画一个三角形？原理是什么？","order":17,"star":17,"date":"2023-03-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-CSS 如何画一个三角形？原理是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"CSS 如何画一个三角形？原理是什么？"}]]},"version":""},{"id":140,"title":"如何使用 css 完成视差滚动效果?","content":"#\n\n\n\n\n一、是什么#\n\n视差滚动（Parallax Scrolling）是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验\n\n我们可以把网页解刨成：背景层、内容层、悬浮层\n\n\n\n当滚动鼠标滑轮的时候，各个图层以不同的速度移动，形成视觉差的效果\n\n\n\n\n二、实现方式#\n\n使用css形式实现视觉差滚动效果的方式有：\n\n * background-attachment\n * transform:translate3D\n\n\nbackground-attachment#\n\n作用是设置背景图像是否固定或者随着页面的其余部分滚动\n\n值分别有如下：\n\n * scroll：默认值，背景图像会随着页面其余部分的滚动而移动\n * fixed：当页面的其余部分滚动时，背景图像不会移动\n * inherit：继承父元素 background-attachment 属性的值\n\n完成滚动视觉差就需要将background-attachment属性设置为fixed，让背景相对于视口固定。及时一个元素有滚动机制，背景也不会随着元素的内容而滚\n动\n\n也就是说，背景一开始就已经被固定在初始的位置\n\n核心的css代码如下：\n\n\n\n整体例子如下：\n\n\n\n\ntransform:translate3D#\n\n同样，让我们先来看一下两个概念transform和perspective：\n\n * transform: css3 属性，可以对元素进行变换(2d/3d)，包括平移 translate,旋转 rotate,缩放 scale,等等\n * perspective: css3 属性，当元素涉及 3d 变换时，perspective 可以定义我们眼睛看到的 3d 立体效果，即空间感\n\n3D视角示意图如下所示：\n\n\n\n举个例子：\n\n\n\n而这种方式实现视觉差动的原理如下：\n\n * 容器设置上 transform-style: preserve-3d 和 perspective: xpx，那么处于这个容器的子元素就将位于 3D\n   空间中，\n\n * 子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z 轴方向距离屏幕（我们的眼睛）的距离也就不一样\n\n * 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY\n   相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果\n\n\n参考文献#\n\n * https://imweb.io/topic/5b73ef73a56e07401e48729d\n * https://juejin.cn/post/6844903654458146823#heading-5","routePath":"/interview/css/visual_scrolling","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现方式","id":"二实现方式","depth":2,"charIndex":138},{"text":"background-attachment","id":"background-attachment","depth":3,"charIndex":222},{"text":"transform:translate3D","id":"transformtranslate3d","depth":3,"charIndex":527},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1052}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何使用 css 完成视差滚动效果?","footer":"如何使用 css 完成视差滚动效果?","order":13,"star":13,"date":"2023-03-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-如何使用 css 完成视差滚动效果?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何使用 css 完成视差滚动效果?"}]]},"version":""},{"id":141,"title":"说说你对工厂模式的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂\n\n其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品\n\n举个例子：\n\n * 编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）\n * 后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B\n   类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；\n * 这种情况下，就需要将创建实例的工作从调用方（A\n   类）中分离，与调用方解耦，也就是使用工厂方法创建实例的工作封装起来（减少代码重复），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，而\n   降低调用者因为创建逻辑导致的错误；\n\n\n二、实现#\n\n工厂模式根据抽象程度的不同可以分为：\n\n * 简单工厂模式（Simple Factory）\n * 工厂方法模式（Factory Method）\n * 抽象工厂模式（Abstract Factory）\n\n\n简单工厂模式#\n\n简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例\n\n假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致\n\n代码如下：\n\n\n\nFactory就是一个简单工厂。当我们调用工厂函数时，只需要传递 name、age、career 就可以获取到包含用户工作内容的实例对象\n\n\n工厂方法模式#\n\n工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的prototype中\n\n这样一来，扩展产品种类就不必修改工厂函数了，和心累就变成抽象类，也可以随时重写某种具体的产品\n\n也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂\n来进行生产\n\n如下代码：\n\n\n\n工厂方法关键核心代码是工厂里面的判断 this 是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品\n\n\n抽象工厂模式#\n\n上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建\n\n通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的\n\n由于JavaScript中并没有抽象类的概念，只能模拟，可以分成四部分：\n\n * 用于创建抽象类的函数\n * 抽象类\n * 具体类\n * 实例化具体类\n\n上面的例子中有coder、hr、boss、driver四种岗位，其中coder可能使用不同的开发语言进行开发，比如JavaScript、Java等等。那么这两种\n语言就是对应的类簇\n\n示例代码如下：\n\n\n\n上面代码中CareerAbstractFactory就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承\n\n\n三、应用场景#\n\n从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节\n\n应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况\n\n抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些\n\n综上，工厂模式适用场景如下：\n\n * 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择\n * 将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；\n * 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦\n   合，提供更大的灵活性\n\n\n参考文献#\n\n * https://www.runoob.com/design-pattern/factory-pattern.html\n * https://juejin.cn/post/6844903653774458888\n * https://zhuanlan.zhihu.com/p/344119981","routePath":"/interview/design/Factory_Pattern","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现","id":"二实现","depth":2,"charIndex":450},{"text":"简单工厂模式","id":"简单工厂模式","depth":3,"charIndex":559},{"text":"工厂方法模式","id":"工厂方法模式","depth":3,"charIndex":722},{"text":"抽象工厂模式","id":"抽象工厂模式","depth":3,"charIndex":977},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1351},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1772}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对工厂模式的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对工厂模式的理解？应用场景？","order":3,"star":3,"date":"2023-03-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说你对工厂模式的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对工厂模式的理解？应用场景？"}]]},"version":""},{"id":142,"title":"说说你对发布订阅、观察者模式的理解？区别？","content":"#\n\n\n\n\n一、观察者模式#\n\n观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新\n\n观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯\n\n\n\n例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸\n\n报社和订报纸的客户就形成了一对多的依赖关系\n\n实现代码如下：\n\n被观察者模式\n\n\n\n观察者：\n\n\n\n使用代码如下：\n\n\n\n上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表\n\n\n二、发布订阅模式#\n\n发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的\n话）可能存在\n\n同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在\n\n\n\n实现代码如下：\n\n\n\n发布者代码如下：\n\n\n\n订阅者代码如下：\n\n\n\n使用代码如下：\n\n\n\n上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责\n\n\n三、区别#\n\n两种设计模式思路是一样的，举个生活例子：\n\n * 观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体\n * 发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决\n\n上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的\n\n两者区别如下图：\n\n\n\n * 在观察者模式中，观察者是知道 Subject 的，Subject\n   一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。\n\n * 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。\n\n * 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）\n\n\n参考文献#\n\n * https://zh.wikipedia.org/zh-hans/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8\n   F\n * https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85\n * https://www.cnblogs.com/onepixel/p/10806891.html\n * https://juejin.cn/post/6978728619782701087","routePath":"/interview/design/Observer_Pattern","lang":"","toc":[{"text":"一、观察者模式","id":"一观察者模式","depth":2,"charIndex":5},{"text":"二、发布订阅模式","id":"二发布订阅模式","depth":2,"charIndex":304},{"text":"三、区别","id":"三区别","depth":2,"charIndex":570},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1039}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对发布订阅、观察者模式的理解？区别？","footer":"说说你对发布订阅、观察者模式的理解？区别？","order":6,"star":6,"date":"2023-03-23T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说你对发布订阅、观察者模式的理解？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对发布订阅、观察者模式的理解？区别？"}]]},"version":""},{"id":143,"title":"说说你对代理模式的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问\n\n代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象\n\n\n\n在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作\n用就是代理的作用\n\n\n二、使用#\n\n在ES6中，存在proxy构建函数能够让我们轻松使用代理模式：\n\n\n\n关于Proxy的使用可以翻看以前的文章\n\n而按照功能来划分，javascript代理模式常用的有：\n\n * 缓存代理\n\n * 虚拟代理\n\n\n缓存代理#\n\n缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果\n\n如实现一个求积乘的函数，如下：\n\n\n\n现在加入缓存代理，如下：\n\n\n\n当第二次调用 proxyMult(1, 2, 3, 4) 时，本体 mult 函数并没有被计算，proxyMult 直接返回了之前缓存好的计算结果\n\n\n虚拟代理#\n\n虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建\n\n常见的就是图片预加载功能：\n\n未使用代理模式如下：\n\n\n\nMyImage对象除了负责给img节点设置src外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则\n\n上述过程loding则是耦合进MyImage对象里的，如果以后某个时候，我们不需要预加载显示 loading 这个功能了，就只能在MyImage对象里面改动代码\n\n使用代理模式，代码则如下：\n\n\n\n使用代理模式后，图片本地对象负责往页面中创建一个img标签，并且提供一个对外的setSrc接口；\n\n代理对象负责在图片未加载完成之前，引入预加载的loading图，负责了图片预加载的功能\n\n上述并没有改变或者增加MyImage的接口，但是通过代理对象，实际上给系统添加了新的行为\n\n并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了\nsetSrc 方法\n\n‘\n\n\n三、应用场景#\n\n现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化\n\n使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 Axios 的实例来进行 HTTP 的请求，使用拦截器 interceptor\n可以提前对 请求前的数据 服务器返回的数据进行一些预处理\n\n以及上述应用到的缓存代理和虚拟代理\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903555036364814#heading-2\n * https://juejin.cn/post/6992510837403418654#heading-7\n * https://sothx.com/2021/06/26/proxy/","routePath":"/interview/design/Proxy_Pattern","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用","id":"二使用","depth":2,"charIndex":221},{"text":"缓存代理","id":"缓存代理","depth":3,"charIndex":333},{"text":"虚拟代理","id":"虚拟代理","depth":3,"charIndex":516},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":975},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1150}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对代理模式的理解？应用场景？","footer":"说说你对代理模式的理解？应用场景？","order":5,"star":5,"date":"2023-03-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说你对代理模式的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对代理模式的理解？应用场景？"}]]},"version":""},{"id":144,"title":"前端物语|面试物语-design","content":" * 说说你对工厂模式的理解？应用场景？\n * 说说你对发布订阅、观察者模式的理解？区别？\n * 说说你对代理模式的理解？应用场景？\n * 说说你对单例模式的理解？如何实现？\n * 说说你对策略模式的理解？应用场景？\n * 说说对设计模式的理解？常见的设计模式有哪些？","routePath":"/interview/design/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"design","tag":"design","title":"前端物语|面试物语-design","index":false,"dir":{"order":1},"date":"2023-03-23T00:00:00.000Z"},"version":""},{"id":145,"title":"说说你对单例模式的理解？如何实现？","content":"#\n\n\n\n\n一、是什么#\n\n单例模式（Singleton\nPattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建\n\n在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：\n\n\n\n从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：\n\n * 全局命名污染\n * 不易维护，容易被重写覆盖\n\n\n二、实现#\n\n在javascript中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：\n\n\n\n使用闭包也能够实现，如下：\n\n\n\n也可以将上述的方法稍作修改，变成构造函数的形式，如下：\n\n\n\n\n三、使用场景#\n\n在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个\n\n可以先创建一个通常的获取对象的方法，如下：\n\n\n\n创建弹窗的代码如下：\n\n\n\n上述这种实现称为惰性单例，意图解决需要时才创建类实例对象\n\n并且Vuex、redux全局态管理库也应用单例模式的思想，如下图：\n\n\n\n现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如jquery、lodash、moment...\n\n\n参考文献#\n\n * https://zh.wikipedia.org/zh-hans/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\n * https://www.runoob.com/design-pattern/singleton-pattern.html\n * https://juejin.cn/post/6844903874210299912#heading-5","routePath":"/interview/design/Singleton_Pattern","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、实现","id":"二实现","depth":2,"charIndex":238},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":372},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":622}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对单例模式的理解？如何实现？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对单例模式的理解？如何实现？","order":1,"star":1,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说你对单例模式的理解？如何实现？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对单例模式的理解？如何实现？"}]]},"version":""},{"id":146,"title":"说说你对策略模式的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来\n\n一个基于策略模式的程序至少由两部分组成：\n\n * 策略类，策略类封装了具体的算法，并负责具体的计算过程\n * 环境类 Context，Context 接受客户的请求，随后 把请求委托给某一个策略类\n\n\n二、使用#\n\n举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为 A 的人，年终奖为工资的 4 倍，绩效为 B 的人，年终奖为工资的 3 倍，绩效为 C\n的人，年终奖为工资的 2 倍\n\n若使用if来实现，代码则如下：\n\n\n\n从上述可有看到，函数内部包含过多if...else，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则\n\n而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：\n\n\n\n上述代码中，obj对应的是策略类，而calculateBouns对应上下通信类\n\n又比如实现一个表单校验的代码，常常会像如下写法：\n\n\n\n上述代码包含多处if语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码\n\n此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：\n\n\n\n然后找出变的地方，作为环境类context，负责接收用户的要求并委托给策略规则对象，如下Validator类：\n\n\n\n通过validator.add方法添加校验规则和错误信息提示，使用如下：\n\n\n\n上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用\n\n\n三、应用场景#\n\n从上面可以看到，使用策略模式的优点有如下：\n\n * 策略模式利用组合，委托等技术和思想，有效的避免很多 if 条件语句\n * 策略模式提供了开放-封闭原则，使代码更容易理解和扩展\n * 策略模式中的代码可以复用\n\n策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”\n\n只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000021883055\n * https://juejin.cn/post/6844903504109109262\n * https://juejin.cn/post/6844903751225081864","routePath":"/interview/design/Strategy_Pattern","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用","id":"二使用","depth":2,"charIndex":181},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":728},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":948}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对策略模式的理解？应用场景？","footer":"说说你对策略模式的理解？应用场景？","order":4,"star":4,"date":"2023-03-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说你对策略模式的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对策略模式的理解？应用场景？"}]]},"version":""},{"id":147,"title":"说说对设计模式的理解？常见的设计模式有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案\n\n设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案\n\n设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力\n\n因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式\n\n比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件\n\n因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题\n\n\n二、有哪些#\n\n常见的设计模式有：\n\n * 单例模式\n * 工厂模式\n * 策略模式\n * 代理模式\n * 中介者模式\n * 装饰者模式\n * ......\n\n\n单例模式#\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例\n对象\n\n如下图的车，只有一辆，一旦借出去则不能再借给别人：\n\n\n\n\n工厂模式#\n\n工厂模式通常会分成 3 个角色：\n\n * 工厂角色-负责实现创建所有实例的内部逻辑.\n * 抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口\n * 具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例\n\n\n\n\n策略模式#\n\n策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换\n\n至少分成两部分：\n\n * 策略类（可变），策略类封装了具体的算法，并负责具体的计算过程\n * 环境类（不变），接受客户的请求，随后将请求委托给某一个策略类\n\n\n代理模式#\n\n代理模式：为对象提供一个代用品或占位符，以便控制对它的访问\n\n例如实现图片懒加载的功能，先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面\n\n\n中介者模式#\n\n中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可\n\n通过中介者模式可以解除对象与对象之间的紧耦合关系\n\n\n装饰者模式#\n\n装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法\n\n通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求\n\n\n三、总结#\n\n不断去学习设计模式，会对我们有着极大的帮助，主要如下：\n\n * 从许多优秀的软件系统中总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作\n\n * 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂\n\n * 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、\n   编写一些重复的代码\n\n * 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统\n\n * 学习设计模式将有助于初学者更加深入地理解面向对象思想\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1\n   %E7%AE%97%E6%9C%BA)\n * https://juejin.cn/post/6844903795017646094\n * https://segmentfault.com/a/1190000030850326","routePath":"/interview/design/design","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":311},{"text":"单例模式","id":"单例模式","depth":3,"charIndex":392},{"text":"工厂模式","id":"工厂模式","depth":3,"charIndex":514},{"text":"策略模式","id":"策略模式","depth":3,"charIndex":648},{"text":"代理模式","id":"代理模式","depth":3,"charIndex":775},{"text":"中介者模式","id":"中介者模式","depth":3,"charIndex":883},{"text":"装饰者模式","id":"装饰者模式","depth":3,"charIndex":995},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1081},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1407}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对设计模式的理解？常见的设计模式有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对设计模式的理解？常见的设计模式有哪些？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","design"],"tag":["interview","design"],"shortTitle":"前端物语|面试物语-说说对设计模式的理解？常见的设计模式有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对设计模式的理解？常见的设计模式有哪些？"}]]},"version":""},{"id":148,"title":"前端物语|面试物语-design","content":" * 说说你对工厂模式的理解？应用场景？\n * 说说你对发布订阅、观察者模式的理解？区别？\n * 说说你对代理模式的理解？应用场景？\n * 说说你对单例模式的理解？如何实现？\n * 说说你对策略模式的理解？应用场景？\n * 说说对设计模式的理解？常见的设计模式有哪些？","routePath":"/interview/design/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"design","tag":"design","title":"前端物语|面试物语-design","index":false,"dir":{"order":1},"date":"2023-03-23T00:00:00.000Z"},"version":""},{"id":149,"title":"前端物语|面试物语-es6","content":" * ES6 中数组新增了哪些扩展？\n * 你是怎么理解 ES6 中 Decorator 的？使用场景？\n * 对象新增了哪些扩展？\n * 你是怎么理解 ES6 中 Generator 的？使用场景？\n * 你是怎么理解 ES6 中 Module 的？使用场景？\n * 对象新增了哪些扩展？\n * 你是怎么理解 ES6 中 Promise 的？使用场景？\n * 你是怎么理解 ES6 中 Proxy 的？使用场景?\n * 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？\n * 说说 var、let、const 之间的区别","routePath":"/interview/es6/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"es6","tag":"es6","title":"前端物语|面试物语-es6","index":false,"dir":{"order":1},"date":"2023-03-30T00:00:00.000Z"},"version":""},{"id":150,"title":"ES6 中数组新增了哪些扩展？","content":"#\n\n\n\n\n一、扩展运算符的应用#\n\nES6 通过扩展元素符...，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n\n\n主要用于函数调用的时候，将一个数组变为参数序列\n\n\n\n可以将某些数据结构转为数组\n\n\n\n能够更简单实现数组复制\n\n\n\n数组的合并也更为简洁了\n\n\n\n注意：通过扩展运算符实现的是浅拷贝，修改了引用指向的值，会同步反映到新数组\n\n下面看个例子就清楚多了\n\n\n\n扩展运算符可以与解构赋值结合起来，用于生成数组\n\n\n\n如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错\n\n\n\n可以将字符串转为真正的数组\n\n\n\n定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组\n\n\n\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错\n\n\n\n\n二、构造函数新增的方法#\n\n关于构造函数，数组新增的方法有如下：\n\n * Array.from()\n * Array.of()\n\n\nArray.from()#\n\n将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）\n\n\n\n还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组\n\n\n\n\nArray.of()#\n\n用于将一组值，转换为数组\n\n\n\n没有参数的时候，返回一个空数组\n\n当参数只有一个的时候，实际上是指定数组的长度\n\n参数个数不少于 2 个时，Array()才会返回由参数组成的新数组\n\n\n\n\n三、实例对象新增的方法#\n\n关于数组实例对象新增的方法有如下：\n\n * copyWithin()\n * find()、findIndex()\n * fill()\n * entries()，keys()，values()\n * includes()\n * flat()，flatMap()\n\n\ncopyWithin()#\n\n将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组\n\n参数如下：\n\n * target（必需）：从该位置开始替换数据。如果为负值，表示倒数。\n * start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。\n * end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。\n\n\n\n\nfind()、findIndex()#\n\nfind()用于找出第一个符合条件的数组成员\n\n参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组\n\n\n\nfindIndex返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1\n\n\n\n这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。\n\n\n\n\nfill()#\n\n使用给定值，填充一个数组\n\n\n\n还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置\n\n\n\n注意，如果填充的类型为对象，则是浅拷贝\n\n\nentries()，keys()，values()#\n\nkeys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历\n\n\n\n\nincludes()#\n\n用于判断数组是否包含给定的值\n\n\n\n方法的第二个参数表示搜索的起始位置，默认为0\n\n参数为负数则表示倒数的位置\n\n\n\n\nflat()，flatMap()#\n\n将数组扁平化处理，返回一个新数组，对原数据没有影响\n\n\n\nflat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为 1\n\n\n\nflatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map()，然后对返回值组成的数组执行flat()方法。该方法返回\n一个新数组，不改变原数组\n\n\n\nflatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this\n\n\n四、数组的空位#\n\n数组的空位指，数组的某一个位置没有任何值\n\nES6\n则是明确将空位转为u\nndefined，包括Array.from、扩展运算符、copyWithin()、fill()、entries()、keys()、values()、find()\n和findIndex()\n\n建议大家在日常书写中，避免出现空位\n\n\n五、排序稳定性#\n\n将sort()默认设置为稳定的排序算法\n\n\n\n排序结果中，straw在spork的前面，跟原始顺序一致\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/array","routePath":"/interview/es6/array","lang":"","toc":[{"text":"一、扩展运算符的应用","id":"一扩展运算符的应用","depth":2,"charIndex":5},{"text":"二、构造函数新增的方法","id":"二构造函数新增的方法","depth":2,"charIndex":357},{"text":"Array.from()","id":"arrayfrom","depth":3,"charIndex":423},{"text":"Array.of()","id":"arrayof","depth":3,"charIndex":546},{"text":"三、实例对象新增的方法","id":"三实例对象新增的方法","depth":3,"charIndex":654},{"text":"copyWithin()","id":"copywithin","depth":3,"charIndex":800},{"text":"find()、findIndex()","id":"findfindindex","depth":3,"charIndex":994},{"text":"fill()","id":"fill","depth":3,"charIndex":1162},{"text":"entries()，keys()，values()","id":"entrieskeysvalues","depth":3,"charIndex":1244},{"text":"includes()","id":"includes","depth":3,"charIndex":1324},{"text":"flat()，flatMap()","id":"flatflatmap","depth":3,"charIndex":1397},{"text":"四、数组的空位","id":"四数组的空位","depth":3,"charIndex":1654},{"text":"五、排序稳定性","id":"五排序稳定性","depth":3,"charIndex":1816},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1880}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-ES6 中数组新增了哪些扩展？","footer":"ES6 中数组新增了哪些扩展？","order":8,"star":8,"date":"2023-03-26T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-ES6 中数组新增了哪些扩展？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"ES6 中数组新增了哪些扩展？"}]]},"version":""},{"id":151,"title":"你是怎么理解 ES6 中 Decorator 的？使用场景？","content":"#\n\n\n\n\n一、介绍#\n\nDecorator，即装饰器，从名字上很容易让我们联想到装饰者模式\n\n简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。\n\nES6中Decorator功能亦如此，其本质也不是什么高大上的结构，就是一个普通的函数，用于扩展类属性和类方法\n\n这里定义一个士兵，这时候他什么装备都没有\n\n\n\n定义一个得到 AK 装备的函数，即装饰器\n\n\n\n使用该装饰器对士兵进行增强\n\n\n\n这时候士兵就有武器了\n\n\n\n上述代码虽然简单，但也能够清晰看到了使用Decorator两大优点：\n\n * 代码可读性变强了，装饰器命名相当于一个注释\n * 在不改变原有代码情况下，对原来功能进行扩展\n\n\n二、用法#\n\nDocorator修饰对象为下面两种：\n\n * 类的装饰\n * 类属性的装饰\n\n\n类的装饰#\n\n当对类本身进行装饰的时候，能够接受一个参数，即类本身\n\n将装饰器行为进行分解，大家能够有个更深入的了解\n\n\n\n下面@testable就是一个装饰器，target就是传入的类，即MyTestableClass，实现了为类添加静态属性\n\n\n\n如果想要传递参数，可以在装饰器外层再封装一层函数\n\n\n\n\n类属性的装饰#\n\n当对类属性进行装饰的时候，能够接受三个参数：\n\n * 类的原型对象\n * 需要装饰的属性名\n * 装饰属性名的描述对象\n\n首先定义一个readonly装饰器\n\n\n\n使用readonly装饰类的name方法\n\n\n\n相当于以下调用\n\n\n\n如果一个方法有多个装饰器，就像洋葱一样，先从外到内进入，再由内到外执行\n\n\n\n外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行\n\n\n注意#\n\n装饰器不能用于修饰函数，因为函数存在变量声明情况\n\n\n\n编译阶段，变成下面\n\n\n\n意图是执行后counter等于 1，但是实际上结果是counter等于 0\n\n\n三、使用场景#\n\n基于Decorator强大的作用，我们能够完成各种场景的需求，下面简单列举几种：\n\n使用react-redux的时候，如果写成下面这种形式，既不雅观也很麻烦\n\n\n\n通过装饰器就变得简洁多了\n\n\n\n将mixins，也可以写成装饰器，让使用更为简洁了\n\n\n\n下面再讲讲core-decorators.js几个常见的装饰器\n\n@antobind#\n\nautobind装饰器使得方法中的this对象，绑定原始对象\n\n\n\n@readonly#\n\nreadonly装饰器使得属性或方法不可写\n\n\n\n@deprecate#\n\ndeprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除\n\n\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/decorator","routePath":"/interview/es6/decorator","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"二、用法","id":"二用法","depth":2,"charIndex":318},{"text":"类的装饰","id":"类的装饰","depth":3,"charIndex":366},{"text":"类属性的装饰","id":"类属性的装饰","depth":3,"charIndex":521},{"text":"注意","id":"注意","depth":3,"charIndex":722},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":808},{"text":"@antobind","id":"antobind","depth":4,"charIndex":977},{"text":"@readonly","id":"readonly","depth":4,"charIndex":1023},{"text":"@deprecate","id":"deprecate","depth":4,"charIndex":1060},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1120}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 中 Decorator 的？使用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>你是怎么理解 ES6 中 Decorator 的？使用场景？","order":3,"star":3,"date":"2023-03-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 中 Decorator 的？使用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 中 Decorator 的？使用场景？"}]]},"version":""},{"id":152,"title":"对象新增了哪些扩展？","content":"#\n\n\n\n\n一、参数#\n\nES6允许为函数的参数设置默认值\n\n\n\n函数的形参是默认声明的，不能使用let或const再次声明\n\n\n\n参数默认值可以与解构赋值的默认值结合起来使用\n\n\n\n上面的foo函数，当参数为对象的时候才能进行解构，如果没有提供参数的时候，变量x和y就不会生成，从而报错，这里设置默认值避免\n\n\n\n参数默认值应该是函数的尾参数，如果不是非尾部的参数设置默认值，实际上这个参数是没发省略的\n\n\n\n\n二、属性#\n\n\n函数的 length 属性#\n\nlength将返回没有指定默认值的参数个数\n\n\n\nrest 参数也不会计入length属性\n\n\n\n如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了\n\n\n\n\nname 属性#\n\n返回该函数的函数名\n\n\n\n如果将一个具名函数赋值给一个变量，则 name属性都返回这个具名函数原本的名字\n\n\n\nFunction构造函数返回的函数实例，name属性的值为anonymous\n\n\n\nbind返回的函数，name属性值会加上bound前缀\n\n\n\n\n三、作用域#\n\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域\n\n等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的\n\n下面例子中，y=x会形成一个单独作用域，x没有被定义，所以指向全局变量x\n\n\n\n\n四、严格模式#\n\n只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错\n\n\n\n\n五、箭头函数#\n\n使用“箭头”（=>）定义函数\n\n\n\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分\n\n\n\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回\n\n\n\n如果返回对象，需要加括号将对象包裹\n\n\n\n注意点：\n\n * 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象\n * 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误\n * 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替\n * 不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/function","routePath":"/interview/es6/function","lang":"","toc":[{"text":"一、参数","id":"一参数","depth":2,"charIndex":5},{"text":"二、属性","id":"二属性","depth":2,"charIndex":206},{"text":"函数的 length 属性","id":"函数的-length-属性","depth":3,"charIndex":214},{"text":"name 属性","id":"name-属性","depth":3,"charIndex":322},{"text":"三、作用域","id":"三作用域","depth":2,"charIndex":462},{"text":"四、严格模式","id":"四严格模式","depth":2,"charIndex":593},{"text":"五、箭头函数","id":"五箭头函数","depth":2,"charIndex":657},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":969}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-对象新增了哪些扩展？","footer":"对象新增了哪些扩展？","order":10,"star":10,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-对象新增了哪些扩展？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"对象新增了哪些扩展？"}]]},"version":""},{"id":153,"title":"你是怎么理解 ES6 中 Generator 的？使用场景？","content":"#\n\n\n\n\n一、介绍#\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同\n\n回顾下上文提到的解决异步的手段：\n\n * 回调函数\n * promise\n\n那么，上文我们提到promsie已经是一种比较流行的解决异步方案，那么为什么还出现Generator？甚至async/await呢？\n\n该问题我们留在后面再进行分析，下面先认识下Generator\n\n\nGenerator 函数#\n\n执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态\n\n形式上，Generator函数是一个普通函数，但是有两个特征：\n\n * function关键字与函数名之间有一个星号\n * 函数体内部使用yield表达式，定义不同的内部状态\n\n\n\n\n二、使用#\n\nGenerator 函数会返回一个遍历器对象，即具有Symbol.iterator属性，并且返回给自己\n\n\n\n通过yield关键字可以暂停generator函数返回的遍历器对象的状态\n\n\n\n上述存在三个状态：hello、world、return\n\n通过next方法才会遍历到下一个内部状态，其运行逻辑如下：\n\n * 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n * 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式\n * 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值\n   。\n * 如果该函数没有return语句，则返回的对象的value属性值为undefined\n\n\n\ndone用来判断是否存在下个状态，value对应状态值\n\nyield表达式本身没有返回值，或者说总是返回undefined\n\n通过调用next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值\n\n\n\n正因为Generator函数返回Iterator对象，因此我们还可以通过for...of进行遍历\n\n\n\n原生对象没有遍历接口，通过Generator函数为它加上这个接口，就能使用for...of进行遍历了\n\n\n\n\n三、异步解决方案#\n\n回顾之前展开异步解决的方案：\n\n * 回调函数\n * Promise 对象\n * generator 函数\n * async/await\n\n这里通过文件读取案例，将几种解决异步的方案进行一个比较：\n\n\n回调函数#\n\n所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数\n\n\n\nreadFile函数的第三个参数，就是回调函数，等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行\n\n\nPromise#\n\nPromise就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用\n\n\n\n这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强\n\n\ngenerator#\n\nyield表达式可以暂停函数执行，next方法用于恢复函数执行，这使得Generator函数非常适合将异步任务同步化\n\n\n\n\nasync/await#\n\n将上面Generator函数改成async/await形式，更为简洁，语义化更强了\n\n\n\n\n区别#\n\n通过上述代码进行分析，将promise、Generator、async/await进行比较：\n\n * promise和async/await是专门用于处理异步操作的\n\n * Generator并不是为异步而设计出来的，它还有其他功能（对象迭代、控制输出、部署Interator接口...）\n\n * promise编写代码相比Generator、async更为复杂化，且可读性也稍差\n\n * Generator、async需要与promise对象搭配处理异步情况\n\n * async实质是Generator的语法糖，相当于会自动执行Generator函数\n\n * async使用上更为简洁，将异步代码以同步的形式进行编写，是处理异步编程的最终方案\n\n\n四、使用场景#\n\nGenerator是异步解决的一种方案，最大特点则是将异步操作同步化表达出来\n\n\n\n包括redux-saga中间件也充分利用了Generator特性\n\n\n\n还能利用Generator函数，在对象上实现Iterator接口\n\n\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/generator-async","routePath":"/interview/es6/generator","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"Generator 函数","id":"generator-函数","depth":3,"charIndex":198},{"text":"二、使用","id":"二使用","depth":2,"charIndex":360},{"text":"三、异步解决方案","id":"三异步解决方案","depth":2,"charIndex":975},{"text":"回调函数","id":"回调函数","depth":3,"charIndex":1087},{"text":"Promise","id":"promise","depth":3,"charIndex":1208},{"text":"generator","id":"generator","depth":3,"charIndex":1313},{"text":"async/await","id":"asyncawait","depth":3,"charIndex":1388},{"text":"区别","id":"区别","depth":3,"charIndex":1448},{"text":"四、使用场景","id":"四使用场景","depth":2,"charIndex":1778},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1902}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 中 Generator 的？使用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>你是怎么理解 ES6 中 Generator 的？使用场景？","order":1,"star":1,"date":"2023-03-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 中 Generator 的？使用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 中 Generator 的？使用场景？"}]]},"version":""},{"id":154,"title":"前端物语|面试物语-es6","content":" * ES6 中数组新增了哪些扩展？\n * 你是怎么理解 ES6 中 Decorator 的？使用场景？\n * 对象新增了哪些扩展？\n * 你是怎么理解 ES6 中 Generator 的？使用场景？\n * 你是怎么理解 ES6 中 Module 的？使用场景？\n * 对象新增了哪些扩展？\n * 你是怎么理解 ES6 中 Promise 的？使用场景？\n * 你是怎么理解 ES6 中 Proxy 的？使用场景?\n * 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？\n * 说说 var、let、const 之间的区别","routePath":"/interview/es6/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"es6","tag":"es6","title":"前端物语|面试物语-es6","index":false,"dir":{"order":1},"date":"2023-03-30T00:00:00.000Z"},"version":""},{"id":155,"title":"你是怎么理解 ES6 中 Module 的？使用场景？","content":"#\n\n\n\n\n一、介绍#\n\n模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。\n\n两个基本的特征：外部特征和内部特征\n\n * 外部特征是指模块跟外部环境联系的接口（即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量）和模块的功能\n\n * 内部特征是指模块的内部环境具有的特点（即该模块的局部数据和程序代码）\n\n\n为什么需要模块化#\n\n * 代码抽象\n * 代码封装\n * 代码复用\n * 依赖管理\n\n如果没有模块化，我们代码会怎样？\n\n * 变量和方法不容易维护，容易污染全局作用域\n * 加载资源的方式通过 script 标签从上到下。\n * 依赖的环境主观逻辑偏重，代码较多就会比较复杂。\n * 大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃\n\n因此，需要一种将JavaScript程序模块化的机制，如\n\n * CommonJs (典型代表：node.js 早期)\n * AMD (典型代表：require.js)\n * CMD (典型代表：sea.js)\n\n\nAMD#\n\nAsynchronous\nModuleDefinition（AMD），异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才\n会运行\n\n代表库为require.js\n\n\n\n\nCommonJs#\n\nCommonJS 是一套 Javascript 模块规范，用于服务端\n\n\n\n其有如下特点：\n\n * 所有代码都运行在模块作用域，不会污染全局作用域\n * 模块是同步加载的，即只有加载完成，才能执行后面的操作\n * 模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存\n * require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值\n\n既然存在了AMD以及CommonJs机制，ES6的Module又有什么不一样？\n\nES6 在语言标准的层面上，实现了Module，即模块功能，完全可以取代 CommonJS和 AMD规范，成为浏览器和服务器通用的模块解决方案\n\nCommonJS 和AMD 模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性\n\n\n\nES6设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n\n\n\n上述代码，只加载 3 个方法，其他方法不加载，即 ES6 可以在编译时就完成模块加载\n\n由于编译加载，使得静态分析成为可能。包括现在流行的typeScript也是依靠静态分析实现功能\n\n\n二、使用#\n\nES6模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是ES5之前就已经规定好\n\n模块功能主要由两个命令构成：\n\n * export：用于规定模块的对外接口\n * import：用于输入其他模块提供的功能\n\n\nexport#\n\n一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量\n\n\n\n输出函数或类\n\n\n\n通过as可以进行输出变量的重命名\n\n\n\n\nimport#\n\n使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块\n\n\n\n同样如果想要输入变量起别名，通过as关键字\n\n\n\n当加载整个模块的时候，需要用到星号*\n\n\n\n输入的变量都是只读的，不允许修改，但是如果是对象，允许修改属性\n\n\n\n不过建议即使能修改，但我们不建议。因为修改之后，我们很难差错\n\nimport后面我们常接着from关键字，from指定模块文件的位置，可以是相对路径，也可以是绝对路径\n\n\n\n如果只有一个模块名，需要有配置文件，告诉引擎模块的位置\n\n\n\n在编译阶段，import会提升到整个模块的头部，首先执行\n\n\n\n多次重复执行同样的导入，只会执行一次\n\n\n\n上面的情况，大家都能看到用户在导入模块的时候，需要知道加载的变量名和函数，否则无法加载\n\n如果不需要知道变量名或函数就完成加载，就要用到export default命令，为模块指定默认输出\n\n\n\n加载该模块的时候，import命令可以为该函数指定任意名字\n\n\n\n\n动态加载#\n\n允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势\n\n这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。 它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出\n\n\n\n\n复合写法#\n\n如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起\n\n\n\n同理能够搭配as、*搭配使用\n\n\n三、使用场景#\n\n如今，ES6模块化已经深入我们日常项目开发中，像vue、react项目搭建项目，组件化开发处处可见，其也是依赖模块化实现\n\nvue组件\n\n\n\nreact组件\n\n\n\n包括完成一些复杂应用的时候，我们也可以拆分成各个模块\n\n\n参考文献#\n\n * https://macsalvation.net/the-history-of-js-module/\n * https://es6.ruanyifeng.com/#docs/module","routePath":"/interview/es6/module","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"为什么需要模块化","id":"为什么需要模块化","depth":3,"charIndex":192},{"text":"AMD","id":"amd","depth":3,"charIndex":479},{"text":"CommonJs","id":"commonjs","depth":3,"charIndex":603},{"text":"二、使用","id":"二使用","depth":2,"charIndex":1120},{"text":"export","id":"export","depth":3,"charIndex":1239},{"text":"import","id":"import","depth":3,"charIndex":1355},{"text":"动态加载","id":"动态加载","depth":3,"charIndex":1804},{"text":"复合写法","id":"复合写法","depth":3,"charIndex":1933},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":2006},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2126}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 中 Module 的？使用场景？","footer":"你是怎么理解 ES6 中 Module 的？使用场景？","order":9,"star":9,"date":"2023-03-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 中 Module 的？使用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 中 Module 的？使用场景？"}]]},"version":""},{"id":156,"title":"对象新增了哪些扩展？","content":"#\n\n\n\n\n一、属性的简写#\n\nES6 中，当对象键名与对应值名相等的时候，可以进行简写\n\n\n\n方法也能够进行简写\n\n\n\n在函数内作为返回值，也会变得方便很多\n\n\n\n注意：简写的对象方法不能用作构造函数，否则会报错\n\n\n\n\n二、属性名表达式#\n\nES6 允许字面量定义对象时，将表达式放在括号内\n\n\n\n表达式还可以用于定义方法名\n\n\n\n注意，属性名表达式与简洁表示法，不能同时使用，会报错\n\n\n\n注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\n\n\n\n\n三、super 关键字#\n\nthis关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象\n\n\n\n\n四、扩展运算符的应用#\n\n在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面\n\n\n\n注意：解构赋值必须是最后一个参数，否则会报错\n\n解构赋值是浅拷贝\n\n\n\n对象的扩展运算符等同于使用Object.assign()方法\n\n\n五、属性的遍历#\n\nES6 一共有 5 种方法可以遍历对象的属性。\n\n * for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）\n\n * Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名\n\n * Object.getOwnPropertyNames(obj)：回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名\n\n * Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名\n\n * Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举\n\n上述遍历，都遵守同样的属性遍历的次序规则：\n\n * 首先遍历所有数值键，按照数值升序排列\n * 其次遍历所有字符串键，按照加入时间升序排列\n * 最后遍历所有 Symbol 键，按照加入时间升序排\n\n\n\n\n六、对象新增的方法#\n\n关于对象新增的方法，分别有以下：\n\n * Object.is()\n * Object.assign()\n * Object.getOwnPropertyDescriptors()\n * Object.setPrototypeOf()，Object.getPrototypeOf()\n * Object.keys()，Object.values()，Object.entries()\n * Object.fromEntries()\n\n\nObject.is()#\n\n严格判断两个值是否相等，与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身\n\n\n\n\nObject.assign()#\n\nObject.assign()方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target\n\nObject.assign()方法的第一个参数是目标对象，后面的参数都是源对象\n\n\n\n注意：Object.assign()方法是浅拷贝，遇到同名属性会进行替换\n\n\nObject.getOwnPropertyDescriptors()#\n\n返回指定对象所有自身属性（非继承属性）的描述对象\n\n\n\n\nObject.setPrototypeOf()#\n\nObject.setPrototypeOf方法用来设置一个对象的原型对象\n\n\n\n\nObject.getPrototypeOf()#\n\n用于读取一个对象的原型对象\n\n\n\n\nObject.keys()#\n\n返回自身的（不含继承的）所有可遍历（enumerable）属性的键名的数组\n\n\n\n\nObject.values()#\n\n返回自身的（不含继承的）所有可遍历（enumerable）属性的键对应值的数组\n\n\n\n\nObject.entries()#\n\n返回一个对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对的数组\n\n\n\n\nObject.fromEntries()#\n\n用于将一个键值对数组转为对象\n\n\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/object","routePath":"/interview/es6/object","lang":"","toc":[{"text":"一、属性的简写","id":"一属性的简写","depth":2,"charIndex":5},{"text":"二、属性名表达式","id":"二属性名表达式","depth":2,"charIndex":111},{"text":"三、super 关键字","id":"三super-关键字","depth":2,"charIndex":250},{"text":"四、扩展运算符的应用","id":"四扩展运算符的应用","depth":2,"charIndex":324},{"text":"五、属性的遍历","id":"五属性的遍历","depth":2,"charIndex":439},{"text":"六、对象新增的方法","id":"六对象新增的方法","depth":2,"charIndex":918},{"text":"Object.is()","id":"objectis","depth":3,"charIndex":1147},{"text":"Object.assign()","id":"objectassign","depth":3,"charIndex":1227},{"text":"Object.getOwnPropertyDescriptors()","id":"objectgetownpropertydescriptors","depth":3,"charIndex":1386},{"text":"Object.setPrototypeOf()","id":"objectsetprototypeof","depth":3,"charIndex":1452},{"text":"Object.getPrototypeOf()","id":"objectgetprototypeof","depth":3,"charIndex":1519},{"text":"Object.keys()","id":"objectkeys","depth":3,"charIndex":1563},{"text":"Object.values()","id":"objectvalues","depth":3,"charIndex":1621},{"text":"Object.entries()","id":"objectentries","depth":3,"charIndex":1683},{"text":"Object.fromEntries()","id":"objectfromentries","depth":3,"charIndex":1749},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1791}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语- 对象新增了哪些扩展？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>对象新增了哪些扩展？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语- 对象新增了哪些扩展？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"对象新增了哪些扩展？"}]]},"version":""},{"id":157,"title":"你是怎么理解 ES6 中 Promise 的？使用场景？","content":"#\n\n\n\n\n一、介绍#\n\nPromise，译为承诺，是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大\n\n在以往我们如果处理多层异步操作，我们往往会像下面那样编写我们的代码\n\n\n\n阅读上面代码，是不是很难受，上述形成了经典的回调地狱\n\n现在通过Promise的改写上面的代码\n\n\n\n瞬间感受到promise解决异步操作的优点：\n\n * 链式操作减低了编码难度\n * 代码可读性明显增强\n\n下面我们正式来认识promise：\n\n\n状态#\n\npromise对象仅有三种状态\n\n * pending（进行中）\n * fulfilled（已成功）\n * rejected（已失败）\n\n\n特点#\n\n * 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态\n * 一旦状态改变（从pending变为fulfilled和从pending变为rejected），就不会再变，任何时候都可以得到这个结果\n\n\n流程#\n\n认真阅读下图，我们能够轻松了解promise整个流程\n\n\n\n\n二、用法#\n\nPromise对象是一个构造函数，用来生成Promise实例\n\n\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject\n\n * resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”\n * reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”\n\n\n实例方法#\n\nPromise构建出来的实例存在以下方法：\n\n * then()\n * catch()\n * finally()\n\nthen()#\n\nthen是实例状态发生改变时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数\n\nthen方法返回的是一个新的Promise实例，也就是promise能链式书写的原因\n\n\n\ncatch#\n\ncatch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数\n\n\n\nPromise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止\n\n\n\n一般来说，使用catch方法代替then()第二个参数\n\nPromise对象抛出的错误不会传递到外层代码，即不会有任何反应\n\n\n\n浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程\n\ncatch()方法之中，还能再抛出错误，通过后面catch方法捕获到\n\nfinally()#\n\nfinally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作\n\n\n\n\n构造函数方法#\n\nPromise构造函数存在以下方法：\n\n * all()\n * race()\n * allSettled()\n * resolve()\n * reject()\n * try()\n\n\nall()#\n\nPromise.all()方法用于将多个 Promise实例，包装成一个新的 Promise实例\n\n\n\n接受一个数组（迭代对象）作为参数，数组成员都应为Promise实例\n\n实例p的状态由p1、p2、p3决定，分为两种：\n\n * 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数\n * 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数\n\n注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法\n\n\n\n如果p2没有自己的catch方法，就会调用Promise.all()的catch方法\n\n\n\n\nrace()#\n\nPromise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例\n\n\n\n只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变\n\n率先改变的 Promise 实例的返回值则传递给p的回调函数\n\n\n\n\nallSettled()#\n\nPromise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例\n\n只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束\n\n\n\nresolve()#\n\n将现有对象转为 Promise对象\n\n\n\n参数可以分成四种情况，分别如下：\n\n * 参数是一个 Promise 实例，promise.resolve将不做任何修改、原封不动地返回这个实例\n * 参数是一个thenable对象，promise.resolve会将这个对象转为 Promise对象，然后就立即执行thenable对象的then()方法\n * 参数不是具有then()方法的对象，或根本就不是对象，Promise.resolve()会返回一个新的 Promise 对象，状态为resolved\n * 没有参数时，直接返回一个resolved状态的 Promise 对象\n\nreject()#\n\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\n\n\n\nPromise.reject()方法的参数，会原封不动地变成后续方法的参数\n\n\n\n\n三、使用场景#\n\n将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化\n\n\n\n通过链式操作，将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题\n\n\n\n通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可\n\n\n\n通过race可以设置图片请求超时\n\n\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/promise","routePath":"/interview/es6/promise","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"状态","id":"状态","depth":3,"charIndex":224},{"text":"特点","id":"特点","depth":3,"charIndex":299},{"text":"流程","id":"流程","depth":3,"charIndex":414},{"text":"二、用法","id":"二用法","depth":2,"charIndex":450},{"text":"实例方法","id":"实例方法","depth":3,"charIndex":627},{"text":"then()","id":"then","depth":4,"charIndex":692},{"text":"catch","id":"catch","depth":4,"charIndex":812},{"text":"finally()","id":"finally","depth":4,"charIndex":1104},{"text":"构造函数方法","id":"构造函数方法","depth":3,"charIndex":1163},{"text":"all()","id":"all","depth":3,"charIndex":1263},{"text":"race()","id":"race","depth":3,"charIndex":1664},{"text":"allSettled()","id":"allsettled","depth":3,"charIndex":1799},{"text":"resolve()","id":"resolve","depth":4,"charIndex":1929},{"text":"reject()","id":"reject","depth":4,"charIndex":2232},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":2348},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2540}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 中 Promise 的？使用场景？","footer":"你是怎么理解 ES6 中 Promise 的？使用场景？","order":5,"star":5,"date":"2023-03-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 中 Promise 的？使用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 中 Promise 的？使用场景？"}]]},"version":""},{"id":158,"title":"你是怎么理解 ES6 中 Proxy 的？使用场景?","content":"#\n\n\n\n\n一、介绍#\n\n定义： 用于定义基本操作的自定义行为\n\n本质： 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(meta programming)\n\n元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分\n本应在编译时完成的工作\n\n一段代码来理解\n\n\n\n这段程序每执行一次能帮我们生成一个名为program的文件，文件内容为 1024 行echo，如果我们手动来写 1024 行代码，效率显然低效\n\n * 元编程优点：与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译\n\nProxy 亦是如此，用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）\n\n\n二、用法#\n\nProxy为 构造函数，用来生成 Proxy实例\n\n\n\n\n参数#\n\ntarget表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））\n\nhandler通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为\n\n\nhandler 解析#\n\n关于handler拦截属性，有如下：\n\n * get(target,propKey,receiver)：拦截对象属性的读取\n * set(target,propKey,value,receiver)：拦截对象属性的设置\n * has(target,propKey)：拦截propKey in proxy的操作，返回一个布尔值\n * deleteProperty(target,propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值\n * ownKeys(target)：拦截Object.keys(proxy)、for...in等循环，返回一个数组\n * getOwnPropertyDescriptor(target,\n   propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象\n * defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy,\n   propKey, propDesc），返回一个布尔值\n * preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值\n * getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象\n * isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值\n * setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值\n * apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作\n * construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作\n\n\nReflect#\n\n若需要在Proxy内部调用对象的默认行为，建议使用Reflect，其是ES6中操作对象而提供的新 API\n\n基本特点：\n\n * 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在\n * 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false）\n * 让Object操作都变成函数行为\n\n下面我们介绍proxy几种用法：\n\n\nget()#\n\nget接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选\n\n\n\nget能够对数组增删改查进行拦截，下面是试下你数组读取负数的索引\n\n\n\n注意：如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则会报错\n\n\n\n\nset()#\n\nset方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身\n\n假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求\n\n\n\n如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用\n\n\n\n注意，严格模式下，set代理如果没有返回true，就会报错\n\n\n\n\ndeleteProperty()#\n\ndeleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除\n\n\n\n注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错\n\n\n取消代理#\n\n\n\n\n三、使用场景#\n\nProxy其功能非常类似于设计模式中的代理模式，常用功能如下：\n\n * 拦截和监视外部对对象的访问\n * 降低函数或类的复杂度\n * 在复杂操作前对操作进行校验或对所需资源进行管理\n\n使用 Proxy 保障数据类型的准确性\n\n\n\n声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey\n\n\n\n还能通过使用Proxy实现观察者模式\n\n观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行\n\nobservable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数\n\n\n\n观察者函数都放进Set集合，当修改obj的值，在会set函数中拦截，自动执行Set所有的观察者\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/proxy\n * https://vue3js.cn/es6","routePath":"/interview/es6/proxy","lang":"","toc":[{"text":"一、介绍","id":"一介绍","depth":2,"charIndex":5},{"text":"二、用法","id":"二用法","depth":2,"charIndex":390},{"text":"参数","id":"参数","depth":3,"charIndex":426},{"text":"handler 解析","id":"handler-解析","depth":3,"charIndex":529},{"text":"Reflect","id":"reflect","depth":3,"charIndex":1426},{"text":"get()","id":"get","depth":3,"charIndex":1637},{"text":"set()","id":"set","depth":3,"charIndex":1795},{"text":"deleteProperty()","id":"deleteproperty","depth":3,"charIndex":2000},{"text":"取消代理","id":"取消代理","depth":3,"charIndex":2151},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":2161},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2524}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 中 Proxy 的？使用场景?","footer":"你是怎么理解 ES6 中 Proxy 的？使用场景?","order":6,"star":6,"date":"2023-03-18T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 中 Proxy 的？使用场景?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 中 Proxy 的？使用场景?"}]]},"version":""},{"id":159,"title":"你是怎么理解 ES6 新增 Set、Map 两种数据结构的？","content":"#\n\n\n\n如果要用一句来描述，我们可以说\n\nSet是一种叫做集合的数据结构，Map是一种叫做字典的数据结构\n\n什么是集合？什么又是字典？\n\n * 集合 是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合\n\n * 字典 是一些元素的集合。每个元素有一个称作 key 的域，不同元素的 key 各不相同\n\n区别？\n\n * 共同点：集合、字典都可以存储不重复的值\n * 不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储\n\n\n一、Set#\n\nSet是es6新增的数据结构，类似于数组，但是成员的值都是唯一的，没有重复的值，我们一般称为集合\n\nSet本身是一个构造函数，用来生成 Set 数据结构\n\n\n\n\n增删改查#\n\nSet的实例关于增删改查的方法：\n\n * add()\n\n * delete()\n\n * has()\n\n * clear()\n\n\nadd()#\n\n添加某个值，返回 Set 结构本身\n\n当添加实例中已经存在的元素，set不会进行处理添加\n\n\n\n\ndelete()#\n\n删除某个值，返回一个布尔值，表示删除是否成功\n\n\n\n\nhas()#\n\n返回一个布尔值，判断该值是否为Set的成员\n\n\n\n\nclear()#\n\n清除所有成员，没有返回值\n\n\n\n\n遍历#\n\nSet实例遍历的方法有如下：\n\n关于遍历的方法，有如下：\n\n * keys()：返回键名的遍历器\n * values()：返回键值的遍历器\n * entries()：返回键值对的遍历器\n * forEach()：使用回调函数遍历每个成员\n\nSet的遍历顺序就是插入顺序\n\nkeys方法、values方法、entries方法返回的都是遍历器对象\n\n\n\nforEach()用于对每个成员执行某种操作，没有返回值，键值、键名都相等，同样的forEach方法有第二个参数，用于绑定处理函数的this\n\n\n\n扩展运算符和Set 结构相结合实现数组或字符串去重\n\n\n\n实现并集、交集、和差集\n\n\n\n\n二、Map#\n\nMap类型是键值对的有序列表，而键和值都可以是任意类型\n\nMap本身是一个构造函数，用来生成 Map 数据结构\n\n\n\n\n增删改查#\n\nMap 结构的实例针对增删改查有以下属性和操作方法：\n\n * size 属性\n * set()\n * get()\n * has()\n * delete()\n * clear()\n\n\nsize#\n\nsize属性返回 Map 结构的成员总数。\n\n\n\n\nset()#\n\n设置键名key对应的键值为value，然后返回整个 Map 结构\n\n如果key已经有值，则键值会被更新，否则就新生成该键\n\n同时返回的是当前Map对象，可采用链式写法\n\n\n\n\nget()#\n\nget方法读取key对应的键值，如果找不到key，返回undefined\n\n\n\n\nhas()#\n\nhas方法返回一个布尔值，表示某个键是否在当前 Map 对象之中\n\n\n\n\ndelete()#\n\ndelete方法删除某个键，返回true。如果删除失败，返回false\n\n\n\n\nclear()#\n\nclear方法清除所有成员，没有返回值\n\n\n\n\n遍历#\n\nMap结构原生提供三个遍历器生成函数和一个遍历方法：\n\n * keys()：返回键名的遍历器\n * values()：返回键值的遍历器\n * entries()：返回所有成员的遍历器\n * forEach()：遍历 Map 的所有成员\n\n遍历顺序就是插入顺序\n\n\n\n\n三、WeakSet 和 WeakMap#\n\n\nWeakSet#\n\n创建WeakSet实例\n\n\n\nWeakSet可以接受一个具有 Iterable接口的对象作为参数\n\n\n\n在API中WeakSet与Set有两个区别：\n\n * 没有遍历操作的API\n * 没有size属性\n\nWeakSet只能成员只能是引用类型，而不能是其他类型的值\n\n\n\nWeakSet里面的引用只要在外部消失，它在 WeakSet里面的引用就会自动消失\n\n\nWeakMap#\n\nWeakMap结构与Map结构类似，也是用于生成键值对的集合\n\n在API中WeakMap与Map有两个区别：\n\n * 没有遍历操作的API\n * 没有clear清空方法\n\n\n\nWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名\n\n\n\nWeakMap的键名所指向的对象，一旦不再需要，里面的键名对象和所对应的键值对会自动消失，不用手动删除引用\n\n举个场景例子：\n\n在网页的 DOM 元素上添加数据，就可以使用WeakMap结构，当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除\n\n\n\n注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用\n\n下面代码中，键值obj会在WeakMap产生新的引用，当你修改obj不会影响到内部\n\n\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/#docs/set-map","routePath":"/interview/es6/set_map","lang":"","toc":[{"text":"一、Set","id":"一set","depth":2,"charIndex":230},{"text":"增删改查","id":"增删改查","depth":3,"charIndex":319},{"text":"add()","id":"add","depth":3,"charIndex":390},{"text":"delete()","id":"delete","depth":3,"charIndex":447},{"text":"has()","id":"has","depth":3,"charIndex":485},{"text":"clear()","id":"clear","depth":3,"charIndex":519},{"text":"遍历","id":"遍历","depth":3,"charIndex":546},{"text":"二、Map","id":"二map","depth":2,"charIndex":845},{"text":"增删改查","id":"增删改查-1","depth":3,"charIndex":913},{"text":"size","id":"size","depth":3,"charIndex":1011},{"text":"set()","id":"set","depth":3,"charIndex":1044},{"text":"get()","id":"get","depth":3,"charIndex":1140},{"text":"has()","id":"has-1","depth":3,"charIndex":1189},{"text":"delete()","id":"delete-1","depth":3,"charIndex":1234},{"text":"clear()","id":"clear-1","depth":3,"charIndex":1285},{"text":"遍历","id":"遍历-1","depth":3,"charIndex":1319},{"text":"三、WeakSet 和 WeakMap","id":"三weakset-和-weakmap","depth":2,"charIndex":1458},{"text":"WeakSet","id":"weakset","depth":3,"charIndex":1481},{"text":"WeakMap","id":"weakmap","depth":3,"charIndex":1671},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2028}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么理解 ES6 新增 Set、Map 两种数据结构的？","footer":"你是怎么理解 ES6 新增 Set、Map 两种数据结构的？","order":7,"star":7,"date":"2023-03-22T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-你是怎么理解 ES6 新增 Set、Map 两种数据结构的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么理解 ES6 新增 Set、Map 两种数据结构的？"}]]},"version":""},{"id":160,"title":"说说 var、let、const 之间的区别","content":"#\n\n\n\n\n一、var#\n\n在 ES5 中，顶层对象的属性和全局变量是等价的，用var声明的变量既是全局变量，也是顶层变量\n\n注意：顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象\n\n\n\n使用var声明的变量存在变量提升的情况\n\n\n\n在编译阶段，编译器会将其变成以下执行\n\n\n\n使用var，我们能够对一个变量进行多次声明，后面声明的变量会覆盖前面的变量声明\n\n\n\n在函数中使用使用var声明变量时候，该变量是局部的\n\n\n\n而如果在函数内不使用var，该变量是全局的\n\n\n\n\n二、let#\n\nlet是ES6新增的命令，用来声明变量\n\n用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效\n\n\n\n不存在变量提升\n\n\n\n这表示在声明它之前，变量a是不存在的，这时如果用到它，就会抛出一个错误\n\n只要块级作用域内存在let命令，这个区域就不再受外部影响\n\n\n\n使用let声明变量前，该变量都不可用，也就是大家常说的“暂时性死区”\n\n最后，let不允许在相同作用域中重复声明\n\n\n\n注意的是相同作用域，下面这种情况是不会报错的\n\n\n\n因此，我们不能在函数内部重新声明参数\n\n\n\n\n三、const#\n\nconst声明一个只读的常量，一旦声明，常量的值就不能改变\n\n\n\n这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值\n\n\n\n如果之前用var或let声明过变量，再用const声明同样会报错\n\n\n\nconst实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动\n\n对于简单类型的数据，值就保存在变量指向的那个内存地址，因此等同于常量\n\n对于复杂类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的，并不能确保改变量的结构不变\n\n\n\n其它情况，const与let一致\n\n\n四、区别#\n\nvar、let、const三者区别可以围绕下面五点展开：\n\n * 变量提升\n * 暂时性死区\n * 块级作用域\n * 重复声明\n * 修改声明的变量\n * 使用\n\n\n变量提升#\n\nvar声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined\n\nlet和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错\n\n\n\n\n暂时性死区#\n\nvar不存在暂时性死区\n\nlet和const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量\n\n\n\n\n块级作用域#\n\nvar不存在块级作用域\n\nlet和const存在块级作用域\n\n\n\n\n重复声明#\n\nvar允许重复声明变量\n\nlet和const在同一作用域不允许重复声明变量\n\n\n\n\n修改声明的变量#\n\nvar和let可以\n\nconst声明一个只读的常量。一旦声明，常量的值就不能改变\n\n\n\n\n使用#\n\n能用const的情况尽量使用const，其他情况下大多数使用let，避免使用var\n\n\n参考文献#\n\n * https://es6.ruanyifeng.com/","routePath":"/interview/es6/var_let_const","lang":"","toc":[{"text":"一、var","id":"一var","depth":2,"charIndex":5},{"text":"二、let","id":"二let","depth":2,"charIndex":253},{"text":"三、const","id":"三const","depth":2,"charIndex":509},{"text":"四、区别","id":"四区别","depth":2,"charIndex":801},{"text":"变量提升","id":"变量提升","depth":3,"charIndex":891},{"text":"暂时性死区","id":"暂时性死区","depth":3,"charIndex":984},{"text":"块级作用域","id":"块级作用域","depth":3,"charIndex":1055},{"text":"重复声明","id":"重复声明","depth":3,"charIndex":1097},{"text":"修改声明的变量","id":"修改声明的变量","depth":3,"charIndex":1146},{"text":"使用","id":"使用","depth":3,"charIndex":1201},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1250}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 var、let、const 之间的区别","footer":"说说 var、let、const 之间的区别","order":4,"star":4,"date":"2023-03-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","es6"],"tag":["interview","es6"],"shortTitle":"前端物语|面试物语-说说 var、let、const 之间的区别","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 var、let、const 之间的区别"}]]},"version":""},{"id":161,"title":"说说你对 Git 的理解？","content":"#\n\n\n\n\n一、是什么#\n\ngit，是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计\n\n分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来\n的本地仓库恢复\n\n\n\n项目开始，只有一个原始版仓库，别的机器可以clone这个原始版本库，那么所有clone的机器，它们的版本库其实都是一样的，并没有主次之分\n\n所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库clone一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，\n也从服务器仓库中拉取别人的提交\n\ngithub实际就可以充当这个服务器角色，其是一个开源协作社区，提供Git仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目\n\n\n二、工作原理#\n\n当我们通过git init创建或者git clone一个项目的时候，项目目录会隐藏一个.git子目录，其作用是用来跟踪管理版本库的\n\nGit 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，git能够知道\n\nGit用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git\n中文件的内容或目录结构计算出来，如下：\n\n\n\n当我们修改文件的时候，git就会修改文件的状态，可以通过git status进行查询，状态情况如下：\n\n * 已修改（modified）：表示修改了文件，但还没保存到数据库中。\n * 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。\n * 已提交（committed）：表示数据已经安全的保存在本地数据库中。\n\n文件状态对应的，不同状态的文件在Git中处于不同的工作区域，主要分成了四部分：\n\n * 工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本\n * 暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中\n * 本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库\n * 远程仓库：远程的仓库，如 github\n\n\n\n\n三、命令#\n\n从上图可以看到，git日常简单的使用就只有上图 6 个命令：\n\n * add\n * commit\n * push\n * pull\n * clone\n * checkout\n\n但实际上还有很多命令，如果想要熟练使用，还有 60 个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/Git\n * https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","routePath":"/interview/git/Git","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、工作原理","id":"二工作原理","depth":2,"charIndex":389},{"text":"三、命令","id":"三命令","depth":2,"charIndex":1012},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1169}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 Git 的理解？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 Git 的理解？","order":4,"star":4,"date":"2023-02-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说你对 Git 的理解？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 Git 的理解？"}]]},"version":""},{"id":162,"title":"说说 Git 中 HEAD、工作树和索引之间的区别？","content":"#\n\n\n\n\n一、HEAD#\n\n在git中，可以存在很多分支，其本质上是一个指向commit对象的可变指针，而Head是一个特别的指针，是一个指向你正在工作中的本地分支的指针\n\n简单来讲，就是你现在在哪儿，HEAD 就指向哪儿\n\n例如当前我们处于master分支，所以HEAD这个指针指向了master分支指针\n\n\n\n然后通过调用git checkout test切换到test分支，那么HEAD则指向test分支，如下图：\n\n\n\n但我们在test分支再一次commit信息的时候，HEAD指针仍然指向了test分支指针，而test分支指针已经指向了最新创建的提交，如下图：\n\n\n\n这个HEAD存储的位置就在.git/HEAD目录中，查看信息可以看到HEAD指向了另一个文件\n\n\n\n这个文件的内容是一串哈希码，而这个哈希码正是master分支上最新的提交所对应的哈希码\n\n所以，当我们切换分支的时候，HEAD指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交\n\n所以，HEAD 指针 ——–> 分支指针 ——–> 最新提交\n\n\n二、工作树和索引#\n\n在Git管理下，大家实际操作的目录被称为工作树，也就是工作区域\n\n在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域\n\n\n\nGit在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库\n\n因此，要提交文件，首先需要把文件加入到索引区域中。\n\n所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交\n\n\n三、区别#\n\n从所在的位置来看：\n\n * HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交\n\n * 工作树是查看和编辑的（源）文件的实际内容\n\n * 索引是放置你想要提交给 git 仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过 git commit\n   则将索引区域的文件提交到 git 仓库中\n\n\n参考文献#\n\n * https://backlog.com/git-tutorial/cn/intro/intro1_4.html\n * https://juejin.cn/post/6844903598522908686\n * https://www.zsythink.net/archives/3412","routePath":"/interview/git/HEAD_tree_index","lang":"","toc":[{"text":"一、HEAD","id":"一head","depth":2,"charIndex":5},{"text":"二、工作树和索引","id":"二工作树和索引","depth":2,"charIndex":486},{"text":"三、区别","id":"三区别","depth":2,"charIndex":708},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":908}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Git 中 HEAD、工作树和索引之间的区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Git 中 HEAD、工作树和索引之间的区别？","order":5,"star":5,"date":"2023-03-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说 Git 中 HEAD、工作树和索引之间的区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Git 中 HEAD、工作树和索引之间的区别？"}]]},"version":""},{"id":163,"title":"前端物语|面试物语-git","content":" * 说说你对 Git 的理解？\n * 说说 Git 中 HEAD、工作树和索引之间的区别？\n * 说说你对版本管理的理解？常用的版本管理工具有哪些？\n * 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?\n * [ 说说你对 git rebase 和 git merge\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge)\n * [ 说说对 git pull 和 git fetch\n   的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch)\n * [ 说说你对 git reset 和 git revert\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert)\n * 说说你对 git stash 的理解？应用场景？","routePath":"/interview/git/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"git","tag":"git","title":"前端物语|面试物语-git","index":false,"dir":{"order":1},"date":"2023-03-23T00:00:00.000Z"},"version":""},{"id":164,"title":"说说你对版本管理的理解？常用的版本管理工具有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n版本控制（Version\ncontrol），是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编\n辑的同一程序文件都得到同步\n\n透过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号\n\n一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推\n\n版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权\n\n简言之，你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点\n\n\n二、有哪些#\n\n版本控制系统在当今的软件开发中，被认为是理所当然的配备工具之一，根据类别可以分成：\n\n * 本地版本控制系统\n * 集中式版本控制系统\n * 分布式版本控制系统\n\n\n本地版本控制系统#\n\n结构如下图所示：\n\n\n\n优点：\n\n * 简单，很多系统中都有内置\n * 适合管理文本，如系统配置\n\n缺点：\n\n * 其不支持远程操作，因此并不适合多人版本开发\n\n\n集中式版本控制系统#\n\n结构如下图所示：\n\n\n\n优点：\n\n * 适合多人团队协作开发\n * 代码集中化管理\n\n缺点：\n\n * 单点故障\n * 必须联网，无法单机工作\n\n代表工具有SVN、CVS：\n\n\nSVN#\n\nTortoiseSVN是一款非常易于使用的跨平台的 版本控制/版本控制/源代码控制软件\n\n\nCVS#\n\nCVS是版本控制系统，是源配置管理（SCM）的重要组成部分。使用它，您可以记录源文件和文档的历史记录\n\n老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便\n\n这一特性使得CVS成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选\n\n分布式版本控制系统#\n\n结构如下图：\n\n\n\n优点：\n\n * 适合多人团队协作开发\n * 代码集中化管理\n * 可以离线工作\n * 每个计算机都是一个完整仓库\n\n分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作\n\n代表工具为Git、HG：\n\n\nGit#\n\nGit是目前世界上最先进的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务\n\n特性：易于学习，占用内存小，具有闪电般快速的性能\n\n使用Git和Gitlab搭建版本控制环境是现在互联网公司最流行的版本控制方式\n\n\nHG#\n\nMercurial是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面\n\nMercurial是一种轻量级分布式版本控制系统，采用 Python语言实现，易于学习和使用，扩展性强\n\n\n三、总结#\n\n版本控制系统的优点如下：\n\n * 记录文件所有历史变化，这是版本控制系统的基本能力\n * 随时恢复到任意时间点，历史记录功能使我们不怕改错代码了\n * 支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行\n * 多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍\n\n\n参考文献#\n\n * https://pm.readthedocs.io/vcs/understanding.html\n * https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6","routePath":"/interview/git/Version_control","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":308},{"text":"本地版本控制系统","id":"本地版本控制系统","depth":3,"charIndex":399},{"text":"集中式版本控制系统","id":"集中式版本控制系统","depth":3,"charIndex":492},{"text":"SVN","id":"svn","depth":3,"charIndex":592},{"text":"CVS","id":"cvs","depth":3,"charIndex":644},{"text":"分布式版本控制系统","id":"分布式版本控制系统","depth":4,"charIndex":790},{"text":"Git","id":"git","depth":3,"charIndex":947},{"text":"HG","id":"hg","depth":3,"charIndex":1067},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1180},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1340}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对版本管理的理解？常用的版本管理工具有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对版本管理的理解？常用的版本管理工具有哪些？","order":3,"star":3,"date":"2023-02-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说你对版本管理的理解？常用的版本管理工具有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对版本管理的理解？常用的版本管理工具有哪些？"}]]},"version":""},{"id":165,"title":"说说 Git 常用的命令有哪些？","content":"#\n\n\n\n\n一、前言#\n\ngit的操作可以通过命令的形式如执行，日常使用就如下图 6 个命令即可\n\n\n\n实际上，如果想要熟练使用，超过 60 多个命令需要了解，下面则介绍下常见的的git命令\n\n\n二、有哪些#\n\n\n配置#\n\nGit自带一个 git config 的工具来帮助设置控制 Git外观和行为的配置变量，在我们安装完git之后，第一件事就是设置你的用户名和邮件地址\n\n后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改\n\n设置提交代码时的用户信息命令如下：\n\n * git config [--global] user.name \"[name]\"\n * git config [--global] user.email \"[email address]\"\n\n\n启动#\n\n一个git项目的初始有两个途径，分别是：\n\n * git init [project-name]：创建或在当前目录初始化一个 git 代码库\n * git clone url：下载一个项目和它的整个代码历史\n\n\n日常基本操作#\n\n在日常工作中，代码常用的基本操作如下：\n\n * git init 初始化仓库，默认为 master 分支\n * git add . 提交全部文件修改到缓存区\n * git add <具体某个文件路径+全名> 提交某些文件到缓存区\n * git diff 查看当前代码 add 后，会 add 哪些内容\n * git diff --staged 查看现在 commit 提交后，会提交哪些内容\n * git status 查看当前分支状态\n * git pull <远程仓库名> <远程分支名> 拉取远程仓库的分支与本地当前分支合并\n * git pull <远程仓库名> <远程分支名>:<本地分支名> 拉取远程仓库的分支与本地某个分支合并\n * git commit -m \"<注释>\" 提交代码到本地仓库，并写提交注释\n * git commit -v 提交时显示所有 diff 信息\n * git commit --amend [file1] [file2] 重做上一次 commit，并包括指定文件的新变化\n\n关于提交信息的格式，可以遵循以下的规则：\n\n * feat: 新特性，添加功能\n * fix: 修改 bug\n * refactor: 代码重构\n * docs: 文档修改\n * style: 代码格式修改, 注意不是 css 修改\n * test: 测试用例修改\n * chore: 其他修改, 比如构建流程, 依赖管理\n\n\n分支操作#\n\n * git branch 查看本地所有分支\n * git branch -r 查看远程所有分支\n * git branch -a 查看本地和远程所有分支\n * git merge <分支名> 合并分支\n * git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态\n * git branch <新分支名> 基于当前分支，新建一个分支\n * git checkout --orphan <新分支名> 新建一个空分支（会保留之前分支的所有文件）\n * git branch -D <分支名> 删除本地某个分支\n * git push <远程库名> :<分支名> 删除远程某个分支\n * git branch <新分支名称> <提交 ID> 从提交历史恢复某个删掉的某个分支\n * git branch -m <原分支名> <新分支名> 分支更名\n * git checkout <分支名> 切换到本地某个分支\n * git checkout <远程库名>/<分支名> 切换到线上某个分支\n * git checkout -b <新分支名> 把基于当前分支新建分支，并切换为这个分支\n\n\n远程同步#\n\n远程操作常见的命令：\n\n * git fetch [remote] 下载远程仓库的所有变动\n * git remote -v 显示所有远程仓库\n * git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并\n * git fetch 获取线上最新版信息记录，不合并\n * git push [remote] [branch] 上传本地指定分支到远程仓库\n * git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突\n * git push [remote] --all 推送所有分支到远程仓库\n\n\n撤销#\n\n * git checkout [file] 恢复暂存区的指定文件到工作区\n\n * git checkout [commit] [file] 恢复某个 commit 的指定文件到暂存区和工作区\n\n * git checkout . 恢复暂存区的所有文件到工作区\n\n * git reset [commit] 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n\n * git reset --hard 重置暂存区与工作区，与上一次 commit 保持一致\n\n * git reset [file] 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n\n * git revert [commit] 后者的所有变化都将被前者抵消，并且应用到当前分支\n\n> reset：真实硬性回滚，目标版本后面的提交记录全部丢失了\n> \n> revert：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有\n\n\n存储操作#\n\n你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储\n\n * git stash 暂时将未提交的变化移除\n\n * git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏\n\n * git stash list 查看所有储藏中的工作\n\n * git stash apply <储藏的名称> 取出储藏中对应的工作状态进行恢复，不会删除储藏\n\n * git stash clear 清空所有储藏中的工作\n\n * git stash drop <储藏的名称> 删除对应的某个储藏\n\n\n三、总结#\n\ngit常用命令速查表如下所示：\n\n\n\n\n参考文献#\n\n * https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\n\n * https://segmentfault.com/a/1190000017875714","routePath":"/interview/git/command","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":97},{"text":"配置","id":"配置","depth":2,"charIndex":106},{"text":"启动","id":"启动","depth":3,"charIndex":343},{"text":"日常基本操作","id":"日常基本操作","depth":3,"charIndex":454},{"text":"分支操作","id":"分支操作","depth":3,"charIndex":1086},{"text":"远程同步","id":"远程同步","depth":3,"charIndex":1601},{"text":"撤销","id":"撤销","depth":3,"charIndex":1892},{"text":"存储操作","id":"存储操作","depth":3,"charIndex":2322},{"text":"三、总结","id":"三总结","depth":2,"charIndex":2627},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2654}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Git 常用的命令有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Git 常用的命令有哪些？","order":1,"star":1,"date":"2023-02-25T02:16:04.564Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说 Git 常用的命令有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Git 常用的命令有哪些？"}]]},"version":""},{"id":166,"title":"说说 git 发生冲突的场景？如何解决？","content":"#\n\n\n\n\n一、是什么#\n\n一般情况下，出现分支的场景有如下：\n\n * 多个分支代码合并到一个分支时\n * 多个分支向同一个远端分支推送\n\n具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称\n\n如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可\n\n应用在命令中，就是push、pull、stash、rebase等命令下都有可能产生冲突情况，从本质上来讲，都是merge和patch（应用补丁）时产生冲突\n\n\n二、分析#\n\n在本地主分值master创建一个a.txt文件，文件起始位置写上master commit，如下：\n\n\n\n然后提交到仓库：\n\n * git add a.txt\n * git commit -m 'master first commit'\n\n创建一个新的分支featurel1分支，并进行切换，如下：\n\n\n\n然后修改a.txt文件首行文字为 featurel commit，然后添加到暂存区，并开始进行提交到仓库：\n\n * git add a.txt\n * git commit -m 'featurel first change'\n\n然后通过git checkout master切换到主分支，通过git merge进行合并，发现不会冲突\n\n此时a.txt文件的内容变成featurel commit，没有出现冲突情况，这是因为git在内部发生了快速合并\n\n> 如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作\n> \n> git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支\n\n如果此时切换到featurel分支，将文件的内容修改成featrue second commit，然后提交到本地仓库\n\n然后切换到主分支，如果此时在a.txt文件再次修改，修改成mastet second commit，然后再次提交到本地仓库\n\n此时，master分支和feature1分支各自都分别有新的提交，变成了下图所示：\n\n\n\n这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突\n\n现在通过git merge featurel进行分支合并，如下所示：\n\n\n\n从冲突信息可以看到，a.txt发生冲突，必须手动解决冲突之后再提交\n\n而git status同样可以告知我们冲突的文件：\n\n\n\n打开a.txt文件，可以看到如下内容：\n\n\n\ngit用<<<<<<<，=======，>>>>>>>标记出不同分支的内容：\n\n * <<<<<<< 和 ======= 之间的区域就是当前更改的内容\n * ======= 和 >>>>>>> 之间的区域就是传入进来更改的内容\n\n现在要做的事情就是将冲突的内容进行更改，对每个文件使用 git add 命令来将其标记为冲突已解决。\n一旦暂存这些原本有冲突的文件，Git就会将它们标记为冲突已解决然后再提交：\n\n * git add a.txt\n * git commit -m \"conflict fixed\"\n\n此时master分支和feature1分支变成了下图所示：\n\n\n\n使用git log命令可以看到合并的信息：\n\n\n\n\n三、总结#\n\n当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成\n\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交\n\n\n参考文献#\n\n * https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344","routePath":"/interview/git/conflict","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、分析","id":"二分析","depth":2,"charIndex":230},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1382},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1465}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 git 发生冲突的场景？如何解决？","footer":"说说 git 发生冲突的场景？如何解决？","order":10,"star":10,"date":"2023-03-23T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说 git 发生冲突的场景？如何解决？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 git 发生冲突的场景？如何解决？"}]]},"version":""},{"id":167,"title":"说说 Git 中 fork, clone,branch 这三个概念，有什么区别?","content":"#\n\n\n\n\n一、是什么#\n\n\nfork#\n\nfork，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线\n\n\n\n转到git仓库中，fork则可以代表分叉、克隆 出一个（仓库的）新拷贝\n\n\n\n包含了原来的仓库（即 upstream repository，上游仓库）所有内容，如分支、Tag、提交\n\n如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库\n\n\nclone#\n\nclone，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓\n\n执行clone命令后，会在当前目录下创建一个名为xxx的目录，并在这个目录下初始化一个 .git 文件夹，然后从中读取最新版本的文件的拷贝\n\n默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来\n\n\nbranch#\n\nbranch，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线\n\nGit 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷\n\n在我们开发中，默认只有一条master分支，如下图所示：\n\n\n\n通过git branch可以创建一个分支，但并不会自动切换到新分支中去\n\n\n\n通过git checkout可以切换到另一个testing分支\n\n\n\n\n二、如何使用#\n\n\nfork#\n\n当你在github发现感兴趣开源项目的时候，可以通过点击github仓库中右上角fork标识的按钮，如下图：\n\n\n\n点击这个操作后会将这个仓库的文件、提交历史、issues 和其余东西的仓库复制到自己的github仓库中，而你本地仓库是不会存在任何更改\n\n然后你就可以通过git clone对你这个复制的远程仓库进行克隆\n\n后续更改任何东西都可以在本地完成，如git add、git commit一系列的操作，然后通过push命令推到自己的远程仓库\n\n如果希望对方接受你的修改，可以通过发送pull requests给对方，如果对方接受。则会将你的修改内容更新到仓库中\n\n\n\n整体流程如下图：\n\n\n\n\nclone#\n\n在github中，开源项目右侧存在code按钮，点击后则会显示开源项目url信息，如下图所示：\n\n\n\n通过git clone xxx则能完成远程项目的下载\n\n\nbranch#\n\n可通过git branch进行查看当前的分支状态，\n\n如果给了--list，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号\n\n以及通过git branch创建一个新的分支出来\n\n\n三、区别#\n\n其三者区别如下：\n\n * fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”\n * clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓\n * branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支\n\n\n参考文献#\n\n * https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库\n * https://git-scm.com/book/zh/v2/Git-分支-分支简介","routePath":"/interview/git/fork_clone_branch","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"fork","id":"fork","depth":3,"charIndex":14},{"text":"clone","id":"clone","depth":3,"charIndex":212},{"text":"branch","id":"branch","depth":3,"charIndex":372},{"text":"二、如何使用","id":"二如何使用","depth":2,"charIndex":610},{"text":"fork","id":"fork-1","depth":3,"charIndex":620},{"text":"clone","id":"clone-1","depth":3,"charIndex":928},{"text":"branch","id":"branch-1","depth":3,"charIndex":1016},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1131},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1329}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Git 中 fork, clone,branch 这三个概念，有什么区别?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Git 中 fork, clone,branch 这三个概念，有什么区别?","order":7,"star":7,"date":"2023-03-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说 Git 中 fork, clone,branch 这三个概念，有什么区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Git 中 fork, clone,branch 这三个概念，有什么区别?"}]]},"version":""},{"id":168,"title":"说说你对 git rebase 和 git merge 的理解？区别？","content":"#\n\n\n\n\n一、是什么#\n\n在使用 git 进行版本管理的项目中，当完成一个特性的开发并将其合并到 master 分支时，会有两种方式：\n\n * git merge\n * git rebase\n\ngit rebase 与 git merge都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同\n\n用法上两者也十分的简单：\n\n\ngit merge#\n\n将当前分支合并到指定分支，命令用法如下：\n\n\n\n\ngit rebase#\n\n将当前分支移植到指定分支或指定commit之上，用法如下：\n\n\n\n常见的参数有--continue，用于解决冲突之后，继续执行rebase\n\n\n\n\n二、分析#\n\n\ngit merge#\n\n通过git merge将当前分支与xxx分支合并，产生的新的commit对象有两个父节点\n\n如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并\n\n举个例子，bugfix分支是从master分支分叉出来的，如下所示：\n\n\n\n合并bugfix分支到master分支时，如果master分支的状态没有被更改过，即 bugfix分支的历史记录包含master分支所有的历史记录\n\n所以通过把master分支的位置移动到bugfix的最新分支上，就完成合并\n\n如果master分支的历史记录在创建bugfix分支后又有新的提交，如下情况：\n\n\n\n这时候使用git merge的时候，会生成一个新的提交，并且master分支的HEAD会移动到新的分支上，如下：\n\n\n\n从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照\n\n\ngit rebase#\n\n同样，master分支的历史记录在创建bugfix分支后又有新的提交，如下情况：\n\n\n\n通过git rebase，会变成如下情况：\n\n\n\n在移交过程中，如果发生冲突，需要修改各自的冲突，如下：\n\n\n\nrebase之后，master的HEAD位置不变。因此，要合并master分支和bugfix分支\n\n\n\n从上面可以看到，rebase会找到不同的分支的最近共同祖先，如上图的B\n\n然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交X和Y也没有被销毁，只是简单地不能再被访问或者使用）\n\n然后将当前分支指向目标最新位置D, 然后将之前另存为临时文件的修改依序应用\n\n\n三、区别#\n\n从上面可以看到，merge和rebasea都是合并历史记录，但是各自特性不同：\n\n\nmerge#\n\n通过merge合并分支会新增一个merge commit，然后将两个分支的历史联系起来\n\n其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂\n\n\nrebase#\n\nrebase会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交\n\n主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 git merge所需的不必要的合并提交\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/361182707\n * https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing\n * https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html","routePath":"/interview/git/gitRebase_ gitMerge","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"git merge","id":"git-merge","depth":3,"charIndex":173},{"text":"git rebase","id":"git-rebase","depth":3,"charIndex":210},{"text":"二、分析","id":"二分析","depth":2,"charIndex":297},{"text":"git merge","id":"git-merge-1","depth":3,"charIndex":305},{"text":"git rebase","id":"git-rebase-1","depth":3,"charIndex":706},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1015},{"text":"merge","id":"merge","depth":3,"charIndex":1064},{"text":"rebase","id":"rebase","depth":3,"charIndex":1162},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1271}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 git rebase 和 git merge 的理解？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 git rebase 和 git merge 的理解？区别？","order":6,"star":6,"date":"2023-03-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说你对 git rebase 和 git merge 的理解？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 git rebase 和 git merge 的理解？区别？"}]]},"version":""},{"id":169,"title":"说说对 git pull 和 git fetch 的理解？有什么区别？","content":"#\n\n\n\n\n一、是什么#\n\n先回顾两个命令的定义\n\n * git fetch 命令用于从另一个存储库下载对象和引用\n * git pull 命令用于从另一个存储库或本地分支获取并集成(整合)\n\n再来看一次git的工作流程图，如下所示：\n\n\n\n可以看到，git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中\n\n而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git\nmerge，这样可能会产生冲突，需要手动解决\n\n在我们本地的git文件中对应也存储了git本地仓库分支的commit ID和 跟踪的远程分支的commit ID，对应文件如下：\n\n * .git/refs/head/[本地分支]\n * .git/refs/remotes/[正在跟踪的分支]\n\n使用 git fetch更新代码，本地的库中master的commitID不变\n\n但是与git上面关联的那个orign/master的commit ID发生改变\n\n这时候我们本地相当于存储了两个代码的版本号，我们还要通过merge去合并这两个不同的代码版本\n\n\n\n也就是fetch的时候本地的master没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地merge合并这两个版本号的代码\n\n相比之下，使用git pull就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：\n\n\n\n\n二、用法#\n\n一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到git pull或者git fetch命令\n\n\nfetch#\n\n用法如下：\n\n\n\n例如从远程的origin仓库的master分支下载代码到本地并新建一个temp分支\n\n\n\n如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来到本地当前分支\n\n这里git fetch不会进行合并，执行后需要手动执行git merge合并，如下：\n\n\n\n\npull#\n\n两者的用法十分相似，pull用法如下：\n\n\n\n例如将远程主机origin的master分支拉取过来，与本地的branchtest分支合并，命令如下：\n\n\n\n同样如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来与本地当前分支合并\n\n\n三、区别#\n\n相同点：\n\n * 在作用上他们的功能是大致相同的，都是起到了更新代码的作用\n\n不同点：\n\n * git pull 是相当于从远程仓库获取最新版本，然后再与本地分支 merge，即 git pull = git fetch + git merge\n * 相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/123370920\n * https://segmentfault.com/a/1190000017030384\n * https://juejin.cn/post/6844903921794859021","routePath":"/interview/git/git_pull _git_fetch","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、用法","id":"二用法","depth":2,"charIndex":639},{"text":"fetch","id":"fetch","depth":3,"charIndex":704},{"text":"pull","id":"pull","depth":3,"charIndex":858},{"text":"三、区别","id":"三区别","depth":2,"charIndex":993},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1190}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 git pull 和 git fetch 的理解？有什么区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 git pull 和 git fetch 的理解？有什么区别？","order":8,"star":8,"date":"2023-03-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说对 git pull 和 git fetch 的理解？有什么区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 git pull 和 git fetch 的理解？有什么区别？"}]]},"version":""},{"id":170,"title":"说说你对 git reset 和 git revert 的理解？区别？","content":"#\n\n\n\n\n一、是什么#\n\n\ngit reset#\n\nreset用于回退版本，可以遗弃不再使用的提交\n\n执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容\n\n\n\n\ngit revert#\n\n在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交\n\n\n\n\n二、如何用#\n\n\ngit reset#\n\n当没有指定ID的时候，默认使用HEAD，如果指定ID，那么就是基于指向ID去变动暂存区或工作区的内容\n\n\n\n日志ID可以通过查询，可以git log进行查询，如下：\n\n\n\n常见命令如下：\n\n * --mixed（默认）：默认的时候，只有暂存区变化\n\n * --hard 参数：如果使用 --hard 参数，那么工作区也会变化\n\n * --soft：如果使用 --soft 参数，那么暂存区和工作区都不会变化\n\n\n\n\ngit revert#\n\n跟git reset用法基本一致，git revert 撤销某次操作，此次操作之前和之后的\ncommit和history都会保留，并且把这次撤销，作为一次最新的提交，如下：\n\n\n\n如果撤销前一个版本，可以通过如下命令：\n\n\n\n撤销前前一次，如下：\n\n\n\n\n三、区别#\n\n撤销（revert）被设计为撤销公开的提交（比如已经 push）的安全方式，git reset被设计为重设本地更改\n\n因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销\n\n两者主要区别如下：\n\n * git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit\n * git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert\n   的内容正好相反，能够抵消要被 revert 的内容\n * 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别\n\n> git revert 是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，之前提交合并的代码仍然存在，导致不能够重新合并\n> \n> 但是 git reset 是之间把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的\n> commit 应该还会被引入\n\n * 如果回退分支的代码以后还需要的情况则使用git revert， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用git reset\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903542931587086\n * https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset","routePath":"/interview/git/git_reset_ git_revert","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"git reset","id":"git-reset","depth":3,"charIndex":14},{"text":"git revert","id":"git-revert","depth":3,"charIndex":96},{"text":"二、如何用","id":"二如何用","depth":2,"charIndex":172},{"text":"git reset","id":"git-reset-1","depth":3,"charIndex":181},{"text":"git revert","id":"git-revert-1","depth":3,"charIndex":401},{"text":"三、区别","id":"三区别","depth":2,"charIndex":542},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1153}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 git reset 和 git revert 的理解？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 git reset 和 git revert 的理解？区别？","order":9,"star":9,"date":"2023-03-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说你对 git reset 和 git revert 的理解？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 git reset 和 git revert 的理解？区别？"}]]},"version":""},{"id":171,"title":"说说你对 git stash 的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\nstash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上\n\n后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码\n\n默认情况下，git stash会缓存下列状态的文件：\n\n * 添加到暂存区的修改（staged changes）\n * Git 跟踪的但并未添加到暂存区的修改（unstaged changes）\n\n但以下状态的文件不会缓存：\n\n * 在工作目录中新的文件（untracked files）\n * 被忽略的文件（ignored files）\n\n如果想要上述的文件都被缓存，可以使用-u或者--include-untracked可以工作目录新的文件，使用-a或者--all命令可以当前目录下的所有修改\n\n\n二、如何使用#\n\n关于git stash常见的命令如下：\n\n * git stash\n\n * git stash save\n\n * git stash list\n\n * git stash pop\n\n * git stash apply\n\n * git stash show\n\n * git stash drop\n\n * git stash clear\n\n\ngit stash#\n\n保存当前工作进度，会把暂存区和工作区的改动保存起来\n\n\ngit stash save#\n\ngit stash save可以用于存储修改.并且将git的工作状态切回到HEAD也就是上一次合法提交上\n\n如果给定具体的文件路径,git stash只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：\n\n * --keep-index 或者 -k 只会存储为加入 git 管理的文件\n\n * --include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态\n\n * -a 或者 --all 命令可以当前目录下的所有修改，包括被 git 忽略的文件\n\n\ngit stash list#\n\n显示保存进度的列表。也就意味着，git stash命令可以多次执行，当多次使用git stash命令后，栈里会充满未提交的代码，如下：\n\n\n\n其中，stash@{0}、stash@{1}就是当前stash的名称\n\n\ngit stash pop#\n\ngit stash pop 从栈中读取最近一次保存的内容，也就是栈顶的stash会恢复到工作区\n\n也可以通过 git stash pop + stash名字执行恢复哪个stash恢复到当前目录\n\n如果从stash中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突\n\n\ngit stash apply#\n\n将堆栈中的内容应用到当前目录，不同于git stash pop，该命令不会将内容从堆栈中删除\n\n也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况\n\n同样，可以通过git stash apply + stash名字执行恢复哪个stash恢复到当前目录\n\n\ngit stash show#\n\n查看堆栈中最新保存的stash和当前目录的差异\n\n通过使用git stash show -p查看详细的不同\n\n通过使用git stash show stash@{1}查看指定的stash和当前目录差异\n\n\n\n\ngit stash drop#\n\ngit stash drop + stash名称表示从堆栈中移除某个指定的 stash\n\n\ngit stash clear#\n\n删除所有存储的进度\n\n\n三、应用场景#\n\n当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情\n\n但是你创建一次未完成的代码的commit提交，这时候就可以使用git stash\n\n例如以下场景：\n\n当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过git pull解决\n\n但是如果可能发生冲突怎么办.直接git pull会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：\n\n * git stash\n * git pull\n * git stash pop\n\n或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用git stash缓存当前区域的代码\n\n * git stash：保存开发到一半的代码\n * git commit -m '修改问题'\n * git stash pop：将代码追加到最新的提交之后","routePath":"/interview/git/git_stash","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何使用","id":"二如何使用","depth":2,"charIndex":367},{"text":"git stash","id":"git-stash","depth":3,"charIndex":546},{"text":"git stash save","id":"git-stash-save","depth":3,"charIndex":586},{"text":"git stash list","id":"git-stash-list","depth":3,"charIndex":853},{"text":"git stash pop","id":"git-stash-pop","depth":3,"charIndex":978},{"text":"git stash apply","id":"git-stash-apply","depth":3,"charIndex":1146},{"text":"git stash show","id":"git-stash-show","depth":3,"charIndex":1302},{"text":"git stash drop","id":"git-stash-drop","depth":3,"charIndex":1424},{"text":"git stash clear","id":"git-stash-clear","depth":3,"charIndex":1487},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1517}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对git stash 的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对git stash 的理解？应用场景？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","git"],"tag":["interview","git"],"shortTitle":"前端物语|面试物语-说说你对git stash 的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对git stash 的理解？应用场景？"}]]},"version":""},{"id":172,"title":"前端物语|面试物语-git","content":" * 说说你对 Git 的理解？\n * 说说 Git 中 HEAD、工作树和索引之间的区别？\n * 说说你对版本管理的理解？常用的版本管理工具有哪些？\n * 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?\n * [ 说说你对 git rebase 和 git merge\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge)\n * [ 说说对 git pull 和 git fetch\n   的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch)\n * [ 说说你对 git reset 和 git revert\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert)\n * 说说你对 git stash 的理解？应用场景？","routePath":"/interview/git/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"git","tag":"git","title":"前端物语|面试物语-git","index":false,"dir":{"order":1},"date":"2023-03-23T00:00:00.000Z"},"version":""},{"id":173,"title":"说说 HTTP1.0/1.1/2.0 的区别?","content":"#\n\n\n\n\n一、HTTP1.0#\n\nHTTP协议的第二个版本，第一个在通讯中指定版本号的 HTTP 协议版本\n\nHTTP 1.0 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个TCP连接\n\n服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求\n\n简单来讲，每次与服务器交互，都需要新开一个连接\n\n\n\n例如，解析html文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接\n\n最终导致，一个html文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接\n\n这种形式明显造成了性能上的缺陷\n\n如果需要建立长连接，需要设置一个非标准的 Connection 字段 Connection: keep-alive\n\n\n二、HTTP1.1#\n\n在HTTP1.1中，默认支持长连接（Connection: keep-alive），即在一个 TCP\n连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟\n\n建立一次连接，多次请求均由这个连接完成\n\n\n\n这样，在加载html文件的时候，文件中多个请求和响应就可以在一个连接中传输\n\n同时，HTTP\n1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求\n的响应内容，这样也显著地减少了整个下载过程所需要的时间\n\n同时，HTTP1.1在HTTP1.0的基础上，增加更多的请求头和响应头来完善的功能，如下：\n\n * 引入了更多的缓存控制策略，如 If-Unmodified-Since, If-Match, If-None-Match 等缓存头来控制缓存策略\n * 引入 range，允许值请求资源某个部分\n * 引入 host，实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点\n\n并且还添加了其他的请求方法：put、delete、options...\n\n\n三、HTTP2.0#\n\n而HTTP2.0在相比之前版本，性能上有很大的提升，如添加了一个特性：\n\n * 多路复用\n * 二进制分帧\n * 首部压缩\n * 服务器推送\n\n\n多路复用#\n\nHTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”\n\n\n\n上图中，可以看到第四步中css、js资源是同时发送到服务端\n\n\n二进制分帧#\n\n帧是HTTP2通信中最小单位信息\n\nHTTP/2 采用二进制格式传输数据，而非 HTTP 1.x的文本格式，解析起来更高效\n\n将请求和响应数据分割为更小的帧，并且它们采用二进制编码\n\nHTTP2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流\n\n每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件\n\n\n首部压缩#\n\nHTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送\n\n首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新\n\n例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销\n\n\n\n\n服务器推送#\n\nHTTP2引入服务器推送，允许服务端推送资源给客户端\n\n服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源\n\n免得客户端再次创建连接发送请求到服务器端获取\n\n这种方式非常合适加载静态资源\n\n\n\n\n四、总结#\n\nHTTP1.0：\n\n * 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接\n\nHTTP1.1：\n\n * 引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用\n * 在同一个 TCP 连接里面，客户端可以同时发送多个请求\n * 虽然允许复用 TCP 连接，但是同一个 TCP\n   连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n * 新增了一些请求方法\n * 新增了一些请求头和响应头\n\nHTTP2.0：\n\n * 采用二进制格式而非文本格式\n * 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行\n * 使用报头压缩，降低开销\n * 服务器推送\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E\n   5%8D%8F%E8%AE%AE#HTTP/1.0\n * https://www.jianshu.com/p/52d86558ca57\n * https://segmentfault.com/a/1190000016496448\n * https://zhuanlan.zhihu.com/p/26559480","routePath":"/interview/http/10_1-1_20","lang":"","toc":[{"text":"一、HTTP1.0","id":"一http10","depth":2,"charIndex":5},{"text":"二、HTTP1.1","id":"二http11","depth":2,"charIndex":334},{"text":"三、HTTP2.0","id":"三http20","depth":2,"charIndex":865},{"text":"多路复用","id":"多路复用","depth":3,"charIndex":950},{"text":"二进制分帧","id":"二进制分帧","depth":3,"charIndex":1062},{"text":"首部压缩","id":"首部压缩","depth":3,"charIndex":1284},{"text":"服务器推送","id":"服务器推送","depth":3,"charIndex":1453},{"text":"四、总结","id":"四总结","depth":2,"charIndex":1584},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1939}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 HTTP1.0/1.1/2.0 的区别?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 HTTP1.0/1.1/2.0 的区别?","order":3,"star":3,"date":"2023-03-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说 HTTP1.0/1.1/2.0 的区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 HTTP1.0/1.1/2.0 的区别?"}]]},"version":""},{"id":174,"title":"如何理解 CDN？说说实现原理？","content":"#\n\n\n\n\n一、是什么#\n\nCDN (全称 Content Delivery Network)，即内容分发网络\n\n构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用\n户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术\n\n简单来讲，CDN就是根据用户位置分配最近的资源\n\n于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫边缘节点，其实就是缓存了源站内容的代理服务器。如下图：\n\n\n\n\n二、原理分析#\n\n在没有应用CDN时，我们使用域名访问某一个站点时的路径为\n\n> 用户提交域名 → 浏览器对域名进行解释 →DNS 解析得到目的主机的 IP 地址 → 根据 IP 地址访问发出请求 → 得到请求数据并回复\n\n应用CDN后，DNS 返回的不再是 IP 地址，而是一个CNAME(Canonical Name ) 别名记录，指向CDN的全局负载均衡\n\nCNAME实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是CDN实现的关键\n\n负载均衡系统#\n\n由于没有返回IP地址，于是本地DNS会向负载均衡系统再发送请求 ，则进入到CDN的全局负载均衡系统进行智能调度：\n\n * 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点\n\n * 看用户所在的运营商网络，找相同网络的边缘节点\n\n * 检查边缘节点的负载情况，找负载较轻的节点\n\n * 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等\n\n结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问CDN的缓存代理\n\n整体流程如下图：\n\n\n\n缓存代理#\n\n缓存系统是 CDN的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源\n\n其中有两个衡量CDN服务质量的指标：\n\n * 命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比\n * 回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比\n\n缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户\n\n回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源\n\n现在的商业 CDN命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上\n\n\n三、总结#\n\nCDN 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度\n\nCDN 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速\n\n通过CDN的负载均衡系统，智能调度边缘节点提供服务，相当于CDN服务的大脑，而缓存系统相当于CDN的心脏，缓存命中直接返回给用户，否则回源\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/內容傳遞網路\n * https://juejin.cn/post/6844903890706661389#heading-5\n * https://blog.csdn.net/lxx309707872/article/details/109078783","routePath":"/interview/http/CDN","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、原理分析","id":"二原理分析","depth":2,"charIndex":273},{"text":"负载均衡系统","id":"负载均衡系统","depth":4,"charIndex":501},{"text":"缓存代理","id":"缓存代理","depth":4,"charIndex":751},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1056},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1223}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何理解 CDN？说说实现原理？","footer":"如何理解 CDN？说说实现原理？","order":9,"star":9,"date":"2023-03-31T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-如何理解 CDN？说说实现原理？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何理解 CDN？说说实现原理？"}]]},"version":""},{"id":175,"title":"DNS 协议 是什么？说说 DNS 完整的查询过程?","content":"#\n\n\n\n\n一、是什么#\n\nDNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器\n\n简单来讲，DNS相当于一个翻译官，负责将域名翻译成ip地址\n\n * IP 地址：一长串能够唯一地标记网络上的计算机的数字\n * 域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识\n\n\n\n\n二、域名#\n\n域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名...\n\n\n\n例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，系统为用户做了兼容，域名末尾的根域名.一般不需要输入\n\n在域名的每一层都会有一个域名服务器，如下图：\n\n\n\n除此之外，还有电脑默认的本地域名服务器\n\n\n三、查询方式#\n\nDNS 查询的方式有两种：\n\n * 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案\n\n\n\n * 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求\n\n\n\n\n四、域名缓存#\n\n在域名服务器解析的时候，使用缓存保存域名和IP地址的映射\n\n计算机中DNS的记录也分成了两种缓存方式：\n\n * 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗\n * 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件\n\n\n五、查询过程#\n\n解析域名的过程如下：\n\n * 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表\n\n * 若没有命中，则继续搜索操作系统的 DNS 缓存\n\n * 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果\n\n * 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询\n   \n   * 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器\n   * 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n   * 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址\n\n * 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来\n\n * 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起\n\n * 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起\n\n流程如下图所示：\n\n\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F\n * https://www.cnblogs.com/jmilkfan-fanguiju/p/12789677.html\n * https://segmentfault.com/a/1190000039039275","routePath":"/interview/http/DNS","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、域名","id":"二域名","depth":2,"charIndex":209},{"text":"三、查询方式","id":"三查询方式","depth":2,"charIndex":378},{"text":"四、域名缓存","id":"四域名缓存","depth":2,"charIndex":523},{"text":"五、查询过程","id":"五查询过程","depth":2,"charIndex":671},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1160}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-DNS 协议 是什么？说说 DNS 完整的查询过程?","footer":"DNS 协议 是什么？说说 DNS 完整的查询过程?","order":14,"star":14,"date":"2023-04-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-DNS 协议 是什么？说说 DNS 完整的查询过程?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"DNS 协议 是什么？说说 DNS 完整的查询过程?"}]]},"version":""},{"id":176,"title":"说一下 GET 和 POST 的区别？","content":"#\n\n\n\n\n一、是什么#\n\nGET和POST，两者是HTTP协议中发送请求的方法\n\nGET#\n\nGET方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据\n\nPOST#\n\nPOST方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或副作用\n\n本质上都是TCP链接，并无差别\n\n但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别\n\n\n二、区别#\n\n从w3schools得到的标准答案的区别如下：\n\n * GET 在浏览器回退时是无害的，而 POST 会再次提交请求。\n * GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。\n * GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。\n * GET 请求只能进行 url 编码，而 POST 支持多种编码方式。\n * GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。\n * GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。\n * 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。\n * GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。\n * GET 参数通过 URL 传递，POST 放在 Request body 中\n\n\n参数位置#\n\n貌似从上面看到GET与POST请求区别非常大，但两者实质并没有区别\n\n无论 GET还是 POST，用的都是同一个传输层协议，所以在传输上没有区别\n\n当不携带参数的时候，两者最大的区别为第一行方法名不同\n\n> POST /uri HTTP/1.1 \\r\\n\n> \n> GET /uri HTTP/1.1 \\r\\n\n\n当携带参数的时候，我们都知道GET请求是放在url中，POST则放在body中\n\nGET 方法简约版报文是这样的\n\n\n\nPOST方法简约版报文是这样的\n\n\n\n注意：这里只是约定，并不属于HTTP规范，相反的，我们可以在POST请求中url中写入参数，或者GET请求中的body携带参数\n\n\n参数长度#\n\nHTTP协议没有Body和 URL 的长度限制，对 URL限制的大多是浏览器和服务器的原因\n\nIE对URL长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持\n\n这里限制的是整个URL长度，而不仅仅是参数值的长度\n\n服务器处理长URL 要消耗比较多的资源，为了性能和安全考虑，会给 URL 长度加限制\n\n\n安全#\n\nPOST比GET 安全，因为数据在地址栏上不可见\n\n然而，从传输的角度来说，他们都是不安全的，因为HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文\n\n只有使用HTTPS才能加密安全\n\n\n数据包#\n\n对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应 200（返回数据）\n\n对于POST，浏览器先发送header，服务器响应 100 continue，浏览器再发送data，服务器响应 200 ok\n\n并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次\n\n\n参考文献#\n\n * https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&mid=100000054&idx=1&sn=71f6\n   c214f3833d9ca20b9f7dcd9d33e4#rd\n * https://blog.fundebug.com/2019/02/22/compare-http-method-get-and-post/\n * https://www.w3school.com.cn/tags/html_ref_httpmethods.asp","routePath":"/interview/http/GET_POST","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"GET","id":"get","depth":4,"charIndex":41},{"text":"POST","id":"post","depth":4,"charIndex":88},{"text":"二、区别","id":"二区别","depth":2,"charIndex":196},{"text":"参数位置","id":"参数位置","depth":3,"charIndex":604},{"text":"参数长度","id":"参数长度","depth":3,"charIndex":913},{"text":"安全","id":"安全","depth":3,"charIndex":1121},{"text":"数据包","id":"数据包","depth":3,"charIndex":1233},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1397}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说一下 GET 和 POST 的区别？","footer":"说一下 GET 和 POST 的区别？","order":11,"star":11,"date":"2023-04-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说一下 GET 和 POST 的区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说一下 GET 和 POST 的区别？"}]]},"version":""},{"id":177,"title":"为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？","content":"#\n\n\n\n\n一、安全特性#\n\n在上篇文章中，我们了解到HTTP在通信过程中，存在以下问题：\n\n * 通信使用明文（不加密），内容可能被窃听\n * 不验证通信方的身份，因此有可能遭遇伪装\n\n而HTTPS的出现正是解决这些问题，HTTPS是建立在SSL之上，其安全性由SSL来保证\n\n在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能\n\n> SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer\n> Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议\n\n\n\n\n二、如何做#\n\nSSL的实现这些功能主要依赖于三种手段：\n\n * 对称加密：采用协商的密钥对数据加密\n * 非对称加密：实现身份认证和密钥协商\n * 摘要算法：验证信息的完整性\n * 数字签名：身份验证\n\n\n对称加密#\n\n对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性\n\n\n\n\n非对称加密#\n\n非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密\n\n公钥和私钥都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密\n\n\n\n\n混合加密#\n\n在HTTPS通信过程中，采用的是对称加密+非对称加密，也就是混合加密\n\n在对称加密中讲到，如果能够保证了密钥的安全，那整个通信过程就可以说具有了机密性\n\n而HTTPS采用非对称加密解决秘钥交换的问题\n\n具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”\n\n\n\n这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信\n\n举个例子#\n\n网站秘密保管私钥，在网上任意分发公钥，你想要登录网站只要用公钥加密就行了，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文\n\n上述的方法解决了数据加密，在网络传输过程中，数据有可能被篡改，并且黑客可以伪造身份发布公钥，如果你获取到假的公钥，那么混合加密也并无多大用处，你的数据扔被黑客解\n决\n\n因此，在上述加密的基础上仍需加上完整性、身份验证的特性，来实现真正的安全，实现这一功能则是摘要算法\n\n\n摘要算法#\n\n实现完整性的手段主要是摘要算法，也就是常说的散列函数、哈希函数\n\n可以理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”\n\n\n\n摘要算法保证了“数字摘要”和原文是完全等价的。所以，我们只要在原文后附上它的摘要，就能够保证数据的完整性\n\n比如，你发了条消息：“转账 1000 元”，然后再加上一个 SHA-2\n的摘要。网站收到后也计算一下消息的摘要，把这两份“指纹”做个对比，如果一致，就说明消息是完整可信的，没有被修改\n\n\n\n\n数字签名#\n\n数字签名能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名\n\n原理其实很简单，就是用私钥加密，公钥解密\n\n签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的\n\n\n\n和消息本身一样，因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段，也就是说，怎么判断这个公钥就是你的公钥\n\n这时候就需要一个第三方，就是证书验证机构\n\n\nCA 验证机构#\n\n数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场\n\nCA 对公钥的签名认证要求包括序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”\n\n流程如下图：\n\n\n\n * 服务器的运营人员向数字证书认证机构提出公开密钥的申请\n * 数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名\n * 然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起\n * 服务器会将这份由数字证书认证机构颁发的数字证书发送给客户端，以进行非对称加密方式通信\n\n接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，则证明：\n\n * 认证服务器的公开密钥的是真实有效的数字证书认证机构\n * 服务器的公开密钥是值得信赖的\n\n\n三、总结#\n\n可以看到，HTTPS与HTTP虽然只差一个SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：\n\n * 机密性：混合算法\n * 完整性：摘要算法\n * 身份认证：数字签名\n * 不可否定：数字签名\n\n同时引入第三方证书机构，确保公开秘钥的安全性\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/100657391\n * https://juejin.cn/post/6844903830987997197#heading-7\n * https://cloud.tencent.com/developer/article/1748862","routePath":"/interview/http/HTTPS","lang":"","toc":[{"text":"一、安全特性","id":"一安全特性","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":284},{"text":"对称加密","id":"对称加密","depth":3,"charIndex":388},{"text":"非对称加密","id":"非对称加密","depth":3,"charIndex":456},{"text":"混合加密","id":"混合加密","depth":3,"charIndex":571},{"text":"举个例子","id":"举个例子","depth":4,"charIndex":770},{"text":"摘要算法","id":"摘要算法","depth":3,"charIndex":986},{"text":"数字签名","id":"数字签名","depth":3,"charIndex":1251},{"text":"CA 验证机构","id":"ca-验证机构","depth":3,"charIndex":1482},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1865},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2009}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？","footer":"为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？","order":6,"star":6,"date":"2023-03-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？"}]]},"version":""},{"id":178,"title":"什么是 HTTP? HTTP 和 HTTPS 的区别?","content":"#\n\n\n\n\n一、HTTP#\n\nHTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范\n\n\n\n在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等......\n\n而HTTP是一个传输协议，即将数据由 A 传到 B 或将 B 传输到 A，并且 A 与 B 之间能够存放很多第三方，如： A<=>X<=>Y<=>Z<=>B\n\n传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如 HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别\n\n在实际应用中，HTTP常被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密\n\n特点如下：\n\n * 支持客户/服务器模式\n\n * 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快\n\n * 灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记\n\n * 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间\n\n * 无状态：HTTP 协议无法根据之前的状态进行本次的请求处理\n\n\n二、HTTPS#\n\n在上述介绍HTTP中，了解到HTTP传递信息是以明文的形式发送内容，这并不安全。而HTTPS出现正是为了解决HTTP不安全的特性\n\n为了保证这些隐私数据能加密传输，让HTTP运行安全的SSL/TLS协议上，即 HTTPS = HTTP + SSL/TLS，通过\nSSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密\n\nSSL 协议位于TCP/IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持\n\n\n\n流程图如下所示：\n\n\n\n * 首先客户端通过 URL 访问服务器建立 SSL 连接\n * 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端\n * 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级\n * 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站\n * 服务器利用自己的私钥解密出会话密钥\n * 服务器利用会话密钥加密与客户端之间的通信\n\n\n三、区别#\n\n * HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全\n * HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443\n * HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP\n * HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高\n\n\n参考文献#\n\n * https://www.cnblogs.com/klb561/p/10289199.html\n * https://www.jianshu.com/p/205c0fc51c97","routePath":"/interview/http/HTTP_HTTPS","lang":"","toc":[{"text":"一、HTTP","id":"一http","depth":2,"charIndex":5},{"text":"二、HTTPS","id":"二https","depth":2,"charIndex":582},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1066},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1287}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-什么是 HTTP? HTTP 和 HTTPS 的区别?","footer":"什么是 HTTP? HTTP 和 HTTPS 的区别?","order":10,"star":10,"date":"2023-03-31T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-什么是 HTTP? HTTP 和 HTTPS 的区别?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"什么是 HTTP? HTTP 和 HTTPS 的区别?"}]]},"version":""},{"id":179,"title":"如何理解 OSI 七层模型?","content":"#\n\n\n\n\n一、是什么#\n\nOSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO )\n提出的一个试图使各种计算机在世界范围内互连为网络的标准框架\n\nOSI将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰\n\n\n二、划分#\n\nOSI主要划分了七层，如下图所示：\n\n\n\n\n应用层#\n\n应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用\n\n该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的\nSMTP协议等\n\n在应用层交互的数据单元我们称之为报文\n\n\n表示层#\n\n表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务\n\n该层提供的服务主要包括数据压缩，数据加密以及数据描述，使应用程序不必担心在各台计算机中表示和存储的内部格式差异\n\n\n会话层#\n\n会话层就是负责建立、管理和终止表示层实体之间的通信会话\n\n该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法\n\n\n传输层#\n\n传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题\n\n传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层\n\n其中，主要的传输层协议是TCP和UDP\n\n\n网络层#\n\n两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网\n\n网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送\n\n在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包，向下传输到数据链路层\n\n在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层\n\n\n数据链路层#\n\n数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议\n\n在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP数据报组装成帧，在两个相邻节点间的链路上传送帧\n\n每一帧的数据可以分成：报头head和数据data两部分:\n\n * head 标明数据发送者、接受者、数据类型，如 MAC 地址\n * data 存储了计算机之间交互的数据\n\n通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源\n\n\n物理层#\n\n作为OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送\n\n该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）\n\n该层主要是和硬件有关，与软件关系不大\n\n\n三、传输过程#\n\n数据在各层之间的传输如下图所示：\n\n\n\n * 应用层报文被传送到运输层\n * 在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用\n * 应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端\n   能够判断报文中的比特是否在途中已被改变\n * 运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报\n * 网络层数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧\n * 在物理层数据帧被封装成比特流，之后通过传输介质传送到对端\n * 对端再一步步解开封装，获取到传送的数据\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B\n * https://zhuanlan.zhihu.com/p/32059190\n * https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/","routePath":"/interview/http/OSI","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、划分","id":"二划分","depth":2,"charIndex":175},{"text":"应用层","id":"应用层","depth":3,"charIndex":204},{"text":"表示层","id":"表示层","depth":3,"charIndex":365},{"text":"会话层","id":"会话层","depth":3,"charIndex":497},{"text":"传输层","id":"传输层","depth":3,"charIndex":569},{"text":"网络层","id":"网络层","depth":3,"charIndex":692},{"text":"数据链路层","id":"数据链路层","depth":3,"charIndex":891},{"text":"物理层","id":"物理层","depth":3,"charIndex":1193},{"text":"三、传输过程","id":"三传输过程","depth":2,"charIndex":1309},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1672}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何理解 OSI 七层模型?","footer":"如何理解 OSI 七层模型?","order":7,"star":7,"date":"2023-03-18T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-如何理解 OSI 七层模型?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何理解 OSI 七层模型?"}]]},"version":""},{"id":180,"title":"前端物语|面试物语-http","content":" * 说说 HTTP1.0/1.1/2.0 的区别?\n * 如何理解 CDN？说说实现原理？\n * DNS 协议 是什么？说说 DNS 完整的查询过程?\n * 说一下 GET 和 POST 的区别？\n * 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？\n * 什么是 HTTP? HTTP 和 HTTPS 的区别?\n * 如何理解 OSI 七层模型?\n * 如何理解 TCP/IP 协议?\n * 如何理解 UDP 和 TCP? 区别? 应用场景?\n * 说说对 WebSocket 的理解？应用场景？\n * 说说地址栏输入 URL 敲下回车后发生了什么?\n * 说说 TCP 为什么需要三次握手和四次挥手？\n * 说说 HTTP 常见的请求头有哪些? 作用？\n * 说说 HTTP 常见的状态码有哪些，适用场景？","routePath":"/interview/http/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"http","tag":"http","title":"前端物语|面试物语-http","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":181,"title":"如何理解 TCP/IP 协议?","content":"#\n\n\n\n\n一、是什么#\n\nTCP/IP，传输控制协议/网际协议，是指能够在多个不同网络间实现信息传输的协议簇\n\n * TCP（传输控制协议）\n\n一种面向连接的、可靠的、基于字节流的传输层通信协议\n\n * IP（网际协议）\n\n用于封包交换数据网络的协议\n\nTCP/IP 协议不仅仅指的是TCP和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇，\n\n只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以通称为 TCP/IP 协议族（英语：TCP/IP Protocol Suite，或 TCP/IP\nProtocols）\n\n\n二、划分#\n\nTCP/IP 协议族按层次分别了五层体系或者四层体系\n\n五层体系的协议结构是综合了 OSI 和 TCP/IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层\n\n五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层\n\n如下图所示：\n\n\n\n\n五层体系#\n\n应用层#\n\nTCP/IP 模型将 OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务\n\n如：FTP、Telnet、DNS、SMTP 等\n\n传输层#\n\n该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能\n\n传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）\n\n其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输\n\n网络层#\n\n负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机\n\n在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送\n\n数据链路层#\n\n数据链路层在两个相邻节点传输数据时，将网络层交下来的 IP 数据报组装成帧，在两个相邻节点之间的链路上传送帧\n\n物理层#\n\n保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境\n\n\n四层体系#\n\nTCP/IP 的四层结构则如下表所示：\n\n层次名称    单位    功 能                                协 议\n网络接口层   帧     负责实际数据的传输，对应 OSI 参考模型的下两层          HDLC（高级链路控制协议）PPP（点对点协议） SLIP（串行线路接口协议）\n网络层     数据报   负责网络间的寻址数据传输，对应 OSI 参考模型的第三层       IP（网际协议） ICMP（网际控制消息协议）ARP（地址解析协议） RARP（反向地址解析协议）\n传输层     报文段   负责提供可靠的传输服务，对应 OSI 参考模型的第四层        TCP（控制传输协议） UDP（用户数据报协议）\n应用层           负责实现一切与应用程序相关的功能，对应 OSI 参考模型的上三层   FTP（文件传输协议） HTTP（超文本传输协议）\n                                                 DNS（域名服务器协议）SMTP（简单邮件传输协议）NFS（网络文件系统协议）\n\n\n三、总结#\n\nOSI 参考模型与 TCP/IP 参考模型区别如下：\n\n相同点：\n\n * OSI 参考模型与 TCP/IP 参考模型都采用了层次结构\n * 都能够提供面向连接和无连接两种通信服务机制\n\n不同点：\n\n * OSI 采用的七层模型； TCP/IP 是四层或五层结构\n\n * TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分\n\n * OSI 参考模型虽然网络划分为七层，但实现起来较困难。TCP/IP 参考模型作为一种简化的分层结构是可以的\n\n * TCP/IP\n   协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，\n   这也就造成 OSI 设想中的应用程序维度的分层是无法实现的\n\n三种模型对应关系如下图所示：\n\n\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F\n * https://zhuanlan.zhihu.com/p/103162095\n * https://segmentfault.com/a/1190000039204681\n * https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/","routePath":"/interview/http/TCP_IP","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、划分","id":"二划分","depth":2,"charIndex":284},{"text":"五层体系","id":"五层体系","depth":3,"charIndex":462},{"text":"应用层","id":"应用层","depth":4,"charIndex":469},{"text":"传输层","id":"传输层","depth":4,"charIndex":567},{"text":"网络层","id":"网络层","depth":4,"charIndex":708},{"text":"数据链路层","id":"数据链路层","depth":4,"charIndex":794},{"text":"物理层","id":"物理层","depth":4,"charIndex":858},{"text":"四层体系","id":"四层体系","depth":3,"charIndex":898},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1407},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1810}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何理解 TCP/IP 协议?","footer":"如何理解 TCP/IP 协议?","order":5,"star":5,"date":"2023-03-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-如何理解 TCP/IP 协议?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何理解 TCP/IP 协议?"}]]},"version":""},{"id":182,"title":"如何理解 UDP 和 TCP? 区别? 应用场景?","content":"#\n\n\n\n\n一、UDP#\n\nUDP（User Datagram\nProtocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层\n\n也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文\n\n而对接收方，接到后直接去除首部，交给上面的应用层就完成任务\n\nUDP报头包括 4 个字段，每个字段占用 2 个字节（即 16 个二进制位），标题短，开销小\n\n\n\n特点如下：\n\n * UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务\n * 传输途中出现丢包，UDP 也不负责重发\n * 当包的到达顺序出现乱序时，UDP 没有纠正的功能。\n * 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为\n\n\n二、TCP#\n\nTCP（Transmission Control\nProtocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送\n\n可以想象成流水形式的，发送方 TCP 会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP\n会根据当前网络的拥塞状态来确定每个报文段的大小\n\nTCP报文首部有 20 个字节，额外开销大\n\n\n\n特点如下：\n\n * TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n * 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n * 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（\n   主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）\n\n\n三、区别#\n\nUDP与TCP两者的都位于传输层，如下图所示：\n\n\n\n两者区别如下表所示：\n\n       TCP                UDP\n可靠性    可靠                 不可靠\n连接性    面向连接               无连接\n报文     面向字节流              面向报文\n效率     传输效率低              传输效率高\n双共性    全双工                一对一、一对多、多对一、多对多\n流量控制   滑动窗口               无\n拥塞控制   慢开始、拥塞避免、快重传、快恢复   无\n传输效率   慢                  快\n\n * TCP 是面向连接的协议，建立连接 3 次握手、断开连接四次挥手，UDP\n   是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取\n\n * TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方\n\n * TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个 TCP 报文段传输后，在目的站重新装配。UDP\n   协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用\n\n * TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n两者应用场景如下图：\n\n\n\n可以看到，TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而 UDP 适用场景为对效率要求高，对准确性要求低的场景\n\n\n参考文献#\n\n * https://zh.wikipedia.org\n * https://www.shangmayuan.com/a/a1e3ceb218284cefb95de7fd.html\n * https://segmentfault.com/a/1190000021815671","routePath":"/interview/http/UDP_TCP","lang":"","toc":[{"text":"一、UDP","id":"一udp","depth":2,"charIndex":5},{"text":"二、TCP","id":"二tcp","depth":2,"charIndex":403},{"text":"三、区别","id":"三区别","depth":2,"charIndex":830},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1576}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何理解 UDP 和 TCP? 区别? 应用场景?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>如何理解 UDP 和 TCP? 区别? 应用场景?","order":4,"star":4,"date":"2023-03-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-如何理解 UDP 和 TCP? 区别? 应用场景?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何理解 UDP 和 TCP? 区别? 应用场景?"}]]},"version":""},{"id":183,"title":"说说对 WebSocket 的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\nWebSocket，是一种网络传输协议，位于OSI模型的应用层。可在单个TCP连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅\n\n客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输\n\n\n\n从上图可见，websocket服务器与客户端通过握手连接，连接成功后，两者都能主动的向对方发送或接受数据\n\n而在websocket出现之前，开发实时web应用的方式为轮询\n\n不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果\n\n轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 CPU资源\n\n\n二、特点#\n\n\n全双工#\n\n通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合\n\n例如指 A→B 的同时 B→A ，是瞬时同步的\n\n\n二进制帧#\n\n采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比http/2，WebSocket更侧重于“实时通信”，而HTTP/2\n更侧重于提高传输效率，所以两者的帧结构也有很大的区别\n\n不像 HTTP/2 那样定义流，也就不存在多路复用、优先级等特性\n\n自身就是全双工，也不需要服务器推送\n\n\n协议名#\n\n引入ws和wss分别代表明文和密文的websocket协议，且默认端口使用 80 或 443，几乎与http一致\n\n\n\n\n握手#\n\nWebSocket也要有一个握手过程，然后才能正式收发数据\n\n客户端发送数据格式如下：\n\n\n\n * Connection：必须设置 Upgrade，表示客户端希望连接升级\n * Upgrade：必须设置 Websocket，表示希望升级到 Websocket 协议\n * Sec-WebSocket-Key：客户端发送的一个 base64\n   编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept 应答，否则客户端会抛出错误，并关闭连接\n * Sec-WebSocket-Version ：表示支持的 Websocket 版本\n\n服务端返回的数据格式：\n\n\n\n * HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接\n * Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一\n   个专用的 UUID，再计算摘要\n\n\n优点#\n\n * 较少的控制开销：数据包头部协议较小，不同于 http 每次请求需要携带完整的头部\n * 更强的实时性：相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少\n * 保持创连接状态：创建通信后，可省略状态信息，不同于 HTTP 每次请求需要携带身份验证\n * 更好的二进制支持：定义了二进制帧，更好处理二进制内容\n * 支持扩展：用户可以扩展 websocket 协议、实现部分自定义的子协议\n * 更好的压缩效果：Websocket 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率\n\n\n二、应用场景#\n\n基于websocket的事实通信的特点，其存在的应用场景大概有：\n\n * 弹幕\n * 媒体聊天\n * 协同编辑\n * 基于位置的应用\n * 体育实况更新\n * 股票基金报价实时更新\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/WebSocket\n * https://www.oschina.net/translate/9-killer-uses-for-websockets","routePath":"/interview/http/WebSocket","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、特点","id":"二特点","depth":2,"charIndex":331},{"text":"全双工","id":"全双工","depth":3,"charIndex":339},{"text":"二进制帧","id":"二进制帧","depth":3,"charIndex":409},{"text":"协议名","id":"协议名","depth":3,"charIndex":563},{"text":"握手","id":"握手","depth":3,"charIndex":630},{"text":"优点","id":"优点","depth":3,"charIndex":1108},{"text":"二、应用场景","id":"二应用场景","depth":2,"charIndex":1388},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1490}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 WebSocket 的理解？应用场景？","footer":"说说对 WebSocket 的理解？应用场景？","order":12,"star":12,"date":"2023-04-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说对 WebSocket 的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 WebSocket 的理解？应用场景？"}]]},"version":""},{"id":184,"title":"说说地址栏输入 URL 敲下回车后发生了什么?","content":"#\n\n\n\n\n一、简单分析#\n\n简单的分析，从输入 URL到回车后发生的行为如下：\n\n * URL 解析\n * DNS 查询\n * TCP 连接\n * HTTP 请求\n * 响应请求\n * 页面渲染\n\n\n二、详细分析#\n\n\nURL 解析#\n\n首先判断你输入的是一个合法的URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作\n\nURL的解析第过程中的第一步，一个url的结构解析如下：\n\n\n\n\nDNS 查询#\n\n在之前文章中讲过DNS的查询，这里就不再讲述了\n\n整个查询过程如下图所示：\n\n\n\n最终，获取到了域名对应的目标服务器IP地址\n\n\nTCP 连接#\n\n在之前文章中，了解到tcp是一种面向有连接的传输层协议\n\n在确定目标服务器服务器的IP地址后，则经历三次握手建立TCP连接，流程如下：\n\n\n\n\n发送 http 请求#\n\n当建立tcp连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器\n\n请求的内容包括：\n\n * 请求行\n * 请求头\n * 请求主体\n\n\n\n\n响应请求#\n\n当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个HTTP响应消息，包括：\n\n * 状态行\n * 响应头\n * 响应正文\n\n\n\n在服务器响应之后，由于现在http默认开始长连接keep-alive，当页面关闭之后，tcp链接则会经过四次挥手完成断开\n\n\n页面渲染#\n\n当浏览器接收到服务器响应的资源后，首先会对资源进行解析：\n\n * 查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储 cookie，解压 gzip，缓存资源等等\n * 查看响应头的 Content-Type 的值，根据不同的资源类型采用不同的解析方式\n\n关于页面的渲染过程如下：\n\n * 解析 HTML，构建 DOM 树\n * 解析 CSS ，生成 CSS 规则树\n * 合并 DOM 树和 CSS 规则，生成 render 树\n * 布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算\n * 绘制 render 树（ paint ），绘制页面像素信息\n * 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上\n\n\n\n\n参考文献#\n\n * https://github.com/febobo/web-interview/issues/141\n * https://zhuanlan.zhihu.com/p/80551769","routePath":"/interview/http/after_url","lang":"","toc":[{"text":"一、简单分析","id":"一简单分析","depth":2,"charIndex":5},{"text":"二、详细分析","id":"二详细分析","depth":2,"charIndex":100},{"text":"URL 解析","id":"url-解析","depth":3,"charIndex":110},{"text":"DNS 查询","id":"dns-查询","depth":3,"charIndex":200},{"text":"TCP 连接","id":"tcp-连接","depth":3,"charIndex":274},{"text":"发送 http 请求","id":"发送-http-请求","depth":3,"charIndex":355},{"text":"响应请求","id":"响应请求","depth":3,"charIndex":449},{"text":"页面渲染","id":"页面渲染","depth":3,"charIndex":593},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":957}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说地址栏输入 URL 敲下回车后发生了什么?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说地址栏输入 URL 敲下回车后发生了什么?","order":1,"star":1,"date":"2023-02-25T15:07:55.940Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说地址栏输入 URL 敲下回车后发生了什么?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说地址栏输入 URL 敲下回车后发生了什么?"}]]},"version":""},{"id":185,"title":"说说 TCP 为什么需要三次握手和四次挥手？","content":"#\n\n\n\n\n一、三次握手#\n\n三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包\n\n主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备\n\n过程如下：\n\n * 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态\n * 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK\n   的值，此时服务器处于 SYN_RCVD 的状态\n * 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到\n   ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接\n\n\n\n上述每一次握手的作用如下：\n\n * 第一次握手：客户端发送网络包，服务端收到了这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n * 第二次握手：服务端发包，客户端收到了这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能\n   力是否正常\n * 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常\n\n通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了\n\n\n为什么不是两次握手?#\n\n如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到\n\n并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源\n\n\n二、四次挥手#\n\ntcp终止一个连接，需要经过四次挥手\n\n过程如下：\n\n * 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认\n * 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK\n   报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态\n * 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态\n * 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于\n   TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK\n   报文之后，就处于关闭连接了，处于 CLOSED 状态\n\n\n\n\n四次挥手原因#\n\n服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FI\nN报文断开连接，因此需要四次挥手\n\n\n三、总结#\n\n一个完整的三次握手四次挥手如下图所示：\n\n\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/53374516\n * https://segmentfault.com/a/1190000020610336","routePath":"/interview/http/handshakes_waves","lang":"","toc":[{"text":"一、三次握手","id":"一三次握手","depth":2,"charIndex":5},{"text":"为什么不是两次握手?","id":"为什么不是两次握手","depth":3,"charIndex":703},{"text":"二、四次挥手","id":"二四次挥手","depth":2,"charIndex":862},{"text":"四次挥手原因","id":"四次挥手原因","depth":3,"charIndex":1327},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1436},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1467}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说TCP为什么需要三次握手和四次挥手？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说TCP为什么需要三次握手和四次挥手？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说TCP为什么需要三次握手和四次挥手？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说TCP为什么需要三次握手和四次挥手？"}]]},"version":""},{"id":186,"title":"说说 HTTP 常见的请求头有哪些? 作用？","content":"#\n\n\n\n\n一、是什么#\n\nHTTP 头字段（HTTP header fields）,是指在超文本传输协议（HTTP）的请求和响应消息中的消息头部分\n\n它们定义了一个超文本传输协议事务中的操作参数\n\nHTTP 头部字段可以自己根据需要定义，因此可能在 Web服务器和浏览器上发现非标准的头字段\n\n下面是一个HTTP请求的请求头：\n\n\n\n\n二、分类#\n\n常见的请求字段如下表所示：\n\n字段名                 说明                                                示例\nAccept              能够接受的回应内容类型（Content-Types）                        Accept: text/plain\nAccept-Charset      能够接受的字符集                                          Accept-Charset: utf-8\nAccept-Encoding     能够接受的编码方式列表                                       Accept-Encoding: gzip, deflate\nAccept-Language     能够接受的回应内容的自然语言列表                                  Accept-Language: en-US\nAuthorization       用于超文本传输协议的认证的认证信息                                 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\nCache-Control       用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令                  Cache-Control: no-cache\nConnection          该浏览器想要优先使用的连接类型                                   Connection: keep-alive Connection: Upgrade\nCookie              服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie      Cookie: $Version=1; Skin=new;\nContent-Length      以 八位字节数组 （8 位的字节）表示的请求体的长度                        Content-Length: 348\nContent-Type        请求体的 多媒体类型                                        Content-Type: application/x-www-form-urlencoded\nDate                发送该消息的日期和时间                                       Date: Tue, 15 Nov 1994 08:12:31 GMT\nExpect              表明客户端要求服务器做出特定的行为                                 Expect: 100-continue\nHost                服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号                Host: en.wikipedia.org:80 Host: en.wikipedia.org\nIf-Match            仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT   If-Match: \"737060cd8c284d8af7ad3082f209582d\"\n                    这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源\nIf-Modified-Since   允许在对应的内容未被修改的情况下返回 304 未修改                        If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\nIf-None-Match       允许在对应的内容未被修改的情况下返回 304 未修改                        If-None-Match: \"737060cd8c284d8af7ad3082f209582d\"\nIf-Range            如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体         If-Range: \"737060cd8c284d8af7ad3082f209582d\"\nRange               仅请求某个实体的一部分                                       Range: bytes=500-999\nUser-Agent          浏览器的浏览器身份标识字符串                                    User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0)\n                                                                      Gecko/20100101 Firefox/21.0\nOrigin              发起一个针对 跨来源资源共享 的请求                                Origin: http://www.example-social-network.com\n\n\n三、使用场景#\n\n通过配合请求头和响应头，可以满足一些场景的功能实现：\n\n\n协商缓存#\n\n协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对请求头响应头来管理的\n\nLast-Modified 表示本地文件最后修改日期，浏览器会在 request header\n加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来\n\nEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的\n\nIf-None-Match的 header 会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来\n\n而强制缓存不需要发送请求到服务端，根据请求头expires和cache-control判断是否命中强缓存\n\n强制缓存与协商缓存的流程图如下所示：\n\n\n\n\n会话状态#\n\ncookie，类型为「小型文本文件」，指某些网站为了辨别用户身份而储存在用户本地终端上的数据，通过响应头set-cookie决定\n\n作为一段一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 Cookie有效期、安全性、使用范围的可选属性组成\n\nCookie 主要用于以下三个方面：\n\n * 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n * 个性化设置（如用户自定义设置、主题等）\n * 浏览器行为跟踪（如跟踪分析用户行为等\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/HTTP头字段\n * https://github.com/amandakelake/blog/issues/41","routePath":"/interview/http/headers","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、分类","id":"二分类","depth":2,"charIndex":168},{"text":"三、使用场景","id":"三使用场景","depth":2,"charIndex":2550},{"text":"协商缓存","id":"协商缓存","depth":3,"charIndex":2588},{"text":"会话状态","id":"会话状态","depth":3,"charIndex":3004},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":3264}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 HTTP 常见的请求头有哪些? 作用？","footer":"说说 HTTP 常见的请求头有哪些? 作用？","order":13,"star":13,"date":"2023-04-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说 HTTP 常见的请求头有哪些? 作用？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 HTTP 常见的请求头有哪些? 作用？"}]]},"version":""},{"id":187,"title":"前端物语|面试物语-http","content":" * 说说 HTTP1.0/1.1/2.0 的区别?\n * 如何理解 CDN？说说实现原理？\n * DNS 协议 是什么？说说 DNS 完整的查询过程?\n * 说一下 GET 和 POST 的区别？\n * 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？\n * 什么是 HTTP? HTTP 和 HTTPS 的区别?\n * 如何理解 OSI 七层模型?\n * 如何理解 TCP/IP 协议?\n * 如何理解 UDP 和 TCP? 区别? 应用场景?\n * 说说对 WebSocket 的理解？应用场景？\n * 说说地址栏输入 URL 敲下回车后发生了什么?\n * 说说 TCP 为什么需要三次握手和四次挥手？\n * 说说 HTTP 常见的请求头有哪些? 作用？\n * 说说 HTTP 常见的状态码有哪些，适用场景？","routePath":"/interview/http/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"http","tag":"http","title":"前端物语|面试物语-http","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":188,"title":"说说 HTTP 常见的状态码有哪些，适用场景？","content":"#\n\n\n\n\n一、是什么#\n\nHTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码\n\n它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774与 RFC 4918等规范扩展\n\n简单来讲，http状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态\n\n\n二、分类#\n\n状态码第一位数字决定了不同的响应状态，有如下：\n\n * 1 表示消息\n * 2 表示成功\n * 3 表示重定向\n * 4 表示请求错误\n * 5 表示服务器错误\n\n\n1xx#\n\n代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\n\n常见的有：\n\n * 100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者\n   如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n * 101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级\n\n\n2xx#\n\n代表请求已成功被服务器接收、理解、并接受\n\n常见的有：\n\n * 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n\n * 201（已创建）：请求成功并且服务器创建了新的资源\n\n * 202（已创建）：服务器已经接收请求，但尚未处理\n\n * 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n\n * 204（无内容）：服务器成功处理请求，但没有返回任何内容\n\n * 205（重置内容）：服务器成功处理请求，但没有返回任何内容\n\n * 206（部分内容）：服务器成功处理了部分请求\n\n\n3xx#\n\n表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向\n\n常见的有：\n\n * 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n\n * 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n\n * 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n * 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n\n * 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n\n * 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n\n4xx#\n\n代表了客户端看起来可能发生了错误，妨碍了服务器的处理\n\n常见的有：\n\n * 400（错误请求）： 服务器不理解请求的语法\n * 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n * 403（禁止）： 服务器拒绝请求\n * 404（未找到）： 服务器找不到请求的网页\n * 405（方法禁用）： 禁用请求中指定的方法\n * 406（不接受）： 无法使用请求的内容特性响应请求的网页\n * 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n * 408（请求超时）： 服务器等候请求时发生超时\n\n\n5xx#\n\n表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生\n\n常见的有：\n\n * 500（服务器内部错误）：服务器遇到错误，无法完成请求\n * 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n * 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n * 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n * 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n * 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n\n三、适用场景#\n\n下面给出一些状态码的适用场景：\n\n * 100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST\n   数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输\n\n * 206：一般用来做断点续传，或者是视频文件等大文件的加载\n\n * 301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名\n\n * 302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面\n\n * 304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分\n\n * 400：参数有误，请求无法被服务器识别\n\n * 403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回\n\n * 404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时\n\n * 503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503\n\n * 504：网关超时\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/HTTP状态码\n * https://kebingzao.com/2018/10/05/http-status-code/","routePath":"/interview/http/status","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、分类","id":"二分类","depth":2,"charIndex":205},{"text":"1xx","id":"1xx","depth":3,"charIndex":295},{"text":"2xx","id":"2xx","depth":3,"charIndex":535},{"text":"3xx","id":"3xx","depth":3,"charIndex":804},{"text":"4xx","id":"4xx","depth":3,"charIndex":1223},{"text":"5xx","id":"5xx","depth":3,"charIndex":1515},{"text":"三、适用场景","id":"三适用场景","depth":2,"charIndex":1823},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2334}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 HTTP 常见的状态码有哪些，适用场景？","footer":"说说 HTTP 常见的状态码有哪些，适用场景？","order":8,"star":8,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","http"],"tag":["interview","http"],"shortTitle":"前端物语|面试物语-说说 HTTP 常见的状态码有哪些，适用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 HTTP 常见的状态码有哪些，适用场景？"}]]},"version":""},{"id":189,"title":"概览","content":"#\n\n * JavaScript\n\n * [ == 和 ===区别，分别在什么情况使用](https://www.h7ml.cn/posts/interview/JavaScript/==\n   _===)\n\n * 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？\n\n * DOM 常见的操作有哪些？\n\n * ajax 原理是什么？如何实现？\n\n * 数组的常用方法有哪些？\n\n * bind、call、apply 区别？如何实现一个 bind?\n\n * Javascript 本地存储的方式有哪些？区别及应用场景？\n\n * 说说你对闭包的理解？闭包使用场景\n\n * JavaScript 中执行上下文和执行栈是什么？\n\n * 大文件上传如何做断点续传？\n\n * 深拷贝浅拷贝的区别？如何实现一个深拷贝？\n\n * 说说 JavaScript 中的数据类型？存储上的差别？\n\n * 什么是防抖和节流？有什么区别？如何实现？\n\n * 说说 JavaScript 中的事件模型\n\n * 解释下什么是事件代理？应用场景？\n\n * 说说你对事件循环的理解\n\n * Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？\n\n * 说说你对函数式编程的理解？优缺点？\n\n * Javascript 如何实现继承？\n\n * 说说你了解的 js 数据结构？\n\n * 说说 Javascript 数字精度丢失的问题，如何解决？\n\n * 说说 JavaScript 中内存泄漏的几种情况？\n\n * 说说 new 操作符具体干了什么？\n\n * JavaScript 原型，原型链 ? 有什么特点？\n\n * 如何实现上拉加载，下拉刷新？\n\n * 说说你对正则表达式的理解？应用场景？\n\n * 说说你对作用域链的理解\n\n * web 常见的攻击方式有哪些？如何防御？\n\n * 什么是单点登录？如何实现？\n\n * JavaScript 字符串的常用方法有哪些？\n\n * 举例说明你对尾递归的理解，有哪些应用场景\n\n * 谈谈 this 对象的理解\n\n * 谈谈 JavaScript 中的类型转换机制\n\n * typeof 与 instanceof 区别\n\n * 如何判断一个元素是否在可视区域中？\n\n * NodeJS\n\n * 说说对 Node 中的 Buffer 的理解？应用场景？\n\n * 说说 Node 中的 EventEmitter? 如何实现一个 EventEmitter?\n\n * 说说对 Node 中的 Stream 的理解？应用场景？\n\n * 说说对 Nodejs 中的事件循环机制理解?\n\n * 如何实现文件上传？说说你的思路\n\n * 说说对 Node 中的 fs 模块的理解? 有哪些常用方法\n\n * 说说 Node. js 有哪些全局对象？\n\n * 如何实现 jwt 鉴权机制？说说你的思路\n\n * 说说对中间件概念的理解，如何封装 node 中间件？\n\n * 说说你对 Node.js 的理解？优缺点？应用场景？\n\n * 如果让你来设计一个分页功能, 你会怎么设计? 前后端如何交互?\n\n * Node 性能如何进行监控以及优化？\n\n * 说说对 Node 中的 process 的理解？有哪些常用方法？\n\n * 说说 Node 文件查找的优先级以及 Require 方法的文件查找策略?\n\n * README.md\n\n * React\n\n * React 事件绑定的方式有哪些？区别？\n\n * React 构建组件的方式有哪些？区别？\n\n * 说说对 Fiber 架构的理解？解决了什么问题？\n\n * 说说对高阶组件的理解？应用场景?\n\n * 说说 React 性能优化的手段有哪些？\n\n * 说说 React Jsx 转换成真实 DOM 过程？\n\n * 说说对 React 的理解？有哪些特性？\n\n * 说说对 React Hooks 的理解？解决了什么问题？\n\n * 说说你对 React Router 的理解？常用的 Router 组件有哪些？\n\n * 说说 React Router 有几种模式？实现原理？\n\n * 说说对 React refs 的理解？应用场景？\n\n * [ 说说 Real DOM 和 Virtual DOM\n   的区别？优缺点？](https://www.h7ml.cn/posts/interview/React/Real_DOM_Virtual DOM)\n\n * 说说对 Redux 中间件的理解？常用的中间件有哪些？实现原理？\n\n * 说说 React 的事件机制？\n\n * 在 react 中组件间过渡动画如何实现？\n\n * 说说你在 React 项目是如何捕获错误的？\n\n * 说说对 React 中类组件和函数组件的理解？有什么区别？\n\n * React 中组件之间如何通信？\n\n * 说说对受控组件和非受控组件的理解？应用场景？\n\n * 说说 React diff 的原理是什么？\n\n * 你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？\n\n * 说说你对 immutable 的理解？如何应用在 react 项目中？\n\n * 说说 react 中引入 css 的方式有哪几种？区别？\n\n * 说说你是如何提高组件的渲染效率的？在 React 中如何避免不必要的 render？\n\n * React 中的 key 有什么作用？\n\n * 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？\n\n * 说说你对 Redux 的理解？其工作原理？\n\n * 说说 React render 方法的原理？在什么时候会被触发？\n\n * 说说 React 服务端渲染怎么做？原理是什么？\n\n * 说说 React 中的 setState 执行机制\n\n * state 和 props 有什么区别？\n\n * 说说你在使用 React 过程中遇到的常见问题？如何解决?\n\n * super() 和 super(props) 有什么区别？\n\n * algorithm\n\n * 说说你对算法的理解？应用场景？\n\n * 说说你对二分查找的理解？如何实现？应用场景？\n\n * 说说你对堆的理解？如何实现？应用场景？\n\n * 说说你对链表的理解？常见的操作有哪些？\n\n * 说说你对冒泡排序的理解？如何实现？应用场景？\n\n * 说说你对分而治之、动态规划的理解？区别？\n\n * 说说你对贪心算法、回溯算法的理解？应用场景？\n\n * 说说你对图的理解？相关操作有哪些？\n\n * 说说你对插入排序的理解？如何实现？应用场景？\n\n * 说说你对归并排序的理解？如何实现？应用场景？\n\n * 说说你对快速排序的理解？如何实现？应用场景？\n\n * 说说你对选择排序的理解？如何实现？应用场景？\n\n * 说说你对集合的理解？常见的操作有哪些？\n\n * 说说常见的排序算法有哪些？区别？\n\n * 说说你对栈、队列的理解？应用场景？\n\n * 说说你对数据结构的理解？有哪些？区别？\n\n * 说说你对算法中时间复杂度，空间复杂度的理解？如何计算？\n\n * 说说你对树的理解？相关的操作有哪些？\n\n * applet\n\n * 说说微信小程序的实现原理？\n\n * 说说你对微信小程序的理解？优缺点？\n\n * 说说微信小程序的生命周期函数有哪些？\n\n * 说说微信小程序的登录流程？\n\n * 说说微信小程序中路由跳转的方式有哪些？区别？\n\n * 说说提高微信小程序的应用速度的手段有哪些？\n\n * 说说微信小程序的发布流程？\n\n * 说说微信小程序的支付流程？\n\n * css\n\n * 谈谈你对 BFC 的理解？\n\n * css3 动画有哪些？\n\n * 说说你对盒子模型的理解?\n\n * 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？\n\n * 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？\n\n * CSS3 新增了哪些新特性？\n\n * 如果要做优化，CSS 提高性能的方法有哪些？\n\n * 说说设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？\n\n * 说说 em/px/rem/vh/vw 区别?\n\n * 说说 flexbox（弹性盒布局模型）,以及适用场景？\n\n * 介绍一下 grid 网格布局\n\n * css 中，有哪些方式可以隐藏页面元素？区别?\n\n * 怎么理解回流跟重绘？什么场景下会触发？\n\n * 让 Chrome 支持小于 12px 的文字方式有哪些？区别？\n\n * 什么是响应式设计？响应式设计的基本原理是什么？如何做？\n\n * 说说对 Css 预编语言的理解？有哪些区别?\n\n * 如何实现单行／多行文本溢出的省略样式？\n\n * CSS 如何画一个三角形？原理是什么？\n\n * 如何使用 css 完成视差滚动效果?\n\n * design\n\n * 说说你对工厂模式的理解？应用场景？\n\n * 说说你对发布订阅、观察者模式的理解？区别？\n\n * 说说你对代理模式的理解？应用场景？\n\n * 说说你对单例模式的理解？如何实现？\n\n * 说说你对策略模式的理解？应用场景？\n\n * 说说对设计模式的理解？常见的设计模式有哪些？\n\n * es6\n\n * ES6 中数组新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Decorator 的？使用场景？\n\n * 对象新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Generator 的？使用场景？\n\n * 你是怎么理解 ES6 中 Module 的？使用场景？\n\n * 对象新增了哪些扩展？\n\n * 你是怎么理解 ES6 中 Promise 的？使用场景？\n\n * 你是怎么理解 ES6 中 Proxy 的？使用场景?\n\n * 你是怎么理解 ES6 新增 Set、Map 两种数据结构的？\n\n * 说说 var、let、const 之间的区别\n\n * git\n\n * 说说你对 Git 的理解？\n\n * 说说 Git 中 HEAD、工作树和索引之间的区别？\n\n * 说说你对版本管理的理解？常用的版本管理工具有哪些？\n\n * 说说 Git 常用的命令有哪些？ ,- 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?\n\n * [ 说说你对 git rebase 和 git merge\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/gitRebase_ gitMerge)\n\n * [ 说说对 git pull 和 git fetch\n   的理解？有什么区别？](https://www.h7ml.cn/posts/interview/git/git_pull _git_fetch)\n\n * [ 说说你对 git reset 和 git revert\n   的理解？区别？](https://www.h7ml.cn/posts/interview/git/git_reset_ git_revert)\n\n * 说说你对 git stash 的理解？应用场景？\n\n * http\n\n * 说说 HTTP1.0/1.1/2.0 的区别?\n\n * 如何理解 CDN？说说实现原理？\n\n * DNS 协议 是什么？说说 DNS 完整的查询过程?\n\n * 说一下 GET 和 POST 的区别？\n\n * 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？\n\n * 什么是 HTTP? HTTP 和 HTTPS 的区别?\n\n * 如何理解 OSI 七层模型?\n\n * 如何理解 TCP/IP 协议?\n\n * 如何理解 UDP 和 TCP? 区别? 应用场景?\n\n * 说说对 WebSocket 的理解？应用场景？\n\n * 说说地址栏输入 URL 敲下回车后发生了什么?\n\n * 说说 TCP 为什么需要三次握手和四次挥手？\n\n * 说说 HTTP 常见的请求头有哪些? 作用？\n\n * 说说 HTTP 常见的状态码有哪些，适用场景？\n\n * linux\n\n * 说说 linux 系统下 文件操作常用的命令有哪些？\n\n * [\n\n * typescript\n\n * 说说你对 TypeScript 中类的理解？应用场景？\n\n * 说说 typescript 的数据类型有哪些？\n\n * 说说你对 TypeScript 装饰器的理解？应用场景？\n\n * 说说你对 TypeScript 中枚举类型的理解？应用场景？\n\n * 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？\n\n * 说说你对 TypeScript 中泛型的理解？应用场景？\n\n * 说说你对 TypeScript 中高级类型的理解？有哪些？\n\n * 说说你对 TypeScript 中接口的理解？应用场景？\n\n * 说说对 TypeScript 中命名空间与模块的理解？区别？\n\n * 说说如何在 React 项目中应用 TypeScript？\n\n * 说说你对 TypeScript 的理解？与 JavaScript 的区别？\n\n * 说说如何在 Vue 项目中应用 TypeScript？\n\n * vue\n\n * vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？\n\n * Vue 项目中有封装过 axios 吗？主要是封装哪方面的？\n\n * 你了解 axios 的原理吗？有看过它的源码吗？\n\n * 双向数据绑定是什么\n\n * Vue 组件之间的通信方式都有哪些？\n\n * Vue 中组件和插件有什么区别？\n\n * Vue 项目中你是如何解决跨域的呢？\n\n * 为什么 data 属性是一个函数而不是一个对象？\n\n * 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？\n\n * 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？\n\n * Vue 中的过滤器了解吗？过滤器的应用场景有哪些？\n\n * SPA 首屏加载速度慢的怎么解决？\n\n * v-if 和 v-for 的优先级是什么？\n\n * 说说你对 keep-alive 的理解是什么？\n\n * 你知道 vue 中 key 的原理吗？说说你对它的理解\n\n * 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n\n * 说说你对 vue 的 mixin 的理解，有什么应用场景？\n\n * Vue 常用的修饰符有哪些有什么应用场景\n\n * Vue 实例挂载的过程\n\n * Vue 中的$nextTick 有什么作用？\n\n * Vue.observable 你有了解过吗？说说看\n\n * vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n\n * v-show 和 v-if 有什么区别？使用场景分别是什么？\n\n * 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢\n\n * SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？\n\n * 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？\n\n * 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路\n\n * vue3 有了解过吗？能说说跟 vue2 的区别吗？\n\n * vue3\n\n * Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n\n * Vue3.0 的设计目标是什么？做了哪些优化\n\n * 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？\n\n * Vue3.0 性能提升主要是通过哪几方面体现的？\n\n * Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？\n\n * css 选择器有哪些？优先级？哪些属性可以继承？\n\n * 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？\n\n * webpack\n\n * 说说 webpack 的热更新是如何做到的？原理是什么？\n\n * 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？\n\n * 说说 webpack 中常见的 Plugin？解决了什么问题？\n\n * 与 webpack 类似的工具还有哪些？区别？\n\n * 说说 webpack 的构建流程?\n\n * 如何提高 webpack 的构建速度？\n\n * 说说如何借助 webpack 来优化前端性能？\n\n * 说说 webpack proxy 工作原理？为什么能解决跨域?\n\n * 说说你对 webpack 的理解？解决了什么问题？","routePath":"/interview/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"sidebar_label":"概览","sidebar_position":1},"version":""},{"id":190,"title":"前端物语|面试物语-linux","content":" * 说说 linux 系统下 文件操作常用的命令有哪些？\n * ---\n * 说说你对操作系统的理解？核心概念有哪些？\n * 说说你对 linux 用户管理的理解？相关的命令有哪些？\n * ---\n * 说说你对输入输出重定向和管道的理解？应用场景？\n * 说说你对 shell 的理解？常见的命令？\n * 说说什么是进程？什么是线程？区别？\n * ---","routePath":"/interview/linux/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"linux","tag":"linux","title":"前端物语|面试物语-linux","index":false,"dir":{"order":1},"date":"2023-04-04T00:00:00.000Z"},"version":""},{"id":191,"title":"说说 linux 系统下 文件操作常用的命令有哪些？","content":"#\n\n\n\n\n一、是什么#\n\nLinux 是一个开源的操作系统（OS），是一系列 Linux 内核基础上开发的操作系统的总称（常见的有 Ubuntu、centos）\n\n系统通常会包含以下 4 个主要部分\n\n * 内核\n * shell\n * 文件系统\n * 应用程序\n\n文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录\n\n\n\n\n二、文件操作#\n\n常见处理目录的命令如下：\n\n * ls（英文全拼：list files）: 列出目录及文件名\n * cd（英文全拼：change directory）：切换目录\n * pwd（英文全拼：print work directory）：显示目前的目录\n * mkdir（英文全拼：make directory）：创建一个新的目录\n * rmdir（英文全拼：remove directory）：删除一个空的目录\n * cp（英文全拼：copy file）: 复制文件或目录\n * rm（英文全拼：remove）: 删除文件或目录\n * mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称\n\n\nls#\n\n列出目录文件，选项与参数：\n\n * -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)\n * -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)\n * -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)\n\n例如将家目录下的所有文件列出来(含属性与隐藏档)\n\n\n\n\ncd#\n\n切换工作目录\n\n语法：\n\n\n\n\n\n\npwd#\n\npwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。\n\n\n\n选项与参数：\n\n * -P ：显示出确实的路径，而非使用连结 (link) 路径\n\n\nmkdir#\n\n创建新目录\n\n语法：\n\n\n\n选项与参数：\n\n * -m ：配置文件的权限\n * -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来\n\n\nrmdir (删除空的目录)#\n\n语法：\n\n\n\n选项与参数：\n\n * -p ：连同上一级『空的』目录也一起删除\n\n\ncp#\n\n即拷贝文件和目录\n\n语法：\n\n\n\n用法如下：\n\n\n\n常用参数如下：\n\n * -r 递归的拷贝，常用来拷贝一整个目录\n\n\nrm (移除文件或目录)#\n\n语法：\n\n\n\n选项与参数：\n\n * -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\n * -i ：互动模式，在删除前会询问使用者是否动作\n * -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！\n\n\nmv (移动文件与目录，或修改名称)#\n\n语法：\n\n\n\n选项与参数：\n\n * -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\n * -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\n * -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)\n\n\nln#\n\nLinux 文件的存储方式分为 3 个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode\n标识绑定到文件内容\n\nLinux 下有两种链接类型：硬链接和软链接\n\n硬链接#\n\n使链接的两个文件共享同样文件内容，就是同样的 inode ，一旦文件 1 和文件 2 之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容\n\n语法：\n\n\n\n\n\n删除文件 1 不会影响删除文件 2，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除\n\n只有同时删除了两个文件后后，它们共同指向的文件内容才会消失。\n\n软链接#\n\n类似window系统的快捷方式\n\n使用方式：\n\n\n\n其实 file2 只是 file1 的一个快捷方式，它指向的是 file1 ，所以显示的是 file1 的内容，但其实 file2 的 inode 与\nfile1 并不相同\n\n如果\n\n删除了 file2 的话， file1 是不会受影响的，但如果删除 file1 的话， file2 就会变成死链接，因为指向的文件不见了\n\n\n三、文件查看#\n\n常见的文件内容查看有如下：\n\n * cat 由第一行开始显示文件内容\n * less 一页一页的显示文件内容\n * head 只看头几行\n * tail 只看尾巴几行\n\n\ncat#\n\n由第一行开始显示文件内容\n\n语法：\n\n\n\n常见的选项与参数如下：\n\n * -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！\n * -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同\n\n\nless#\n\n一页一页翻动，以下实例输出/etc/man.config 文件的内容：\n\n\n\nless 运行时可以输入的命令有：\n\n * 空白键 ：向下翻动一页；\n * [pagedown]：向下翻动一页；\n * [pageup] ：向上翻动一页；\n * /字串 ：向下搜寻『字串』的功能；\n * ?字串 ：向上搜寻『字串』的功能；\n * n ：重复前一个搜寻 (与 / 或 ? 有关！)\n * N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)\n * q ：离开 less 这个程序\n\n\nhead#\n\n取出文件前面几行\n\n语法：\n\n\n\n选项与参数：\n\n * -n ：后面接数字，代表显示几行的意思\n\n\n\n\ntail#\n\n取出文件后面几行\n\n语法：\n\n\n\n选项与参数：\n\n * -n ：后面接数字，代表显示几行的意思\n * -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c 才会结束 tail 的侦测\n\n\n参考文献#\n\n * https://www.runoob.com/linux/linux-file-content-manage.html\n * https://juejin.cn/post/6938385978004340744#heading-35\n * https://zh.wikipedia.org/wiki/Linux","routePath":"/interview/linux/file","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、文件操作","id":"二文件操作","depth":2,"charIndex":203},{"text":"ls","id":"ls","depth":3,"charIndex":519},{"text":"cd","id":"cd","depth":3,"charIndex":678},{"text":"pwd","id":"pwd","depth":3,"charIndex":701},{"text":"mkdir","id":"mkdir","depth":3,"charIndex":803},{"text":"rmdir (删除空的目录)","id":"rmdir-删除空的目录","depth":3,"charIndex":885},{"text":"cp","id":"cp","depth":3,"charIndex":943},{"text":"rm (移除文件或目录)","id":"rm-移除文件或目录","depth":3,"charIndex":1008},{"text":"mv (移动文件与目录，或修改名称)","id":"mv-移动文件与目录或修改名称","depth":3,"charIndex":1142},{"text":"ln","id":"ln","depth":3,"charIndex":1308},{"text":"硬链接","id":"硬链接","depth":4,"charIndex":1428},{"text":"软链接","id":"软链接","depth":4,"charIndex":1605},{"text":"三、文件查看","id":"三文件查看","depth":2,"charIndex":1800},{"text":"cat","id":"cat","depth":3,"charIndex":1895},{"text":"less","id":"less","depth":3,"charIndex":2006},{"text":"head","id":"head","depth":3,"charIndex":2252},{"text":"tail","id":"tail","depth":3,"charIndex":2311},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2417}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 linux系统下 文件操作常用的命令有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 linux系统下 文件操作常用的命令有哪些？","order":2,"star":2,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说 linux系统下 文件操作常用的命令有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 linux系统下 文件操作常用的命令有哪些？"}]]},"version":""},{"id":192,"title":"前端物语|面试物语-linux","content":" * 说说 linux 系统下 文件操作常用的命令有哪些？\n * ---\n * 说说你对操作系统的理解？核心概念有哪些？\n * 说说你对 linux 用户管理的理解？相关的命令有哪些？\n * ---\n * 说说你对输入输出重定向和管道的理解？应用场景？\n * 说说你对 shell 的理解？常见的命令？\n * 说说什么是进程？什么是线程？区别？\n * ---","routePath":"/interview/linux/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"linux","tag":"linux","title":"前端物语|面试物语-linux","index":false,"dir":{"order":1},"date":"2023-04-04T00:00:00.000Z"},"version":""},{"id":193,"title":"React 中的 key 有什么作用？","content":"--------------------------------------------------------------------------------\n\nicon: question description: 前端物语|面试物语-React 中的 key 有什么作用？ footer: 浙 ICP 备\n2021037683 号-2React 中的 key 有什么作用？ order: 2 star: 2 date: 2023-02-24 author: h7ml\nimage: https://www.h7ml.cn/logo.png banner: https://www.h7ml.cn/logo.png\ncategory:\n\n * interview\n * React tag:\n * interview\n * React shortTitle: 前端物语|面试物语-React 中的 key 有什么作用？ isOriginal: false head:\n   * * meta\n   * name: keywords content: React 中的 key 有什么作用？\n\n--------------------------------------------------------------------------------\n\n\nReact 中的 key 有什么作用？#\n\n\n\n\n一、是什么#\n\n首先，先给出react组件中进行列表渲染的一个示例：\n\n\n\n然后在输出就可以看到react所提示的警告信息：\n\n\n\n根据意思就可以得到渲染列表的每一个子元素都应该需要一个唯一的key值\n\n在这里可以使用列表的id属性作为key值以解决上面这个警告\n\n\n\n\n二、作用#\n\n跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染\n\n因此key的值需要为每一个元素赋予一个确定的标识\n\n如果列表数据渲染中，在数据后面插入一条数据，key作用并不大，如下：\n\n\n\n前面的元素在diff算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的DOM树中\n\n因此，在这种情况下，元素有无key属性意义并不大\n\n下面再来看看在前面插入数据时，使用key与不使用key的区别：\n\n\n\n当拥有key的时候，react根据key属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将 000 元素插入到最前面位置\n\n当没有key的时候，所有的li标签都需要进行修改\n\n同样，并不是拥有key值代表性能越高，如果说只是文本内容改变了，不写key反而性能和效率更高\n\n主要是因为不写key是将所有的文本内容替换一下，节点不会发生变化\n\n而写key则涉及到了节点的增和删，发现旧key不存在了，则将其删除，新key在之前没有，则插入，这就增加性能的开销\n\n\n三、总结#\n\n良好使用key属性是性能优化的非常关键的一步，注意事项为：\n\n * key 应该是唯一的\n\n * key 不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）\n\n * 使用 index 作为 key 值，对性能没有优化\n\nreact判断key的流程具体如下图：\n\n\n\n\n参考文献#\n\n * https://zh-hans.reactjs.org/docs/lists-and-keys.html#gatsby-focus-wrapper\n * https://segmentfault.com/a/1190000017511836","routePath":"/interview/linux/key","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":605},{"text":"二、作用","id":"二作用","depth":2,"charIndex":741},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1246},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1397}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语----","footer":"---","order":5,"star":5,"date":"2023-03-29T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语----","isOriginal":false,"head":[["meta",{"name":"keywords","content":"---"}]]},"version":""},{"id":194,"title":"说说你对操作系统的理解？核心概念有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n操作系统（Operating\nSystem，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基\n石\n\n简单来讲，操作系统就是一种复杂的软件，相当于软件管家\n\n操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务，\n\n操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用，如下图：\n\n\n\n许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序\n\n\n二、核心概念#\n\n操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：\n\n * 进程（线程）：进程（线程）是操作系统对 CPU 的抽象\n\n * 虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象\n\n * 文件：文件是操作系统对物理磁盘的抽象\n\n * shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。\n\n * GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互\n\n * 计算机架构(computer architecture)：\n   在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构\n\n * 多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力\n\n * 程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置\n\n * 多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术\n\n * CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核\n\n * 图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片\n\n * 缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中\n\n * RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器\n\n * ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除\n\n * 虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制\n\n * 驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序\n\n * USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范\n\n * 地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范\n\n * 进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法\n\n * 目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器\n\n * 路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。\n\n * 根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /\n\n * 工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。\n\n * 文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念\n\n * 客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。\n\n * 服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备\n\n\n三、总结#\n\n * 操作系统是管理计算机硬件与软件资源的程序，是计算机的基石\n * 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源\n * 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项\n * 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。\n   内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性\n\n\n参考文献#\n\n * https://www.cnblogs.com/cxuanBlog/p/13297199.html\n * https://www.cnblogs.com/cxuanblog/p/12607608.html\n * https://www.anvilliu.com/2021/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%B\n   D%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","routePath":"/interview/linux/linux","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、核心概念","id":"二核心概念","depth":2,"charIndex":356},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1844},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2072}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对操作系统的理解？核心概念有哪些？","footer":"说说你对操作系统的理解？核心概念有哪些？","order":3,"star":3,"date":"2023-03-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说你对操作系统的理解？核心概念有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对操作系统的理解？核心概念有哪些？"}]]},"version":""},{"id":195,"title":"说说你对 linux 用户管理的理解？相关的命令有哪些？","content":"#\n\n\n\n\n一、是什么#\n\nLinux 是一个多用户的系统，允许使用者在系统上通过规划不同类型、不同层级的用户，并公平地分配系统资源与工作环境\n\n而与 Windows 系统最大的不同， Linux 允许不同的用户同时登录主机，同时使用主机的资源\n\n既然是多用户的系统，那么最常见的问题就是权限，不同的用户对于不同的文件都应该有各自的权限\n\n例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的\n\n这里面涉及到用户与用户组的概念\n\n\n二、用户与用户组#\n\nLinux以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux\n作为多用户系统的可行性\n\n从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象：\n\n * 文件所有者\n * 用户组成员\n * 其他人\n\n每一个对象对某一个文件的持有权限是不同的\n\n\n文件所有者#\n\n当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，同时排他性地拥有该文件\n\n除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作\n\n\n用户组#\n\n将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组\n\n这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有\n\n例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可\n\n\n其他人#\n\n既与文件所有者没有任何联系的其他用户\n\n\n小结#\n\n户和用户组的对应关系是：一对一、多对一、一对多或多对多：\n\n * 一对一：某个用户可以是某个组的唯一成员\n * 多对一：多个用户可以是某个唯一的组的成员，不归属其它用户组\n * 一对多：某个用户可以是多个用户组的成员\n * 多对多：多个用户对应多个用户组，并且几个用户可以是归属相同的组\n\n\n拓展#\n\n当我们使用ls -l的时候，会列出当前目录的文件信息，如下：\n\n\n\n * d：文件类型\n * rwxr-xr-x：文件权限\n * 3 硬链接数或目录包含的文件数\n * osmond：文件所有者\n * 4096：文件长度\n * 05-16 13:32：文件上次修改的事件和日期\n * nobp：文件名\n\n下面主要看看文件权限分析，实际上是由 9 个字符组成，每 3 个一组：\n\n * 第一组控制文件所有者的访问权限\n * 第二组控制所有者所在用户组的其他成员的访问权限\n * 第三组控制系统其他用户的访问权限\n\n-代表当前没有，rwx对应代表的意思如下：\n\n\n\n\n三、用户操作#\n\n用户相关的操作有如下：\n\n\n新增用户#\n\nuseradd 可以用来创建新用户，简要语法为：\n\n\n\n例如：\n\n添加一个一般用户\n\n\n\n为添加的用户指定相应的用户组\n\n\n\n创建一个系统用户\n\n\n\n为新添加的用户指定/home 目录\n\n\n\n\n设置密码#\n\n创建的用户还没有设置登录密码，需要利用passwd进行密码设置\n\n\n\noption 参数有如下：\n\n * -d 删除密码\n * -f 强迫用户下次登录时必须修改口令\n * -w 口令要到期提前警告的天数\n * -k 更新只能发送在过期之后\n * -l 停止账号使用\n * -S 显示密码信息\n * -u 启用已被停止的账户\n * -x 指定口令最长存活期\n * -g 修改群组密码\n * 指定口令最短存活期\n * -i 口令过期后多少天停用账户\n\n例如，修改用户密码\n\n\n\n显示账号密码信息\n\n\n\n删除用户密码\n\n\n\n\n修改用户#\n\nchage 命令用来修改与用户密码相关的过期信息，如密码失效日、密码最短保留天数、失效前警告天数等\n\n\n\n常见的参数有：\n\n * -d：指定密码最后修改日期\n\n * -E：密码到期的日期\n\n * -l：列出用户以及密码的有效期\n\n * -m：密码能够更改的最小天数\n\n * -M：密码保持有效的最大天数\n\n\n删除用户#\n\nuserdel 命令用来删除用户的相关的所有数据。\n\n\n\n常见的参数有：\n\n * -r：删除用户登入目录以及目录中所有文件\n\n例如删除用户账号\n\n\n\n用户组相关的操作如下：\n\n\n新增用户组#\n\ngroupadd用于创建一个新的工作组，新工作组的信息将被添加到系统文件中\n\n\n\n常见的参数有如下：\n\n * -g：指定新建工作组的 id；\n * -r：创建系统工作组，系统工作组的组 ID 小于 500\n * -K：覆盖配置文件 \"/ect/login.defs\"\n * -o：允许添加组 ID 号不唯一的工作组\n * -f,--force: 如果指定的组已经存在，此选项将失明了仅以成功状态退出\n\n例如创建一个新的组，并添加组 ID。\n\n\n\n\n修改用户#\n\ngroupmod命令用来修改 group相关的参数，例如群组识别码或者名称\n\n\n\n常见的参数有：\n\n * -g <群组识别码> 　设置欲使用的群组识别码\n * -o 　重复使用群组识别码\n * -n <新群组名称> 　设置欲使用的群组名\n\n例如修改组名：\n\n\n\n\n删除用户组#\n\ngroupdel 用于删除用户组，如果该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组\n\n\n\n日常工作通常会碰到只有root用户才有权限执行的操作，这就需要使用用户身份切换的命令：\n\n\nsu#\n\n用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码\n\n\nsudo#\n\nsudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行\n\n不是所有的用户都能执行 sudo 命令的，而是在 /etc/sudoers 文件内的用户才能执行这个命令\n\n例如sudo命令使用ls：\n\n\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/37964411\n * https://zhuanlan.zhihu.com/p/105482468","routePath":"/interview/linux/linux_users","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、用户与用户组","id":"二用户与用户组","depth":2,"charIndex":258},{"text":"文件所有者","id":"文件所有者","depth":3,"charIndex":434},{"text":"用户组","id":"用户组","depth":3,"charIndex":535},{"text":"其他人","id":"其他人","depth":3,"charIndex":769},{"text":"小结","id":"小结","depth":3,"charIndex":796},{"text":"拓展","id":"拓展","depth":3,"charIndex":947},{"text":"三、用户操作","id":"三用户操作","depth":3,"charIndex":1233},{"text":"新增用户","id":"新增用户","depth":3,"charIndex":1256},{"text":"设置密码","id":"设置密码","depth":2,"charIndex":1360},{"text":"修改用户","id":"修改用户","depth":3,"charIndex":1627},{"text":"删除用户","id":"删除用户","depth":3,"charIndex":1788},{"text":"新增用户组","id":"新增用户组","depth":3,"charIndex":1884},{"text":"修改用户","id":"修改用户-1","depth":3,"charIndex":2116},{"text":"删除用户组","id":"删除用户组","depth":3,"charIndex":2255},{"text":"su","id":"su","depth":3,"charIndex":2362},{"text":"sudo","id":"sudo","depth":3,"charIndex":2404},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2538}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 linux 用户管理的理解？相关的命令有哪些？","footer":"说说你对 linux 用户管理的理解？相关的命令有哪些？","order":7,"star":7,"date":"2023-04-02T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说你对 linux 用户管理的理解？相关的命令有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 linux 用户管理的理解？相关的命令有哪些？"}]]},"version":""},{"id":196,"title":"Vue3.0 性能提升主要是通过哪几方面体现的？","content":"--------------------------------------------------------------------------------\n\nicon: question description: 前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？ footer: 浙 ICP 备\n2021037683 号-2Vue3.0 性能提升主要是通过哪几方面体现的？ order: 1 star: 1 date: 2023-02-24 author:\nh7ml image: https://www.h7ml.cn/logo.png banner: https://www.h7ml.cn/logo.png\ncategory:\n\n * interview\n * vue3 tag:\n * interview\n * vue3 shortTitle: 前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？ isOriginal: false head:\n   * * meta\n   * name: keywords content: Vue3.0 性能提升主要是通过哪几方面体现的？\n\n--------------------------------------------------------------------------------\n\n\nVue3.0 性能提升主要是通过哪几方面体现的？#\n\n\n\n\n一、编译阶段#\n\n回顾Vue2，我们知道每个组件实例都对应一个 watcher\n实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染\n\n\n\n试想一下，一个组件结构如下图\n\n\n\n可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费\n\n因此，Vue3在编译阶段，做了进一步优化。主要有如下：\n\n * diff 算法优化\n * 静态提升\n * 事件监听缓存\n * SSR 优化\n\ndiff 算法优化#\n\nvue3在diff算法中相比vue2增加了静态标记\n\n关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较\n\n下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高\n\n\n\n关于静态类型枚举如下\n\n\n\n静态提升#\n\nVue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用\n\n这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用\n\n\n\n没有做静态提升之前\n\n\n\n做了静态提升之后\n\n\n\n静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可\n\n同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff\n\n事件监听缓存#\n\n默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化\n\n\n\n没开启事件监听器缓存\n\n\n\n开启事件侦听器缓存后\n\n\n\n上述发现开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用\n\nSSR 优化#\n\n当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个 static\nnode，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染\n\n\n\n编译后\n\n\n\n\n二、源码体积#\n\n相比Vue2，Vue3整体体积变小了，除了移出一些不常用的 API，再重要的是Tree shanking\n\n任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小\n\n\n\n\n三、响应式系统#\n\nvue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式\n\nvue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历\n\n * 可以监听动态属性的添加\n * 可以监听到数组的索引和数组length属性\n * 可以监听删除属性\n\n关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍\n\n\n参考文献#\n\n * https://juejin.cn/post/6903171037211557895","routePath":"/interview/linux/performance","lang":"","toc":[{"text":"一、编译阶段","id":"一编译阶段","depth":2,"charIndex":628},{"text":"diff 算法优化","id":"diff-算法优化","depth":4,"charIndex":897},{"text":"静态提升","id":"静态提升","depth":4,"charIndex":1048},{"text":"事件监听缓存","id":"事件监听缓存","depth":4,"charIndex":1293},{"text":"SSR 优化","id":"ssr-优化","depth":4,"charIndex":1407},{"text":"二、源码体积","id":"二源码体积","depth":2,"charIndex":1525},{"text":"三、响应式系统","id":"三响应式系统","depth":2,"charIndex":1657},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1878}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语----","footer":"---","order":9,"star":9,"date":"2023-04-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语----","isOriginal":false,"head":[["meta",{"name":"keywords","content":"---"}]]},"version":""},{"id":197,"title":"说说你对输入输出重定向和管道的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\nlinux中有三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是 0、1、2：\n\n * STDIN 是标准输入，默认从键盘读取信息\n * STDOUT 是标准输出，默认将输出结果输出至终端\n * STDERR 是标准错误，默认将输出结果输出至终端\n\n对于任何linux命令的执行会有下面的过程：\n\n\n\n一条命令的执行需要键盘等的标准输入，命令的执行和正确或错误，其中的每一个双向箭头就是一个通道，所以数据流可以流入到文件端（重定向或管道）\n\n简单来讲，重定向就是把本来要显示在终端的命令结果，输送到别的地方，分成：\n\n * 输入重定向：流出到屏幕如果命令所需的输入不是来自键盘，而是来自指定的文件\n * 输出重定向：命令的输出可以不显示在屏幕，而是写在指定的文件中\n\n管道就是把两个命令连接起来使用，一个命令的输出作为另一个命令的输入\n\n两者的区别在于：\n\n * 管道触发两个子进程，执行 | 两边的程序；而重定向是在一个进程内执行。\n * 管道两边都是 shell 命令\n * 重定向符号的右边只能是 Linux 文件\n * 重定向符号的优先级大于管道\n\n\n二、命令#\n\n重定向常见的命令符号有：\n\n * > ： 输出重定向到一个文件或设备 覆盖原来的文件\n\n> 如果该文件不存在，则新建一个文件\n> \n> 如果该文件已经存在，会把文件内容覆盖\n> \n> 这些操纵不会征用用户的确认\n\n * >> ：输出重定向到一个文件或设备，但是是 追加原来的文件的末尾\n * < ：用于制定命令的输入\n * << ：从键盘的输入重定向为某个命令的输入\n\n> 以逐行输入的模式（回车键进行换行）\n> \n> 所有输入的行都将在输入结束字符串之后发送给命令\n\n * 2> 将一个标准错误输出重定向到一个文件或设备，会覆盖原来的文件\n * 2>> 将一个标准错误输出重定向到一个文件或设备，是追加到原来的文件\n * 2>&1：组合符号，将标准错误输出重定向到标准输出相同的地方\n\n> 1 就是代表标准输出\n\n * >& 将一个标准错误输出重定向到一个文件或设备覆盖原来的文件\n * |& 将一个标准错误管道输出到另一个命令作为输入\n\n\n三、应用场景#\n\n将当前目录的文件输出重定向到1.txt文件中，并且会清空原有的1.txt的内容\n\n\n\n或者以追加的形式，重定向输入到1.txt中\n\n\n\n将标准错误输出到某个文件，可以如下：\n\n\n\n通过组合符号将两者结合一起，无论进程输出的信息是正确还是错误的信息，都会重定向到指定的文件里\n\n\n\n再者通过管道查询文件内容是否包含想要的信息：\n\n\n\n上述cat test.txt会将test.txt的内容作为标准输出，然后利用管道，将其作为grep -n 'xxx'命令的标准输入。\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000020519335\n * https://murphypei.github.io/blog/2018/04/linux-redirect-pipe\n * https://www.huaweicloud.com/articles/0fb70e8c724ae79f4fc8d676cd6160d3.html","routePath":"/interview/linux/redirect_pipe","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、命令","id":"二命令","depth":2,"charIndex":506},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":935},{"text":"参考文献","id":"参考文献","depth":3,"charIndex":1179}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对输入输出重定向和管道的理解？应用场景？","footer":"说说你对输入输出重定向和管道的理解？应用场景？","order":6,"star":6,"date":"2023-04-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说你对输入输出重定向和管道的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对输入输出重定向和管道的理解？应用场景？"}]]},"version":""},{"id":198,"title":"说说你对 shell 的理解？常见的命令？","content":"#\n\n\n\n\n一、是什么#\n\nShell是一个由c语言编写的应用程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言\n\n它连接了用户和Linux内核，让用户能够更加高效、安全、低成本地使用 Linux 内核\n\n其本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、微信等其它软件没有什么区别，特殊的地方就是开机立马启动，并呈现在用户面前\n\n主要作用是接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等，同样能够调用和组织其他的应用程序，相当于一个领导者\n的身份，如下图：\n\n\n\n那么shell脚本就是多个 Shell 命令的组合并通过 if 条件分支控制或循环来组合运算，实现一些复杂功能，文件后缀名为.sh\n\n常用的 ls 命令，它本身也是一个 Shell 脚本，通过执行这个 Shell 脚本可以列举当前目录下的文件列表，如下创建一个hello.sh脚本\n\n\n\n * #!/bin/bash ：指定脚本要使用的 Shell 类型为 Bash\n\n * ls、echo： 脚本文件的内容，表明我们执行 hello.sh 脚本时会列举出当前目录的文件列表并且会向控制台打印 `hello world\n\n执行方式为.hello.zsh\n\n\n二、种类#\n\nLinux 的 Shell 种类众多，只要能给用户提供命令行环境的程序，常见的有：\n\n * Bourne Shell（sh），是目前所有 Shell 的祖先，被安装在几乎所有发源于 Unix 的操作系统上\n\n * Bourne Again shell（bash） ，是 sh 的一个进阶版本，比 sh 更优秀， bash 是目前大多数 Linux 发行版以及\n   macOS 操作系统的默认 Shell\n\n * C Shell（csh） ，它的语法类似 C 语言\n\n * TENEX C Shell（tcsh） ，它是 csh 的优化版本\n\n * Korn shell（ksh） ，一般在收费的 Unix 版本上比较多见\n\n * Z Shell（zsh） ，它是一种比较新近的 Shell ，集 bash 、 ksh 和 tcsh 各家之大成\n\n\n\n关于 Shell 的几个常见命令：\n\n * ls：查看文件\n * cd：切换工作目录\n * pwd：显示用户当前目录\n * mkdir：创建目录\n * cp：拷贝\n * rm：删除\n * mv：移动\n * du：显示目录所占用的磁盘空间\n\n\n三、命令#\n\nShell 并不是简单的堆砌命令，我们还可以在 Shell 中编程，这和使用 C++、C#、Java、Python 等常见的编程语言并没有什么两样。\n\nShell 虽然没有 C++、Java、Python 等强大，但也支持了基本的编程元素，例如：\n\n * if...else 选择结构，case...in 开关语句，for、while、until 循环；\n * 变量、数组、字符串、注释、加减乘除、逻辑运算等概念；\n * 函数，包括用户自定义的函数和内置函数（例如 printf、export、eval 等）\n\n下面以bash为例简单了解一下shell的基本使用\n\n\n变量#\n\nBash 没有数据类型的概念，所有的变量值都是字符串，可以保存一个数字、一个字符、一个字符串等等\n\n同时无需提前声明变量，给变量赋值会直接创建变量\n\n访问变量的语法形式为：${var} 和 $var 。\n\n变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。\n\n\n\n\n条件控制#\n\n跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在[[ ]]里的表达式\n\n跟其他语言一样，使用if...else进行表达，如果中括号里的表达式为真，那么then和fi之间的代码会被执行，如果则else和fi之间的代码会被执行\n\n\n\nfi标志着条件代码块的结束\n\n\n函数#\n\nbash 函数定义语法如下：\n\n\n\n * 函数定义时，function 关键字可有可无\n * 函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell\n   默认将以最后一条命令的运行结果，作为函数返回值\n * 函数返回值在调用该函数后通过 $? 来获得\n * 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可\n\n\n参考文献#\n\n * http://c.biancheng.net/view/706.html\n * https://juejin.cn/post/6930013333454061575","routePath":"/interview/linux/shell","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、种类","id":"二种类","depth":2,"charIndex":572},{"text":"三、命令","id":"三命令","depth":2,"charIndex":1076},{"text":"变量","id":"变量","depth":3,"charIndex":1367},{"text":"条件控制","id":"条件控制","depth":3,"charIndex":1529},{"text":"函数","id":"函数","depth":3,"charIndex":1692},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1933}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 shell 的理解？常见的命令？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 shell 的理解？常见的命令？","order":1,"star":1,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说你对 shell 的理解？常见的命令？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 shell 的理解？常见的命令？"}]]},"version":""},{"id":199,"title":"说说什么是进程？什么是线程？区别？","content":"#\n\n\n\n\n一、进程#\n\n操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位\n\n操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是CPU\n\n\n\n进程是一种抽象的概念，从来没有统一的标准定义看，一般由程序、数据集合和进程控制块三部分组成：\n\n * 程序用于描述进程要完成的功能，是控制进程执行的指令集\n * 数据集合是程序在执行时所需要的数据和工作区\n * 程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志\n\n\n二、线程#\n\n线程（thread）是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行\n\n一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步\n\n举个例子，假设你经营着一家物业管理公司。最初，业务量很小，事事都需要你亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡——这叫单线程，所有的工作都得顺序执\n行\n\n后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了——这叫多线程，你是主线程\n\n\n\n但实际上，并不是线程越多，进程的工作效率越高，这是因为在一个进程内，不管你创建了多少线程，它们总是被限定在一颗CPU内，或者多核CPU的一个核内\n\n这意味着，多线程在宏观上是并行的，在微观上则是分时切换串行的，多线程编程无法充分发挥多核计算资源的优势\n\n这导致使用多线程做任务并行处理时，线程数量超过一定数值后，线程越多速度反倒越慢的原因\n\n\n三、区别#\n\n * 本质区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位\n\n * 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程\n   都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小\n\n * 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过 CPU 调度，在每个时间片中只有一个线程执行）\n\n * 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU\n   外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源\n\n * 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也\n   被称为轻权进程或者轻量级进程\n\n举个例子：进程=火车，线程=车厢\n\n * 线程在进程下行进（单纯的车厢无法运行）\n * 一个进程可以包含多个线程（一辆火车可以有多个车厢）\n * 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）\n * 同一进程下不同线程间数据很易共享（A 车厢换到 B 车厢很容易）\n * 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）\n * 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/106283969\n * https://blog.csdn.net/ThinkWAon/article/details/102021274\n * https://www.zhihu.com/question/25532384","routePath":"/interview/linux/thread_process","lang":"","toc":[{"text":"一、进程","id":"一进程","depth":2,"charIndex":5},{"text":"二、线程","id":"二线程","depth":2,"charIndex":244},{"text":"三、区别","id":"三区别","depth":2,"charIndex":708},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1414}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说什么是进程？什么是线程？区别？","footer":"说说什么是进程？什么是线程？区别？","order":4,"star":4,"date":"2023-03-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语-说说什么是进程？什么是线程？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说什么是进程？什么是线程？区别？"}]]},"version":""},{"id":200,"title":"说说 linux 系统下 文本编辑常用的命令有哪些？","content":"--------------------------------------------------------------------------------\n\nicon: question description: 前端物语|面试物语-说说 linux 系统下 文本编辑常用的命令有哪些？ footer: 浙 ICP 备\n2021037683 号-2说说 linux 系统下 文本编辑常用的命令有哪些？ order: 1 star: 1 date: 2023-02-24\nauthor: h7ml image: https://www.h7ml.cn/logo.png banner:\nhttps://www.h7ml.cn/logo.png category:\n\n * interview\n * linux tag:\n * interview\n * linux shortTitle: 前端物语|面试物语-说说 linux 系统下 文本编辑常用的命令有哪些？ isOriginal: false\n   head:\n   * * meta\n   * name: keywords content: 说说 linux 系统下 文本编辑常用的命令有哪些？\n\n--------------------------------------------------------------------------------\n\n\n说说 linux 系统下 文本编辑常用的命令有哪些？#\n\n\n\n\n一、是什么#\n\nVim是从 vi 发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方\n\n而vim可以说是程序开发者的一项很好用的工具\n\n\n二、使用#\n\n基本上 vi/vim 共分为三种模式，分别是：\n\n * 命令模式（Command mode）\n * 输入模式（Insert mode）\n * 底线命令模式（Last line mode）\n\n\n\n\n命令模式#\n\nVim 的默认模式，在这个模式下，你不能输入文本，但是可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等\n\n移动光标#\n\n常用的命令如下：\n\n * h 向左移动一个字符\n * j 向下移动一个字符\n * k 向上移动一个字符\n * i 向右移动一个字符\n\n或者使用方向键进行控制\n\n如果想要向下移动n行，可通过使用 \"nj\" 或 \"n↓\" 的组合按键\n\n搜索#\n\n常见的命令如下：\n\n * /word：向光标之下寻找一个名称为 word 的字符\n\n * ?word：向光标之上寻找一个字符串名称为 word 的字符串\n\n * n：代表重复前一个搜寻的动作，即再次执行上一次的操作\n\n * N：反向进行前一个搜索动作\n\n删除、复制、粘贴#\n\n常用的命令如下：\n\n * x：向后删除一个字符\n * X：向前删除一个字符\n * nc：n 为数字，连续向后删除 n 个字符\n * dd：删除游标所在的那一整行\n * d0：删除游标所在处，到该行的最前面一个字符\n * d$删除游标所在处，到该行的最后一个字符\n * ndd：除光标所在的向下 n 行\n * yy：复制游标所在的那一行\n * y0：复制光标所在的那个字符到该行行首的所有数据\n * y$：复制光标所在的那个字符到该行行尾的所有数据\n * p：已复制的数据在光标下一行贴上\n * P：已复制的数据在光标上一行贴上\n * nc：重复删除 n 行数据\n\n\n输入模式#\n\n命令模式通过输入大小写i、a、o可以切换到输入模式，如下：\n\n * i：从目前光标所在处输入\n * I：在目前所在行的第一个非空格符处开始输入\n * a：从目前光标所在的下一个字符处开始输入\n * A：从光标所在行的最后一个字符处开始输入\n * o：在目前光标所在的下一行处输入新的一行\n * O：目前光标所在的上一行处输入新的一行\n\n输入模式我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容\n\n如果想从插入模式回到命令模式，使用按下键盘左上角的ESC键\n\n\n底线命令模式#\n\n这个模式下可以运行一些命令例如“退出”，“保存”，等动作，为了进入底线命令模式，首先要进入命令模式，再按下冒号键：\n\n常见的命令如下：\n\n * w：将编辑的数据写入硬盘档案中\n * w!：若文件属性为『只读』时，强制写入该档案\n * q：未修改，直接退出\n * q!：修改过但不存储\n * wq：储存后离开\n\n\n参考文献#\n\n * https://www.runoob.com/linux/linux-vim.html","routePath":"/interview/linux/vim","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":643},{"text":"二、使用","id":"二使用","depth":2,"charIndex":780},{"text":"命令模式","id":"命令模式","depth":3,"charIndex":885},{"text":"移动光标","id":"移动光标","depth":4,"charIndex":961},{"text":"搜索","id":"搜索","depth":4,"charIndex":1084},{"text":"删除、复制、粘贴","id":"删除复制粘贴","depth":4,"charIndex":1216},{"text":"输入模式","id":"输入模式","depth":3,"charIndex":1510},{"text":"底线命令模式","id":"底线命令模式","depth":3,"charIndex":1752},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1917}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语----","footer":"---","order":8,"star":8,"date":"2023-04-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","linux"],"tag":["interview","linux"],"shortTitle":"前端物语|面试物语----","isOriginal":false,"head":[["meta",{"name":"keywords","content":"---"}]]},"version":""},{"id":201,"title":"前端物语|面试物语-typescript","content":" * 说说你对 TypeScript 中类的理解？应用场景？\n * 说说 typescript 的数据类型有哪些？\n * 说说你对 TypeScript 装饰器的理解？应用场景？\n * 说说你对 TypeScript 中枚举类型的理解？应用场景？\n * 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？\n * 说说你对 TypeScript 中泛型的理解？应用场景？\n * 说说你对 TypeScript 中高级类型的理解？有哪些？\n * 说说你对 TypeScript 中接口的理解？应用场景？\n * 说说对 TypeScript 中命名空间与模块的理解？区别？\n * 说说如何在 React 项目中应用 TypeScript？\n * 说说你对 TypeScript 的理解？与 JavaScript 的区别？\n * 说说如何在 Vue 项目中应用 TypeScript？","routePath":"/interview/typescript/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"typescript","tag":"typescript","title":"前端物语|面试物语-typescript","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":202,"title":"说说你对 TypeScript 中类的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n类（Class）是面向对象程序设计（OOP，Object-Oriented Programming）实现信息封装的基础\n\n> 类是一种用户定义的引用数据类型，也称类类型\n\n传统的面向对象语言基本都是基于类的，JavaScript 基于原型的方式让开发者多了很多理解成本\n\n在 ES6 之后，JavaScript 拥有了 class 关键字，虽然本质依然是构造函数，但是使用起来已经方便了许多\n\n但是JavaScript 的class依然有一些特性还没有加入，比如修饰符和抽象类\n\nTypeScript 的 class 支持面向对象的所有特性，比如 类、接口等\n\n\n二、使用方式#\n\n定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：\n\n * 字段 ： 字段是类里面声明的变量。字段表示对象的有关数据。\n * 构造函数： 类实例化时调用，可以为类的对象分配内存。\n * 方法： 方法为对象要执行的操作\n\n如下例子：\n\n\n\n\n继承#\n\n类的继承使用过extends的关键字\n\n\n\nDog是一个 派生类，它派生自 Animal 基类，派生类通常被称作子类，基类通常被称作 超类\n\nDog类继承了Animal类，因此实例dog也能够使用Animal类move方法\n\n同样，类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写，通过super关键字是对父类的直接引用，该关键字可以引用父类的属性和方法，如下：\n\n\n\n\n修饰符#\n\n可以看到，上述的形式跟ES6十分的相似，typescript在此基础上添加了三种修饰符：\n\n * 公共 public：可以自由的访问类程序里定义的成员\n * 私有 private：只能够在该类的内部进行访问\n * 受保护 protect：除了在该类的内部可以访问，还可以在子类中仍然可以访问\n\n\n私有修饰符#\n\n只能够在该类的内部进行访问，实例对象并不能够访问\n\n\n\n并且继承该类的子类并不能访问，如下图所示：\n\n\n\n\n受保护修饰符#\n\n跟私有修饰符很相似，实例对象同样不能访问受保护的属性，如下：\n\n\n\n有一点不同的是 protected 成员在子类中仍然可以访问\n\n\n\n除了上述修饰符之外，还有只读修饰符\n\n只读修饰符#\n\n通过readonly关键字进行声明，只读属性必须在声明时或构造函数里被初始化，如下：\n\n\n\n除了实例属性之外，同样存在静态属性\n\n\n静态属性#\n\n这些属性存在于类本身上面而不是类的实例上，通过static进行定义，访问这些属性需要通过 类型.静态属性 的这种形式访问，如下所示：\n\n\n\n上述的类都能发现一个特点就是，都能够被实例化，在 typescript中，还存在一种抽象类\n\n\n抽象类#\n\n抽象类做为其它派生类的基类使用，它们一般不会直接被实例化，不同于接口，抽象类可以包含成员的实现细节\n\nabstract关键字是用于定义抽象类和在抽象类内部定义抽象方法，如下所示：\n\n\n\n这种类并不能被实例化，通常需要我们创建子类去继承，如下：\n\n\n\n\n三、应用场景#\n\n除了日常借助类的特性完成日常业务代码，还可以将类（class）也可以作为接口，尤其在 React 工程中是很常用的，如下：\n\n\n\n由于组件需要传入 props 的类型 Props ，同时有需要设置默认 props 即 defaultProps，这时候更加适合使用class作为接口\n\n先声明一个类，这个类包含组件 props 所需的类型和初始值：\n\n\n\n当我们需要传入 props 类型的时候直接将 Props 作为接口传入，此时 Props\n的作用就是接口，而当需要我们设置defaultProps初始值的时候，我们只需要:\n\n\n\nProps 的实例就是 defaultProps 的初始值，这就是 class作为接口的实际应用，我们用一个 class\n起到了接口和设置初始值两个作用，方便统一管理，减少了代码量\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/classes.html\n * https://www.runoob.com/typescript/ts-class.html","routePath":"/interview/typescript/class","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":295},{"text":"继承","id":"继承","depth":3,"charIndex":441},{"text":"修饰符","id":"修饰符","depth":3,"charIndex":640},{"text":"私有修饰符","id":"私有修饰符","depth":3,"charIndex":794},{"text":"受保护修饰符","id":"受保护修饰符","depth":3,"charIndex":856},{"text":"只读修饰符","id":"只读修饰符","depth":4,"charIndex":952},{"text":"静态属性","id":"静态属性","depth":3,"charIndex":1026},{"text":"抽象类","id":"抽象类","depth":3,"charIndex":1151},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1283},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1652}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中类的理解？应用场景？","footer":"说说你对 TypeScript 中类的理解？应用场景？","order":10,"star":10,"date":"2023-03-30T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中类的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中类的理解？应用场景？"}]]},"version":""},{"id":203,"title":"说说 typescript 的数据类型有哪些？","content":"#\n\n\n\n\n一、是什么#\n\ntypescript 和 javascript几乎一样，拥有相同的数据类型，另外在javascript基础上提供了更加实用的类型供开发使用\n\n在开发阶段，可以为明确的变量定义为某种类型，这样typescript就能在编译阶段进行类型检查，当类型不合符预期结果的时候则会出现错误提示\n\n\n二、有哪些#\n\ntypescript 的数据类型主要有如下：\n\n * boolean（布尔类型）\n * number（数字类型）\n * string（字符串类型）\n * array（数组类型）\n * tuple（元组类型）\n * enum（枚举类型）\n * any（任意类型）\n * null 和 undefined 类型\n * void 类型\n * never 类型\n * object 对象类型\n\n\nboolean#\n\n布尔类型\n\n\n\n\nnumber#\n\n数字类型，和javascript一样，typescript的数值类型都是浮点数，可支持二进制、八进制、十进制和十六进制\n\n\n\n进制表示：\n\n\n\n\nstring#\n\n字符串类型，和JavaScript一样，可以使用双引号（\"）或单引号（'）表示字符串\n\n\n\n作为超集，当然也可以使用模版字符串``进行包裹，通过 ${} 嵌入变量\n\n\n\n\narray#\n\n数组类型，跟javascript一致，通过[]进行包裹，有两种写法：\n\n方式一：元素类型后面接上 []\n\n\n\n方式二：使用数组泛型，Array<元素类型>：\n\n\n\n\ntuple#\n\n元祖类型，允许表示一个已知元素数量和类型的数组，各元素的类型不必相同\n\n\n\n赋值的类型、位置、个数需要和定义（生明）的类型、位置、个数一致\n\n\nenum#\n\nenum类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字\n\n\n\n\nany#\n\n可以指定任何类型的值，在编程阶段还不清楚类型的变量指定一个类型，不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，这时候可以使用any类型\n\n使用any类型允许被赋值为任意类型，甚至可以调用其属性、方法\n\n\n\n定义存储各种类型数据的数组时，示例代码如下：\n\n\n\n\nnull 和 和 undefined#\n\n在JavaScript 中 null表示 \"什么都没有\"，是一个只有一个值的特殊类型，表示一个空对象引用，而undefined表示一个没有设置值的变量\n\n默认情况下null和undefined是所有类型的子类型， 就是说你可以把 null和 undefined赋值给 number类型的变量\n\n\n\n但是ts配置了--strictNullChecks标记，null和undefined只能赋值给void和它们各自\n\n\nvoid#\n\n用于标识方法返回值的类型，表示该方法没有返回值。\n\n\n\n\nnever#\n\nnever是其他类型 （包括null和 undefined）的子类型，可以赋值给任何类型，代表从不会出现的值\n\n但是没有类型是 never 的子类型，这意味着声明 never 的变量只能被 never 类型所赋值。\n\nnever 类型一般用来指定那些总是会抛出异常、无限循环\n\n\n\n\nobject#\n\n对象类型，非原始类型，常见的形式通过{}进行包裹\n\n\n\n\n三、总结#\n\n和javascript基本一致，也分成：\n\n * 基本类型\n * 引用类型\n\n在基础类型上，typescript增添了void、any、emum等原始类型\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/basic-types.html","routePath":"/interview/typescript/data_type","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":156},{"text":"boolean","id":"boolean","depth":3,"charIndex":358},{"text":"number","id":"number","depth":3,"charIndex":377},{"text":"string","id":"string","depth":3,"charIndex":459},{"text":"array","id":"array","depth":3,"charIndex":554},{"text":"tuple","id":"tuple","depth":3,"charIndex":645},{"text":"enum","id":"enum","depth":3,"charIndex":725},{"text":"any","id":"any","depth":3,"charIndex":789},{"text":"null 和 和 undefined","id":"null-和-和-undefined","depth":3,"charIndex":935},{"text":"void","id":"void","depth":3,"charIndex":1164},{"text":"never","id":"never","depth":3,"charIndex":1200},{"text":"object","id":"object","depth":3,"charIndex":1350},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1388},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1475}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 typescript 的数据类型有哪些？","footer":"说说 typescript 的数据类型有哪些？","order":7,"star":7,"date":"2023-03-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说 typescript 的数据类型有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 typescript 的数据类型有哪些？"}]]},"version":""},{"id":204,"title":"说说你对 TypeScript 装饰器的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上\n\n是一种在不改变原类和使用继承的情况下，动态地扩展对象功能\n\n同样的，本质也不是什么高大上的结构，就是一个普通的函数，@expression 的形式其实是Object.defineProperty的语法糖\n\nexpression求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入\n\n\n二、使用方式#\n\n由于typescript是一个实验性特性，若要使用，需要在tsconfig.json文件启动，如下：\n\n\n\ntypescript装饰器的使用和javascript基本一致\n\n类的装饰器可以装饰：\n\n * 类\n\n * 方法/属性\n\n * 参数\n\n * 访问器\n\n\n类装饰#\n\n例如声明一个函数 addAge 去给 Class 的属性 age 添加年龄.\n\n\n\n上述代码，实际等同于以下形式：\n\n\n\n上述可以看到，当装饰器作为修饰类的时候，会把构造器传递进去。 constructor.prototype.age 就是在每一个实例化对象上面添加一个 age\n属性\n\n\n方法/属性装饰#\n\n同样，装饰器可以用于修饰类的方法，这时候装饰器函数接收的参数变成了：\n\n * target：对象的原型\n * propertyKey：方法的名称\n * descriptor：方法的属性描述符\n\n可以看到，这三个属性实际就是Object.defineProperty的三个参数，如果是类的属性，则没有传递第三个参数\n\n如下例子：\n\n\n\n输出如下图所示：\n\n\n\n\n参数装饰#\n\n接收 3 个参数，分别是：\n\n * target ：当前对象的原型\n * propertyKey ：参数的名称\n * index：参数数组中的位置\n\n\n\n输入如下图：\n\n\n\n\n访问器装饰#\n\n使用起来方式与方法装饰一致，如下：\n\n\n\n\n装饰器工厂#\n\n如果想要传递参数，使装饰器变成类似工厂函数，只需要在装饰器函数内部再函数一个函数即可，如下：\n\n\n\n\n执行顺序#\n\n当多个装饰器应用于一个声明上，将由上至下依次对装饰器表达式求值，求值的结果会被当作函数，由下至上依次调用，例如如下：\n\n\n\n\n三、应用场景#\n\n可以看到，使用装饰器存在两个显著的优点：\n\n * 代码可读性变强了，装饰器命名相当于一个注释\n * 在不改变原有代码情况下，对原来功能进行扩展\n\n后面的使用场景中，借助装饰器的特性，除了提高可读性之后，针对已经存在的类，可以通过装饰器的特性，在不改变原有代码情况下，对原来功能进行扩展\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/decorators.html\n * https://juejin.cn/post/6844903876605280269#heading-5","routePath":"/interview/typescript/decorator","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":206},{"text":"类装饰","id":"类装饰","depth":3,"charIndex":346},{"text":"方法/属性装饰","id":"方法属性装饰","depth":3,"charIndex":497},{"text":"参数装饰","id":"参数装饰","depth":3,"charIndex":687},{"text":"访问器装饰","id":"访问器装饰","depth":3,"charIndex":782},{"text":"装饰器工厂","id":"装饰器工厂","depth":3,"charIndex":812},{"text":"执行顺序","id":"执行顺序","depth":3,"charIndex":871},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":941},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1095}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 装饰器的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 TypeScript 装饰器的理解？应用场景？","order":3,"star":3,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 装饰器的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 装饰器的理解？应用场景？"}]]},"version":""},{"id":205,"title":"说说你对 TypeScript 中枚举类型的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型\n\n通俗来说，枚举就是一个对象的所有可能取值的集合\n\n在日常生活中也很常见，例如表示星期的 SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY\n就可以看成是一个枚举\n\n枚举的说明与结构和联合相似，其形式为：\n\n\n\n\n二、使用#\n\n枚举的使用是通过enum关键字进行定义，形式如下：\n\n\n\n声明关键字为枚举类型的方式如下：\n\n\n\n类型可以分成：\n\n * 数字枚举\n\n * 字符串枚举\n\n * 异构枚举\n\n\n数字枚举#\n\n当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且默认从 0 开始依次累加:\n\n\n\n如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加 1：\n\n\n\n\n字符串枚举#\n\n\n\n如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：\n\n\n\n\n异构枚举#\n\n即将数字枚举和字符串枚举结合起来混合起来使用，如下：\n\n\n\n通常情况下我们很少会使用异构枚举\n\n\n本质#\n\n现在一个枚举的案例如下：\n\n\n\n通过编译后，javascript如下：\n\n\n\n上述代码可以看到， Direction[Direction[\"Up\"] = 0] = \"Up\"可以分成\n\n * Direction[\"Up\"] = 0\n * Direction[0] = \"Up\"\n\n所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：\n\n\n\n并且多处定义的枚举是可以进行合并操作，如下：\n\n\n\n编译后，js代码如下：\n\n\n\n可以看到，Direction对象属性回叠加\n\n\n三、应用场景#\n\n就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：\n\n\n\n包括后端日常返回 0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护\n\n\n参考文献#\n\n * https://zh.wikipedia.org/wiki/%E6%9E%9A%E4%B8%BE\n * https://www.jianshu.com/p/b9e1caa4dd98\n * https://juejin.cn/post/6844904112669065224#heading-30","routePath":"/interview/typescript/enum","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用","id":"二使用","depth":2,"charIndex":207},{"text":"数字枚举","id":"数字枚举","depth":3,"charIndex":301},{"text":"字符串枚举","id":"字符串枚举","depth":3,"charIndex":406},{"text":"异构枚举","id":"异构枚举","depth":3,"charIndex":456},{"text":"本质","id":"本质","depth":3,"charIndex":512},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":753},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":878}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中枚举类型的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 TypeScript 中枚举类型的理解？应用场景？","order":3,"star":3,"date":"2023-02-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中枚举类型的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中枚举类型的理解？应用场景？"}]]},"version":""},{"id":206,"title":"说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？","content":"#\n\n\n\n\n一、是什么#\n\n函数是JavaScript 应用程序的基础，帮助我们实现抽象层、模拟类、信息隐藏和模块\n\n在TypeScript 里，虽然已经支持类、命名空间和模块，但函数仍然是主要定义行为的方式，TypeScript 为 JavaScript\n函数添加了额外的功能，丰富了更多的应用场景\n\n函数类型在 TypeScript 类型系统中扮演着非常重要的角色，它们是可组合系统的核心构建块\n\n\n二、使用方式#\n\n跟javascript 定义函数十分相似，可以通过funciton 关键字、箭头函数等形式去定义，例如下面一个简单的加法函数：\n\n\n\n上述只定义了函数的两个参数类型，这个时候整个函数虽然没有被显式定义，但是实际上TypeScript 编译器是能够通过类型推断到这个函数的类型，如下图所示：\n\n\n\n当鼠标放置在第三行add函数名的时候，会出现完整的函数定义类型，通过: 的形式来定于参数类型，通过 => 连接参数和返回值类型\n\n当我们没有提供函数实现的情况下，有两种声明函数类型的方式，如下所示：\n\n\n\n当存在函数重载时，只能使用方式一的形式\n\n\n可选参数#\n\n当函数的参数可能是不存在的，只需要在参数后面加上 ? 代表参数可能不存在，如下：\n\n\n\n这时候参数b可以是number类型或者undefined类型，即可以传一个number类型或者不传都可以\n\n\n剩余类型#\n\n剩余参数与JavaScript的语法类似，需要用 ... 来表示剩余参数\n\n如果剩余参数 rest 是一个由number类型组成的数组，则如下表示：\n\n\n\n\n函数重载#\n\n允许创建数项名称相同但输入输出类型或个数不同的子程序，它可以简单地称为一个单独功能可以执行多项任务的能力\n\n关于typescript函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 |操作符或者?操作符，把所有可能的输入类型全部包含进去，用于具体实现\n\n这里的函数重载也只是多个函数的声明，具体的逻辑还需要自己去写，typescript并不会真的将你的多个重名 function的函数体进行合并\n\n例如我们有一个 add 函数，它可以接收 string类型的参数进行拼接，也可以接收 number 类型的参数进行相加，如下：\n\n\n\n\n三、区别#\n\n从上面可以看到：\n\n * 从定义的方式而言，typescript 声明函数需要定义参数类型或者声明返回值类型\n * typescript 在参数中，添加可选参数供使用者选择\n * typescript 增添函数重载功能，使用者只需要通过查看函数声明的方式，即可知道函数传递的参数个数以及类型\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/functions.html\n * https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD\n * https://jkchao.github.io/typescript-book-chinese/typings/functions.html#%E9%8\n   7%8D%E8%BD%BD","routePath":"/interview/typescript/function","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":201},{"text":"可选参数","id":"可选参数","depth":3,"charIndex":483},{"text":"剩余类型","id":"剩余类型","depth":3,"charIndex":589},{"text":"函数重载","id":"函数重载","depth":3,"charIndex":675},{"text":"三、区别","id":"三区别","depth":2,"charIndex":956},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1111}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？"}]]},"version":""},{"id":207,"title":"说说你对 TypeScript 中泛型的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n泛型程序设计（generic programming）是程序设计语言的一种风格或范式\n\n泛型允许我们在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型在typescript中，定义函数，接口或者类的时候，不预先\n定义好具体的类型，而在使用的时候在指定类型的一种特性\n\n假设我们用一个函数，它可接受一个 number 参数并返回一个number 参数，如下写法：\n\n\n\n如果我们打算接受一个 string 类型，然后再返回 string类型，则如下写法：\n\n\n\n上述两种编写方式，存在一个最明显的问题在于，代码重复度比较高\n\n虽然可以使用 any类型去替代，但这也并不是很好的方案，因为我们的目的是接收什么类型的参数返回什么类型的参数，即在运行时传入参数我们才能确定类型\n\n这种情况就可以使用泛型，如下所示：\n\n\n\n可以看到，泛型给予开发者创造灵活、可重用代码的能力\n\n\n二、使用方式#\n\n泛型通过<>的形式进行表述，可以声明：\n\n * 函数\n\n * 接口\n\n * 类\n\n\n函数声明#\n\n声明函数的形式如下：\n\n\n\n定义泛型的时候，可以一次定义多个类型参数，比如我们可以同时定义泛型 T 和 泛型 U：\n\n\n\n\n接口声明#\n\n声明接口的形式如下：\n\n\n\n那么当我们想传入一个 number 作为参数的时候，就可以这样声明函数:\n\n\n\n\n#\n\n\n类声明#\n\n使用泛型声明类的时候，既可以作用于类本身，也可以作用与类的成员函数\n\n下面简单实现一个元素同类型的栈结构，如下所示：\n\n\n\n使用方式如下：\n\n\n\n如果上述只能传递 string 和 number 类型，这时候就可以使用 的方式猜实现约束泛型，如下所示：\n\n\n\n除了上述的形式，泛型更高级的使用如下：\n\n例如要设计一个函数，这个函数接受两个参数，一个参数为对象，另一个参数为对象上的属性，我们通过这两个参数返回这个属性的值\n\n这时候就设计到泛型的索引类型和约束类型共同实现\n\n\n索引类型、约束类型#\n\n索引类型 keyof T 把传入的对象的属性类型取出生成一个联合类型，这里的泛型 U 被约束在这个联合类型中，如下所示：\n\n\n\n上述为什么需要使用泛型约束，而不是直接定义第一个参数为 object类型，是因为默认情况 object\n指的是{}，而我们接收的对象是各种各样的，一个泛型来表示传入的对象类型，比如 T extends object\n\n使用如下图所示：\n\n\n\n\n多类型约束#\n\n例如如下需要实现两个接口的类型约束：\n\n\n\n可以创建一个接口继承上述两个接口，如下：\n\n\n\n正确使用如下：\n\n\n\n通过泛型约束就可以达到多类型约束的目的\n\n\n三、应用场景#\n\n通过上面初步的了解，后述在编写 typescript\n的时候，定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性的时候，这种情况下就可以使用泛型\n\n灵活的使用泛型定义类型，是掌握typescript 必经之路\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/generics.html","routePath":"/interview/typescript/generic","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":417},{"text":"函数声明","id":"函数声明","depth":3,"charIndex":468},{"text":"接口声明","id":"接口声明","depth":3,"charIndex":537},{"text":"","id":"","depth":3,"charIndex":599},{"text":"类声明","id":"类声明","depth":3,"charIndex":603},{"text":"索引类型、约束类型","id":"索引类型约束类型","depth":3,"charIndex":847},{"text":"多类型约束","id":"多类型约束","depth":3,"charIndex":1045},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1132},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1266}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中泛型的理解？应用场景？","footer":"说说你对 TypeScript 中泛型的理解？应用场景？","order":8,"star":8,"date":"2023-03-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中泛型的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中泛型的理解？应用场景？"}]]},"version":""},{"id":208,"title":"说说你对 TypeScript 中高级类型的理解？有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n除了string、number、boolean 这种基础类型外，在 typescript 类型声明中还存在一些高级的类型应用\n\n这些高级类型，是typescript为了保证语言的灵活性，所使用的一些语言特性。这些特性有助于我们应对复杂多变的开发场景\n\n\n二、有哪些#\n\n常见的高级类型有如下：\n\n * 交叉类型\n * 联合类型\n * 类型别名\n * 类型索引\n * 类型约束\n * 映射类型\n * 条件类型\n\n\n交叉类型#\n\n通过 & 将多个类型合并为一个类型，包含了所需的所有类型的特性，本质上是一种并的操作\n\n语法如下：\n\n\n\n适用于对象合并场景，如下将声明一个函数，将两个对象合并成一个对象并返回：\n\n\n\n\n联合类型#\n\n联合类型的语法规则和逻辑 “或” 的符号一致，表示其类型为连接的多个类型中的任意一个，本质上是一个交的关系\n\n语法如下：\n\n\n\n例如 number | string | boolean 的类型只能是这三个的一种，不能共存\n\n如下所示：\n\n\n\n\n类型别名#\n\n类型别名会给一个类型起个新名字，类型别名有时和接口很像，但是可以作用于原始值、联合类型、元组以及其它任何你需要手写的类型\n\n可以使用 type SomeName = someValidTypeAnnotation的语法来创建类型别名：\n\n\n\n此外类型别名可以是泛型:\n\n\n\n也可以使用类型别名来在属性里引用自己：\n\n\n\n可以看到，类型别名和接口使用十分相似，都可以描述一个对象或者函数\n\n两者最大的区别在于，interface只能用于定义对象类型，而 type\n的声明方式除了对象之外还可以定义交叉、联合、原始类型等，类型声明的方式适用范围显然更加广泛\n\n\n类型索引#\n\nkeyof 类似于 Object.keys ，用于获取一个接口中 Key 的联合类型。\n\n\n\n\n类型约束#\n\n通过关键字 extend 进行约束，不同于在 class 后使用 extends 的继承作用，泛型内使用的主要作用是对泛型加以约束\n\n\n\n类型约束通常和类型索引一起使用，例如我们有一个方法专门用来获取对象的值，但是这个对象并不确定，我们就可以使用 extends 和 keyof 进行约束。\n\n\n\n\n映射类型#\n\n通过 in 关键字做类型的映射，遍历已有接口的 key 或者是遍历联合类型，如下例子：\n\n\n\n上述的结构，可以分成这些步骤：\n\n * keyof T：通过类型索引 keyof 的得到联合类型 'a' | 'b'\n * P in keyof T 等同于 p in 'a' | 'b'，相当于执行了一次 forEach 的逻辑，遍历 'a' | 'b'\n\n所以最终ReadOnlyObj的接口为下述：\n\n\n\n\n条件类型#\n\n条件类型的语法规则和三元表达式一致，经常用于一些类型不确定的情况。\n\n\n\n上面的意思就是，如果 T 是 U 的子集，就是类型 X，否则为类型 Y\n\n\n三、总结#\n\n可以看到，如果只是掌握了 typeScript 的一些基础类型，可能很难游刃有余的去使用 typeScript，需要了解一些typescript的高阶用法\n\n并且typescript在版本的迭代中新增了很多功能，需要不断学习与掌握\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/advanced-types.html\n * https://juejin.cn/post/6844904003604578312\n * https://zhuanlan.zhihu.com/p/103846208","routePath":"/interview/typescript/high_type","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、有哪些","id":"二有哪些","depth":2,"charIndex":140},{"text":"交叉类型","id":"交叉类型","depth":3,"charIndex":219},{"text":"联合类型","id":"联合类型","depth":3,"charIndex":320},{"text":"类型别名","id":"类型别名","depth":3,"charIndex":449},{"text":"类型索引","id":"类型索引","depth":3,"charIndex":735},{"text":"类型约束","id":"类型约束","depth":3,"charIndex":790},{"text":"映射类型","id":"映射类型","depth":3,"charIndex":947},{"text":"条件类型","id":"条件类型","depth":3,"charIndex":1157},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1239},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1364}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中高级类型的理解？有哪些？","footer":"说说你对 TypeScript 中高级类型的理解？有哪些？","order":6,"star":6,"date":"2023-03-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中高级类型的理解？有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中高级类型的理解？有哪些？"}]]},"version":""},{"id":209,"title":"前端物语|面试物语-typescript","content":" * 说说你对 TypeScript 中类的理解？应用场景？\n * 说说 typescript 的数据类型有哪些？\n * 说说你对 TypeScript 装饰器的理解？应用场景？\n * 说说你对 TypeScript 中枚举类型的理解？应用场景？\n * 说说你对 TypeScript 中函数的理解？与 JavaScript 函数的区别？\n * 说说你对 TypeScript 中泛型的理解？应用场景？\n * 说说你对 TypeScript 中高级类型的理解？有哪些？\n * 说说你对 TypeScript 中接口的理解？应用场景？\n * 说说对 TypeScript 中命名空间与模块的理解？区别？\n * 说说如何在 React 项目中应用 TypeScript？\n * 说说你对 TypeScript 的理解？与 JavaScript 的区别？\n * 说说如何在 Vue 项目中应用 TypeScript？","routePath":"/interview/typescript/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"typescript","tag":"typescript","title":"前端物语|面试物语-typescript","index":false,"dir":{"order":1},"date":"2023-04-07T00:00:00.000Z"},"version":""},{"id":210,"title":"说说你对 TypeScript 中接口的理解？应用场景？","content":"#\n\n\n\n\n一、是什么#\n\n接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法\n\n简单来讲，一个接口所描述的是一个对象相关的属性和方法，但并不提供具体创建此对象实例的方法\n\ntypescript的核心功能之一就是对类型做检测，虽然这种检测方式是“鸭式辨型法”，而接口的作用就是为为这些类型命名和为你的代码或第三方代码定义一个约定\n\n\n二、使用方式#\n\n接口定义如下：\n\n\n\n例如有一个函数，这个函数接受一个 User 对象，然后返回这个 User 对象的 name 属性:\n\n\n\n可以看到，参数需要有一个user的name属性，可以通过接口描述user参数的结构\n\n\n\n这些属性并不一定全部实现，上述传入的对象必须拥有name和age属性，否则typescript在编译阶段会报错，如下图：\n\n\n\n如果不想要age属性的话，这时候可以采用可选属性，如下表示：\n\n\n\n这时候age属性则可以是number类型或者undefined类型\n\n有些时候，我们想要一个属性变成只读属性，在typescript只需要使用readonly声明，如下：\n\n\n\n当我们修改属性的时候，就会出现警告，如下所示：\n\n\n\n这是属性中有一个函数，可以如下表示：\n\n\n\n如果传递的对象不仅仅是上述的属性，这时候可以使用：\n\n * 类型推断\n\n\n\n * 给接口添加字符串索引签名\n\n\n\n接口还能实现继承，如下图：\n\n\n\n也可以继承多个，父类通过逗号隔开，如下：\n\n\n\n\n三、应用场景#\n\n例如在javascript中定义一个函数，用来获取用户的姓名和年龄：\n\n\n\n如果多人开发的都需要用到这个函数的时候，如果没有注释，则可能出现各种运行时的错误，这时候就可以使用接口定义参数变量：\n\n\n\n包括后面讲到类的时候也会应用到接口\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/interfaces.html","routePath":"/interview/typescript/interface","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":220},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":673},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":802}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 中接口的理解？应用场景？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说你对 TypeScript 中接口的理解？应用场景？","order":4,"star":4,"date":"2023-03-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 中接口的理解？应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 中接口的理解？应用场景？"}]]},"version":""},{"id":211,"title":"说说对 TypeScript 中命名空间与模块的理解？区别？","content":"#\n\n\n\n\n一、模块#\n\nTypeScript 与ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块\n\n相反地，如果一个文件不带有顶级的import或者export声明，那么它的内容被视为全局可见的\n\n例如我们在在一个 TypeScript 工程下建立一个文件 1.ts，声明一个变量a，如下：\n\n\n\n然后在另一个文件同样声明一个变量a，这时候会出现错误信息\n\n\n\n提示重复声明a变量，但是所处的空间是全局的\n\n如果需要解决这个问题，则通过import或者export引入模块系统即可，如下：\n\n\n\n在typescript中，export关键字可以导出变量或者类型，用法与es6模块一致，如下：\n\n\n\n通过import 引入模块，如下：\n\n\n\n\n二、命名空间#\n\n命名空间一个最明确的目的就是解决重名问题\n\n命名空间定义了标识符的可见范围，一个标识符可在多个名字空间中定义，它在不同名字空间中的含义是互不相干的\n\n这样，在一个新的名字空间中可定义任何标识符，它们不会与任何已有的标识符发生冲突，因为已有的定义都处于其他名字空间中\n\nTypeScript 中命名空间使用 namespace 来定义，语法格式如下：\n\n\n\n以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加\nexport 关键字\n\n使用方式如下：\n\n\n\n命名空间本质上是一个对象，作用是将一系列相关的全局变量组织到一个对象的属性，如下：\n\n\n\n编译成js如下：\n\n\n\n\n三、区别#\n\n * 命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript\n   对象，使用起来十分容易。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型的应用中\n\n * 像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖\n\n * 在正常的 TS 项目开发过程中并不建议用命名空间，但通常在通过 d.ts 文件标记 js\n   库类型的时候使用命名空间，主要作用是给编译器编写代码的时候参考使用\n\n\n参考文献#\n\n * https://www.tslang.cn/docs/handbook/modules.html\n * https://www.tslang.cn/docs/handbook/namespaces.html\n * https://www.tslang.cn/docs/handbook/namespaces-and-modules.html","routePath":"/interview/typescript/namespace_module","lang":"","toc":[{"text":"一、模块","id":"一模块","depth":2,"charIndex":5},{"text":"二、命名空间","id":"二命名空间","depth":2,"charIndex":351},{"text":"三、区别","id":"三区别","depth":2,"charIndex":699},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":933}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说对 TypeScript 中命名空间与模块的理解？区别？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说对 TypeScript 中命名空间与模块的理解？区别？","order":5,"star":5,"date":"2023-03-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说对 TypeScript 中命名空间与模块的理解？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说对 TypeScript 中命名空间与模块的理解？区别？"}]]},"version":""},{"id":212,"title":"说说如何在 React 项目中应用 TypeScript？","content":"#\n\n\n\n\n一、前言#\n\n单独的使用 TypeScript 并不会导致学习成本很高，但是绝大部分前端开发者的项目都是依赖于框架的\n\n例如与 Vue、React 这些框架结合使用的时候，会有一定的门槛\n\n使用 TypeScript 编写 React 代码，除了需要 TypeScript 这个库之外，还需要安装\n@types/react、@types/react-dom\n\n\n\n至于上述使用 @types 的库的原因在于，目前非常多的 JavaScript 库并没有提供自己关于 TypeScript 的声明文件\n\n所以，ts 并不知道这些库的类型以及对应导出的内容，这里 @types 实际就是社区中的 DefinitelyTyped 库，定义了目前市面上绝大多数的\nJavaScript 库的声明\n\n所以下载相关的 JavaScript 对应的 @types 声明时，就能够使用使用该库对应的类型定义\n\n\n二、使用方式#\n\n在编写 React 项目的时候，最常见的使用的组件就是：\n\n * 无状态组件\n * 有状态组件\n * 受控组件\n\n\n无状态组件#\n\n主要作用是用于展示 UI，如果使用 js 声明，则如下所示：\n\n\n\n但这时候 ts 会出现报错提示，原因在于没有定义 porps 类型，这时候就可以使用 interface 接口去定义 porps 即可，如下：\n\n\n\n但是我们都知道 props 里面存在 children 属性，我们不可能每个 porps 接口里面定义多一个 children，如下：\n\n\n\n更加规范的写法是使用 React 里面定义好的 FC 属性，里面已经定义好 children 类型，如下：\n\n\n\n * React.FC 显式地定义了返回类型，其他方式是隐式推导的\n\n * React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全\n\n * React.FC 为 children 提供了隐式的类型（ReactElement | null）\n\n\n有状态组件#\n\n可以是一个类组件且存在 props 和 state 属性\n\n如果使用 TypeScript 声明则如下所示：\n\n\n\n上述通过泛型对 props、state 进行类型定义，然后在使用的时候就可以在编译器中获取更好的智能提示\n\n关于 Component 泛型类的定义，可以参考下 React 的类型定义文件\nnode_modules/@types/React/index.d.ts，如下所示：\n\n\n\n从上述可以看到，state 属性也定义了可读类型，目的是为了防止直接调用 this.state 更新状态\n\n\n受控组件#\n\n受控组件的特性在于元素的内容通过组件的状态 state 进行控制\n\n由于组件内部的事件是合成事件，不等同于原生事件，\n\n例如一个 input 组件修改内部的状态，常见的定义的时候如下所示：\n\n\n\n常用 Event 事件对象类型：\n\n * ClipboardEvent 剪贴板事件对象\n * DragEvent 拖拽事件对象\n * ChangeEvent Change 事件对象\n * KeyboardEvent 键盘事件对象\n * MouseEvent 鼠标事件对象\n * TouchEvent 触摸事件对象\n * WheelEvent 滚轮事件对象\n * AnimationEvent 动画事件对象\n * TransitionEvent 过渡事件对象\n\nT 接收一个 DOM 元素类型\n\n\n三、总结#\n\n上述只是简单的在 React 项目使用 TypeScript，但在编写 React 项目的时候，还存在 hooks、默认参数、以及 store 等等......\n\nTypeScript 在框架中使用的学习成本相对会更高，需要不断编写才能熟练\n\n\n参考文献#\n\n * https://juejin.cn/post/6952696734078369828\n * https://juejin.cn/post/6844903684422254606","routePath":"/interview/typescript/react","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、使用方式","id":"二使用方式","depth":2,"charIndex":403},{"text":"无状态组件","id":"无状态组件","depth":3,"charIndex":470},{"text":"有状态组件","id":"有状态组件","depth":3,"charIndex":872},{"text":"受控组件","id":"受控组件","depth":3,"charIndex":1133},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1486},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1616}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说如何在 React 项目中应用 TypeScript？","footer":"说说如何在 React 项目中应用 TypeScript？","order":12,"star":12,"date":"2023-04-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说如何在 React 项目中应用 TypeScript？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说如何在 React 项目中应用 TypeScript？"}]]},"version":""},{"id":213,"title":"说说你对 TypeScript 的理解？与 JavaScript 的区别？","content":"#\n\n\n\n\n一、是什么#\n\nTypeScript 是 JavaScript 的类型的超集，支持ES6语法，支持面向对象编程的概念，如类、接口、继承、泛型等\n\n> 超集，不得不说另外一个概念，子集，怎么理解这两个呢，举个例子，如果一个集合 A 里面的的所有元素集合 B 里面都存在，那么我们可以理解集合 B 是集合 A\n> 的超集，集合 A 为集合 B 的子集\n\n\n\n其是一种静态类型检查的语言，提供了类型注解，在代码编译阶段就可以检查出数据类型的错误\n\n同时扩展了JavaScript 的语法，所以任何现有的JavaScript 程序可以不加改变的在 TypeScript 下工作\n\n为了保证兼容性，TypeScript 在编译阶段需要编译器编译成纯 JavaScript 来运行，是为大型应用之开发而设计的语言，如下：\n\nts 文件如下：\n\n\n\n编译文件后：\n\n\n\n\n二、特性#\n\nTypeScript 的特性主要有如下：\n\n * 类型批注和编译时类型检查 ：在编译时批注变量类型\n * 类型推断：ts 中没有批注变量类型会自动推断变量的类型\n * 类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除\n * 接口：ts 中用接口来定义对象类型\n * 枚举：用于取值被限定在一定范围内的场景\n * Mixin：可以接受任意类型的值\n * 泛型编程：写代码时使用一些以后才指定的类型\n * 名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突\n * 元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组\n * ...\n\n\n类型批注#\n\n通过类型批注提供在编译时启动类型检查的静态类型，这是可选的，而且可以忽略而使用 JavaScript 常规的动态类型\n\n\n\n对于基本类型的批注是 number、bool 和 string，而弱或动态类型的结构则是 any 类型\n\n\n类型推断#\n\n当类型没有给出时，TypeScript 编译器利用类型推断来推断类型，如下：\n\n\n\n变量 str 被推断为字符串类型，这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时\n\n如果缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型\n\n\n接口#\n\n接口简单来说就是用来描述对象的类型 数据的类型有 number、null、string 等数据格式，对象的类型就是用接口来描述的\n\n\n\n\n三、区别#\n\n * TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法\n * TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译\n * TypeScript 文件的后缀名 .ts （.ts，.tsx，.dts），JavaScript 文件是 .js\n * 在编写 TypeScript 的文件的时候就会自动编译成 js 文件\n\n更多的区别如下图所示：\n\n\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/140012915\n * https://www.jianshu.com/p/c8aaba6e8ce0\n * https://www.cnblogs.com/powertoolsteam/p/13500668.html","routePath":"/interview/typescript/typescript_javascript","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、特性","id":"二特性","depth":2,"charIndex":384},{"text":"类型批注","id":"类型批注","depth":3,"charIndex":677},{"text":"类型推断","id":"类型推断","depth":3,"charIndex":800},{"text":"接口","id":"接口","depth":3,"charIndex":939},{"text":"三、区别","id":"三区别","depth":2,"charIndex":1013},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1245}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 TypeScript 的理解？与 JavaScript 的区别？","footer":"说说你对 TypeScript 的理解？与 JavaScript 的区别？","order":11,"star":11,"date":"2023-04-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说你对 TypeScript 的理解？与 JavaScript 的区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 TypeScript 的理解？与 JavaScript 的区别？"}]]},"version":""},{"id":214,"title":"说说如何在 Vue 项目中应用 TypeScript？","content":"#\n\n\n\n\n一、前言#\n\n与 link 类似\n\n在VUE项目中应用typescript，我们需要引入一个库vue-property-decorator，\n\n其是基于vue-class-component库而来，这个库vue官方推出的一个支持使用class方式来开发vue单文件组件的库\n\n主要的功能如下：\n\n * methods 可以直接声明为类的成员方法\n * 计算属性可以被声明为类的属性访问器\n * 初始化的 data 可以被声明为类属性\n * data、render 以及所有的 Vue 生命周期钩子可以直接作为类的成员方法\n * 所有其他属性，需要放在装饰器中\n\n\n二、使用#\n\nvue-property-decorator 主要提供了多个装饰器和一个函数:\n\n * @Prop\n * @PropSync\n * @Model\n * @Watch\n * @Provide\n * @Inject\n * @ProvideReactive\n * @InjectReactive\n * @Emit\n * @Ref\n * @Component (由 vue-class-component 提供)\n * Mixins (由 vue-class-component 提供)\n\n\n@Component#\n\nComponent装饰器它注明了此类为一个Vue组件，因此即使没有设置选项也不能省略\n\n如果需要定义比如 name、components、filters、directives以及自定义属性，就可以在Component装饰器中定义，如下：\n\n\n\n\ncomputed、data、methods#\n\n这里取消了组件的 data 和 methods 属性，以往 data 返回对象中的属性、methods 中的方法需要直接定义在 Class\n中，当做类的属性和方法\n\n\n\n\n@props#\n\n组件接收属性的装饰器，如下使用：\n\n\n\n\n@watch#\n\n实际就是Vue中的监听器，如下：\n\n\n\n\n@emit#\n\nvue-property-decorator 提供的 @Emit 装饰器就是代替Vue中的事件的触发$emit，如下：\n\n\n\n\n三 、总结#\n\n可以看到上述typescript版本的vue\nclass的语法与平时javascript版本使用起来还是有很大的不同，多处用到class与装饰器，但实际上本质是一致的，只有不断编写才会得心应手","routePath":"/interview/typescript/vue","lang":"","toc":[{"text":"一、前言","id":"一前言","depth":2,"charIndex":5},{"text":"二、使用","id":"二使用","depth":2,"charIndex":287},{"text":"@Component","id":"component","depth":3,"charIndex":536},{"text":"computed、data、methods","id":"computeddatamethods","depth":3,"charIndex":672},{"text":"@props","id":"props","depth":3,"charIndex":782},{"text":"@watch","id":"watch","depth":3,"charIndex":812},{"text":"@emit","id":"emit","depth":3,"charIndex":842},{"text":"三 、总结","id":"三-总结","depth":2,"charIndex":914}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说如何在 Vue 项目中应用 TypeScript？","footer":"说说如何在 Vue 项目中应用 TypeScript？","order":9,"star":9,"date":"2023-03-28T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","typescript"],"tag":["interview","typescript"],"shortTitle":"前端物语|面试物语-说说如何在 Vue 项目中应用 TypeScript？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说如何在 Vue 项目中应用 TypeScript？"}]]},"version":""},{"id":215,"title":"vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？","content":"#\n\n\n\n\n一、如何部署#\n\n前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的web容器指定的静态目录下即可\n\n我们知道vue项目在构建后，是生成一系列的静态文件\n\n\n\n常规布署我们只需要将这个目录上传至目标服务器即可\n\n\n\n让web容器跑起来，以nginx为例\n\n\n\n配置完成记得重启nginx\n\n\n\n操作完后就可以在浏览器输入域名进行访问了\n\n当然上面只是提到最简单也是最直接的一种布署方式\n\n什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开\n\n\n二、404 问题#\n\n这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？\n\n我们先还原一下场景：\n\n * vue项目在本地时运行正常，但部署到服务器中，刷新页面，出现了 404 错误\n\n先定位一下，HTTP 404 错误意味着链接指向的资源不存在\n\n问题在于为什么不存在？且为什么只有history模式下会出现这个问题？\n\n\n为什么 history 模式下有问题#\n\nVue是属于单页应用（single-page application）\n\n而SPA是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个index.html\n\n现在，我们回头来看一下我们的nginx配置\n\n\n\n可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html\n文件，然后我们在跳转路由进入到 www.xxx.com/login\n\n关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况\n\n\n为什么 hash 模式下没有问题#\n\nrouter hash 模式我们都知道是用符号#表示的，如 website.com/#/login, hash 的值为 #/login\n\n它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面\n\nhash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com/#/login 只有 website.com 会被包含在请求中\n，因此对于服务端来说，即使没有配置location，也不会返回 404 错误\n\n\n解决方案#\n\n看到这里我相信大部分同学都能想到怎么解决问题了，\n\n产生问题的本质是因为我们的路由是通过 JS 来执行视图切换的，\n\n当我们进入到子路由时刷新页面，web容器没有相对应的页面此时会出现 404\n\n所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理\n\n对nginx配置文件.conf修改，添加try_files $uri $uri/ /index.html;\n\n\n\n修改完配置文件后记得配置的更新\n\n\n\n这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件\n\n为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面\n\n\n\n关于后端配置方案还有：Apache、nodejs等，思想是一致的，这里就不展开述说了\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903872637632525\n * https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0","routePath":"/interview/vue/404","lang":"","toc":[{"text":"一、如何部署","id":"一如何部署","depth":2,"charIndex":5},{"text":"二、404 问题","id":"二404-问题","depth":2,"charIndex":270},{"text":"为什么 history 模式下有问题","id":"为什么-history-模式下有问题","depth":3,"charIndex":443},{"text":"为什么 hash 模式下没有问题","id":"为什么-hash-模式下没有问题","depth":3,"charIndex":789},{"text":"解决方案","id":"解决方案","depth":2,"charIndex":1068},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1440}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？","footer":"vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？","order":23,"star":23,"date":"2023-04-11T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？"}]]},"version":""},{"id":216,"title":"前端物语|面试物语-vue","content":" * vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？\n * Vue 项目中有封装过 axios 吗？主要是封装哪方面的？\n * 你了解 axios 的原理吗？有看过它的源码吗？\n * 双向数据绑定是什么\n * Vue 组件之间的通信方式都有哪些？\n * Vue 中组件和插件有什么区别？\n * Vue 项目中你是如何解决跨域的呢？\n * 为什么 data 属性是一个函数而不是一个对象？\n * 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？\n * 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？\n * Vue 中的过滤器了解吗？过滤器的应用场景有哪些？\n * SPA 首屏加载速度慢的怎么解决？\n * v-if 和 v-for 的优先级是什么？\n * 说说你对 keep-alive 的理解是什么？\n * 你知道 vue 中 key 的原理吗？说说你对它的理解\n * 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n * 说说你对 vue 的 mixin 的理解，有什么应用场景？\n * Vue 常用的修饰符有哪些有什么应用场景\n * Vue 实例挂载的过程\n * Vue 中的$nextTick 有什么作用？\n * Vue.observable 你有了解过吗？说说看\n * vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n * v-show 和 v-if 有什么区别？使用场景分别是什么？\n * 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢\n * SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？\n * 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？\n * 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路\n * vue3 有了解过吗？能说说跟 vue2 的区别吗？","routePath":"/interview/vue/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"vue","tag":"vue","title":"前端物语|面试物语-vue","index":false,"dir":{"order":1},"date":"2023-04-17T00:00:00.000Z"},"version":""},{"id":217,"title":"Vue 项目中有封装过 axios 吗？主要是封装哪方面的？","content":"#\n\n\n\n\n一、axios 是什么#\n\naxios 是一个轻量的 HTTP客户端\n\n基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。自Vue2.0\n起，尤大宣布取消对 vue-resource 的官方推荐，转而推荐 axios。现在 axios 已经成为大部分 Vue 开发者的首选\n\n\n特性#\n\n * 从浏览器中创建 XMLHttpRequests\n * 从 node.js 创建 http请求\n * 支持 Promise API\n * 拦截请求和响应\n * 转换请求数据和响应数据\n * 取消请求\n * 自动转换JSON 数据\n * 客户端支持防御XSRF\n\n\n基本使用#\n\n安装\n\n\n\n导入\n\n\n\n发送请求\n\n\n\n并发请求axios.all([])\n\n\n\n\n二、为什么要封装#\n\naxios 的 API 很友好，你完全可以很轻松地在项目中直接使用。\n\n不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍\n\n这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 axios 再使用\n\n举个例子：\n\n\n\n如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了\n\n这时候我们就需要对axios进行二次封装，让使用更为便利\n\n\n三、如何封装#\n\n封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间.......\n\n设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分\n\n请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)\n\n状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好\n\n请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便\n\n请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问\n\n响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务\n\n\n设置接口请求前缀#\n\n利用node环境变量来作判断，用来区分开发、测试、生产环境\n\n\n\n在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域\n\n\n\n\n设置请求头与超时时间#\n\n大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基\n础配置\n\n\n\n\n封装请求方法#\n\n先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去\n\n\n\n把封装的方法放在一个api.js文件中\n\n\n\n页面中就能直接调用\n\n\n\n这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可\n\n\n请求拦截器#\n\n请求拦截器可以在每个请求里加上 token，做了统一处理后维护起来也方便\n\n\n\n\n响应拦截器#\n\n响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权\n\n\n\n\n小结#\n\n * 封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力\n * 封装 axios 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案\n\n\n参考文献#\n\n * https://www.html.cn/qa/vue-js/20544.html\n * https://juejin.cn/post/6844904033782611976\n * https://juejin.cn/post/6844903801451708429","routePath":"/interview/vue/axios","lang":"","toc":[{"text":"一、axios 是什么","id":"一axios-是什么","depth":2,"charIndex":5},{"text":"特性","id":"特性","depth":3,"charIndex":188},{"text":"基本使用","id":"基本使用","depth":3,"charIndex":327},{"text":"二、为什么要封装","id":"二为什么要封装","depth":2,"charIndex":376},{"text":"三、如何封装","id":"三如何封装","depth":2,"charIndex":649},{"text":"设置接口请求前缀","id":"设置接口请求前缀","depth":3,"charIndex":925},{"text":"设置请求头与超时时间","id":"设置请求头与超时时间","depth":3,"charIndex":1027},{"text":"封装请求方法","id":"封装请求方法","depth":3,"charIndex":1129},{"text":"请求拦截器","id":"请求拦截器","depth":3,"charIndex":1248},{"text":"响应拦截器","id":"响应拦截器","depth":3,"charIndex":1297},{"text":"小结","id":"小结","depth":3,"charIndex":1346},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1456}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 项目中有封装过 axios 吗？主要是封装哪方面的？","footer":"Vue 项目中有封装过 axios 吗？主要是封装哪方面的？","order":29,"star":29,"date":"2023-04-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 项目中有封装过 axios 吗？主要是封装哪方面的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 项目中有封装过 axios 吗？主要是封装哪方面的？"}]]},"version":""},{"id":218,"title":"你了解 axios 的原理吗？有看过它的源码吗？","content":"#\n\n\n\n\n一、axios 的使用#\n\n关于axios的基本使用，上篇文章已经有所涉及，这里再稍微回顾下：\n\n发送请求\n\n\n\n请求拦截器\n\n\n\n响应拦截器\n\n\n\n取消请求\n\n\n\n\n二、实现一个简易版 axios#\n\n构建一个Axios构造函数，核心代码为request\n\n\n\n导出axios实例\n\n\n\n上述就已经能够实现axios({ })这种方式的请求\n\n下面是来实现下axios.method()这种形式的请求\n\n\n\n将Axios.prototype上的方法搬运到request上\n\n首先实现个工具类，实现将b方法混入到a，并且修改this指向\n\n\n\n修改导出的方法\n\n\n\n构建拦截器的构造函数\n\n\n\n实现axios.interceptors.response.use和axios.interceptors.request.use\n\n\n\n执行语句axios.interceptors.response.use和axios.interceptors.request.use的时候，实现获取axios实\n例上的interceptors对象，然后再获取response或request拦截器，再执行对应的拦截器的use方法\n\n把Axios上的方法和属性搬到request过去\n\n\n\n现在request也有了interceptors对象，在发送请求的时候，会先获取request拦截器的handlers的方法来执行\n\n首先将执行ajax的请求封装成一个方法\n\n\n\n获得handlers中的回调\n\n\n\nchains大概是['fulfilled1','reject1','fulfilled2','reject2','this.sendAjax','undefin\ned','fulfilled2','reject2','fulfilled1','reject1']这种形式\n\n这样就能够成功实现一个简易版axios\n\n\n三、源码分析#\n\n首先看看目录结构\n\n\n\naxios发送请求有很多实现的方法，实现入口文件为axios.js\n\n\n\n主要核心是 Axios.prototype.request，各种请求方式的调用实现都是在 request 内部实现的， 简单看下 request 的逻辑\n\n\n\nrequest入口参数为config，可以说config贯彻了axios的一生\n\naxios 中的 config主要分布在这几个地方：\n\n * 默认配置 defaults.js\n * config.method默认为 get\n * 调用 createInstance 方法创建 axios实例，传入的config\n * 直接或间接调用 request 方法，传入的 config\n\n\n\n从源码中，可以看到优先级：默认配置对象default < method:get < Axios的实例属性this.default < request参数\n\n下面重点看看request方法\n\n\n\n拦截器interceptors是在构建axios实例化的属性\n\n\n\nInterceptorManager构造函数\n\n\n\n请求拦截器方法是被 unshift到拦截器中，响应拦截器是被push到拦截器中的。最终它们会拼接上一个叫dispatchRequest的方法被后续的\npromise 顺序执行\n\n\n\n再来看看axios是如何实现取消请求的，实现文件在CancelToken.js\n\n\n\n实际上取消请求的操作是在 xhr.js 中也有响应的配合的\n\n\n\n巧妙的地方在 CancelToken中 executor 函数，通过resolve函数的传递与执行，控制promise的状态\n\n\n小结#\n\n\n\n\n参考文献#\n\n * https://juejin.cn/post/6856706569263677447#heading-4\n * https://juejin.cn/post/6844903907500490766\n * https://github.com/axios/axios","routePath":"/interview/vue/axiosCode","lang":"","toc":[{"text":"一、axios 的使用","id":"一axios-的使用","depth":2,"charIndex":5},{"text":"二、实现一个简易版 axios","id":"二实现一个简易版-axios","depth":2,"charIndex":89},{"text":"三、源码分析","id":"三源码分析","depth":2,"charIndex":806},{"text":"小结","id":"小结","depth":3,"charIndex":1526},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1534}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你了解 axios 的原理吗？有看过它的源码吗？","footer":"你了解 axios 的原理吗？有看过它的源码吗？","order":11,"star":11,"date":"2023-03-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你了解 axios 的原理吗？有看过它的源码吗？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你了解 axios 的原理吗？有看过它的源码吗？"}]]},"version":""},{"id":219,"title":"双向数据绑定是什么","content":"#\n\n\n\n\n一、什么是双向绑定#\n\n我们先从单向绑定切入单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新双向绑定就很容易联想\n到了，在单向绑定的基础上，用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定举个栗子\n\n\n\n当用户填写表单时，View的状态就被更新了，如果此时可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定关系图如下\n\n\n\n\n二、双向绑定的原理是什么#\n\n我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成\n\n * 数据层（Model）：应用的数据及业务逻辑\n * 视图层（View）：应用的展示效果，各类 UI 组件\n * 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来\n\n而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定”\n。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理\n\n\n理解 ViewModel#\n\n它的主要职责就是：\n\n * 数据变化后更新视图\n * 视图变化后更新数据\n\n当然，它还有两个主要部分组成\n\n * 监听器（Observer）：对所有数据的属性进行监听\n * 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数\n\n\n三、实现双向绑定#\n\n我们还是以Vue为例，先来看看Vue中的双向绑定流程是什么的\n\n 1. new Vue()首先执行初始化，对data执行响应化处理，这个过程发生Observe中\n 2. 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中\n 3. 同时定义⼀个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数\n 4. 由于data的某个key在⼀个视图中可能出现多次，所以每个key都需要⼀个管家Dep来管理多个Watcher\n 5. 将来 data 中数据⼀旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数\n\n流程图如下：\n\n\n\n\n实现#\n\n先来一个构造函数：执行初始化，对data执行响应化处理\n\n\n\n对data选项执行响应化具体操作\n\n\n\n编译Compile#\n\n对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数\n\n\n\n\n\n依赖收集#\n\n视图中会用到data中某key，这称为依赖。同⼀个key可能出现多次，每次都需要收集出来用⼀个Watcher来维护它们，此过程称为依赖收集多个Watcher需要\n⼀个Dep来管理，需要更新时由Dep统⼀通知\n\n\n\n实现思路\n\n 1. defineReactive时为每⼀个key创建⼀个Dep实例\n 2. 初始化视图时读取某个key，例如name1，创建⼀个watcher1\n 3. 由于触发name1的getter方法，便将watcher1添加到name1对应的 Dep 中\n 4. 当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新\n\n\n\n声明Dep\n\n\n\n创建watcher时触发getter\n\n\n\n依赖收集，创建Dep实例\n\n\n\n\n参考文献#\n\n * https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416\n * https://juejin.cn/post/6844903942254510087#heading-9\n\n面试官 VUE 系列总进度：3／33\n\n说说你对 vue 的理解? 说说你对 SPA（单页应用）的理解?","routePath":"/interview/vue/bind","lang":"","toc":[{"text":"一、什么是双向绑定","id":"一什么是双向绑定","depth":2,"charIndex":5},{"text":"二、双向绑定的原理是什么","id":"二双向绑定的原理是什么","depth":2,"charIndex":230},{"text":"理解 ViewModel","id":"理解-viewmodel","depth":3,"charIndex":467},{"text":"三、实现双向绑定","id":"三实现双向绑定","depth":3,"charIndex":626},{"text":"实现","id":"实现","depth":3,"charIndex":945},{"text":"编译`Compile`","id":"编译compile","depth":4,"charIndex":-1},{"text":"依赖收集","id":"依赖收集","depth":4,"charIndex":1059},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1405}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-双向数据绑定是什么","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>双向数据绑定是什么","order":9,"star":9,"date":"2023-03-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-双向数据绑定是什么","isOriginal":false,"head":[["meta",{"name":"keywords","content":"双向数据绑定是什么"}]]},"version":""},{"id":220,"title":"Vue 组件之间的通信方式都有哪些？","content":"#\n\n\n\n\n一、组件间通信的概念#\n\n开始之前，我们把组件间通信这个词进行拆分\n\n * 组件\n * 通信\n\n都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上\n，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中\n传入某些数据，这个本质就形成了组件之间的通信\n\n\n二、组件间通信解决了什么#\n\n在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现\n了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的\n作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统\n\n\n二、组件间通信的分类#\n\n组件间通信的分类可以分成以下\n\n * 父子组件之间的通信\n * 兄弟组件之间的通信\n * 祖孙与后代组件之间的通信\n * 非关系组件间之间的通信\n\n关系图:\n\n\n\n\n三、组件间通信的方案#\n\n整理vue中 8 种常规的通信方案\n\n 1. 通过 props 传递\n 2. 通过 $emit 触发自定义事件\n 3. 使用 ref\n 4. EventBus\n 5. $parent 或$root\n 6. attrs 与 listeners\n 7. Provide 与 Inject\n 8. Vuex\n\n\nprops 传递数据#\n\n\n\n * 适用场景：父组件传递数据给子组件\n * 子组件设置props属性，定义接收父组件传递过来的参数\n * 父组件在使用子组件标签中通过字面量来传递值\n\nChildren.vue\n\n\n\nFather.vue组件\n\n\n\n\n$emit 触发自定义事件#\n\n * 适用场景：子组件传递数据给父组件\n * 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n * 父组件绑定监听器获取到子组件传递过来的参数\n\nChilfen.vue\n\n\n\nFather.vue\n\n\n\n\nref#\n\n * 父组件在使用子组件的时候设置ref\n * 父组件通过设置子组件ref来获取数据\n\n父组件\n\n\n\n\nEventBus#\n\n * 使用场景：兄弟组件传值\n * 创建一个中央事件总线EventBus\n * 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值\n * 另一个兄弟组件通过$on监听自定义事件\n\nBus.js\n\n\n\nChildren1.vue\n\n\n\nChildren2.vue\n\n\n\n\n$parent 或$ root#\n\n * 通过共同祖辈$parent或者$root搭建通信桥连\n\n兄弟组件\n\nthis.$parent.on('add',this.add)\n\n另一个兄弟组件\n\nthis.$parent.emit('add')\n\n\n$attrs 与$ listeners#\n\n * 适用场景：祖先传递数据给子孙\n * 设置批量向下传属性$attrs和 $listeners\n * 包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。\n * 可以通过 v-bind=\"$attrs\" 传⼊内部组件\n\n\n\n\n\n\nprovide 与 inject#\n\n * 在祖先组件定义provide属性，返回传递的值\n * 在后代组件通过inject接收组件传递过来的值\n\n祖先组件\n\n\n\n后代组件\n\n\n\n\nvuex#\n\n * 适用场景: 复杂关系的组件数据传递\n\n * Vuex作用相当于一个用来存储共享变量的容器\n\n * state用来存放共享变量的地方\n\n * getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值\n\n * mutations用来存放修改state的方法。\n\n * actions也是用来存放修改 state 的方法，不过action是在mutations的基础上进行。常用来做一些异步操作\n\n\n小结#\n\n * 父子关系的组件数据传递选择 props   与 $emit进行传递，也可选择ref\n * 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递\n * 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject\n * 复杂关系的组件数据传递可以通过vuex存放共享的变量\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903990052782094#heading-0\n * https://zh.wikipedia.org/wiki/\\%E9\\%80\\%9A\\%E4\\%BF\\%A1\n * https://vue3js.cn/docs/zh\n\n面试官 VUE 系列总进度：5／33\n\n说说你对 vue 的理解?\n\n说说你对 SPA（单页应用）的理解?\n\n说说你对双向绑定的理解?\n\n说说你对 Vue 生命周期的理解?","routePath":"/interview/vue/communication","lang":"","toc":[{"text":"一、组件间通信的概念","id":"一组件间通信的概念","depth":2,"charIndex":5},{"text":"二、组件间通信解决了什么","id":"二组件间通信解决了什么","depth":2,"charIndex":240},{"text":"二、组件间通信的分类","id":"二组件间通信的分类","depth":2,"charIndex":499},{"text":"三、组件间通信的方案","id":"三组件间通信的方案","depth":2,"charIndex":595},{"text":"props 传递数据","id":"props-传递数据","depth":3,"charIndex":761},{"text":"$emit 触发自定义事件","id":"emit-触发自定义事件","depth":3,"charIndex":886},{"text":"ref","id":"ref","depth":3,"charIndex":1016},{"text":"EventBus","id":"eventbus","depth":3,"charIndex":1074},{"text":"$parent 或$ root","id":"parent-或root","depth":3,"charIndex":1230},{"text":"$attrs  与$ listeners","id":"attrs--与-listeners","depth":3,"charIndex":-1},{"text":"provide 与 inject","id":"provide-与-inject","depth":3,"charIndex":1520},{"text":"`vuex`","id":"vuex","depth":3,"charIndex":-1},{"text":"小结","id":"小结","depth":3,"charIndex":1841},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2014}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 组件之间的通信方式都有哪些？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>Vue 组件之间的通信方式都有哪些？","order":4,"star":4,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 组件之间的通信方式都有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 组件之间的通信方式都有哪些？"}]]},"version":""},{"id":221,"title":"Vue 中组件和插件有什么区别？","content":"#\n\n\n\n\n一、组件是什么#\n\n回顾以前对组件的定义：\n\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件\n\n组件的优势\n\n * 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现\n\n * 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件\n   之间低耦合，职责单一，所以逻辑会比分析整个系统要简单\n\n * 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级\n\n\n二、插件是什么#\n\n插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：\n\n * 添加全局方法或者属性。如: vue-custom-element\n * 添加全局资源：指令/过滤器/过渡等。如 vue-touch\n * 通过全局混入来添加一些组件选项。如vue-router\n * 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n * 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如vue-router\n\n\n三、两者的区别#\n\n两者的区别主要表现在以下几个方面：\n\n * 编写形式\n * 注册形式\n * 使用场景\n\n\n编写形式#\n\n编写组件#\n\n编写一个组件，可以有很多方式，我们最常见的就是vue单文件的这种格式，每一个.vue文件我们都可以看成是一个组件\n\nvue文件标准格式\n\n\n\n我们还可以通过template属性来编写一个组件，如果组件内容多，我们可以在外部定义template组件内容，如果组件内容并不多，我们可直接写在template\n属性上\n\n\n\n编写插件#\n\nvue插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象\n\n\n\n\n注册形式#\n\n组件注册#\n\nvue组件注册主要分为全局注册与局部注册\n\n全局注册通过Vue.component方法，第一个参数为组件的名称，第二个参数为传入的配置项\n\n\n\n局部注册只需在用到的地方通过components属性注册一个组件\n\n\n\n插件注册#\n\n插件的注册通过Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项\n\n\n\n注意的是：\n\n注册插件的时候，需要在调用 new Vue() 启动应用之前完成\n\nVue.use会自动阻止多次注册相同插件，只会注册一次\n\n\n使用场景#\n\n具体的其实在插件是什么章节已经表述了，这里在总结一下\n\n组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue\n\n插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身\n\n简单来说，插件就是指对Vue的功能的增强或补充\n\n\n参考文献#\n\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/components_plugin","lang":"","toc":[{"text":"一、组件是什么","id":"一组件是什么","depth":2,"charIndex":5},{"text":"二、插件是什么","id":"二插件是什么","depth":2,"charIndex":344},{"text":"三、两者的区别","id":"三两者的区别","depth":2,"charIndex":590},{"text":"编写形式","id":"编写形式","depth":3,"charIndex":645},{"text":"编写组件","id":"编写组件","depth":4,"charIndex":652},{"text":"编写插件","id":"编写插件","depth":4,"charIndex":818},{"text":"注册形式","id":"注册形式","depth":3,"charIndex":891},{"text":"组件注册","id":"组件注册","depth":4,"charIndex":898},{"text":"插件注册","id":"插件注册","depth":4,"charIndex":1013},{"text":"使用场景","id":"使用场景","depth":3,"charIndex":1148},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1299}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 中组件和插件有什么区别？","footer":"Vue 中组件和插件有什么区别？","order":17,"star":17,"date":"2023-04-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 中组件和插件有什么区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 中组件和插件有什么区别？"}]]},"version":""},{"id":222,"title":"Vue 项目中你是如何解决跨域的呢？","content":"#\n\n\n\n\n一、跨域是什么#\n\n跨域本质是浏览器基于同源策略的一种安全手段\n\n同源策略（Sameoriginpolicy），是一种约定，它是浏览器最核心也最基本的安全功能\n\n所谓同源（即指在同一个域）具有以下三个相同点\n\n * 协议相同（protocol）\n * 主机相同（host）\n * 端口相同（port）\n\n反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域\n\n> 一定要注意跨域是浏览器的限制，你用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，你获取不到数据。用 postman\n> 请求接口能够请求到数据。这些再次印证了跨域是浏览器的限制。\n\n\n二、如何解决#\n\n解决跨域的方法有很多，下面列举了三种：\n\n * JSONP\n * CORS\n * Proxy\n\n而在vue项目中，我们主要针对CORS或Proxy这两种方案进行展开\n\n\nCORS#\n\nCORS （Cross-Origin Resource Sharing，跨域资源共享）是一个系统，它由一系列传输的 HTTP 头组成，这些 HTTP\n头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应\n\nCORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源\n\n只要后端实现了 CORS，就实现了跨域\n\n\n\n以koa框架举例\n\n添加中间件，直接设置Access-Control-Allow-Origin响应头\n\n\n\nps: Access-Control-Allow-Origin\n设置为*其实意义不大，可以说是形同虚设，实际应用中，上线前我们会将Access-Control-Allow-Origin 值设为我们目标host\n\n\nProxy#\n\n代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网\n络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击\n\n方案一\n\n如果是通过vue-cli脚手架工具搭建项目，我们可以通过webpack为我们起一个本地服务器作为请求的代理对象\n\n通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果 web 应用和接口服务器不在一起仍会跨域\n\n在vue.config.js文件，新增以下代码\n\n\n\n通过axios发送请求中，配置请求的根路径\n\n\n\n方案二\n\n此外，还可通过服务端实现代理请求转发\n\n以express框架为例\n\n\n\n方案三\n\n通过配置nginx实现代理\n\n","routePath":"/interview/vue/cors","lang":"","toc":[{"text":"一、跨域是什么","id":"一跨域是什么","depth":2,"charIndex":5},{"text":"二、如何解决","id":"二如何解决","depth":2,"charIndex":307},{"text":"CORS","id":"cors","depth":3,"charIndex":401},{"text":"Proxy","id":"proxy","depth":3,"charIndex":749}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 项目中你是如何解决跨域的呢？","footer":"Vue 项目中你是如何解决跨域的呢？","order":15,"star":15,"date":"2023-03-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 项目中你是如何解决跨域的呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 项目中你是如何解决跨域的呢？"}]]},"version":""},{"id":223,"title":"为什么 data 属性是一个函数而不是一个对象？","content":"#\n\n\n\n\n一、实例和组件定义 data 的区别#\n\nvue实例的时候定义data属性既可以是一个对象，也可以是一个函数\n\n\n\n组件中定义data属性，只能是一个函数\n\n如果为组件data直接定义为一个对象\n\n\n\n则会得到警告信息\n\n\n\n警告说明：返回的data应该是一个函数在每一个组件实例中\n\n\n二、组件 data 定义函数与对象的区别#\n\n上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？\n\n在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例\n\n这里我们模仿组件构造函数，定义data属性，采用对象的形式\n\n\n\n创建两个组件实例\n\n\n\n修改componentA组件data属性的值，componentB中的值也发生了改变\n\n\n\n产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响\n\n如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）\n\n\n\n修改componentA组件data属性的值，componentB中的值不受影响\n\n\n\nvue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染\n\n\n三、原理分析#\n\n首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象\n\n源码位置：/vue-dev/src/core/instance/state.js\n\n\n\ndata既能是object也能是function，那为什么还会出现上文警告呢？\n\n别急，继续看下文\n\n组件在创建的时候，会进行选项的合并\n\n源码位置：/vue-dev/src/core/util/options.js\n\n自定义组件会进入mergeOptions进行选项合并\n\n\n\n定义data会进行数据校验\n\n源码位置：/vue-dev/src/core/instance/init.js\n\n这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示\n\n\n\n\n四、结论#\n\n * 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况\n * 组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会\n   返回全新data对象","routePath":"/interview/vue/data","lang":"","toc":[{"text":"一、实例和组件定义 data 的区别","id":"一实例和组件定义-data-的区别","depth":2,"charIndex":5},{"text":"二、组件 data 定义函数与对象的区别","id":"二组件-data-定义函数与对象的区别","depth":2,"charIndex":149},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":548},{"text":"四、结论","id":"四结论","depth":3,"charIndex":892}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-为什么 data 属性是一个函数而不是一个对象？","footer":"为什么 data 属性是一个函数而不是一个对象？","order":21,"star":21,"date":"2023-04-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-为什么 data 属性是一个函数而不是一个对象？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"为什么 data 属性是一个函数而不是一个对象？"}]]},"version":""},{"id":224,"title":"动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？","content":"#\n\n\n\n\n一、直接添加属性的问题#\n\n我们从一个例子开始\n\n定义一个p标签，通过v-for指令进行遍历\n\n然后给botton标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行\n\n\n\n实例化一个vue实例，定义data属性和methods方法\n\n\n\n点击按钮，发现结果不及预期，数据虽然更新了（console打印出了新属性），但页面并没有更新\n\n\n二、原理分析#\n\n为什么产生上面的情况呢？\n\n下面来分析一下\n\nvue2是用过Object.defineProperty实现数据响应式\n\n\n\n当我们访问foo属性或者设置foo值的时候都能够触发setter与getter\n\n\n\n但是我们为obj添加新属性的时候，却无法触发事件属性的拦截\n\n\n\n原因是一开始obj的foo属性被设成了响应式数据，而bar是后面新增的属性，并没有通过Object.defineProperty设置成响应式数据\n\n\n三、解决方案#\n\nVue 不允许在已经创建的实例上动态添加新的响应式属性\n\n若想实现数据与视图同步更新，可采取下面三种解决方案：\n\n * Vue.set()\n * Object.assign()\n * $forcecUpdated()\n\n\nVue.set()#\n\nVue.set( target, propertyName/index, value )\n\n参数\n\n * {Object | Array} target\n * {string | number} propertyName/index\n * {any} value\n\n返回值：设置的值\n\n通过Vue.set向响应式对象中添加一个property，并确保这个新 property同样是响应式的，且触发视图更新\n\n关于Vue.set源码（省略了很多与本节不相关的代码）\n\n源码位置：src\\core\\observer\\index.js\n\n\n\n这里无非再次调用defineReactive方法，实现新增属性的响应式\n\n关于defineReactive方法，内部还是通过Object.defineProperty实现属性拦截\n\n大致代码如下：\n\n\n\n\nObject.assign()#\n\n直接使用Object.assign()添加到对象的新属性不会触发更新\n\n应创建一个新的对象，合并原对象和混入对象的属性\n\n\n\n\n$forceUpdate#\n\n如果你发现你自己需要在 Vue中做一次强制更新，99.9% 的情况，是你在某个地方做错了事\n\n$forceUpdate迫使Vue 实例重新渲染\n\nPS：仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。\n\n\n小结#\n\n * 如果为对象添加少量的新属性，可以直接采用Vue.set()\n\n * 如果需要为新对象添加大量的新属性，则通过Object.assign()创建新对象\n\n * 如果你实在不知道怎么操作时，可采取$forceUpdate()进行强制刷新 (不建议)\n\nPS：vue3是用过proxy实现数据响应式的，直接动态添加新属性仍可以实现数据响应式\n\n\n参考文献#\n\n * https://cn.vuejs.org/v2/api/#Vue-set\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/data_object_add_attrs","lang":"","toc":[{"text":"一、直接添加属性的问题","id":"一直接添加属性的问题","depth":2,"charIndex":5},{"text":"二、原理分析","id":"二原理分析","depth":2,"charIndex":184},{"text":"三、解决方案","id":"三解决方案","depth":2,"charIndex":406},{"text":"Vue.set()","id":"vueset","depth":3,"charIndex":526},{"text":"Object.assign()","id":"objectassign","depth":3,"charIndex":909},{"text":"$forceUpdate","id":"forceupdate","depth":3,"charIndex":991},{"text":"小结","id":"小结","depth":3,"charIndex":1114},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1292}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？","footer":"动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？","order":16,"star":16,"date":"2023-04-01T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？"}]]},"version":""},{"id":225,"title":"你了解 vue 的 diff 算法吗？说说看","content":"#\n\n\n\n\n一、是什么#\n\ndiff 算法是一种通过同层的树节点进行比较的高效算法\n\n其有两个特点：\n\n * 比较只会在同层级进行, 不会跨层级比较\n * 在 diff 比较的过程中，循环从两边向中间比较\n\ndiff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较\n\n\n二、比较方式#\n\ndiff整体策略为：深度优先，同层比较\n\n 1. 比较只会在同层级进行, 不会跨层级比较\n\n 2. 比较的过程中，循环从两边向中间收拢\n\n下面举个vue通过diff算法更新的例子：\n\n新旧VNode节点如下图所示：\n\n\n\n第一次循环后，发现旧节点 D 与新节点 D 相同，直接复用旧节点 D 作为diff后的第一个真实节点，同时旧节点endIndex移动到 C，新节点的\nstartIndex 移动到了 C\n\n\n\n第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的\nendIndex 移动到了 B，新节点的 startIndex 移动到了 E\n\n\n\n第三次循环中，发现 E 没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了\nA。旧节点的 startIndex 和 endIndex 都保持不动\n\n\n\n第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的\nstartIndex 移动到了 B，新节点的startIndex 移动到了 B\n\n\n\n第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex移动到了\nC，新节点的 startIndex 移动到了 F\n\n\n\n新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点\nF，直接创建 F 节点对应的真实节点放到 B 节点后面\n\n\n\n\n三、原理分析#\n\n当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图\n\n源码位置：src/core/vdom/patch.js\n\n\n\npatch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：\n\n * 没有新节点，直接触发旧节点的destory钩子\n * 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm\n * 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点\n * 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点\n\n下面主要讲的是patchVnode部分\n\n\n\npatchVnode主要做了几个判断：\n\n * 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容\n * 新节点和旧节点如果都有子节点，则处理比较更新子节点\n * 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点\n * 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除\n\n子节点不完全一致，则调用updateChildren\n\n\n\nwhile循环主要处理了以下五种情景：\n\n * 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1\n * 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1\n * 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到\n   oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1\n * 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到\n   oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1\n * 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：\n   * 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的\n     VNode 节点，再进行patchVnode，同时将这个真实 dom移动到 oldStartVnode 对应的真实 dom 的前面\n   * 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置\n\n\n小结#\n\n * 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁\n * 通过isSameVnode进行判断，相同则调用patchVnode方法\n * patchVnode做了以下操作：\n   * 找到对应的真实dom，称为el\n   * 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点\n   * 如果oldVnode有子节点而VNode没有，则删除el子节点\n   * 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el\n   * 如果两者都有子节点，则执行updateChildren函数比较子节点\n * updateChildren主要做了以下操作：\n   * 设置新旧VNode的头尾指针\n   * 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找\n     key一致的VNode 节点再分情况操作\n\n\n参考文献#\n\n * https://juejin.cn/post/6881907432541552648#heading-1\n * https://www.infoq.cn/article/udlcpkh4iqb0cr5wgy7f","routePath":"/interview/vue/diff","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、比较方式","id":"二比较方式","depth":2,"charIndex":166},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":939},{"text":"小结","id":"小结","depth":3,"charIndex":2265},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2714}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你了解 vue 的 diff 算法吗？说说看","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>你了解 vue 的 diff 算法吗？说说看","order":1,"star":1,"date":"2023-02-26T20:08:28.602Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你了解 vue 的 diff 算法吗？说说看","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你了解 vue 的 diff 算法吗？说说看"}]]},"version":""},{"id":226,"title":"你有写过自定义指令吗？自定义指令的应用场景有哪些？","content":"#\n\n\n\n\n一、什么是指令#\n\n开始之前我们先学习一下指令系统这个词\n\n指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力\n\n在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统\n\n我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能\n\n除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令\n\n指令使用的几种方式：\n\n\n\n\n二、如何实现#\n\n注册一个自定义指令有全局注册与局部注册\n\n全局注册主要是通过Vue.directive方法进行注册\n\nVue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数\n\n\n\n局部注册通过在组件options选项中设置directive属性\n\n\n\n然后你可以在模板中任何元素上使用新的 v-focus property，如下：\n\n\n\n自定义指令也像组件那样存在钩子函数：\n\n * bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\n\n * inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)\n\n * update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode\n   更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新\n\n * componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用\n\n * unbind：只调用一次，指令与元素解绑时调用\n\n所有的钩子函数的参数都有以下：\n\n * el：指令所绑定的元素，可以用来直接操作 DOM\n * binding：一个对象，包含以下 property：\n   * name：指令名，不包括 v- 前缀。\n   * value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\n   * oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\n   * expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\n   * arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\n   * modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar:\n     true }\n * vnode：Vue 编译生成的虚拟节点\n * oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用\n\n> 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行\n\n举个例子：\n\n\n\n\n三、应用场景#\n\n使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例：\n\n * 表单防止重复提交\n * 图片懒加载\n * 一键 Copy 的功能\n\n\n表单防止重复提交#\n\n表单防止重复提交这种情况设置一个v-throttle自定义指令来实现\n\n举个例子：\n\n\n\n\n图片懒加载#\n\n设置一个v-lazy自定义指令完成图片懒加载\n\n\n\n\n一键 Copy 的功能#\n\n\n\n关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景\n\n\n参考文献#\n\n * https://vue3js.cn/docs/zh\n * https://juejin.cn/post/6844904197448531975#heading-5\n * https://www.cnblogs.com/chenwenhao/p/11924161.html#_label2","routePath":"/interview/vue/directive","lang":"","toc":[{"text":"一、什么是指令","id":"一什么是指令","depth":2,"charIndex":5},{"text":"二、如何实现","id":"二如何实现","depth":3,"charIndex":248},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1341},{"text":"表单防止重复提交","id":"表单防止重复提交","depth":3,"charIndex":1425},{"text":"图片懒加载","id":"图片懒加载","depth":3,"charIndex":1482},{"text":"一键 Copy 的功能","id":"一键-copy-的功能","depth":3,"charIndex":1517},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1574}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你有写过自定义指令吗？自定义指令的应用场景有哪些？","footer":"你有写过自定义指令吗？自定义指令的应用场景有哪些？","order":30,"star":30,"date":"2023-04-17T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你有写过自定义指令吗？自定义指令的应用场景有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你有写过自定义指令吗？自定义指令的应用场景有哪些？"}]]},"version":""},{"id":227,"title":"你是怎么处理 vue 项目中的错误的？","content":"#\n\n\n\n\n一、错误类型#\n\n任何一个框架，对于错误的处理都是一种必备的能力\n\n在Vue 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。\n\n主要的错误来源包括：\n\n * 后端接口错误\n * 代码中本身逻辑错误\n\n\n二、如何处理#\n\n\n后端接口错误#\n\n通过axios的interceptor实现网络请求的response先进行一层拦截\n\n\n\n\n代码逻辑问题#\n\n全局设置错误处理#\n\n设置全局错误处理函数\n\n\n\nerrorHandler指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例\n\n不过值得注意的是，在不同Vue 版本中，该全局 API 作用的范围会有所不同：\n\n> 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error\n> 输出而避免应用崩\n\n> 从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了\n\n> 从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如\n> async 函数)，则来自其 Promise 链的错误也会被处理\n\n生命周期钩子#\n\nerrorCaptured是 2.5.0 新增的一个生命钩子函数，当捕获到一个来自子孙组件的错误时被调用\n\n基本类型\n\n\n\n此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播\n\n参考官网，错误传播规则如下：\n\n * 默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报\n * 如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。\n * 如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler\n * 一个 errorCaptured 钩子能够返回 false\n   以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的\n   config.errorHandler\n\n下面来看个例子\n\n定义一个父组件cat\n\n\n\n定义一个子组件kitten，其中dontexist()并没有定义，存在错误\n\n\n\n页面中使用组件\n\n\n\n在父组件的errorCaptured则能够捕获到信息\n\n\n\n\n三、源码分析#\n\n异常处理源码\n\n源码位置：/src/core/util/error.js\n\n\n\n\n小结#\n\n * handleError在需要捕获异常的地方调用，首先获取到报错的组件，之后递归查找当前组件的父组件，依次调用errorCaptured\n   方法，在遍历调用完所有 errorCaptured 方法或 errorCaptured 方法有报错时，调用 globalHandleError 方法\n * globalHandleError调用全局的 errorHandler 方法，再通过logError判断环境输出错误信息\n * invokeWithErrorHandling更好的处理异步错误信息\n * logError判断环境，选择不同的抛错方式。非生产环境下，调用warn方法处理错误\n\n\n参考文献#\n\n * https://juejin.cn/post/6844904096936230925\n\n * https://segmentfault.com/a/1190000018606181","routePath":"/interview/vue/error","lang":"","toc":[{"text":"一、错误类型","id":"一错误类型","depth":2,"charIndex":5},{"text":"二、如何处理","id":"二如何处理","depth":2,"charIndex":133},{"text":"后端接口错误","id":"后端接口错误","depth":3,"charIndex":143},{"text":"代码逻辑问题","id":"代码逻辑问题","depth":3,"charIndex":198},{"text":"全局设置错误处理","id":"全局设置错误处理","depth":4,"charIndex":207},{"text":"生命周期钩子","id":"生命周期钩子","depth":4,"charIndex":584},{"text":"三、源码分析","id":"三源码分析","depth":3,"charIndex":1193},{"text":"小结","id":"小结","depth":3,"charIndex":1243},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1547}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你是怎么处理 vue 项目中的错误的？","footer":"你是怎么处理 vue 项目中的错误的？","order":18,"star":18,"date":"2023-04-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你是怎么处理 vue 项目中的错误的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你是怎么处理 vue 项目中的错误的？"}]]},"version":""},{"id":228,"title":"Vue 中的过滤器了解吗？过滤器的应用场景有哪些？","content":"#\n\n\n\n\n一、是什么#\n\n过滤器（filter）是输送介质管道上不可缺少的一种装置\n\n大白话，就是把一些不必要的东西过滤掉\n\n过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数\n\nVue 允许你自定义过滤器，可被用于一些常见的文本格式化\n\nps: Vue3中已废弃filter\n\n\n二、如何用#\n\nvue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示：\n\n\n\n\n定义 filter#\n\n在组件的选项中定义本地的过滤器\n\n\n\n定义全局过滤器：\n\n\n\n注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器\n\n过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数\n\n过滤器可以串联：\n\n\n\n在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message\n的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。\n\n过滤器是 JavaScript函数，因此可以接收参数：\n\n\n\n这里，filterA 被定义为接收三个参数的过滤器函数。\n\n其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数\n\n举个例子：\n\n\n\n\n小结#\n\n * 部过滤器优先于全局过滤器被调用\n * 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右\n\n\n三、应用场景#\n\n平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等\n\n比如我们要实现将 30000 => 30,000，这时候我们就需要使用过滤器\n\n\n\n\n四、原理分析#\n\n使用过滤器\n\n\n\n在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲\n\n\n\n首先分析一下_f：\n\n_f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回\n\n\n\n关于resolveFilter\n\n\n\n内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器；\n\nresolveAsset的代码如下：\n\n\n\n下面再来分析一下_s：\n\n_s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的\ntext 属性中，渲染到视图中\n\n\n\n最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式\n\n\n\n\n小结#\n\n * 在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数）\n * 编译后通过调用resolveFilter函数找到对应过滤器并返回结果\n * 执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图\n\n\n参考文献#\n\n * https://cn.vuejs.org/v2/guide/filters.html#ad\n * https://blog.csdn.net/weixin_42724176/article/details/105546684\n * https://vue3js.cn","routePath":"/interview/vue/filter","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何用","id":"二如何用","depth":2,"charIndex":171},{"text":"定义 filter","id":"定义-filter","depth":3,"charIndex":257},{"text":"小结","id":"小结","depth":3,"charIndex":675},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":746},{"text":"四、原理分析","id":"四原理分析","depth":2,"charIndex":847},{"text":"小结","id":"小结-1","depth":3,"charIndex":1279},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1465}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 中的过滤器了解吗？过滤器的应用场景有哪些？","footer":"Vue 中的过滤器了解吗？过滤器的应用场景有哪些？","order":24,"star":24,"date":"2023-04-12T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 中的过滤器了解吗？过滤器的应用场景有哪些？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 中的过滤器了解吗？过滤器的应用场景有哪些？"}]]},"version":""},{"id":229,"title":"SPA 首屏加载速度慢的怎么解决？","content":"#\n\n\n\n\n一、什么是首屏加载#\n\n首屏时间（First Contentful\nPaint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容\n\n首屏加载可以说是用户体验中最重要的环节\n\n\n关于计算首屏时间#\n\n利用performance.timing提供的数据：\n\n\n\n通过DOMContentLoad或者performance来计算出首屏时间\n\n\n\n\n二、加载慢的原因#\n\n在页面渲染的过程，导致加载速度慢的因素可能如下：\n\n * 网络延时问题\n * 资源文件体积是否过大\n * 资源是否重复发送请求去加载了\n * 加载脚本的时候，渲染内容堵塞了\n\n\n三、解决方案#\n\n常见的几种 SPA 首屏优化方式\n\n * 减小入口文件积\n * 静态资源本地缓存\n * UI 框架按需加载\n * 图片资源的压缩\n * 组件重复打包\n * 开启 GZip 压缩\n * 使用 SSR\n\n\n减小入口文件体积#\n\n常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n\n\n\n在vue-router配置路由的时候，采用动态加载路由的形式\n\n\n\n以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n\n\n静态资源本地缓存#\n\n后端返回资源问题：\n\n * 采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头\n\n * 采用Service Worker离线缓存\n\n前端合理利用localStorage\n\n\nUI 框架按需加载#\n\n在日常使用UI框架，例如element-UI、或者antd，我们经常性直接引用整个UI库\n\n\n\n但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用\n\n\n\n\n组件重复打包#\n\n假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载\n\n解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置\n\n\n\nminChunks为 3 表示会把使用 3 次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件\n\n\n图片资源的压缩#\n\n图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素\n\n对于所有的图片资源，我们可以进行适当的压缩\n\n对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。\n\n\n开启 GZip 压缩#\n\n拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin\n\n\n\n在vue.congig.js中引入并修改webpack配置\n\n\n\n在服务器我们也要做相应的配置 如果发送请求的浏览器支持gzip，就发送给它gzip格式的文件 我的服务器是用express框架搭建的\n只要安装一下compression就能使用\n\n\n\n\n使用 SSR#\n\nSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成 html 字符串，再发送到浏览器\n\n从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染\n\n\n小结#\n\n减少首屏渲染时间的方法有很多，总的来讲可以分成两大部分 ：资源加载优化 和 页面渲染优化\n\n下图是更为全面的首屏优化的方案\n\n\n\n大家可以根据自己项目的情况选择各种方式进行首屏渲染的优化\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/88639980?utm_source=wechat_session\n * https://www.chengrang.com/how-browsers-work.html\n * https://juejin.cn/post/6844904185264095246\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/first_page_time","lang":"","toc":[{"text":"一、什么是首屏加载","id":"一什么是首屏加载","depth":2,"charIndex":5},{"text":"关于计算首屏时间","id":"关于计算首屏时间","depth":3,"charIndex":132},{"text":"二、加载慢的原因","id":"二加载慢的原因","depth":2,"charIndex":215},{"text":"三、解决方案","id":"三解决方案","depth":2,"charIndex":315},{"text":"减小入口文件体积","id":"减小入口文件体积","depth":3,"charIndex":425},{"text":"静态资源本地缓存","id":"静态资源本地缓存","depth":3,"charIndex":592},{"text":"UI 框架按需加载","id":"ui-框架按需加载","depth":3,"charIndex":712},{"text":"组件重复打包","id":"组件重复打包","depth":3,"charIndex":813},{"text":"图片资源的压缩","id":"图片资源的压缩","depth":3,"charIndex":971},{"text":"开启 GZip 压缩","id":"开启-gzip-压缩","depth":3,"charIndex":1097},{"text":"使用 SSR","id":"使用-ssr","depth":3,"charIndex":1288},{"text":"小结","id":"小结","depth":3,"charIndex":1398},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1499}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-SPA首屏加载速度慢的怎么解决？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>SPA首屏加载速度慢的怎么解决？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-SPA首屏加载速度慢的怎么解决？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"SPA首屏加载速度慢的怎么解决？"}]]},"version":""},{"id":230,"title":"v-if 和 v-for 的优先级是什么？","content":"#\n\n\n\n\n一、作用#\n\nv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染\n\nv-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而\nitem 则是被迭代的数组元素的别名\n\n在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化\n\n两者在用法上\n\n\n\n\n二、优先级#\n\nv-if与v-for都是vue模板系统中的指令\n\n在vue模板编译的时候，会将指令系统转化成可执行的render函数\n\n\n示例#\n\n编写一个p标签，同时使用v-if与 v-for\n\n\n\n创建vue实例，存放isShow与items数据\n\n\n\n模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数\n\n\n\n_l是vue的列表渲染函数，函数内部都会进行一次if判断\n\n初步得到结论：v-for优先级是比v-if高\n\n再将v-for与v-if置于不同标签\n\n\n\n再输出下render函数\n\n\n\n这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染\n\n我们再在查看下vue源码\n\n源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js\n\n\n\n在进行if判断的时候，v-for是比v-if先进行判断\n\n最终结论：v-for优先级比v-if高\n\n\n三、注意事项#\n\n 1. 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）\n 2. 如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行 v-if 判断，然后在内部进行 v-for 循环\n\n\n\n 3. 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项\n\n","routePath":"/interview/vue/if_for","lang":"","toc":[{"text":"一、作用","id":"一作用","depth":2,"charIndex":5},{"text":"二、优先级","id":"二优先级","depth":2,"charIndex":224},{"text":"示例","id":"示例","depth":3,"charIndex":293},{"text":"三、注意事项","id":"三注意事项","depth":2,"charIndex":659}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-v-if 和 v-for 的优先级是什么？","footer":"v-if 和 v-for 的优先级是什么？","order":22,"star":22,"date":"2023-04-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-v-if 和 v-for 的优先级是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"v-if 和 v-for 的优先级是什么？"}]]},"version":""},{"id":231,"title":"前端物语|面试物语-vue","content":" * vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？\n * Vue 项目中有封装过 axios 吗？主要是封装哪方面的？\n * 你了解 axios 的原理吗？有看过它的源码吗？\n * 双向数据绑定是什么\n * Vue 组件之间的通信方式都有哪些？\n * Vue 中组件和插件有什么区别？\n * Vue 项目中你是如何解决跨域的呢？\n * 为什么 data 属性是一个函数而不是一个对象？\n * 动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？\n * 你了解 vue 的 diff 算法吗？说说看 ,- 你是怎么处理 vue 项目中的错误的？\n * Vue 中的过滤器了解吗？过滤器的应用场景有哪些？\n * SPA 首屏加载速度慢的怎么解决？\n * v-if 和 v-for 的优先级是什么？\n * 说说你对 keep-alive 的理解是什么？\n * 你知道 vue 中 key 的原理吗？说说你对它的理解\n * 请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？\n * 说说你对 vue 的 mixin 的理解，有什么应用场景？\n * Vue 常用的修饰符有哪些有什么应用场景\n * Vue 实例挂载的过程\n * Vue 中的$nextTick 有什么作用？\n * Vue.observable 你有了解过吗？说说看\n * vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\n * v-show 和 v-if 有什么区别？使用场景分别是什么？\n * 你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢\n * SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？\n * 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？\n * 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路\n * vue3 有了解过吗？能说说跟 vue2 的区别吗？","routePath":"/interview/vue/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"vue","tag":"vue","title":"前端物语|面试物语-vue","index":false,"dir":{"order":1},"date":"2023-04-17T00:00:00.000Z"},"version":""},{"id":232,"title":"说说你对 keep-alive 的理解是什么？","content":"#\n\n\n\n\n一、Keep-alive 是什么#\n\nkeep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM\n\nkeep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们\n\nkeep-alive可以设置以下props属性：\n\n * include - 字符串或正则表达式。只有名称匹配的组件会被缓存\n\n * exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存\n\n * max - 数字。最多可以缓存多少组件实例\n\n关于keep-alive的基本用法：\n\n\n\n使用includes和exclude：\n\n\n\n匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配\n\n设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：\n\n * 首次进入组件时：beforeRouteEnter > beforeCreate > created> mounted > activated > ...\n   ... > beforeRouteLeave > deactivated\n\n * 再次进入组件时：beforeRouteEnter >activated > ... ... > beforeRouteLeave >\n   deactivated\n\n\n二、使用场景#\n\n使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive\n\n举个栗子:\n\n当我们从首页–>列表页–>商详页–>再返回，这时候列表页应该是需要keep-alive\n\n从首页–>列表页–>商详页–>返回到列表页(需要缓存)–>返回到首页(需要缓存)–>再次进入列表页(不需要缓存)，这时候可以按需来控制页面的keep-alive\n\n在路由中设置keepAlive属性判断是否需要缓存\n\n\n\n使用\n\n\n\n\n三、原理分析#\n\nkeep-alive是vue中内置的一个组件\n\n源码位置：src/core/components/keep-alive.js\n\n\n\n可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数\n\nthis.cache是一个对象，用来存储需要缓存的组件，它将以如下形式存储：\n\n\n\n在组件销毁的时候执行pruneCacheEntry函数\n\n\n\n在mounted钩子函数中观测 include 和 exclude 的变化，如下：\n\n\n\n如果include 或exclude\n发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下：\n\n\n\n在该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则\n调用pruneCacheEntry函数将其从this.cache对象剔除即可\n\n关于keep-alive的最强大缓存功能是在render函数中实现\n\n首先获取组件的key值：\n\n\n\n拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：\n\n\n\n直接从缓存中拿 vnode 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在this.keys中最后一个\n\nthis.cache对象中没有该key值的情况，如下：\n\n\n\n表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache中，并且把key存入this.keys中\n\n此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值this.max，如果超过了，则把第一个缓存组件删掉\n\n\n四、思考题：缓存后如何获取数据#\n\n解决方案可以有以下两种：\n\n * beforeRouteEnter\n\n * actived\n\n\nbeforeRouteEnter#\n\n每次组件渲染的时候，都会执行beforeRouteEnter\n\n\n\n\nactived#\n\n在keep-alive缓存的组件被激活的时候，都会执行actived钩子\n\n\n\n注意：服务器端渲染期间avtived不被调用\n\n\n参考文献#\n\n * https://www.cnblogs.com/dhui/p/13589401.html\n * https://www.cnblogs.com/wangjiachen666/p/11497200.html\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/keepalive","lang":"","toc":[{"text":"一、Keep-alive 是什么","id":"一keep-alive-是什么","depth":2,"charIndex":5},{"text":"二、使用场景","id":"二使用场景","depth":2,"charIndex":636},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":857},{"text":"四、思考题：缓存后如何获取数据","id":"四思考题缓存后如何获取数据","depth":2,"charIndex":1651},{"text":"beforeRouteEnter","id":"beforerouteenter","depth":3,"charIndex":1717},{"text":"actived","id":"actived","depth":3,"charIndex":1771},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1846}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 keep-alive 的理解是什么？","footer":"说说你对 keep-alive 的理解是什么？","order":25,"star":25,"date":"2023-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-说说你对 keep-alive 的理解是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 keep-alive 的理解是什么？"}]]},"version":""},{"id":233,"title":"你知道 vue 中 key 的原理吗？说说你对它的理解","content":"{{item}}","routePath":"/interview/vue/key","lang":"","toc":[{"text":"一、Key 是什么","id":"一key-是什么","depth":2,"charIndex":-1},{"text":"场景背后的逻辑","id":"场景背后的逻辑","depth":3,"charIndex":-1},{"text":"二、设置 key 与不设置 key 区别","id":"二设置-key-与不设置-key-区别","depth":2,"charIndex":-1},{"text":"设置 key 值一定能提高 diff 效率吗？","id":"设置-key-值一定能提高-diff-效率吗","depth":3,"charIndex":-1},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你知道 vue 中 key 的原理吗？说说你对它的理解","footer":"你知道 vue 中 key 的原理吗？说说你对它的理解","order":28,"star":28,"date":"2023-04-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你知道 vue 中 key 的原理吗？说说你对它的理解","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你知道 vue 中 key 的原理吗？说说你对它的理解"}]]},"version":""},{"id":234,"title":"请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？","content":"#\n\n\n\n\n一、生命周期是什么#\n\n生命周期（Life\nCycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave\n）的整个过程在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 →\n渲染、卸载等一系列过程我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作\nPS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property\n和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())\n\n\n二、生命周期有哪些#\n\nVue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期\n\n生命周期            描述\nbeforeCreate    组件实例被创建之初\ncreated         组件实例已经完全创建\nbeforeMount     组件挂载之前\nmounted         组件挂载到实例上去之后\nbeforeUpdate    组件数据发生变化，更新之前\nupdated         组件数据更新之后\nbeforeDestroy   组件实例销毁之前\ndestroyed       组件实例销毁之后\nactivated       keep-alive 缓存的组件激活时\ndeactivated     keep-alive 缓存的组件停用时调用\nerrorCaptured   捕获一个来自子孙组件的错误时被调用\n\n\n三、生命周期整体流程#\n\nVue生命周期流程图\n\n\n\n具体分析#\n\nbeforeCreate -> created\n\n * 初始化vue实例，进行数据观测\n\ncreated\n\n * 完成数据观测，属性与方法的运算，watch、event事件回调的配置\n * 可调用methods中的方法，访问和修改 data 数据触发响应式渲染dom，可通过computed和watch完成数据计算\n * 此时vm.$el 并没有被创建\n\ncreated -> beforeMount\n\n * 判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译\n * 优先级：render > template > outerHTML\n * vm.el获取到的是挂载DOM的\n\nbeforeMount\n\n * 在此阶段可获取到vm.el\n * 此阶段vm.el虽已完成 DOM 初始化，但并未挂载在el选项上\n\nbeforeMount -> mounted\n\n * 此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM\n\nmounted\n\n * vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的 DOM\n\nbeforeUpdate\n\n * 更新的数据必须是被渲染在模板上的（el、template、render之一）\n * 此时view层还未更新\n * 若在beforeUpdate中再次修改数据，不会再次触发更新方法\n\nupdated\n\n * 完成view层的更新\n * 若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）\n\nbeforeDestroy\n\n * 实例被销毁前调用，此时实例属性与方法仍可访问\n\ndestroyed\n\n * 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器\n * 并不能清除 DOM，仅仅销毁实例\n\n使用场景分析\n\n生命周期            描述\nbeforeCreate    执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务\ncreated         组件初始化完毕，各种数据可以使用，常用于异步数据获取\nbeforeMount     未执行渲染、更新，dom 未创建\nmounted         初始化结束，dom 已创建，可用于获取访问数据和 dom 元素\nbeforeUpdate    更新前，可用于获取更新前各种状态\nupdated         更新后，所有状态已是最新\nbeforeDestroy   销毁前，可用于一些定时器或订阅的取消\ndestroyed       组件已销毁，作用同上\n\n\n四、题外话：数据请求在 created 和 mouted 的区别#\n\ncreated是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成；mounted是在页面dom节点渲染完毕之后就立刻执行的。触发时机上crea\nted是比mounted要更早的，两者的相同点：都能拿到实例对象的属性和方法。讨论这个问题本质就是触发的时机，放在mounted中的请求有可能导致页面闪动（因为\n此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。\n\n\n参考文献#\n\n * https://juejin.cn/post/6844903811094413320\n * https://baike.baidu.com/\n * http://cn.vuejs.org/\n\n面试官 VUE 系列总进度：4／33\n\n说说你对 vue 的理解?\n\n说说你对 SPA（单页应用）的理解?\n\n说说你对双向绑定的理解?","routePath":"/interview/vue/lifecycle","lang":"","toc":[{"text":"一、生命周期是什么","id":"一生命周期是什么","depth":2,"charIndex":5},{"text":"二、生命周期有哪些","id":"二生命周期有哪些","depth":2,"charIndex":367},{"text":"三、生命周期整体流程","id":"三生命周期整体流程","depth":2,"charIndex":776},{"text":"具体分析","id":"具体分析","depth":4,"charIndex":803},{"text":"四、题外话：数据请求在 created 和 mouted 的区别","id":"四题外话数据请求在-created-和-mouted-的区别","depth":2,"charIndex":1940},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2204}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？","footer":"请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？","order":19,"star":19,"date":"2023-04-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"请描述下你对 vue 生命周期的理解？在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？"}]]},"version":""},{"id":235,"title":"说说你对 vue 的 mixin 的理解，有什么应用场景？","content":"#\n\n\n\n\n一、mixin 是什么#\n\nMixin是面向对象程序设计语言中的类，提供了方法的实现。其他类可以访问mixin类的方法而不必成为其子类\n\nMixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用又避免了多继承的复杂\n\n\nVue 中的 mixin#\n\n先来看一下官方定义\n\n> mixin（混入），提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。\n\n本质其实就是一个js对象，它可以包含我们组件中任意功能选项，如data、components、methods、created、computed等等\n\n我们只要将共用的功能以对象的方式传入 mixins选项中，当组件使用 mixins对象时所有mixins对象的选项都将被混入该组件本身的选项中来\n\n在Vue中我们可以局部混入跟全局混入\n\n\n局部混入#\n\n定义一个mixin对象，有组件options的data、methods属性\n\n\n\n组件通过mixins属性调用mixin对象\n\n\n\n该组件在使用的时候，混合了mixin里面的方法，在自动执行created生命钩子，执行hello方法\n\n\n全局混入#\n\n通过Vue.mixin()进行全局的混入\n\n\n\n使用全局混入需要特别注意，因为它会影响到每一个组件实例（包括第三方组件）\n\nPS：全局混入常用于插件的编写\n\n\n注意事项#\n\n当组件存在与mixin对象相同的选项的时候，进行递归合并的时候组件的选项会覆盖mixin的选项\n\n但是如果相同选项为生命周期钩子的时候，会合并成一个数组，先执行mixin的钩子，再执行组件的钩子\n\n\n二、使用场景#\n\n在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立\n\n这时，可以通过Vue的mixin功能将相同或者相似的代码提出来\n\n举个例子\n\n定义一个modal弹窗组件，内部通过isShowing来控制显示\n\n\n\n定义一个tooltip提示框，内部通过isShowing来控制显示\n\n\n\n通过观察上面两个组件，发现两者的逻辑是相同，代码控制显示也是相同的，这时候mixin就派上用场了\n\n首先抽出共同代码，编写一个mixin\n\n\n\n两个组件在使用上，只需要引入mixin\n\n\n\n通过上面小小的例子，让我们知道了Mixin对于封装一些可复用的功能如此有趣、方便、实用\n\n\n三、源码分析#\n\n首先从Vue.mixin入手\n\n源码位置：/src/core/global-api/mixin.js\n\n\n\n主要是调用merOptions方法\n\n源码位置：/src/core/util/options.js\n\n\n\n从上面的源码，我们得到以下几点：\n\n * 优先递归处理 mixins\n * 先遍历合并parent 中的key，调用mergeField方法进行合并，然后保存在变量options\n * 再遍历 child，合并补上 parent 中没有的key，调用mergeField方法进行合并，保存在变量options\n * 通过 mergeField 函数进行了合并\n\n下面是关于Vue的几种类型的合并策略\n\n * 替换型\n * 合并型\n * 队列型\n * 叠加型\n\n\n替换型#\n\n替换型合并有props、methods、inject、computed\n\n\n\n同名的props、methods、inject、computed会被后来者代替\n\n\n合并型#\n\n和并型合并有：data\n\n\n\nmergeData函数遍历了要合并的 data 的所有属性，然后根据不同情况进行合并：\n\n * 当目标 data 对象不包含当前属性时，调用 set 方法进行合并（set 方法其实就是一些合并重新赋值的方法）\n * 当目标 data 对象包含当前属性并且当前值为纯对象时，递归合并当前对象值，这样做是为了防止对象存在新增属性\n\n\n队列性#\n\n队列性合并有：全部生命周期和watch\n\n\n\n生命周期钩子和watch被合并为一个数组，然后正序遍历一次执行\n\n\n叠加型#\n\n叠加型合并有：component、directives、filters\n\n\n\n叠加型主要是通过原型链进行层层的叠加\n\n\n小结#\n\n * 替换型策略有props、methods、inject、computed，就是将新的同名参数替代旧的参数\n * 合并型策略是data, 通过set方法进行合并和重新赋值\n * 队列型策略有生命周期函数和watch，原理是将函数存入一个数组，然后正序遍历依次执行\n * 叠加型有component、directives、filters，通过原型链进行层层的叠加\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/31018570\n * https://juejin.cn/post/6844904015495446536#heading-1\n * https://juejin.cn/post/6844903846775357453\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/mixin","lang":"","toc":[{"text":"一、mixin 是什么","id":"一mixin-是什么","depth":2,"charIndex":5},{"text":"Vue 中的 mixin","id":"vue-中的-mixin","depth":3,"charIndex":123},{"text":"局部混入","id":"局部混入","depth":3,"charIndex":364},{"text":"全局混入","id":"全局混入","depth":3,"charIndex":490},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":577},{"text":"二、使用场景","id":"二使用场景","depth":2,"charIndex":684},{"text":"三、源码分析","id":"三源码分析","depth":2,"charIndex":1000},{"text":"替换型","id":"替换型","depth":3,"charIndex":1347},{"text":"合并型","id":"合并型","depth":3,"charIndex":1434},{"text":"队列性","id":"队列性","depth":3,"charIndex":1620},{"text":"叠加型","id":"叠加型","depth":3,"charIndex":1683},{"text":"小结","id":"小结","depth":3,"charIndex":1749},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1938}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 vue 的 mixin 的理解，有什么应用场景？","footer":"说说你对 vue 的 mixin 的理解，有什么应用场景？","order":10,"star":10,"date":"2023-03-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-说说你对 vue 的 mixin 的理解，有什么应用场景？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 vue 的 mixin 的理解，有什么应用场景？"}]]},"version":""},{"id":236,"title":"Vue 常用的修饰符有哪些有什么应用场景","content":"#\n\n\n\n\n一、修饰符是什么#\n\n在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号\n\n在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理\n\nvue中修饰符分为以下五种：\n\n * 表单修饰符\n * 事件修饰符\n * 鼠标按键修饰符\n * 键值修饰符\n * v-bind 修饰符\n\n\n二、修饰符的作用#\n\n\n表单修饰符#\n\n在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model\n\n关于表单的修饰符有如下：\n\n * lazy\n * trim\n * number\n\nlazy#\n\n在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步\n\n\n\ntrim#\n\n自动过滤用户输入的首空格字符，而中间的空格不会过滤\n\n\n\nnumber#\n\n自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值\n\n\n\n\n事件修饰符#\n\n事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符：\n\n * stop\n * prevent\n * self\n * once\n * capture\n * passive\n * native\n\nstop#\n\n阻止了事件冒泡，相当于调用了event.stopPropagation方法\n\n\n\nprevent#\n\n阻止了事件的默认行为，相当于调用了event.preventDefault方法\n\n\n\nself#\n\n只当在 event.target 是当前元素自身时触发处理函数\n\n\n\n> 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而\n> v-on:click.self.prevent 只会阻止对元素自身的点击\n\nonce#\n\n绑定了事件以后只能触发一次，第二次就不会触发\n\n\n\ncapture#\n\n使事件触发从包含这个元素的顶层开始往下触发\n\n\n\npassive#\n\n在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.\nlazy修饰符\n\n\n\n> 不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。\n> \n> passive 会告诉浏览器你不想阻止事件的默认行为\n\nnative#\n\n让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件\n\n\n\n> 使用.native 修饰符来操作普通 HTML 标签是会令事件失效的\n\n\n鼠标按钮修饰符#\n\n鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：\n\n * left 左键点击\n * right 右键点击\n * middle 中键点击\n\n\n\n\n键盘修饰符#\n\n键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：\n\nkeyCode存在很多，但vue为我们提供了别名，分为以下两种：\n\n * 普通键（enter、tab、delete、space、esc、up...）\n * 系统修饰键（ctrl、alt、meta、shift...）\n\n\n\n还可以通过以下方式自定义一些全局的键盘码别名\n\n\n\n\nv-bind 修饰符#\n\nv-bind 修饰符主要是为属性进行操作，用来分别有如下：\n\n * async\n * prop\n * camel\n\nasync#\n\n能对props进行一个双向绑定\n\n\n\n以上这种方法相当于以下的简写\n\n\n\n使用async需要注意以下两点：\n\n * 使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致\n\n * 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用\n\n * 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的\n\nprops#\n\n设置自定义标签属性，避免暴露数据，防止污染 HTML 结构\n\n\n\ncamel#\n\n将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox\n\n\n\n\n三、应用场景#\n\n根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景：\n\n * .stop：阻止事件冒泡\n * .native：绑定原生事件\n * .once：事件只执行一次\n * .self ：将事件绑定在自身身上，相当于阻止事件冒泡\n * .prevent：阻止默认事件\n * .caption：用于事件捕获\n * .once：只触发一次\n * .keyCode：监听特定键盘按下\n * .right：右键\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000016786254\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue/modifier","lang":"","toc":[{"text":"一、修饰符是什么","id":"一修饰符是什么","depth":2,"charIndex":5},{"text":"二、修饰符的作用","id":"二修饰符的作用","depth":2,"charIndex":186},{"text":"表单修饰符","id":"表单修饰符","depth":3,"charIndex":198},{"text":"lazy","id":"lazy","depth":4,"charIndex":288},{"text":"trim","id":"trim","depth":4,"charIndex":351},{"text":"number","id":"number","depth":4,"charIndex":387},{"text":"事件修饰符","id":"事件修饰符","depth":3,"charIndex":447},{"text":"stop","id":"stop","depth":4,"charIndex":553},{"text":"prevent","id":"prevent","depth":4,"charIndex":601},{"text":"self","id":"self","depth":4,"charIndex":654},{"text":"once","id":"once","depth":4,"charIndex":806},{"text":"capture","id":"capture","depth":4,"charIndex":839},{"text":"passive","id":"passive","depth":4,"charIndex":874},{"text":"native","id":"native","depth":4,"charIndex":1076},{"text":"鼠标按钮修饰符","id":"鼠标按钮修饰符","depth":3,"charIndex":1177},{"text":"键盘修饰符","id":"键盘修饰符","depth":3,"charIndex":1262},{"text":"v-bind 修饰符","id":"v-bind-修饰符","depth":3,"charIndex":1449},{"text":"async","id":"async","depth":4,"charIndex":1520},{"text":"props","id":"props","depth":4,"charIndex":1769},{"text":"camel","id":"camel","depth":4,"charIndex":1810},{"text":"三、应用场景","id":"三应用场景","depth":2,"charIndex":1858},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2069}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 常用的修饰符有哪些有什么应用场景","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>Vue 常用的修饰符有哪些有什么应用场景","order":5,"star":5,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 常用的修饰符有哪些有什么应用场景","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 常用的修饰符有哪些有什么应用场景"}]]},"version":""},{"id":237,"title":"Vue 实例挂载的过程","content":"- mount to normal elements instead.`); return this; } const options =\nthis.$options; // resolve template/el and convert to render function if\n(!options.render) { let template = options.template; // 存在template模板，解析vue模板文件\nif (template) { if (typeof template === 'string') { if (template.charAt(0) ===\n'#') { template = idToTemplate(template); /* istanbul ignore if */ if\n(process.env.NODE_ENV !== 'production' && !template) { warn(`Template element\nnot found or is empty: ${options.template}`, this); } } } else if\n(template.nodeType) { template = template.innerHTML; } else { if\n(process.env.NODE_ENV !== 'production') { warn('invalid template option:' +\ntemplate, this); } return this; } } else if (el) { // 通过选择器获取元素内容 template =\ngetOuterHTML(el); } if (template) { /* istanbul ignore if */ if\n(process.env.NODE_ENV !== 'production' && config.performance && mark) {\nmark('compile'); } /** * 1.将temmplate解析ast tree * 2.将ast tree转换成render语法字符串 *\n3.生成render方法 */ const { render, staticRenderFns } = compileToFunctions(\ntemplate, { outputSourceRange: process.env.NODE_ENV !== 'production',\nshouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters:\noptions.delimiters, comments: options.comments, }, this ); options.render =\nrender; options.staticRenderFns = staticRenderFns; /* istanbul ignore if */ if\n(process.env.NODE_ENV !== 'production' && config.performance && mark) {\nmark('compile end'); measure(`vue ${this._name} compile`, 'compile', 'compile\nend'); } } } return mount.call(this, el, hydrating); };","routePath":"/interview/vue/new_vue","lang":"","toc":[{"text":"一、思考","id":"一思考","depth":2,"charIndex":-1},{"text":"一、分析","id":"一分析","depth":2,"charIndex":-1},{"text":"三、结论","id":"三结论","depth":2,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 实例挂载的过程","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>Vue 实例挂载的过程","order":6,"star":6,"date":"2023-03-05T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 实例挂载的过程","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 实例挂载的过程"}]]},"version":""},{"id":238,"title":"Vue 中的$nextTick 有什么作用？","content":"#\n\n\n\n\n一、NextTick 是什么#\n\n官方对其的定义\n\n> 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n什么意思呢？\n\n我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新\n\n举例一下\n\nHtml结构\n\n\n\n构建一个vue实例\n\n\n\n修改message\n\n\n\n这时候想获取页面最新的DOM节点，却发现获取到的是旧值\n\n\n\n这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中\n\n如果我们一直修改相同数据，异步操作队列还会进行去重\n\n等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新\n\n为什么要有 nexttick#\n\n举个例子\n\n\n\n如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新 10\n万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略\n\n\n二、使用场景#\n\n如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick()\n\n第一个参数为：回调函数（可以获取最近的DOM结构）\n\n第二个参数为：执行函数上下文\n\n\n\n组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上\n\n\n\n$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情\n\n\n\n\n三、实现原理#\n\n源码位置：/src/core/util/next-tick.js\n\ncallbacks也就是异步操作队列\n\ncallbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次\n\n\n\ntimerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有：\n\nPromise.then、MutationObserver、setImmediate、setTimeout\n\n通过上面任意一种方法，进行降级操作\n\n\n\n无论是微任务还是宏任务，都会放到flushCallbacks使用\n\n这里将callbacks里面的函数复制一份，同时callbacks置空\n\n依次执行callbacks里面的函数\n\n\n\n小结：\n\n 1. 把回调函数放入 callbacks 等待执行\n 2. 将执行函数放到微任务或者宏任务中\n 3. 事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调\n\n\n参考文献#\n\n * https://juejin.cn/post/6844904147804749832","routePath":"/interview/vue/nexttick","lang":"","toc":[{"text":"一、NextTick 是什么","id":"一nexttick-是什么","depth":2,"charIndex":5},{"text":"为什么要有 nexttick","id":"为什么要有-nexttick","depth":4,"charIndex":378},{"text":"二、使用场景","id":"二使用场景","depth":2,"charIndex":508},{"text":"三、实现原理","id":"三实现原理","depth":2,"charIndex":746},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1178}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue 中的$nextTick 有什么作用？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>Vue 中的$nextTick 有什么作用？","order":3,"star":3,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue 中的$nextTick 有什么作用？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue 中的$nextTick 有什么作用？"}]]},"version":""},{"id":239,"title":"Vue.observable 你有了解过吗？说说看","content":"#\n\n\n\n\n一、Observable 是什么#\n\nObservable 翻译过来我们可以理解成可观察的\n\n我们先来看一下其在Vue中的定义\n\n> Vue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象\n\n返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器\n\n\n\n其作用等同于\n\n\n\n在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象\n\n在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的\n\n\n二、使用场景#\n\n在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择\n\n创建一个js文件\n\n\n\n在.vue文件中直接使用即可\n\n\n\n\n三、原理分析#\n\n源码位置：src\\core\\observer\\index.js\n\n\n\nObserver类\n\n\n\nwalk函数\n\n\n\ndefineReactive方法\n\n\n\n\n参考文献#\n\n * https://blog.csdn.net/qq_32682301/article/details/105419673\n * https://wbbyouzi.com/archives/343","routePath":"/interview/vue/observable","lang":"","toc":[{"text":"一、Observable 是什么","id":"一observable-是什么","depth":2,"charIndex":5},{"text":"二、使用场景","id":"二使用场景","depth":2,"charIndex":301},{"text":"三、原理分析","id":"三原理分析","depth":2,"charIndex":420},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":508}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue.observable 你有了解过吗？说说看","footer":"Vue.observable 你有了解过吗？说说看","order":14,"star":14,"date":"2023-03-18T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-Vue.observable 你有了解过吗？说说看","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue.observable 你有了解过吗？说说看"}]]},"version":""},{"id":240,"title":"vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？","content":"#\n\n\n\n\n一、是什么#\n\n权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源\n\n而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发\n\n * 页面加载触发\n * 页面上的按钮点击触发\n\n总的来说，所有的请求发起都触发自前端路由或视图\n\n所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：\n\n * 路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页\n\n * 视图方面，用户只能看到自己有权浏览的内容和有权操作的控件\n\n * 最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截\n\n\n二、如何做#\n\n前端权限控制可以分为四个方面：\n\n * 接口权限\n * 按钮权限\n * 菜单权限\n * 路由权限\n\n\n接口权限#\n\n接口权限目前一般采用jwt的形式来验证，没有通过的话一般返回401，跳转到登录页面重新进行登录\n\n登录完拿到token，将token存起来，通过axios请求拦截器进行拦截，每次请求的时候头部携带token\n\n\n\n\n路由权限控制#\n\n方案一\n\n初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验\n\n\n\n这种方式存在以下四种缺点：\n\n * 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。\n\n * 全局路由守卫里，每次路由跳转都要做权限判断。\n\n * 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n\n * 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n方案二\n\n初始化的时候先挂载不需要权限控制的路由，比如登录页，404 等错误页。如果用户通过 URL 进行强制访问，则会直接进入 404，相当于从源头上做了控制\n\n登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用addRoutes添加路由\n\n\n\n按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限\n\n这种方式也存在了以下的缺点：\n\n * 全局路由守卫里，每次路由跳转都要做判断\n * 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译\n * 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识\n\n\n菜单权限#\n\n菜单权限可以理解成将页面与理由进行解耦\n\n方案一#\n\n菜单与路由分离，菜单由后端返回\n\n前端定义路由信息\n\n\n\nname字段都不为空，需要根据此字段与后端返回菜单做关联，后端返回的菜单信息中必须要有name对应的字段，并且做唯一性校验\n\n全局路由守卫里做判断\n\n\n\n每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的，而后端返回的菜单就已经是经过权限过滤的\n\n如果根据路由name找不到对应的菜单，就表示用户有没权限访问\n\n如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态\n挂载\n\n这种方式的缺点：\n\n * 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用\n * 全局路由守卫里，每次路由跳转都要做判断\n\n方案二#\n\n菜单和路由都由后端返回\n\n前端统一定义路由组件\n\n\n\n后端路由组件返回以下格式\n\n\n\n在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件\n\n如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理\n\n这种方法也会存在缺点：\n\n * 全局路由守卫里，每次路由跳转都要做判断\n * 前后端的配合要求更高\n\n\n按钮权限#\n\n方案一#\n\n按钮权限也可以用v-if判断\n\n但是如果页面过多，每个页面页面都要获取用户权限role和路由表里的meta.btnPermissions，然后再做判断\n\n这种方式就不展开举例了\n\n方案二#\n\n通过自定义指令进行按钮权限的判断\n\n首先配置路由\n\n\n\n自定义权限鉴定指令\n\n\n\n在使用的按钮中只需要引用v-has指令\n\n\n\n\n小结#\n\n关于权限如何选择哪种合适的方案，可以根据自己项目的方案项目，如考虑路由与菜单是否分离\n\n权限需要前后端结合，前端尽可能的去控制，更多的需要后台判断\n\n\n参考文献#\n\n * https://mp.weixin.qq.com/s/b-D2eH1mLwL_FkaZwjueSw\n * https://segmentfault.com/a/1190000020887109\n * https://juejin.cn/post/6844903648057622536#heading-6","routePath":"/interview/vue/permission","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":341},{"text":"接口权限","id":"接口权限","depth":3,"charIndex":400},{"text":"路由权限控制","id":"路由权限控制","depth":3,"charIndex":515},{"text":"菜单权限","id":"菜单权限","depth":3,"charIndex":1086},{"text":"方案一","id":"方案一","depth":4,"charIndex":1114},{"text":"方案二","id":"方案二","depth":4,"charIndex":1511},{"text":"按钮权限","id":"按钮权限","depth":3,"charIndex":1714},{"text":"方案一","id":"方案一-1","depth":4,"charIndex":1721},{"text":"方案二","id":"方案二-1","depth":4,"charIndex":1817},{"text":"小结","id":"小结","depth":3,"charIndex":1888},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1969}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？","footer":"vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？","order":13,"star":13,"date":"2023-03-16T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"}]]},"version":""},{"id":241,"title":"v-show 和 v-if 有什么区别？使用场景分别是什么？","content":"#\n\n\n\n\n一、v-show 与 v-if 的共同点#\n\n我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含 v-else)，都能控制元素在页面是否显示\n\n在用法上也是相同的\n\n\n\n * 当表达式为true的时候，都会占据页面的位置\n * 当表达式都为false时，都不会占据页面位置\n\n\n二、v-show 与 v-if 的区别#\n\n * 控制手段不同\n * 编译过程不同\n * 编译条件不同\n\n控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除\n\n编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于 css 切换\n\n编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染\n\n * v-show 由false变为true的时候不会触发组件的生命周期\n\n * v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为fal\n   se的时候触发组件的beforeDestory、destoryed方法\n\n性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n\n\n三、v-show 与 v-if 原理分析#\n\n具体解析流程这里不展开讲，大致流程如下\n\n * 将模板template转为ast结构的JS对象\n * 用ast得到的JS对象拼装render和staticRenderFns函数\n * render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息\n * vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点\n\n\nv-show 原理#\n\n不管初始条件是什么，元素总是会被渲染\n\n我们看一下在vue中是如何实现的\n\n代码很好理解，有transition就执行transition，没有就直接设置display属性\n\n\n\n\nv-if 原理#\n\nv-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分\n\n返回一个node节点，render函数通过表达式的值来决定是否生成DOM\n\n\n\n\n四、v-show 与 v-if 的使用场景#\n\nv-if 与 v-show 都能控制dom元素在页面的显示\n\nv-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）\n\n如果需要非常频繁地切换，则使用 v-show 较好\n\n如果在运行时条件很少改变，则使用 v-if 较好\n\n\n参考文献#\n\n * https://www.jianshu.com/p/7af8554d8f08\n * https://juejin.cn/post/6897948855904501768\n * https://vue3js/docs/zh","routePath":"/interview/vue/show_if","lang":"","toc":[{"text":"一、v-show 与 v-if 的共同点","id":"一v-show-与-v-if-的共同点","depth":2,"charIndex":5},{"text":"二、v-show 与 v-if 的区别","id":"二v-show-与-v-if-的区别","depth":2,"charIndex":158},{"text":"三、v-show 与 v-if 原理分析","id":"三v-show-与-v-if-原理分析","depth":2,"charIndex":630},{"text":"v-show 原理","id":"v-show-原理","depth":3,"charIndex":845},{"text":"v-if 原理","id":"v-if-原理","depth":3,"charIndex":948},{"text":"四、v-show 与 v-if 的使用场景","id":"四v-show-与-v-if-的使用场景","depth":2,"charIndex":1071},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1218}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-v-show 和 v-if 有什么区别？使用场景分别是什么？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>v-show 和 v-if 有什么区别？使用场景分别是什么？","order":7,"star":7,"date":"2023-03-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-v-show 和 v-if 有什么区别？使用场景分别是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"v-show 和 v-if 有什么区别？使用场景分别是什么？"}]]},"version":""},{"id":242,"title":"你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢","content":"#\n\n\n\n\n一、什么是 SPA#\n\nSPA（single-page\napplication），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在\n单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页\n面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内\n容，而杯子始终是那个杯子结构如下图\n\n\n\n我们熟知的 JS 框架如react,vue,angular,ember都属于SPA\n\n\n二、SPA 和 MPA 的区别#\n\n上面大家已经对单页面有所了解了，下面来讲讲多页应用 MPA（MultiPage-page\napplication），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文\n件，公共文件则根据需求按需加载如下图\n\n\n\n单页应用与多页应用的区别#\n\n             单页面应用（SPA）         多页面应用（MPA）\n组成           一个主页面和多个页面片段       多个主页面\n刷新方式         局部刷新               整页刷新\nurl 模式       哈希模式               历史模式\nSEO 搜索引擎优化   难实现，可使用 SSR 方式改善   容易实现\n数据传递         容易                 通过 url、cookie、localStorage 等传递\n页面切换         速度快，用户体验良好         切换加载资源，速度慢，用户体验差\n维护成本         相对容易               相对复杂\n\n单页应用优缺点#\n\n优点：\n\n * 具有桌面应用的即时性、网站的可移植性和可访问性\n * 用户体验好、快，内容的改变不需要重新加载整个页面\n * 良好的前后端分离，分工更明确\n\n缺点：\n\n * 不利于搜索引擎的抓取\n * 首次渲染速度相对较慢\n * \n\n\n三、实现一个 SPA#\n\n原理#\n\n 1. 监听地址栏中hash变化驱动界面变化\n 2. 用pushsate记录浏览器的历史，驱动界面发送变化\n\n\n\n实现#\n\nhash 模式#\n\n核心通过监听url中的hash来进行路由跳转\n\n\n\nhistory 模式#\n\nhistory 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的 api\n\n * history.pushState 浏览器历史纪录添加记录\n * history.replaceState修改浏览器历史纪录中当前纪录\n * history.popState 当 history 发生变化时触发\n\n\n\n\n四、题外话：如何给 SPA 做 SEO#\n\n下面给出基于Vue的SPA如何实现SEO的三种方式\n\n 1. SSR 服务端渲染\n\n将组件或页面通过服务器生成 html，再返回给浏览器，如nuxt.js\n\n 2. 静态化\n\n目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过 WEB 服务器的\nURL Rewrite的方式，它的原理是通过 web 服务器内部模块按一定规则将外部的 URL\n请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现 URL 静态化的效果\n\n 3. 使用Phantomjs针对爬虫处理\n\n原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node\nserver，再通过PhantomJS来解析完整的HTML，返回给爬虫。下面是大致流程图\n\n\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000019623624\n * https://juejin.cn/post/6844903512107663368\n * https://www.cnblogs.com/constantince/p/5586851.html","routePath":"/interview/vue/spa","lang":"","toc":[{"text":"一、什么是 SPA","id":"一什么是-spa","depth":2,"charIndex":5},{"text":"二、SPA 和 MPA 的区别","id":"二spa-和-mpa-的区别","depth":2,"charIndex":341},{"text":"单页应用与多页应用的区别","id":"单页应用与多页应用的区别","depth":4,"charIndex":507},{"text":"单页应用优缺点","id":"单页应用优缺点","depth":4,"charIndex":864},{"text":"三、实现一个 SPA","id":"三实现一个-spa","depth":2,"charIndex":992},{"text":"原理","id":"原理","depth":4,"charIndex":1005},{"text":"实现","id":"实现","depth":4,"charIndex":1067},{"text":"四、题外话：如何给 SPA 做 SEO","id":"四题外话如何给-spa-做-seo","depth":3,"charIndex":1305},{"text":"参考文献","id":"参考文献","depth":3,"charIndex":1742}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢","footer":"你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢","order":26,"star":26,"date":"2023-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢","isOriginal":false,"head":[["meta",{"name":"keywords","content":"你对 SPA 单页面的理解，它的优缺点分别是什么？如何实现 SPA 应用呢"}]]},"version":""},{"id":243,"title":"SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？","content":"","routePath":"/interview/vue/ssr","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":-1},{"text":"**传统 web 开发**","id":"传统-web-开发","depth":3,"charIndex":-1},{"text":"**单页应用 SPA**","id":"单页应用-spa","depth":3,"charIndex":-1},{"text":"服务端渲染 SSR","id":"服务端渲染-ssr","depth":3,"charIndex":-1},{"text":"二、解决了什么","id":"二解决了什么","depth":2,"charIndex":-1},{"text":"三、如何实现","id":"三如何实现","depth":2,"charIndex":-1},{"text":"小结","id":"小结","depth":3,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？","footer":"SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？","order":12,"star":12,"date":"2023-03-15T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？"}]]},"version":""},{"id":244,"title":"说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","content":"#\n\n\n\n\n一、为什么要划分#\n\n使用vue构建项目，项目结构清晰会提高开发效率，熟悉项目的各种配置同样会让开发效率更高\n\n在划分项目结构的时候，需要遵循一些基本的原则：\n\n * 文件夹和文件夹内部文件的语义一致性\n * 单一入口/出口\n * 就近原则，紧耦合的文件应该放到一起，且应以相对路径引用\n * 公共的文件应该以绝对路径的方式从根目录引用\n * /src 外的文件不应该被引入\n\n\n文件夹和文件夹内部文件的语义一致性#\n\n我们的目录结构都会有一个文件夹是按照路由模块来划分的，如pages文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且仅应该包含路由模块，而不应该有别的其\n他的非路由模块的文件夹\n\n这样做的好处在于一眼就从 pages文件夹看出这个项目的路由有哪些\n\n\n单一入口/出口#\n\n举个例子，在pages文件夹里面存在一个seller文件夹，这时候seller 文件夹应该作为一个独立的模块由外部引入，并且 seller/index.js\n应该作为外部引入 seller 模块的唯一入口\n\n\n\n这样做的好处在于，无论你的模块文件夹内部有多乱，外部引用的时候，都是从一个入口文件引入，这样就很好的实现了隔离，如果后续有重构需求，你就会发现这种方式的优点\n\n\n就近原则，紧耦合的文件应该放到一起，且应以相对路径引用#\n\n使用相对路径可以保证模块内部的独立性\n\n\n\n举个例子\n\n假设我们现在的 seller 目录是在 src/pages/seller，如果我们后续发生了路由变更，需要加一个层级，变成\nsrc/pages/user/seller。\n\n如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，seller 文件夹内部不需要做任何变更。\n\n但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 import 的路径做修改\n\n\n公共的文件应该以绝对路径的方式从根目录引用#\n\n公共指的是多个路由模块共用，如一些公共的组件，我们可以放在src/components下\n\n在使用到的页面中，采用绝对路径的形式引用\n\n\n\n同样的，如果我们需要对文件夹结构进行调整。将 /src/components/input 变成\n/src/components/new/input，如果使用绝对路径，只需要全局搜索替换\n\n再加上绝对路径有全局的语义，相对路径有独立模块的语义\n\n\n/src 外的文件不应该被引入#\n\nvue-cli脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个src文件夹，里面放着所有的项目需要的资源，js,css, png, svg\n等等。src 外会放一些项目配置，依赖，环境等文件\n\n这样的好处是方便划分项目代码文件和配置文件\n\n\n二、目录结构#\n\n单页面目录结构\n\n\n\n多页面目录结构\n\n\n\n\n小结#\n\n项目的目录结构很重要，因为目录结构能体现很多东西，怎么规划目录结构可能每个人有自己的理解，但是按照一定的规范去进行目录的设计，能让项目整个架构看起来更为简洁，更\n加易用\n\n\n参考文献#\n\n * https://juejin.cn/post/6844904129186234381#heading-0\n\n * https://zhuanlan.zhihu.com/p/89693668","routePath":"/interview/vue/structure","lang":"","toc":[{"text":"一、为什么要划分","id":"一为什么要划分","depth":2,"charIndex":5},{"text":"文件夹和文件夹内部文件的语义一致性","id":"文件夹和文件夹内部文件的语义一致性","depth":3,"charIndex":195},{"text":"单一入口/出口","id":"单一入口出口","depth":3,"charIndex":345},{"text":"就近原则，紧耦合的文件应该放到一起，且应以相对路径引用","id":"就近原则紧耦合的文件应该放到一起且应以相对路径引用","depth":3,"charIndex":542},{"text":"公共的文件应该以绝对路径的方式从根目录引用","id":"公共的文件应该以绝对路径的方式从根目录引用","depth":3,"charIndex":795},{"text":"/src 外的文件不应该被引入","id":"src-外的文件不应该被引入","depth":3,"charIndex":1012},{"text":"二、目录结构","id":"二目录结构","depth":2,"charIndex":1157},{"text":"小结","id":"小结","depth":3,"charIndex":1189},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1281}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","footer":"说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","order":27,"star":27,"date":"2023-04-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"}]]},"version":""},{"id":245,"title":"什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路","content":"#\n\n\n\n\n一、什么是虚拟 DOM#\n\n虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM\n为这两个框架都带来了跨平台的能力（React-Native 和 Weex）\n\n实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点)\n作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上\n\n在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children)\n三个属性，不同框架对这三个属性的名命可能会有差别\n\n创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应\n\n在vue中同样使用到了虚拟DOM技术\n\n定义真实DOM\n\n\n\n实例化vue\n\n\n\n观察render的render，我们能得到虚拟DOM\n\n\n\n通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作，\n经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能\n\n\n二、为什么需要虚拟 DOM#\n\nDOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的\n\n真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下：\n\n由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验\n\n举个例子：\n\n你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程\n\n当你在一次操作时，需要更新 10 个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行\n10 次流程\n\n而通过VNode，同样更新 10 个DOM节点，虚拟DOM不会立即操作DOM，而是将这 10\n次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算\n\n> 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM\n> 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS\n> 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI\n\n\n三、如何实现虚拟 DOM#\n\n首先可以看看vue中VNode的结构\n\n源码位置：src/core/vdom/vnode.js\n\n\n\n这里对VNode进行稍微的说明：\n\n * 所有对象的 context 选项都指向了 Vue 实例\n * elm 属性则指向了其相对应的真实 DOM 节点\n\nvue是通过createElement生成VNode\n\n源码位置：src/core/vdom/create-element.js\n\n\n\n上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断\n\n\n\n可以看到_createElement接收 5 个参数：\n\n * context 表示 VNode 的上下文环境，是 Component 类型\n\n * tag 表示标签，它可以是一个字符串，也可以是一个 Component\n\n * data 表示 VNode 的数据，它是一个 VNodeData 类型\n\n * children 表示当前 VNode的子节点，它是任意类型的\n\n * normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的\n\n根据normalizationType 的类型，children会有不同的定义\n\n\n\nsimpleNormalizeChildren方法调用场景是 render 函数是编译生成的\n\nnormalizeChildren方法调用场景分为下面两种：\n\n * render 函数是用户手写的\n * 编译 slot、v-for 的时候会产生嵌套数组\n\n无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为\nVNode 的 Array），这里就不展开说了\n\n规范化children的源码位置在：src/core/vdom/helpers/normalzie-children.js\n\n在规范化children后，就去创建VNode\n\n\n\ncreateComponent同样是创建VNode\n\n源码位置：src/core/vdom/create-component.js\n\n\n\n稍微提下createComponent生成VNode的三个关键流程：\n\n * 构造子类构造函数Ctor\n * installComponentHooks安装组件钩子函数\n * 实例化 vnode\n\n\n小结#\n\ncreateElement 创建 VNode 的过程，每个 VNode 有 children，children\n每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构\n\n\n参考文献#\n\n * https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/create-element.html\n   #children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96\n * https://juejin.cn/post/6876711874050818061","routePath":"/interview/vue/vnode","lang":"","toc":[{"text":"一、什么是虚拟 DOM","id":"一什么是虚拟-dom","depth":2,"charIndex":5},{"text":"二、为什么需要虚拟 DOM","id":"二为什么需要虚拟-dom","depth":2,"charIndex":521},{"text":"三、如何实现虚拟 DOM","id":"三如何实现虚拟-dom","depth":2,"charIndex":1101},{"text":"小结","id":"小结","depth":3,"charIndex":2177},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2282}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路","footer":"什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路","order":21,"star":21,"date":"2023-04-09T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路","isOriginal":false,"head":[["meta",{"name":"keywords","content":"什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路"}]]},"version":""},{"id":246,"title":"vue3 有了解过吗？能说说跟 vue2 的区别吗？","content":"#\n\n\n\n\n一、Vue3 介绍#\n\n关于vue3的重构背景，尤大是这样说的：\n\n「Vue 新版本的理念成型于 2018 年末，当时 Vue 2\n的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了\n\n在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript\n语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」\n\n简要就是：\n\n * 利用新的语言特性(es6)\n * 解决架构问题\n\n\n哪些变化#\n\n\n\n从上图中，我们可以概览Vue3的新特性，如下：\n\n * 速度更快\n * 体积减少\n * 更易维护\n * 更接近原生\n * 更易使用\n\n\n速度更快#\n\nvue3相比vue2\n\n * 重写了虚拟Dom实现\n\n * 编译模板的优化\n\n * 更高效的组件初始化\n\n * undate性能提高 1.3~2 倍\n\n * SSR速度提高了 2~3 倍\n\n\n\n\n体积更小#\n\n通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的\n\n能够tree-shaking，有两大好处：\n\n * 对开发人员，能够对vue实现更多其他的功能，而不必担忧整体体积过大\n\n * 对使用者，打包出来的包体积变小了\n\nvue可以开发出更多其他的功能，而不必担忧vue打包出来的整体体积过多\n\n\n\n\n更易维护#\n\ncompositon Api#\n\n * 可与现有的Options API一起使用\n * 灵活的逻辑组合与复用\n * Vue3模块可以和其他框架搭配使用\n\n\n\n更好的 Typescript 支持#\n\nVUE3是基于typescipt编写的，可以享受到自动的类型定义提示\n\n\n\n编译器重写#\n\n\n\n\n更接近原生#\n\n可以自定义渲染 API\n\n\n\n\n更易使用#\n\n响应式 Api 暴露出来\n\n\n\n轻松识别组件重新渲染原因\n\n\n\n\n二、Vue3 新增特性#\n\nVue 3 中需要关注的一些新功能包括：\n\n * framents\n * Teleport\n * composition Api\n * createRenderer\n\n\nframents#\n\n在 Vue3.x 中，组件现在支持有多个根节点\n\n\n\n\nTeleport#\n\nTeleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术，就有点像哆啦 A 梦的“任意门”\n\n在vue2中，像 modals,toast 等这样的元素，如果我们嵌套在 Vue 的某个组件内部，那么处理嵌套组件的定位、z-index 和样式就会变得很困难\n\n通过Teleport，我们可以在组件的逻辑位置写模板代码，然后在 Vue 应用范围之外渲染它\n\n\n\n\ncreateRenderer#\n\n通过createRenderer，我们能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台\n\n我们可以将其生成在canvas画布上\n\n\n\n关于createRenderer，我们了解下基本使用，就不展开讲述了\n\n\n\n\ncomposition Api#\n\ncomposition Api，也就是组合式api，通过这种形式，我们能够更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理\n\n\n\n关于compositon api的使用，这里以下图展开\n\n\n\n简单使用:\n\n\n\n\n三、非兼容变更#\n\n\nGlobal API#\n\n * 全局 Vue API 已更改为使用应用程序实例\n * 全局和内部 API 已经被重构为可 tree-shakable\n\n\n模板指令#\n\n * 组件上 v-model 用法已更改\n * 和 非 v-for节点上key用法已更改\n * 在同一元素上使用的 v-if 和 v-for 优先级已更改\n * v-bind=\"object\" 现在排序敏感\n * v-for 中的 ref 不再注册 ref 数组\n\n\n组件#\n\n * 只能使用普通函数创建功能组件\n * functional 属性在单文件组件 (SFC)\n * 异步组件现在需要 defineAsyncComponent 方法来创建\n\n\n渲染函数#\n\n * 渲染函数API改变\n * $scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露\n * 自定义指令 API 已更改为与组件生命周期一致\n * 一些转换 class 被重命名了：\n   * v-enter -> v-enter-from\n   * v-leave -> v-leave-from\n * 组件 watch 选项和实例方法 $watch不再支持点分隔字符串路径，请改用计算函数作为参数\n * 在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。VUE3.x\n   现在使用应用程序容器的 innerHTML。\n\n\n其他小改变#\n\n * destroyed 生命周期选项被重命名为 unmounted\n * beforeDestroy 生命周期选项被重命名为 beforeUnmount\n * [prop default工厂函数不再有权访问 this 是上下文\n * 自定义指令 API 已更改为与组件生命周期一致\n * data 应始终声明为函数\n * 来自 mixin 的 data 选项现在可简单地合并\n * attribute 强制策略已更改\n * 一些过渡 class 被重命名\n * 组建 watch 选项和实例方法 $watch不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。\n * 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 元素，而不是渲染其内部内容。\n * 在Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x\n   现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。\n\n\n移除 API#\n\n * keyCode 支持作为 v-on 的修饰符\n * $on，$off和$once 实例方法\n * 过滤filter\n * 内联模板 attribute\n * $destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。\n\n\n参考文献#\n\n * https://vue3js.cn/docs/zh/guide/migration/introduction.html#%E6%A8%A1%E6%9D%B\n   F%E6%8C%87%E4%BB%A4\n * https://composition-api.vuejs.org/zh/#api-%E4%BB%8B%E7%BB%8D","routePath":"/interview/vue/vue3_vue2","lang":"","toc":[{"text":"一、Vue3 介绍","id":"一vue3-介绍","depth":2,"charIndex":5},{"text":"哪些变化","id":"哪些变化","depth":2,"charIndex":259},{"text":"速度更快","id":"速度更快","depth":3,"charIndex":336},{"text":"体积更小","id":"体积更小","depth":3,"charIndex":441},{"text":"更易维护","id":"更易维护","depth":3,"charIndex":615},{"text":"compositon Api","id":"compositon-api","depth":4,"charIndex":622},{"text":"更好的 Typescript 支持","id":"更好的-typescript-支持","depth":4,"charIndex":701},{"text":"编译器重写","id":"编译器重写","depth":4,"charIndex":759},{"text":"更接近原生","id":"更接近原生","depth":3,"charIndex":770},{"text":"更易使用","id":"更易使用","depth":3,"charIndex":794},{"text":"二、Vue3 新增特性","id":"二vue3-新增特性","depth":2,"charIndex":834},{"text":"framents","id":"framents","depth":3,"charIndex":933},{"text":"Teleport","id":"teleport","depth":3,"charIndex":972},{"text":"createRenderer","id":"createrenderer","depth":3,"charIndex":1182},{"text":"composition Api","id":"composition-api","depth":3,"charIndex":1314},{"text":"三、非兼容变更","id":"三非兼容变更","depth":3,"charIndex":1444},{"text":"Global API","id":"global-api","depth":3,"charIndex":1455},{"text":"模板指令","id":"模板指令","depth":3,"charIndex":1532},{"text":"组件","id":"组件","depth":3,"charIndex":1673},{"text":"渲染函数","id":"渲染函数","depth":3,"charIndex":1766},{"text":"其他小改变","id":"其他小改变","depth":3,"charIndex":2097},{"text":"移除 API","id":"移除-api","depth":3,"charIndex":2592},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2723}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-vue3 有了解过吗？能说说跟 vue2 的区别吗？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>vue3 有了解过吗？能说说跟 vue2 的区别吗？","order":8,"star":8,"date":"2023-03-06T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue"],"tag":["interview","vue"],"shortTitle":"前端物语|面试物语-vue3 有了解过吗？能说说跟 vue2 的区别吗？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"vue3 有了解过吗？能说说跟 vue2 的区别吗？"}]]},"version":""},{"id":247,"title":"前端物语|面试物语-vue3","content":" * Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n * Vue3.0 的设计目标是什么？做了哪些优化\n * 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？\n * Vue3.0 性能提升主要是通过哪几方面体现的？\n * Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？\n * css 选择器有哪些？优先级？哪些属性可以继承？\n * 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","routePath":"/interview/vue3/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"vue3","tag":"vue3","title":"前端物语|面试物语-vue3","index":false,"dir":{"order":1},"date":"2023-03-29T00:00:00.000Z"},"version":""},{"id":248,"title":"Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？","content":"#\n\n\n\n\n开始之前#\n\nComposition API 可以说是Vue3的最大特点，那么为什么要推出Composition Api，解决了什么问题？\n\n通常使用Vue2开发的项目，普遍会存在以下问题：\n\n * 代码的可读性随着组件变大而变差\n * 每一种代码复用的方式，都存在缺点\n * TypeScript 支持有限\n\n以上通过使用Composition Api都能迎刃而解\n\n\n正文#\n\n\n一、Options Api#\n\nOptions API，即大家常说的选项\nAPI，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑\n\n如下图：\n\n\n\n可以看到Options代码编写方式，如果是组件状态，则写在data属性上，如果是方法，则写在methods属性上...\n\n用组件的选项 (data、computed、methods、watch) 组织逻辑在大多数情况下都有效\n\n然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解\n\n\n二、Composition Api#\n\n在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）\n\n即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API\n\n\n\n\n三、对比#\n\n下面对Composition Api与Options Api进行两大方面的比较\n\n * 逻辑组织\n * 逻辑复用\n\n逻辑组织#\n\nOptions API#\n\n假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）\n\n\n\n可以看到，这种碎片化使得理解和维护复杂组件变得困难\n\n选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块\n\nCompostion API#\n\n而Compositon API正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去\n\n下面举个简单例子，将处理count属性相关的代码放在同一个函数了\n\n\n\n组件上中使用count\n\n\n\n再来一张图进行对比，可以很直观地感受到 Composition API在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可\n\n\n\n逻辑复用#\n\n在Vue2中，我们是用过mixin去复用相同的逻辑\n\n下面举个例子，我们会另起一个mixin.js文件\n\n\n\n然后在组件中使用\n\n\n\n使用单个mixin似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候\n\n\n\n会存在两个非常明显的问题：\n\n * 命名冲突\n * 数据来源不清晰\n\n现在通过Compositon API这种方式改写上面的代码\n\n\n\n在组件中使用\n\n\n\n可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题\n\n\n小结#\n\n * 在逻辑组织和逻辑复用方面，Composition API是优于Options API\n * 因为Composition API几乎是函数，会有更好的类型推断。\n * Composition API对 tree-shaking 友好，代码也更容易压缩\n * Composition API中见不到this的使用，减少了this指向不明的情况\n * 如果是小型组件，可以继续使用Options API，也是十分友好的","routePath":"/interview/vue3/composition","lang":"","toc":[{"text":"开始之前","id":"开始之前","depth":2,"charIndex":5},{"text":"正文","id":"正文","depth":2,"charIndex":191},{"text":"一、Options Api","id":"一options-api","depth":3,"charIndex":197},{"text":"二、Composition Api","id":"二composition-api","depth":3,"charIndex":463},{"text":"三、对比","id":"三对比","depth":3,"charIndex":596},{"text":"逻辑组织","id":"逻辑组织","depth":4,"charIndex":661},{"text":"逻辑复用","id":"逻辑复用","depth":4,"charIndex":1025},{"text":"小结","id":"小结","depth":3,"charIndex":1271}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？","footer":"Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？","order":5,"star":5,"date":"2023-03-15T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"}]]},"version":""},{"id":249,"title":"Vue3.0 的设计目标是什么？做了哪些优化","content":"#\n\n\n\n\n一、设计目标#\n\n不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下Vue3之前我们或许会面临的问题\n\n * 随着功能的增长，复杂组件的代码变得越来越难以维护\n\n * 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制\n\n * 类型推断不够友好\n\n * bundle的时间太久了\n\n而 Vue3 经过长达两三年时间的筹备，做了哪些事情？\n\n我们从结果反推\n\n * 更小\n * 更快\n * TypeScript 支持\n * API 设计一致性\n * 提高自身可维护性\n * 开放更多底层功能\n\n一句话概述，就是更小更快更友好了\n\n\n更小#\n\nVue3移除一些不常用的 API\n\n引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了\n\n\n更快#\n\n主要体现在编译方面：\n\n * diff 算法优化\n * 静态提升\n * 事件监听缓存\n * SSR 优化\n\n下篇文章我们会进一步介绍\n\n\n更友好#\n\nvue3在兼顾vue2的options API的同时还推出了composition API，大大增加了代码的逻辑组织和代码复用能力\n\n这里代码简单演示下：\n\n存在一个获取鼠标位置的函数\n\n\n\n我们只需要调用这个函数，即可获取x、y的坐标，完全不用关注实现过程\n\n试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高\n\n同时，VUE3是基于typescipt编写的，可以享受到自动的类型定义提示\n\n\n三、优化方案#\n\nvue3从很多层面都做了优化，可以分成三个方面：\n\n * 源码\n * 性能\n * 语法 API\n\n\n源码#\n\n源码可以从两个层面展开：\n\n * 源码管理\n * TypeScript\n\n源码管理#\n\nvue3整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中\n\n\n\n这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性\n\n另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue 使用的，这样用户如果只想使用\nVue3的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue\n\nTypeScript#\n\nVue3是基于typeScript编写的，提供了更好的类型检查，能支持复杂的类型推导\n\n\n性能#\n\nvue3是从什么哪些方面对性能进行进一步优化呢？\n\n * 体积优化\n * 编译优化\n * 数据劫持优化\n\n这里讲述数据劫持：\n\n在vue2中，数据劫持是通过Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除\n\n\n\n尽管Vue为了解决这个问题提供了 set和delete实例方法，但是对于用户来说，还是增加了一定的心智负担\n\n同时在面对嵌套层级比较深的情况下，就存在性能问题\n\n\n\n相比之下，vue3是通过proxy监听整个对象，那么对于删除还是监听当然也能监听到\n\n同时Proxy 并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在getter\n中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归\n\n\n语法 API#\n\n这里当然说的就是composition API，其两大显著的优化：\n\n * 优化逻辑组织\n * 优化逻辑复用\n\n逻辑组织#\n\n一张图，我们可以很直观地感受到 Composition API在逻辑组织方面的优势\n\n\n\n相同功能的代码编写在一块，而不像options API那样，各个功能的代码混成一块\n\n逻辑复用#\n\n在vue2中，我们是通过mixin实现功能混合，如果多个mixin混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰\n\n而通过composition这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可\n\n同样是上文的获取鼠标位置的例子\n\n\n\n组件使用\n\n\n\n可以看到，整个数据来源清晰了，即使去编写更多的hook函数，也不会出现命名冲突的问题\n\n\n参考文献#\n\n * https://juejin.cn/post/6850418112878575629#heading-5\n * https://vue3js.cn/docs/zh","routePath":"/interview/vue3/goal","lang":"","toc":[{"text":"一、设计目标","id":"一设计目标","depth":2,"charIndex":5},{"text":"更小","id":"更小","depth":3,"charIndex":276},{"text":"更快","id":"更快","depth":3,"charIndex":347},{"text":"更友好","id":"更友好","depth":3,"charIndex":421},{"text":"三、优化方案","id":"三优化方案","depth":2,"charIndex":644},{"text":"源码","id":"源码","depth":3,"charIndex":703},{"text":"源码管理","id":"源码管理","depth":4,"charIndex":745},{"text":"TypeScript","id":"typescript","depth":4,"charIndex":979},{"text":"性能","id":"性能","depth":3,"charIndex":1037},{"text":"语法 API","id":"语法-api","depth":3,"charIndex":1388},{"text":"逻辑组织","id":"逻辑组织","depth":4,"charIndex":1453},{"text":"逻辑复用","id":"逻辑复用","depth":4,"charIndex":1548},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1748}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue3.0 的设计目标是什么？做了哪些优化","footer":"Vue3.0 的设计目标是什么？做了哪些优化","order":4,"star":4,"date":"2023-03-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-Vue3.0 的设计目标是什么？做了哪些优化","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue3.0 的设计目标是什么？做了哪些优化"}]]},"version":""},{"id":250,"title":"前端物语|面试物语-vue3","content":" * Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？\n * Vue3.0 的设计目标是什么？做了哪些优化\n * 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？\n * Vue3.0 性能提升主要是通过哪几方面体现的？\n * Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？\n * css 选择器有哪些？优先级？哪些属性可以继承？\n * 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","routePath":"/interview/vue3/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"vue3","tag":"vue3","title":"前端物语|面试物语-vue3","index":false,"dir":{"order":1},"date":"2023-03-29T00:00:00.000Z"},"version":""},{"id":251,"title":"用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？","content":"#\n\n\n\n\n一、组件设计#\n\n组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式\n\n现在有一个场景，点击新增与编辑都弹框出来进行填写，功能上大同小异，可能只是标题内容或者是显示的主体内容稍微不同\n\n这时候就没必要写两个组件，只需要根据传入的参数不同，组件显示不同内容即可\n\n这样，下次开发相同界面程序时就可以写更少的代码，意义着更高的开发效率，更少的 Bug和更少的程序体积\n\n\n二、需求分析#\n\n实现一个Modal组件，首先确定需要完成的内容：\n\n * 遮罩层\n\n * 标题内容\n\n * 主体内容\n\n * 确定和取消按钮\n\n主体内容需要灵活，所以可以是字符串，也可以是一段 html 代码\n\n特点是它们在当前vue实例之外独立存在，通常挂载于body之上\n\n除了通过引入import的形式，我们还可通过API的形式进行组件的调用\n\n还可以包括配置全局样式、国际化、与typeScript结合\n\n\n三、实现流程#\n\n首先看看大致流程：\n\n * 目录结构\n\n * 组件内容\n\n * 实现 API 形式\n\n * 事件处理\n\n * 其他完善\n\n\n目录结构#\n\nModal组件相关的目录结构\n\n\n\n因为 Modal 会被 app.use(Modal) 调用作为一个插件，所以都放在plugins目录下\n\n\n组件内容#\n\n首先实现modal.vue的主体显示内容大致如下\n\n\n\n最外层上通过 Vue3 Teleport 内置组件进行包裹，其相当于传送门，将里面的内容传送至body之上\n\n并且从DOM结构上来看，把modal该有的内容（遮罩层、标题、内容、底部按钮）都实现了\n\n关于主体内容\n\n\n\n可以看到根据传入content的类型不同，对应显示不同得到内容\n\n最常见的则是通过调用字符串和默认插槽的形式\n\n\n\n通过 API 形式调用Modal组件的时候，content可以使用下面两种\n\n * h 函数\n\n\n\n * JSX\n\n\n\n\n实现 API 形式#\n\n那么组件如何实现API形式调用Modal组件呢？\n\n在Vue2中，我们可以借助Vue实例以及Vue.extend的方式获得组件实例，然后挂载到body上\n\n\n\n虽然Vue3移除了Vue.extend方法，但可以通过createVNode实现\n\n\n\n在Vue2中，可以通过this的形式调用全局 API\n\n\n\n而在 Vue3 的 setup 中已经没有 this概念了，需要调用app.config.globalProperties挂载到全局\n\n\n\n\n事件处理#\n\n下面再看看看Modal组件内部是如何处理「确定」「取消」事件的，既然是Vue3，当然采用Compositon API 形式\n\n\n\n在上面代码中，可以看得到除了使用传统emit的形式使父组件监听，还可通过_hub属性中添加 on-cancel，on-confirm方法实现在API中进行监听\n\n\n\n下面再来目睹下_hub是如何实现\n\n\n\n\n其他完善#\n\n关于组件实现国际化、与typsScript结合，大家可以根据自身情况在此基础上进行更改\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000038928664","routePath":"/interview/vue3/modal_component","lang":"","toc":[{"text":"一、组件设计","id":"一组件设计","depth":2,"charIndex":5},{"text":"二、需求分析","id":"二需求分析","depth":2,"charIndex":203},{"text":"三、实现流程","id":"三实现流程","depth":2,"charIndex":412},{"text":"目录结构","id":"目录结构","depth":3,"charIndex":483},{"text":"组件内容","id":"组件内容","depth":3,"charIndex":562},{"text":"实现 API 形式","id":"实现-api-形式","depth":3,"charIndex":826},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":1063},{"text":"其他完善","id":"其他完善","depth":3,"charIndex":1239},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1292}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？","order":3,"star":3,"date":"2023-03-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？"}]]},"version":""},{"id":252,"title":"Vue3.0 性能提升主要是通过哪几方面体现的？","content":"#\n\n\n\n\n一、编译阶段#\n\n回顾Vue2，我们知道每个组件实例都对应一个 watcher\n实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染\n\n\n\n试想一下，一个组件结构如下图\n\n\n\n可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 diff 和遍历其实都是不需要的，造成性能浪费\n\n因此，Vue3在编译阶段，做了进一步优化。主要有如下：\n\n * diff 算法优化\n * 静态提升\n * 事件监听缓存\n * SSR 优化\n\ndiff 算法优化#\n\nvue3在diff算法中相比vue2增加了静态标记\n\n关于这个静态标记，其作用是为了会发生变化的地方添加一个flag标记，下次发生变化的时候直接找该地方进行比较\n\n下图这里，已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高\n\n\n\n关于静态类型枚举如下\n\n\n\n静态提升#\n\nVue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用\n\n这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用\n\n\n\n没有做静态提升之前\n\n\n\n做了静态提升之后\n\n\n\n静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可\n\n同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff\n\n事件监听缓存#\n\n默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化\n\n\n\n没开启事件监听器缓存\n\n\n\n开启事件侦听器缓存后\n\n\n\n上述发现开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用\n\nSSR 优化#\n\n当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个 static\nnode，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染\n\n\n\n编译后\n\n\n\n\n二、源码体积#\n\n相比Vue2，Vue3整体体积变小了，除了移出一些不常用的 API，再重要的是Tree shanking\n\n任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小\n\n\n\n\n三、响应式系统#\n\nvue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式\n\nvue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历\n\n * 可以监听动态属性的添加\n * 可以监听到数组的索引和数组length属性\n * 可以监听删除属性\n\n关于这两个 API 具体的不同，我们下篇文章会进行一个更加详细的介绍\n\n\n参考文献#\n\n * https://juejin.cn/post/6903171037211557895","routePath":"/interview/vue3/performance","lang":"","toc":[{"text":"一、编译阶段","id":"一编译阶段","depth":2,"charIndex":5},{"text":"diff 算法优化","id":"diff-算法优化","depth":4,"charIndex":274},{"text":"静态提升","id":"静态提升","depth":4,"charIndex":425},{"text":"事件监听缓存","id":"事件监听缓存","depth":4,"charIndex":670},{"text":"SSR 优化","id":"ssr-优化","depth":4,"charIndex":784},{"text":"二、源码体积","id":"二源码体积","depth":2,"charIndex":902},{"text":"三、响应式系统","id":"三响应式系统","depth":2,"charIndex":1034},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1255}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？","footer":"Vue3.0 性能提升主要是通过哪几方面体现的？","order":7,"star":7,"date":"2023-03-29T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-Vue3.0 性能提升主要是通过哪几方面体现的？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue3.0 性能提升主要是通过哪几方面体现的？"}]]},"version":""},{"id":253,"title":"Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？","content":"#\n\n\n\n\n一、Object.defineProperty#\n\n定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n\n为什么能实现响应式#\n\n通过defineProperty 两个属性，get及set\n\n * get\n\n属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的 this\n并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值\n\n * set\n\n属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined\n\n下面通过代码展示：\n\n定义一个响应式函数defineReactive\n\n\n\n调用defineReactive，数据发生变化触发update方法，实现数据响应式\n\n\n\n在对象存在多个key情况下，需要进行遍历\n\n\n\n如果存在嵌套对象的情况，还需要在defineReactive中进行递归\n\n\n\n当给key赋值为对象的时候，还需要在set属性中进行递归\n\n\n\n上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题\n\n现在对一个对象进行删除与添加属性操作，无法劫持到\n\n\n\n当我们对一个数组进行监听的时候，并不那么好使了\n\n\n\n可以看到数据的api无法劫持到，从而无法实现数据响应式，\n\n所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写\n\n还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题\n\n\n小结#\n\n * 检测不到对象属性的添加和删除\n * 数组API方法无法监听到\n * 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题\n\n\n二、proxy#\n\nProxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n\n在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了\n\n下面通过代码进行展示：\n\n定义一个响应式方法reactive\n\n\n\n测试一下简单数据的操作，发现都能劫持\n\n\n\n再测试嵌套对象情况，这时候发现就不那么 OK 了\n\n\n\n如果要解决，需要在get之上再进行一层代理\n\n\n\n\n三、总结#\n\nObject.defineProperty只能遍历对象属性进行劫持\n\n\n\nProxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\n\n\n\nProxy可以直接监听数组的变化（push、shift、splice）\n\n\n\nProxy有多达 13\n种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的\n\n正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）\n\n\n\nProxy 不兼容 IE，也没有 polyfill, defineProperty 能支持到 IE9\n\n\n参考文献#\n\n * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Obje\n   cts/Object/defineProperty","routePath":"/interview/vue3/proxy","lang":"","toc":[{"text":"一、Object.defineProperty","id":"一objectdefineproperty","depth":2,"charIndex":5},{"text":"小结","id":"小结","depth":3,"charIndex":727},{"text":"二、proxy","id":"二proxy","depth":2,"charIndex":806},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1010},{"text":"参考文献","id":"参考文献","depth":3,"charIndex":1356}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？","footer":"Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？","order":6,"star":6,"date":"2023-03-25T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？"}]]},"version":""},{"id":254,"title":"css 选择器有哪些？优先级？哪些属性可以继承？","content":"#\n\n\n\n\n一、选择器#\n\nCSS 选择器是 CSS 规则的第一部分\n\n它是元素和其他部分组合起来告诉浏览器哪个 HTML 元素应当是被选为应用规则中的 CSS 属性值的方式\n\n选择器所选择的元素，叫做“选择器的对象”\n\n我们从一个Html结构开始\n\n\n\n关于css属性选择器常用的有：\n\n * id 选择器（#box），选择 id 为 box 的元素\n\n * 类选择器（.one），选择类名为 one 的所有元素\n\n * 标签选择器（div），选择标签为 div 的所有元素\n\n * 后代选择器（#box div），选择 id 为 box 元素内部所有的 div 元素\n\n * 子选择器（.one>one_1），选择父元素为.one 的所有.one_1 的元素\n\n * 相邻同胞选择器（.one+.two），选择紧接在.one 之后的所有.two 元素\n\n * 群组选择器（div,p），选择 div、p 的所有元素\n\n还有一些使用频率相对没那么多的选择器：\n\n * 伪类选择器\n\n\n\n * 伪元素选择器\n\n\n\n * 属性选择器\n\n\n\n在CSS3中新增的选择器有如下：\n\n * 层次选择器（p~ul），选择前面有 p 元素的每个 ul 元素\n * 伪类选择器\n\n\n\n * 属性选择器\n\n\n\n\n二、优先级#\n\n相信大家对CSS选择器的优先级都不陌生：\n\n> 内联 > ID 选择器 > 类选择器 > 标签选择器\n\n到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：\n\n * 如果存在内联样式，那么 A = 1, 否则 A = 0\n\n * B 的值等于 ID 选择器出现的次数\n\n * C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数\n\n * D 的值等于 标签选择器 和 伪元素 出现的总次数\n\n这里举个例子：\n\n\n\n套用上面的算法，依次求出 A B C D 的值：\n\n * 因为没有内联样式 ，所以 A = 0\n\n * ID 选择器总共出现了 1 次， B = 1\n\n * 类选择器出现了 1 次， 属性选择器出现了 0 次，伪类选择器出现 0 次，所以 C = (1 + 0 + 0) = 1\n\n * 标签选择器出现了 3 次， 伪元素出现了 0 次，所以 D = (3 + 0) = 3\n\n上面算出的A 、 B、C、D 可以简记作：(0, 1, 1, 3)\n\n知道了优先级是如何计算之后，就来看看比较规则：\n\n * 从左往右依次进行比较 ，较大者优先级更高\n * 如果相等，则继续往右移动一位进行比较\n * 如果 4 位全部相等，则后面的会覆盖前面的\n\n经过上面的优先级计算规则，我们知道内联样式的优先级最高，如果外部样式需要覆盖内联样式，就需要使用!important\n\n\n三、继承属性#\n\n在css中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性\n\n关于继承属性，可以分成：\n\n * 字体系列属性\n\n\n\n * 文本系列属性\n\n\n\n * 元素可见性\n\n\n\n * 表格布局属性\n\n\n\n * 列表属性\n\n\n\n * 引用\n\n\n\n * 光标属性\n\n\n\n继承中比较特殊的几点：\n\n * a 标签的字体颜色不能被继承\n\n * h1-h6 标签字体的大下也是不能被继承的\n\n\n无继承的属性#\n\n * display\n\n * 文本属性：vertical-align、text-decoration\n\n * 盒子模型的属性：宽度、高度、内外边距、边框等\n\n * 背景属性：背景图片、颜色、位置等\n\n * 定位属性：浮动、清除浮动、定位 position 等\n\n * 生成内容属性：content、counter-reset、counter-increment\n\n * 轮廓样式属性：outline-style、outline-width、outline-color、outline\n\n * 页面样式属性：size、page-break-before、page-break-after\n\n\n参考文献#\n\n * https://www.html.cn/qa/css3/13444.html\n * https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors","routePath":"/interview/vue3/selector","lang":"","toc":[{"text":"一、选择器","id":"一选择器","depth":2,"charIndex":5},{"text":"二、优先级","id":"二优先级","depth":2,"charIndex":546},{"text":"三、继承属性","id":"三继承属性","depth":2,"charIndex":1166},{"text":"无继承的属性","id":"无继承的属性","depth":3,"charIndex":1368},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1672}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-css 选择器有哪些？优先级？哪些属性可以继承？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>css 选择器有哪些？优先级？哪些属性可以继承？","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","css"],"tag":["interview","css"],"shortTitle":"前端物语|面试物语-css 选择器有哪些？优先级？哪些属性可以继承？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"css 选择器有哪些？优先级？哪些属性可以继承？"}]]},"version":""},{"id":255,"title":"说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","content":"#\n\n\n\n\n一、是什么#\n\nTree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination\n\n简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码\n\n如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去\n\n而treeshaking则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕\n\n也就是说 ，tree shaking 其实是找出使用的代码\n\n在Vue2中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是Vue实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到\n\n\n\n而Vue3源码引入tree shaking特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中\n\n\n\n\n二、如何做#\n\nTree\nshaking是基于ES6模板语法（import与exports），主要是借助ES6模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量\n\nTree shaking无非就是做了两件事：\n\n * 编译阶段利用ES6 Module判断哪些模块已经加载\n * 判断那些模块和变量未被使用或者引用，进而删除对应代码\n\n下面就来举个例子：\n\n通过脚手架vue-cli安装Vue2与Vue3项目\n\n\n\n\nVue2 项目#\n\n组件中使用data属性\n\n\n\n对项目进行打包，体积如下图\n\n\n\n为组件设置其他属性（compted、watch）\n\n\n\n再一次打包，发现打包出来的体积并没有变化\n\n\n\n\nVue3 项目#\n\n组件中简单使用\n\n\n\n将项目进行打包\n\n\n\n在组件中引入computed和watch\n\n\n\n再次对项目进行打包，可以看到在引入computer和watch之后，项目整体体积变大了\n\n\n\n\n三、作用#\n\n通过Tree shaking，Vue3给我们带来的好处是：\n\n * 减少程序体积（更小）\n * 减少程序执行时间（更快）\n * 便于将来对程序架构进行优化（更友好）\n\n\n参考文献#\n\n * https://segmentfault.com/a/1190000038962700","routePath":"/interview/vue3/treeshaking","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"二、如何做","id":"二如何做","depth":2,"charIndex":406},{"text":"Vue2 项目","id":"vue2-项目","depth":3,"charIndex":625},{"text":"Vue3 项目","id":"vue3-项目","depth":3,"charIndex":720},{"text":"三、作用","id":"三作用","depth":2,"charIndex":824},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":916}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","order":1,"star":1,"date":"2023-02-27T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","vue3"],"tag":["interview","vue3"],"shortTitle":"前端物语|面试物语-说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？"}]]},"version":""},{"id":256,"title":"说说 webpack 的热更新是如何做到的？原理是什么？","content":"#\n\n\n\n\n一、是什么#\n\nHMR全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用\n\n例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失\n\n如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用\n\n在webpack中配置开启热模块也非常的简单，如下代码：\n\n\n\n通过上述这种配置，如果我们修改并保存css文件，确实能够以不刷新的形式更新到页面中\n\n但是，当我们修改并保存js文件之后，页面依旧自动刷新了，这里并没有触发热模块\n\n所以，HMR并不像 Webpack 的其他特性一样可以开箱即用，需要有一些额外的操作\n\n我们需要去指定哪些模块发生更新时进行HRM，如下代码：\n\n\n\n\n二、实现原理#\n\n首先来看看一张图，如下：\n\n\n\n * Webpack Compile：将 JS 源代码编译成 bundle.js\n * HMR Server：用来将热更新的文件输出给 HMR Runtime\n * Bundle Server：静态资源文件服务器，提供文件访问路径\n * HMR Runtime：socket 服务器，会被注入到浏览器，更新文件的变化\n * bundle.js：构建输出的文件\n * 在 HMR Runtime 和 HMR Server 之间建立 websocket，即图上 4 号线，用于实时更新文件变化\n\n上面图中，可以分成两个阶段：\n\n * 启动阶段为上图 1 - 2 - A - B\n\n在编写未经过webpack打包的源代码后，Webpack Compile 将源代码和 HMR Runtime 一起编译成 bundle文件，传输给Bundle\nServer 静态资源服务器\n\n * 更新阶段为上图 1 - 2 - 3 - 4\n\n当某一个文件或者模块发生变化时，webpack监听到文件变化对文件重新编译打包，编译生成唯一的hash值，这个hash值用来作为下一次热更新的标识\n\n根据变化的内容生成两个补丁文件：manifest（包含了 hash 和 chundId，用来说明变化的内容）和chunk.js 模块\n\n由于socket服务器在HMR Runtime 和 HMR Server之间建立\nwebsocket链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的hash值，如下图的h属性，作为下一次热更细的标识\n\n\n\n在浏览器接受到这条消息之前，浏览器已经在上一次socket 消息中已经记住了此时的hash 标识，这时候我们会创建一个 ajax 去服务端请求获取到变化内容的\nmanifest 文件\n\nmainfest文件包含重新build生成的hash值，以及变化的模块，对应上图的c属性\n\n浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程，实现局部模块更新\n\n\n\n\n三、总结#\n\n关于webpack热模块更新的总结如下：\n\n * 通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和 Socket 服务\n * express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）\n * socket server 是一个 websocket 的长连接，双方可以通信\n * 当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）\n * 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）\n * 浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/138446061\n * https://github.com/Jocs/jocs.github.io/issues/15\n * https://juejin.cn/post/6844904134697549832","routePath":"/interview/webpack/HMR","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":3,"charIndex":5},{"text":"二、实现原理","id":"二实现原理","depth":2,"charIndex":379},{"text":"三、总结","id":"三总结","depth":2,"charIndex":1269},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1638}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 webpack 的热更新是如何做到的？原理是什么？","footer":"说说 webpack 的热更新是如何做到的？原理是什么？","order":8,"star":8,"date":"2023-03-29T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说 webpack 的热更新是如何做到的？原理是什么？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 webpack 的热更新是如何做到的？原理是什么？"}]]},"version":""},{"id":257,"title":"说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？","content":"#\n\n\n\n\n一、区别#\n\n前面两节我们有提到Loader与Plugin对应的概念，先来回顾下\n\n * loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中\n * plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事\n\n从整个运行时机上来看，如下图所示：\n\n\n\n可以看到，两者在运行时机上的区别：\n\n * loader 运行在打包文件之前\n * plugins 在整个编译周期都起作用\n\n在Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API改变输出结果\n\n对于loader，实质是一个转换器，将 A 文件进行编译形成 B 文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程\n\n\n二、编写 loader#\n\n在编写 loader 前，我们首先需要了解 loader 的本质\n\n其本质为函数，函数中的 this 作为上下文会被 webpack 填充，因此我们不能将 loader设为一个箭头函数\n\n函数接受一个参数，为 webpack 传递给 loader 的文件源内容\n\n函数中 this 是由 webpack 提供的对象，能够获取当前 loader 所需要的各种信息\n\n函数中有异步操作或同步操作，异步操作通过 this.callback 返回，返回值要求为 string 或者 Buffer\n\n代码如下所示：\n\n\n\n一般在编写loader的过程中，保持功能单一，避免做多种功能\n\n如less文件转换成 css文件也不是一步到位，而是 less-loader、css-loader、style-loader几个\nloader的链式调用才能完成转换\n\n\n三、编写 plugin#\n\n由于webpack基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务\n\n在之前也了解过，webpack编译会创建两个核心对象：\n\n * compiler：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack\n   整个生命周期相关的钩子\n * compilation：作为 plugin\n   内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation\n   将被创建\n\n如果自己要实现plugin，也需要遵循一定的规范：\n\n * 插件必须是一个函数或者是一个包含 apply 方法的对象，这样才能访问compiler实例\n * 传给每个插件的 compiler 和 compilation 对象都是同一个引用，因此不建议修改\n * 异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住\n\n实现plugin的模板如下：\n\n\n\n在 emit 事件发生时，代表源文件的转换和组装已经完成，可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容\n\n\n参考文献#\n\n * https://webpack.docschina.org/api/loaders/\n * https://webpack.docschina.org/api/compiler-hooks/\n * https://segmentfault.com/a/1190000039877943","routePath":"/interview/webpack/Loader_Plugin","lang":"","toc":[{"text":"一、区别","id":"一区别","depth":2,"charIndex":5},{"text":"二、编写 loader","id":"二编写-loader","depth":2,"charIndex":418},{"text":"三、编写 plugin","id":"三编写-plugin","depth":2,"charIndex":805},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1382}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？","order":1,"star":1,"date":"2023-03-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？"}]]},"version":""},{"id":258,"title":"说说 webpack 中常见的 Plugin？解决了什么问题？","content":"html-webpack-plugin","routePath":"/interview/webpack/Plugin","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":-1},{"text":"配置方式","id":"配置方式","depth":3,"charIndex":-1},{"text":"二、特性","id":"二特性","depth":2,"charIndex":-1},{"text":"三、常见的 Plugin","id":"三常见的-plugin","depth":2,"charIndex":-1},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":3,"charIndex":-1},{"text":"clean-webpack-plugin","id":"clean-webpack-plugin","depth":3,"charIndex":-1},{"text":"mini-css-extract-plugin","id":"mini-css-extract-plugin","depth":3,"charIndex":-1},{"text":"DefinePlugin","id":"defineplugin","depth":3,"charIndex":-1},{"text":"copy-webpack-plugin","id":"copy-webpack-plugin","depth":3,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 webpack 中常见的 Plugin？解决了什么问题？","footer":"说说 webpack 中常见的 Plugin？解决了什么问题？","order":9,"star":9,"date":"2023-04-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说 webpack 中常见的 Plugin？解决了什么问题？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 webpack 中常见的 Plugin？解决了什么问题？"}]]},"version":""},{"id":259,"title":"前端物语|面试物语-webpack","content":" * 说说 webpack 的热更新是如何做到的？原理是什么？\n * 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？\n * 说说 webpack 中常见的 Plugin？解决了什么问题？\n * 与 webpack 类似的工具还有哪些？区别？\n * 说说 webpack 的构建流程?\n * 如何提高 webpack 的构建速度？\n * 说说如何借助 webpack 来优化前端性能？\n * 说说 webpack proxy 工作原理？为什么能解决跨域?\n * 说说你对 webpack 的理解？解决了什么问题？","routePath":"/interview/webpack/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"webpack","tag":"webpack","title":"前端物语|面试物语-webpack","index":false,"dir":{"order":1},"date":"2023-04-03T00:00:00.000Z"},"version":""},{"id":260,"title":"与 webpack 类似的工具还有哪些？区别？","content":"","routePath":"/interview/webpack/Rollup_Parcel_snowpack_Vite","lang":"","toc":[{"text":"一、模块化工具","id":"一模块化工具","depth":2,"charIndex":-1},{"text":"Rollup","id":"rollup","depth":3,"charIndex":-1},{"text":"Parcel","id":"parcel","depth":3,"charIndex":-1},{"text":"Snowpack","id":"snowpack","depth":3,"charIndex":-1},{"text":"Vite","id":"vite","depth":3,"charIndex":-1},{"text":"webpack","id":"webpack","depth":3,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-与 webpack 类似的工具还有哪些？区别？","footer":"与 webpack 类似的工具还有哪些？区别？","order":7,"star":7,"date":"2023-03-21T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-与 webpack 类似的工具还有哪些？区别？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"与 webpack 类似的工具还有哪些？区别？"}]]},"version":""},{"id":261,"title":"说说 webpack 的构建流程?","content":"#\n\n\n\n\n一、运行流程#\n\nwebpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来\n\n在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条webpack机制中，去改变webpack的运作，使得整个系统扩展性良好\n\n从启动到结束会依次执行以下三大步骤：\n\n * 初始化流程：从配置文件和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数\n * 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的\n   Module，递归地进行编译处理\n * 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统\n\n\n\n\n初始化流程#\n\n从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n\n配置文件默认下为webpack.config.js，也或者通过命令的形式指定配置文件，主要作用是用于激活webpack的加载项和插件\n\n关于文件配置内容分析，如下注释：\n\n\n\nwebpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的 plugins\n\n完成上述步骤之后，则开始初始化Compiler编译对象，该对象掌控者webpack声明周期，不执行具体的任务，只是进行一些调度工作\n\n\n\nCompiler 对象继承自 Tapable，初始化时定义了很多钩子函数\n\n\n编译构建流程#\n\n根据配置中的 entry 找出所有的入口文件\n\n\n\n初始化完成后会调用Compiler的run来真正启动webpack编译构建流程，主要流程如下：\n\n * compile 开始编译\n * make 从入口点分析模块及其依赖的模块，创建这些模块对象\n * build-module 构建模块\n * seal 封装构建结果\n * emit 把各个 chunk 输出到结果文件\n\ncompile 编译#\n\n执行了run方法后，首先会触发compile，主要是构建一个Compilation对象\n\n该对象是编译阶段的主要执行者，主要会依次下述流程：执行模块创建、依赖收集、分块、打包等主要任务的对象\n\nmake 编译模块#\n\n当完成了上述的compilation对象后，就开始从Entry入口文件开始读取，主要执行_addModuleChain()函数，如下：\n\n\n\n过程如下：\n\n_addModuleChain中接收参数dependency传入的入口依赖，使用对应的工厂函数NormalModuleFactory.create方法生成一个空\n的module对象\n\n回调中会把此module存入compilation.modules对象和dependencies.module对象中，由于是入口文件，也会存入compilati\non.entries中\n\n随后执行buildModule进入真正的构建模块module内容的过程\n\nbuild module 完成模块编译#\n\n这里主要调用配置的loaders，将我们的模块转成标准的JS模块\n\n在用Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack后面对代码的分析\n\n从配置的入口模块开始，分析其\nAST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系\n\n\n输出流程#\n\nseal 输出资源#\n\nseal方法主要是要生成chunks，对chunks进行一系列的优化操作，并生成要输出的代码\n\nwebpack 中的 chunk ，可以理解为配置在 entry 中的模块，或者是动态引入的模块\n\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表\n\nemit 输出完成#\n\n在确定好输出内容后，根据配置确定输出的路径和文件名\n\n\n\n在 Compiler 开始生成文件前，钩子 emit 会被执行，这是我们修改最终文件的最后一个机会\n\n从而webpack整个打包过程则结束了\n\n\n小结#\n\n\n\n\n参考文献#\n\n * https://github.com/Cosen95/blog/issues/48\n * https://developer.aliyun.com/article/61047","routePath":"/interview/webpack/build_process","lang":"","toc":[{"text":"一、运行流程","id":"一运行流程","depth":2,"charIndex":5},{"text":"初始化流程","id":"初始化流程","depth":3,"charIndex":357},{"text":"编译构建流程","id":"编译构建流程","depth":3,"charIndex":663},{"text":"compile 编译","id":"compile-编译","depth":4,"charIndex":859},{"text":"make 编译模块","id":"make-编译模块","depth":4,"charIndex":969},{"text":"build module 完成模块编译","id":"build-module-完成模块编译","depth":4,"charIndex":1282},{"text":"输出流程","id":"输出流程","depth":3,"charIndex":1498},{"text":"seal 输出资源","id":"seal-输出资源","depth":4,"charIndex":1505},{"text":"emit 输出完成","id":"emit-输出完成","depth":4,"charIndex":1680},{"text":"小结","id":"小结","depth":3,"charIndex":1794},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1802}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说 webpack 的构建流程?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说 webpack 的构建流程?","order":3,"star":3,"date":"2023-03-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说 webpack 的构建流程?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说 webpack 的构建流程?"}]]},"version":""},{"id":262,"title":"如何提高 webpack 的构建速度？","content":"#\n\n\n\n\n一、背景#\n\n随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 webpack 的构建时间也会越来越久\n\n构建时间与我们日常开发效率密切相关，当我们本地开发启动 devServer 或者 build 的时候，如果时间过长，会大大降低我们的工作效率\n\n所以，优化webpack 构建速度是十分重要的环节\n\n\n二、如何优化#\n\n常见的提升构建速度的手段有如下：\n\n * 优化 loader 配置\n * 合理使用 resolve.extensions\n * 优化 resolve.modules\n * 优化 resolve.alias\n * 使用 DLLPlugin 插件\n * 使用 cache-loader\n * terser 启动多线程\n * 合理使用 sourceMap\n\n\n优化 loader 配置#\n\n在使用loader时，可以通过配置include、exclude、test属性来匹配文件，接触include、exclude规定哪些匹配应用loader\n\n如采用 ES6 的项目为例，在配置 babel-loader时，可以这样：\n\n\n\n\n合理使用 resolve.extensions#\n\n在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， resolve可以帮助webpack从每个\nrequire/import 语句中，找到需要引入到合适的模块代码\n\n通过resolve.extensions是解析到文件时自动添加拓展名，默认情况如下：\n\n\n\n当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找\n\n当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度\n\n\n优化 resolve.modules#\n\nresolve.modules 用于配置 webpack\n去哪些目录下寻找第三方模块。默认值为['node_modules']，所以默认会从node_modules中查找文件当安装的第三方模块都放在项目根目录下的\n./node_modules目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：\n\n\n\n\n优化 resolve.alias#\n\nalias给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是./../../的形式\n\n通过配置alias以减少查找过程\n\n\n\n\n使用 DLLPlugin 插件#\n\nDLL全称是 动态链接库，是为软件在 winodw 种实现共享函数库的一种实现方式，而 Webpack 也内置了 DLL\n的功能，为的就是可以共享，不经常改变的代码，抽成一个共享的库。这个库在之后的编译过程中，会被引入到其他项目的代码中\n\n使用步骤分成两部分：\n\n * 打包一个 DLL 库\n * 引入 DLL 库\n\n打包一个 DLL 库#\n\nwebpack内置了一个DllPlugin可以帮助我们打包一个 DLL 的库文件\n\n\n\n引入 DLL 库#\n\n使用 webpack 自带的 DllReferencePlugin 插件对 mainfest.json 映射文件进行分析，获取要使用的DLL库\n\n然后再通过AddAssetHtmlPlugin插件，将我们打包的DLL库引入到Html模块中\n\n\n\n\n使用 cache-loader#\n\n在一些性能开销较大的 loader之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度\n\n保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此loader\n\n\n\n\nterser 启动多线程#\n\n使用多进程并行运行来提高构建速度\n\n\n\n\n合理使用 sourceMap#\n\n打包生成 sourceMap 的时候，如果信息越详细，打包速度就会越慢。对应属性取值如下所示：\n\n\n\n\n三、总结#\n\n可以看到，优化webpack构建的方式有很多，主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手\n\n\n参考文献#\n\n * https://github.com/ly2011/blog/issues/44\n * https://xie.infoq.cn/article/541418eb82a674741a0ad8865\n * https://zhuanlan.zhihu.com/p/139498741","routePath":"/interview/webpack/improve_build","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、如何优化","id":"二如何优化","depth":2,"charIndex":168},{"text":"优化 loader 配置","id":"优化-loader-配置","depth":3,"charIndex":354},{"text":"合理使用 resolve.extensions","id":"合理使用-resolveextensions","depth":3,"charIndex":489},{"text":"优化 resolve.modules","id":"优化-resolvemodules","depth":3,"charIndex":749},{"text":"优化 resolve.alias","id":"优化-resolvealias","depth":3,"charIndex":931},{"text":"使用 DLLPlugin 插件","id":"使用-dllplugin-插件","depth":3,"charIndex":1032},{"text":"打包一个 DLL 库","id":"打包一个-dll-库","depth":4,"charIndex":1209},{"text":"引入 DLL 库","id":"引入-dll-库","depth":4,"charIndex":1266},{"text":"使用 cache-loader","id":"使用-cache-loader","depth":3,"charIndex":1401},{"text":"terser 启动多线程","id":"terser-启动多线程","depth":3,"charIndex":1531},{"text":"合理使用 sourceMap","id":"合理使用-sourcemap","depth":3,"charIndex":1567},{"text":"三、总结","id":"三总结","depth":3,"charIndex":1636},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1703}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-如何提高 webpack 的构建速度？","footer":"如何提高 webpack 的构建速度？","order":4,"star":4,"date":"2023-03-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-如何提高 webpack 的构建速度？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"如何提高 webpack 的构建速度？"}]]},"version":""},{"id":263,"title":"前端物语|面试物语-webpack","content":" * 说说 webpack 的热更新是如何做到的？原理是什么？\n * 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？\n * 说说 webpack 中常见的 Plugin？解决了什么问题？\n * 与 webpack 类似的工具还有哪些？区别？\n * 说说 webpack 的构建流程?\n * 如何提高 webpack 的构建速度？\n * 说说如何借助 webpack 来优化前端性能？\n * 说说 webpack proxy 工作原理？为什么能解决跨域?\n * 说说你对 webpack 的理解？解决了什么问题？","routePath":"/interview/webpack/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"algorithm","order":1,"author":"h7ml","category":"webpack","tag":"webpack","title":"前端物语|面试物语-webpack","index":false,"dir":{"order":1},"date":"2023-04-03T00:00:00.000Z"},"version":""},{"id":264,"title":"说说如何借助 webpack 来优化前端性能？","content":"#\n\n\n\n\n一、背景#\n\n随着前端的项目逐渐扩大，必然会带来的一个问题就是性能\n\n尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃\n\n一般项目在完成后，会通过webpack进行打包，利用webpack对前端项目性能优化是一个十分重要的环节\n\n\n二、如何优化#\n\n通过webpack优化前端的手段有：\n\n * JS 代码压缩\n * CSS 代码压缩\n * Html 文件代码压缩\n * 文件大小压缩\n * 图片压缩\n * Tree Shaking\n * 代码分离\n * 内联 chunk\n\n\nJS 代码压缩#\n\nterser是一个JavaScript的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让bundle更小\n\n在production模式下，webpack 默认就是使用 TerserPlugin 来处理我们的代码的。如果想要自定义配置它，配置方法如下：\n\n\n\n属性介绍如下：\n\n * extractComments：默认值为 true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释\n * parallel：使用多进程并发运行提高构建的速度，默认值是 true，并发运行的默认数量： os.cpus().length - 1\n * terserOptions：设置我们的 terser 相关的配置：\n * compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为 true\n * mangle：设置丑化相关的选项，可以直接设置为 true\n * toplevel：底层变量是否进行转换\n * keep_classnames：保留类的名称\n * keep_fnames：保留函数的名称\n\n\nCSS 代码压缩#\n\nCSS压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等\n\nCSS 的压缩我们可以使用另外一个插件：css-minimizer-webpack-plugin\n\n\n\n配置方法如下：\n\n\n\n\nHtml 文件代码压缩#\n\n使用HtmlWebpackPlugin插件来生成HTML的模板时候，通过配置属性minify进行html优化\n\n\n\n设置了minify，实际会使用另一个插件html-minifier-terser\n\n\n文件大小压缩#\n\n对文件的大小进行压缩，减少http传输过程中宽带的损耗\n\n\n\n\n\n\n图片压缩#\n\n一般来说在打包之后，一些图片文件的大小是远远要比 js 或者 css 文件要来的大，所以图片压缩较为重要\n\n配置方法如下：\n\n\n\n\nTree Shaking#\n\nTree Shaking 是一个术语，在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）\n\n在webpack实现Trss shaking有两种不同的方案：\n\n * usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的\n * sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n\n两种不同的配置方案， 有不同的效果\n\nusedExports#\n\n配置方法也很简单，只需要将usedExports设为true\n\n\n\n使用之后，没被用上的代码在webpack打包中会加入unused harmony export mul注释，用来告知 Terser 在优化时，可以删除掉这段代码\n\n如下面sum函数没被用到，webpack打包会添加注释，terser在优化时，则将该函数去掉\n\n\n\nsideEffects#\n\nsideEffects用于告知webpack compiler哪些模块时有副作用，配置方法是在package.json中设置sideEffects属性\n\n如果sideEffects设置为 false，就是告知webpack可以安全的删除未用到的exports\n\n如果有些文件需要保留，可以设置为数组的形式\n\n\n\n上述都是关于javascript的tree shaking，css同样也能够实现tree shaking\n\ncss tree shaking#\n\ncss进行tree shaking优化可以安装PurgeCss插件\n\n\n\n\n\n * paths：表示要检测哪些目录下的内容需要被分析，配合使用 glob\n * 默认情况下，Purgecss 会将我们的 html 标签的样式移除掉，如果我们希望保留，可以添加一个 safelist 的属性\n\n\n代码分离#\n\n将代码分离到不同的bundle中，之后我们可以按需加载，或者并行加载这些文件\n\n默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度\n\n代码分离可以分出出更小的bundle，以及控制资源加载优先级，提供代码的加载性能\n\n这里通过splitChunksPlugin来实现，该插件webpack已经默认安装和集成，只需要配置即可\n\n默认配置中，chunks 仅仅针对于异步（async）请求，我们可以设置为 initial 或者 all\n\n\n\nsplitChunks主要属性有如下：\n\n * Chunks，对同步代码还是异步代码进行处理\n * minSize： 拆分包的大小, 至少为 minSize，如何包的大小不超过 minSize，这个包不会拆分\n * maxSize： 将大于 maxSize 的包，拆分为不小于 minSize 的包\n * minChunks：被引入的次数，默认是 1\n\n\n内联 chunk#\n\n可以通过InlineChunkHtmlPlugin插件将一些chunk的模块内联到html，如runtime的代码（对模块进行解析、加载、模块信息相关的代码），\n代码量并不大，但是必须加载的\n\n\n\n\n三、总结#\n\n关于webpack对前端性能的优化，可以通过文件体积大小入手，其次还可通过分包的形式、减少 http 请求次数等方式，实现对前端性能的优化\n\n\n参考文献#\n\n * https://zhuanlan.zhihu.com/p/139498741","routePath":"/interview/webpack/performance","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"二、如何优化","id":"二如何优化","depth":2,"charIndex":139},{"text":"JS 代码压缩","id":"js-代码压缩","depth":3,"charIndex":262},{"text":"CSS 代码压缩","id":"css-代码压缩","depth":3,"charIndex":758},{"text":"Html 文件代码压缩","id":"html-文件代码压缩","depth":3,"charIndex":871},{"text":"文件大小压缩","id":"文件大小压缩","depth":3,"charIndex":986},{"text":"图片压缩","id":"图片压缩","depth":3,"charIndex":1029},{"text":"Tree Shaking","id":"tree-shaking","depth":3,"charIndex":1102},{"text":"usedExports","id":"usedexports","depth":4,"charIndex":1334},{"text":"sideEffects","id":"sideeffects","depth":4,"charIndex":1514},{"text":"css tree shaking","id":"css-tree-shaking","depth":4,"charIndex":1738},{"text":"代码分离","id":"代码分离","depth":3,"charIndex":1903},{"text":"内联 chunk","id":"内联-chunk","depth":3,"charIndex":2345},{"text":"三、总结","id":"三总结","depth":3,"charIndex":2456},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":2535}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说如何借助 webpack 来优化前端性能？","footer":"说说如何借助 webpack 来优化前端性能？","order":6,"star":6,"date":"2023-03-18T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说如何借助 webpack 来优化前端性能？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说如何借助 webpack 来优化前端性能？"}]]},"version":""},{"id":265,"title":"说说 webpack proxy 工作原理？为什么能解决跨域?","content":"#\n\n\n\n\n一、是什么#\n\nwebpack proxy，即webpack提供的代理服务\n\n基本行为就是接收客户端发送的请求后转发给其他服务器\n\n其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）\n\n想要实现代理首先需要一个中间服务器，webpack中提供服务器的工具为webpack-dev-server\n\nwebpack-dev-server#\n\nwebpack-dev-server是 webpack 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起\n\n目的是为了提高开发者日常的开发效率，只适用在开发阶段\n\n关于配置方面，在webpack配置对象属性中通过devServer属性提供，如下：\n\n\n\ndevServetr里面proxy则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配\n\n属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为/api，值为对应的代理匹配规则，对应如下：\n\n * target：表示的是代理到的目标地址\n * pathRewrite：默认情况下，我们的 /api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite\n * secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false\n * changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址\n\n\n二、工作原理#\n\nproxy工作原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器\n\n举个例子：\n\n在开发阶段，本地地址为http://localhost:3000，该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转\n发到另一台服务器中\n\n\n\n\n三、跨域#\n\n在开发阶段， webpack-dev-server 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在\nlocalhost的一个端口上，而后端服务又是运行在另外一个地址上\n\n所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题\n\n通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者\n\n当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地\n\n\n\n在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据\n\n注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制\n\n\n参考文献#\n\n * https://webpack.docschina.org/configuration/dev-server/#devserverproxy","routePath":"/interview/webpack/proxy","lang":"","toc":[{"text":"一、是什么","id":"一是什么","depth":2,"charIndex":5},{"text":"webpack-dev-server","id":"webpack-dev-server","depth":4,"charIndex":162},{"text":"二、工作原理","id":"二工作原理","depth":2,"charIndex":641},{"text":"三、跨域","id":"三跨域","depth":2,"charIndex":815},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1175}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说webpack proxy工作原理？为什么能解决跨域?","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>说说webpack proxy工作原理？为什么能解决跨域?","order":1,"star":1,"date":"2023-02-24T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说webpack proxy工作原理？为什么能解决跨域?","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说webpack proxy工作原理？为什么能解决跨域?"}]]},"version":""},{"id":266,"title":"说说你对 webpack 的理解？解决了什么问题？","content":"#\n\n\n\n\n一、背景#\n\nWebpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源\n\n模块化#\n\n最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的JS 文件中\n\n约定每个文件是一个独立的模块，然后再将这些js文件引入到页面，一个script标签对应一个模块，然后调用模块化的成员\n\n\n\n但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题\n\n项目一旦变大，上述问题会尤其明显\n\n随后，就出现了命名空间方式，规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中\n\n\n\n这种方式也并没有解决第一种方式的依赖等问题\n\n再后来，我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，如下\n\n\n\n上述的方式都是早期解决模块的方式，但是仍然存在一些没有解决的问题。例如，我们是用过script标签在页面引入这些模块的，这些模块的加载并不受代码的控制，时间一久\n维护起来也十分的麻烦\n\n理想的解决方式是，在页面中引入一个JS入口文件，其余用到的模块可以通过代码控制，按需加载进来\n\n除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是CommonJS、ES Modules\n\n\n二、问题#\n\n从后端渲染的JSP、PHP，到前端原生JavaScript，再到jQuery开发，再到目前的三大框架Vue、React、Angular\n\n开发方式，也从javascript到后面的es5、es6、7、8、9、10，再到typescript，包括编写CSS的预处理器less、scss等\n\n现代前端开发已经变得十分的复杂，所以我们开发过程中会遇到如下的问题：\n\n * 需要通过模块化的方式来开发\n * 使用一些高级的特性来加快我们的开发效率或者安全性，比如通过 ES6+、TypeScript 开发脚本逻辑，通过 sass、less 等方式来编写 css\n   样式代码\n * 监听文件的变化来并且反映到浏览器上，提高开发的效率\n * JavaScript 代码需要模块化，HTML 和 CSS 这些资源文件也会面临需要被模块化的问题\n * 开发完成后我们还需要将代码进行压缩、合并以及其他相关的优化\n\n而webpack恰巧可以解决以上问题\n\n\n三、是什么#\n\nwebpack 是一个用于现代JavaScript应用程序的静态模块打包工具\n\n * 静态模块\n\n这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进bundle.js的资源）\n\n当 webpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle\n\n\n\nwebpack的能力#\n\n编译代码能力，提高效率，解决浏览器兼容问题 模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题\n万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制\n\n\n参考文献#\n\n * https://webpack.docschina.org/concepts/\n * https://zhuanlan.zhihu.com/p/267875652","routePath":"/interview/webpack/webpack","lang":"","toc":[{"text":"一、背景","id":"一背景","depth":2,"charIndex":5},{"text":"模块化","id":"模块化","depth":4,"charIndex":59},{"text":"二、问题","id":"二问题","depth":2,"charIndex":580},{"text":"三、是什么","id":"三是什么","depth":2,"charIndex":1009},{"text":"`webpack`的能力","id":"webpack的能力","depth":4,"charIndex":-1},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":1332}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|面试物语-说说你对 webpack 的理解？解决了什么问题？","footer":"说说你对 webpack 的理解？解决了什么问题？","order":5,"star":5,"date":"2023-03-14T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["interview","webpack"],"tag":["interview","webpack"],"shortTitle":"前端物语|面试物语-说说你对 webpack 的理解？解决了什么问题？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"说说你对 webpack 的理解？解决了什么问题？"}]]},"version":""},{"id":267,"title":"React开发技巧总结","content":"#\n\n\n1. useImperativeHandle 暴露部分 API#\n\nuseImperativeHandle 允许我们自定义通过 ref 暴露给父组件的实例值。\n\n\n\n\n2. flushSync 同步更新DOM#\n\nflushSync 中的代码执行后，立即同步更新 DOM。\n\n\n\n\n3. useMemo 缓存计算结果#\n\nuseMemo Hook 类似于 Vue 的 computed，用于缓存（或者说记忆（memoize））一个昂贵的计算。\n\n\n\n\n4. 灵活运用组件 key#\n\n通过给组件设置 key，我们可以控制组件的重新创建和状态重置。\n\n\n\n\n5. composeRefs 组合多个 ref#\n\n当需要将多个 ref 应用到同一个元素时，可以使用 composeRefs 函数。\n\n\n\n\n6. useResizeObserver 监听元素大小变化#\n\n自定义 Hook 来监听元素大小变化并执行回调。\n\n\n\n\n7. React 深色模式/暗黑模式#\n\n使用 media 查询来设置主题色。\n\n\n\n\n8. useEffect 使用心得#\n\n * 空依赖数组 [] 表示只在组件挂载时执行一次。\n * 不提供依赖数组会在每次渲染后执行。\n * 小心使用 DOM refs 作为依赖。\n\n\n9. useReducer 管理复杂状态#\n\n用于管理复杂的状态逻辑，类似于 Redux 中的 reducer 概念。\n\n\n\n\n10. 自定义 Hook#\n\n提取可重用的组件逻辑到自定义 Hook 中。\n\n\n\n\n11. React.memo 和 useCallback#\n\n使用 React.memo 和 useCallback 来优化性能，避免不必要的重渲染。\n\n\n\n\n12. Error Boundaries#\n\n使用错误边界捕获子组件树中的 JavaScript 错误。\n\n\n\n\n13. Portals#\n\n使用 Portals 将子节点渲染到父组件 DOM 树之外的 DOM 节点。\n\n\n\n\n14. useLatestCallback#\n\n用于替代 useCallback，解决返回函数地址不同的问题。\n\n","routePath":"/posts/2024/react-skill","lang":"","toc":[{"text":"1. useImperativeHandle 暴露部分 API","id":"1-useimperativehandle-暴露部分-api","depth":2,"charIndex":3},{"text":"2. flushSync 同步更新DOM","id":"2-flushsync-同步更新dom","depth":2,"charIndex":87},{"text":"3. useMemo 缓存计算结果","id":"3-usememo-缓存计算结果","depth":2,"charIndex":144},{"text":"4. 灵活运用组件 key","id":"4-灵活运用组件-key","depth":2,"charIndex":229},{"text":"5. composeRefs 组合多个 ref","id":"5-composerefs-组合多个-ref","depth":2,"charIndex":281},{"text":"6. useResizeObserver 监听元素大小变化","id":"6-useresizeobserver-监听元素大小变化","depth":2,"charIndex":353},{"text":"7. React 深色模式/暗黑模式","id":"7-react-深色模式暗黑模式","depth":2,"charIndex":414},{"text":"8. useEffect 使用心得","id":"8-useeffect-使用心得","depth":2,"charIndex":458},{"text":"9. useReducer 管理复杂状态","id":"9-usereducer-管理复杂状态","depth":2,"charIndex":551},{"text":"10. 自定义 Hook","id":"10-自定义-hook","depth":2,"charIndex":615},{"text":"11. React.memo 和 useCallback","id":"11-reactmemo-和-usecallback","depth":2,"charIndex":657},{"text":"12. Error Boundaries","id":"12-error-boundaries","depth":2,"charIndex":737},{"text":"13. Portals","id":"13-portals","depth":2,"charIndex":794},{"text":"14. useLatestCallback","id":"14-uselatestcallback","depth":2,"charIndex":851}],"domain":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"React开发技巧总结"}],["meta",{"name":"og:url","content":"https://www.h7ml.cn/posts/2024/react-skill"}],["meta",{"name":"og:image","content":"https://www.h7ml.cn/logo.png"}]]},"version":""},{"id":268,"title":"控制反转（IOC）与依赖注入（DI）","content":"控制反转（IOC）和依赖注入（DI）是面向对象编程中的重要设计原则，用于降低代码间的耦合度，并提高可维护性和可测试性。本文将介绍 IOC 和 DI\n的概念、解决的问题、实现思路以及在 Nest 框架中的具体实现。\n\n\n什么是 IOC#\n\nIOC（Inversion of Control，控制反转）是一种设计原则，通过将对象的创建和管理交给一个容器来实现。在非 IOC\n模式下，对象之间的依赖关系由调用者来控制和管理。而在 IOC 模式下，对象的创建和依赖关系的管理都由容器来完成，从而实现了对象之间的解耦。\n\n\n要解决的问题#\n\n在非 IOC 模式下，如果一个类 B 需要使用类 A 的实例，通常会在 B 中创建 A 的实例对象。而如果类 C 又依赖于类\nB，这种控制权的嵌套会持续下去，导致依赖关系变得复杂。例如，在一个典型的三层架构中，Controller 依赖于 Service 来实现业务逻辑，Service\n依赖于 Repository 来进行数据库操作，Repository 又依赖于 DataSource 来建立数据库连接，而 DataSource 需要从\nConfig 对象中获取用户名密码等信息。\n\n\n\n * 上述代码存在两个问题：\n   1. 依赖关系复杂，对象的创建必须按照特定顺序实例化。\n   2. 这些对象不需要每次都创建新的实例，应该使用单例模式。\n\n\n实现思路#\n\n在 IOC 模式下，不再由调用者来查找和创建类的实例，而是将这些职责交给一个容器来管理，以实现类与类之间的解耦。\n\n\nDI#\n\n依赖注入（Dependency Injection，DI）是实现控制反转的一种常用方式。在 DI\n中，程序会在初始化时扫描类之间的依赖关系，并将这些类的实例注入到容器中。\n\n\n思路#\n\n在初始化时，程序会扫描类之间的依赖关系，并将这些类的实例放入容器中。在创建对象时，程序会根据类的依赖关系，将相应的依赖对象注入到类中。\n\n\n具体实现#\n\nIOC 模式是与语言无关的，不同的框架对 DI 的实现方式也有所不同。\n\n * 在 Java 的 Spring 框架中，可以通过定义 XML 文件来决定类之间的依赖关系。\n * 在 Nest 框架中，可以通过装饰器和元数据来实现 DI。在 Nest 框架中，基于 Reflect 的 MetaData\n   实现了自动分析模块之间的依赖关系。可以使用 Reflect.defineMetadata 和 Reflect.getMetadata\n   方法来设置和读取类或类属性的元数据。通过配合装饰器语法，可以实现依赖注入。\n\n以下是一个使用 Nest 框架的装饰器实现的例子：\n\n\n\n\nIOC 和 DI 的关系#\n\n控制反转是一种设计原则，而依赖注入是实现 IOC 的一种常用方式。除了依赖注入，还有其他实现 IOC 的方式，比如依赖查找（Dependency\nLookup）等。\n\n\n解决循环引用问题#\n\n在模块和服务之间可能存在相互引用的情况，这样就会出现循环依赖。Nest 框架通过使用 forwardRef 来解决循环引用的问题。forwardRef\n可以在模块之间创建一个转发引用，Nest 会单独创建这两个模块，并将它们关联起来。\n\n\n模块中的使用示例：#\n\n\n\n\n服务中的使用示例：#\n\n\n\n以上就是关于控制反转（IOC）与依赖注入（DI）的更深入介绍。通过 IOC 和 DI 的应用，可以实现代码的解耦和提高可维护性。在 Nest\n框架中，通过装饰器和元数据的使用，可以更便捷地实现依赖注入。同时，使用 forwardRef 可以解决循环引用的问题，确保模块和服务之间的依赖关系正确建立。","routePath":"/posts/Nestjs/IOC-DL","lang":"","toc":[{"text":"什么是 IOC","id":"什么是-ioc","depth":2,"charIndex":108},{"text":"要解决的问题","id":"要解决的问题","depth":3,"charIndex":256},{"text":"实现思路","id":"实现思路","depth":3,"charIndex":592},{"text":"DI","id":"di","depth":2,"charIndex":658},{"text":"思路","id":"思路","depth":3,"charIndex":751},{"text":"具体实现","id":"具体实现","depth":3,"charIndex":826},{"text":"IOC 和 DI 的关系","id":"ioc-和-di-的关系","depth":2,"charIndex":1126},{"text":"解决循环引用问题","id":"解决循环引用问题","depth":2,"charIndex":1226},{"text":"模块中的使用示例：","id":"模块中的使用示例","depth":3,"charIndex":1357},{"text":"服务中的使用示例：","id":"服务中的使用示例","depth":3,"charIndex":1372}],"domain":"","frontmatter":{"icon":"generic","order":1,"date":"2024-07-14T00:00:00.000Z","author":"h7ml","title":"控制反转（IOC）与依赖注入（DI）","description":"nestjs  控制反转（IOC）与依赖注入（DI）","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>nestjs  控制反转（IOC）与依赖注入（DI）","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"nestjs  控制反转（IOC）与依赖注入（DI）","category":["IOC","DI","nestjs"],"tag":["DI","IOC","nestjs"],"head":[["meta",{"name":"keywords","content":"nestjs  控制反转（IOC）与依赖注入（DI）"}]]},"version":""},{"id":269,"title":"Nestjs","content":" * 控制反转（IOC）与依赖注入（DI）","routePath":"/posts/Nestjs/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"generic","title":"Nestjs","heroText":"h7ml","date":"2020-01-01T00:00:00.000Z","author":"h7ml","index":true,"category":"Nestjs","show":false,"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml","tag":"PostgreSQL","description":"Nestjs","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"Nestjs"},"version":""},{"id":270,"title":"Nestjs","content":" * 控制反转（IOC）与依赖注入（DI）","routePath":"/posts/Nestjs/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"generic","title":"Nestjs","heroText":"h7ml","date":"2020-01-01T00:00:00.000Z","author":"h7ml","index":true,"category":"Nestjs","show":false,"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml","tag":"PostgreSQL","description":"Nestjs","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"Nestjs"},"version":""},{"id":271,"title":"浏览器知识","content":"跨域#\n\n跨域的原因 —— 浏览器的同源策略\n\n同源策略是浏览器一个重要的安全策略，它用于限制一个 origin\n的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介\n\n同源的定义是两个 URL 的 协议、域名(子域名 + 主域名)、端口号 都相同，否则就会出现跨域\n\n同源策略的限制范围\n 1. 限制跨源网络访问: AJAX 请求不能发送\n 2. 限制跨源脚本 API 访问: DOM 无法获得\n 3. 限制跨源数据存储访问: Cookie LocalStorage 和 IndexDB 无法读取\n\n一般常说的跨域指网络跨域\n\n\n常用的跨域解决方案#\n\n常用的跨域解决方案\n 1. CORS\n 2. JSONP\n 3. Nginx 反向代理\n 4. WebSocket\n 5. postMessage\n 6. document.domain\n\n\nCORS 跨源资源共享#\n\nCORS (跨源资源共享) 是 HTTP 的一部分，它允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而解决了 AJAX 只能同源使用的限制。\n\n> CORS 需要浏览器和服务器同时支持，目前所有浏览器均已支持，只需服务器配置即可使用\n\n浏览器将 CORS 请求分成两类: 简单请求和非简单请求\n\n简单请求#\n\n简单请求必须同时满足以下条件\n\n> 日常开发只会关注前两点\n\n * 请求方法是以下三种方法之一\n   * HEAD\n   * GET\n   * POST\n * 只使用了如下的安全首部字段，不得人为设置其他首部字段\n   * Accept\n   * Accept-Language\n   * Content-Language\n   * Content-Type 仅限以下三种\n     * application/x-www-form-urlencoded\n     * multipart/form-data\n     * text/plain\n * 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器(使用 XMLHttpRequest.upload\n   属性访问XMLHttpRequestUpload 对象)\n * 请求中没有使用 ReadableStream 对象\n\n简单请求基本流程#\n\n 1. 浏览器会直接发出 CORS 请求并在请求头信息之中增加一个 Origin 字段(用来说明本次请求来自哪个源(协议 + 域名 + 端口))\n 2. 服务器判断 Origin 字段决定是否同意这次请求\n 3. 通过请求会在响应头增加 CORS 相关的字段(以Access-Control-开头)\n 4. 拒绝请求时不会增加 CORS 相关的字段，浏览器会抛出异常\n\n简单请求响应头中的 CORS 字段\n * Access-Control-Allow-Origin: 只能是 *(接受任意域名的请求)或者是请求时 Origin 字段的值\n * Access-Control-Allow-Credentials(可选): 是一个布尔值,表示是否允许发送 Cookie\n * Access-Control-Expose-Headers(可选): CORS 请求时 XMLHttpRequest 对象的\n   getResponseHeader() 方法只能拿到 6\n   个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragm\n   a。如果想拿到其他字段就必须在 Access-Control-Expose-Headers 里面指定\n\nCORS 中的 Cookie 设置\n\nCORS 请求默认不发送 Cookie，如果需要发送需要满足如下条件\n\n * 服务器必须设置 Access-Control-Allow-Credentials: true\n * Access-Control-Allow-Origin 字段不能为 *\n * AJAX 请求的配置项需设置 withCredentials = true\n\n非简单请求#\n\n非简单请求是那种对服务器有特殊要求的请求，如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是\napplication/json。 非简单请求会在正式通信之前增加一次 HTTP\n查询请求，称为预检请求，用于获取服务器是否允许该实际请求，同时避免跨域请求对服务器的用户数据产生预期之外的影响\n\n预检请求\n\n预检请求用的请求方法是 OPTIONS 表示这个请求是用来询问的\n\n * 在预检请求请求头信息里会包含如下字段\n   * Origin: 表示本次请求来自哪个源\n   * Access-Control-Request-Method: 用于列出浏览器的 CORS 请求会用到哪些 HTTP 方法\n   * Access-Control-Request-Headers(可选): 指定浏览器 CORS 请求会额外发送的头信息字段\n * 服务器通过后会在预检请求响应头中设置如下字段\n   * Access-Control-Allow-Origin\n   * Access-Control-Allow-Credentials(可选)\n   * Access-Control-Allow-Methods: 表示服务器支持的所有跨域请求的方法(为了避免多次预检请求)\n   * Access-Control-Allow-Headers: 表示服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段\n   * Access-Control-Max-Age(可选): 用来指定本次预检请求的有效期单位为秒，在有效期内将不发出另一条预检请求\n\n一旦服务器通过了预检请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样会有一个 Origin 头信息字段。服务器的回应也都会有一个\nAccess-Control-Allow-Origin 头信息字段\n\nCORS 请求过程\n\n\n\n参考资料 —— 跨域资源共享 CORS 详解\n\n\nJSONP#\n\nJSONP 是利用","routePath":"/posts/browser","lang":"","toc":[{"text":"跨域","id":"跨域","depth":2,"charIndex":-1},{"text":"常用的跨域解决方案","id":"常用的跨域解决方案","depth":3,"charIndex":287},{"text":"CORS 跨源资源共享","id":"cors-跨源资源共享","depth":3,"charIndex":395},{"text":"简单请求","id":"简单请求","depth":4,"charIndex":567},{"text":"非简单请求","id":"非简单请求","depth":4,"charIndex":1745},{"text":"JSONP","id":"jsonp","depth":3,"charIndex":2582},{"text":"浏览器缓存机制","id":"浏览器缓存机制","depth":2,"charIndex":-1},{"text":"强缓存（200 OK）","id":"强缓存200-ok","depth":3,"charIndex":-1},{"text":"缓存位置","id":"缓存位置","depth":4,"charIndex":-1},{"text":"协商缓存（304 Not Modified）","id":"协商缓存304-not-modified","depth":3,"charIndex":-1},{"text":"`Last-Modified` 和 `If-Modified-Since`","id":"last-modified-和-if-modified-since","depth":4,"charIndex":-1},{"text":"ETag 和 If-None-Match","id":"etag-和-if-none-match","depth":4,"charIndex":-1},{"text":"应用场景","id":"应用场景","depth":3,"charIndex":-1},{"text":"用户行为对缓存的影响","id":"用户行为对缓存的影响","depth":3,"charIndex":-1},{"text":"浏览器存储","id":"浏览器存储","depth":2,"charIndex":-1},{"text":"Cookie","id":"cookie","depth":3,"charIndex":-1},{"text":"Cookie 的生成和使用","id":"cookie-的生成和使用","depth":4,"charIndex":-1},{"text":"Web Storage","id":"web-storage","depth":3,"charIndex":-1},{"text":"API 使用","id":"api-使用","depth":4,"charIndex":-1},{"text":"IndexedDB","id":"indexeddb","depth":3,"charIndex":-1},{"text":"API 使用","id":"api-使用-1","depth":4,"charIndex":-1}],"domain":"","frontmatter":{"icon":"chrome","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"es6","tag":"es6","title":"浏览器知识","star":true},"version":""},{"id":272,"title":"编程题","content":"new 运算符#\n\nnew 运算符原理\n 1. 创建一个全新的对象\n 2. 为新创建的对象添加 __proto__ 属模拟实现 new 运算符性并指向构造函数的原型对象\n 3. 将新创建的对象作为函数调用的 this\n 4. 如果构造函数没有返回对象类型，则返回新创建的对象\n\n模拟实现 new 运算符\n\n@code\n\n * new 运算符 —— MDN\n * JavaScript 深入之 new 的模拟实现\n\n\ninstanceof 运算符#\n\ninstanceof 运算符原理\n\ninstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上\n\n模拟实现 instanceof 运算符\n\n@code\n\n * instanceof 运算符 —— MDN\n * instanceof 操作符的实现原理\n\n\nObject.create()#\n\nObject.create()\n\nObject.create() 方法创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__\n\n模拟实现 Object.create()\n\n@code\n\nObject.create() —— MDN\n\n\nFunction.prototype.call()#\n\ncall() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数\n\n模拟实现 Function.prototype.call()\n\n@tab es6\n\n\n\n@tab es6\n\n\n\n * Function.prototype.call() —— MDN\n * JavaScript 深入之 call 和 apply 的模拟实现\n\n\nFunction.prototype.apply()#\n\napply() 方法调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供的参数\n\nFunction.prototype.apply()#javascript @tab es6\n\n@tab es5\n\n\n\n * Function.prototype.apply() —— MDN\n * JavaScript 深入之 call 和 apply 的模拟实现\n\n\nFunction.prototype.bind()#\n\nbind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind()\n的第一个参数，而其余参数将作为新函数的参数供调用时使用。\n\n模拟实现 Function.prototype.bind()#javascript @tab es6\n\n@tab es5\n\n\n\n * Function.prototype.bind() —— MDN\n * 相关学习文章\n   * JavaScript 深入之 bind 的模拟实现\n   * 从一道面试题的进阶，到“我可能看了假源码”\n   * 从一道面试题的进阶，到“我可能看了假源码”（2）\n\n\n工具方法系列#\n\n\ndebounce 函数防抖#\n\n函数防抖\n\n作用: 一个函数在一段时间内多次触发都只执行最后一次 原理:\n利用定时器，在函数第一次执行时设定一个定时器，再次调用时如果已经设定过定时器就清空之前的定时器并设定一个新的定时器，当定时器结束后执行传入的回调函数 应用:\n搜索输入框获取用户输入的联想结果\n\n实现防抖函数\n\n@code\n\n\nthrottle 函数节流#\n\n函数节流\n\n作用: 函数节流指指的是在一段时间内只允许函数执行一次 (例如 3 秒执行一次那么在函数第一次调用后的 3 秒内后面的函数调用将被忽略) 原理:\n利用时间戳来判断，记录上次执行的时间戳，在每次触发事件时判断当前时间是否大于上次执行的时间 + 设置的间隔 ，如果是则执行回调并更新上次执行的时间戳 应用:\n降低 scroll resize 事件的触发频率\n\n实现节流函数\n\n@code","routePath":"/posts/coding/coding","lang":"","toc":[{"text":"new 运算符","id":"new-运算符","depth":3,"charIndex":-1},{"text":"instanceof 运算符","id":"instanceof-运算符","depth":3,"charIndex":207},{"text":"Object.create()","id":"objectcreate","depth":3,"charIndex":374},{"text":"Function.prototype.call()","id":"functionprototypecall","depth":3,"charIndex":518},{"text":"Function.prototype.apply()","id":"functionprototypeapply","depth":3,"charIndex":722},{"text":"Function.prototype.bind()","id":"functionprototypebind","depth":3,"charIndex":941},{"text":"工具方法系列","id":"工具方法系列","depth":2,"charIndex":1255},{"text":"debounce 函数防抖","id":"debounce-函数防抖","depth":3,"charIndex":1265},{"text":"throttle 函数节流","id":"throttle-函数节流","depth":3,"charIndex":1431}],"domain":"","frontmatter":{"icon":"code","order":1,"date":"2021-03-20T00:00:00.000Z","author":"h7ml","category":"es6","tag":"es6","title":"编程题","star":true},"version":""},{"id":273,"title":"前端面试题-手写","content":"1.统计字符串中字符出现的次数#\n\n统计字符串中字符出现的次数\n\n@code\n\n\n2. 函数防抖#\n\n函数防抖\n\n@code\n\n\n3. 函数节流#\n\ndetails 函数节流 @code\n\n\n4. 手写数组去重#\n\n手写数组去重\n\n@code\n\n\n5. url 参数转换为 object#\n\nurl 参数转换为 object\n\n@code","routePath":"/posts/coding/handwriting","lang":"","toc":[{"text":"1.统计字符串中字符出现的次数","id":"1统计字符串中字符出现的次数","depth":3,"charIndex":-1},{"text":"2. 函数防抖","id":"2-函数防抖","depth":3,"charIndex":40},{"text":"3. 函数节流","id":"3-函数节流","depth":3,"charIndex":64},{"text":"4. 手写数组去重","id":"4-手写数组去重","depth":3,"charIndex":95},{"text":"5. url 参数转换为 object","id":"5-url-参数转换为-object","depth":3,"charIndex":123}],"domain":"","frontmatter":{"title":"前端面试题-手写","icon":"contrast","order":1,"star":true},"version":""},{"id":274,"title":"posts","content":"#","routePath":"/posts/coding/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":275,"title":"设计模式","content":" * 适配器模式\n * 外观模式\n * 基本原则\n * 桥接模式\n * 建造者模式\n * 责任链模式\n * 组合模式\n * 命令模式\n * 装饰器模式\n * 工厂模式\n * 享元模式\n * 中介者模式\n * 解释器模式\n * 迭代器模式\n * 备忘录模式\n * 观察者模式\n * 原型模式\n * 代理模式\n * 发布订阅模式\n * 单例模式\n * 状态模式\n * 策略模式\n * 模版模式\n * 访问者模式","routePath":"/posts/designPattern/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"diagram","order":1,"author":"h7ml","category":"design","tag":"design","title":"设计模式","index":false,"dir":{"order":1},"date":"2023-02-27T00:00:00.000Z"},"version":""},{"id":276,"title":"适配器模式","content":"场景#\n\n当我们使用第三方库的时候，常常会遇到当前接口和第三方接口不匹配的情况，比如使用一个 Table 的组件，它要求我们返回的表格数据格式如下：\n\n\n\n但后端返回的数据可能是这样的：\n\n\n\n此时就可以通过适配器模式进行转换。\n\n\n适配器模式#\n\n\n模式定义#\n\n维基百科 给的定义：\n\n> In software engineering, the adapter pattern is a software design pattern that\n> allows the interface of an existing class to be used as another interface.[1]\n> It is often used to make existing classes work with others without modifying\n> their source code.\n\n通过适配器模式可以让当前 class 不改变的情况下正常使用另一个 class。\n\n在以 class 为基础的语言中有两种实现方式，一种是通过组合的方式，适配器类内部包含原对象的实例。一种是通过类继承，适配器类继承原 class 。可以看下\nUML 类图：\n\n\n\n左边的 Adapter 内部拥有 Adaptee 的实例，右边的 Adapter 类直接继承 Adaptee 类。\n\n适配器会将 Adaptee 的 specificOperation 方法进行相应的处理包装为 operation 方法供 client 使用。\n\n现实生活中 iPhone 有两种耳机插口，一种是 Lightning，一种是传统的 3.5 毫米接口。如果是 lightning 插口的耳机想要插到传统的\n3.5 毫米接口的电脑上就需要适配器了。\n\n\n\n通过适配器我们成功将 Lightning 耳机插入到了电脑传统耳机孔，\n\n\n\n\n代码实现#\n\nTable 组件提供了一个 responseProcessor 的钩子，我们只需要通过这个钩子将接口返回的数据进行包装即可。\n\n\n\n\n更多场景#\n\n除了应对数据格式不一致的问题，通过适配器模式还可以为上层提供统一接口，来解决兼容性问题。最典型的例子就是 jQuery ，可以看一下其中一段代码:\n\n\n\n\n易混设计模式#\n\n适配器模式和代理模式在代码结构上很像，代理模式也是对原对象进行包装处理。区别在于它们的意图不同：\n\n * 适配器模式是为了解决两个对象之间不匹配的问题，而原对象又不适合直接修改，此时可以使用适配器模式进行一层转换。\n\n * 代理模式是为了增强原对象的功能，提供的接口不会改变。\n\n\n总结#\n\n适配器模式是一种比较简单的设计模式，它允许将一个类的接口转换为另一个接口，使得原本不兼容的类可以协同工作。通过适配器模式，我们可以在不修改现有类源代码的情况下，\n使其与其他类进行交互。\n\n这个模式的核心是适配器类，它包装了一个已有的类或对象，提供了新的接口以满足客户端的需求。适配器模式常见的实现方式有两种：一种是通过组合，在适配器类内部包含原对象\n的实例；另一种是通过继承，适配器类继承原类。\n\n适配器模式在实际开发中经常用于整合不同系统或库之间的接口差异，使它们能够协同工作。这种模式的优点在于可以提高代码的复用性和可维护性，同时也降低了系统耦合度。然而\n，需要注意的是过度使用适配器模式可能会导致代码变得复杂和难以理解，使用时需谨慎考虑。","routePath":"/posts/designPattern/adapter","lang":"","toc":[{"text":"场景","id":"场景","depth":2,"charIndex":-1},{"text":"适配器模式","id":"适配器模式","depth":2,"charIndex":116},{"text":"模式定义","id":"模式定义","depth":3,"charIndex":125},{"text":"代码实现","id":"代码实现","depth":3,"charIndex":812},{"text":"易混设计模式","id":"易混设计模式","depth":2,"charIndex":971},{"text":"总结","id":"总结","depth":2,"charIndex":1121}],"domain":"","frontmatter":{"title":"适配器模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-13T09:15:00.000Z"},"version":""},{"id":277,"title":"外观模式","content":"场景#\n\n网络请求中，我们一般使用 axios 库，支持用 Promise 风格调用。\n\n\n\n可以看到上边的 get 和 post 传参并不统一，使用起来会比较繁琐，post 还需要手动传递 headers 。\n\n为了解决这些问题，我们可以通过外观（门面）模式来解决。\n\n\n外观（门面）模式#\n\n\n模式定义#\n\n看下 维基百科 的定义。\n\n> The facade pattern (also spelled façade) is a software-design pattern commonly\n> used in object-oriented programming. Analogous to a facade in architecture, a\n> facade is an object that serves as a front-facing interface masking more\n> complex underlying or structural code.\n\n外观模式相当于为一个相对复杂的接口或者结构提供一个上层接口供用户使用，看一下 UML 类图。\n\n\n\n举一个简单例子，比如开电脑是一个复杂的过程，我们可以封装成一个函数来实现：\n\n\n\nUML 类图中外观模式会和很多 class 交互，但在 js\n中可能会很少遇到这种情况，通常是当参数比较复杂或者某个功能使用起来比较麻烦的时候我们就可以通过外观模式进行简化。\n\n\n代码实现#\n\n对于开头 axios 的问题，我们可以对 axios 进行一层封装。\n\n\n\n然后引用 request.js 进行调用。\n\n\n\n> 上边的封装只是为了演示外观模式的使用，实际项目中封装的会更加全面\n\n通过门面模式除了简化了我们的调用，还有一个好处就是将底层调用封装了起来，未来如果底层需要变化，比如上边的 axios 替换为 fetch ，我们只需要去修改\nrequest.js 即可，业务方无需感知。\n\n\n更多场景#\n\n外观模式说的宽泛的话就是将复杂的调用包装一层变的简单些。\n\n平时用到的 Vue 的 template 、React 的 jsx ，也可以认为使用了外观模式，他们都将底层 dom\n创建封装起来，使得我们编写页面会变得更加简单。\n\n\n易混设计模式#\n\n前边讲到的 代理模式、适配器模式、模版方法 结构上和外观模式看起来都有些像，区别就在于他们的意图不同：\n\n * 适配器模式是为了解决两个对象之间不匹配的问题，而原对象又不适合直接修改，此时可以使用适配器模式进行一层转换。\n * 代理模式是为了增强原对象的功能，提供的接口不会改变。\n * 模版模式是将不同功能组合在一起，只提供框架，具体实现还需要调用者传进来。\n * 外观模式是将比较复杂的调用进行一层封装，提供一个新的接口供用户使用。\n\n\n总结#\n\n外观模式是一种比较自然和直观的设计模式，通常在某个功能复杂或者使用频率较高的情况下会被考虑使用。通过外观模式，我们可以将一组相关联的接口和实现进行封装，提供一个\n简化的接口给客户端使用，从而减少客户端与子系统之间的直接交互，降低了系统的复杂度。\n\n除了简化接口和降低复杂度外，外观模式还具有一个重要的好处，即能够更好地应对底层实现的变化。因为客户端只依赖于外观类提供的接口，而不需要了解底层子系统的具体实现细\n节，所以当底层实现发生变化时，只需调整外观类而不影响客户端的代码。\n\n总而言之，外观模式提供了一种简单且灵活的方式来管理复杂系统的接口和实现，使得代码更加清晰易懂，并且有助于未来系统的维护和扩展。","routePath":"/posts/designPattern/appearance","lang":"","toc":[{"text":"场景","id":"场景","depth":2,"charIndex":-1},{"text":"外观（门面）模式","id":"外观门面模式","depth":2,"charIndex":136},{"text":"模式定义","id":"模式定义","depth":3,"charIndex":148},{"text":"代码实现","id":"代码实现","depth":2,"charIndex":628},{"text":"更多场景","id":"更多场景","depth":2,"charIndex":838},{"text":"易混设计模式","id":"易混设计模式","depth":2,"charIndex":960},{"text":"总结","id":"总结","depth":2,"charIndex":1190}],"domain":"","frontmatter":{"title":"外观模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-14T08:15:00.000Z"},"version":""},{"id":278,"title":"基本原则","content":"二十三个经典的 设计模式 已经过完了 ，这里再把一些基本原则过一下，以便平时开发中可以更好的体会。\n\n\n单一职责原则 SRP(Single Responsibility Principle)#\n\n> There should never be more than one reason for a class to change.\" In other\n> words, every class should have only one responsibility.\n\n定义：一个类或者模块应该有且只有一个改变的原因，在 js 中的话更多的会应用在对象、函数中。\n\n最难的地方就在于结合具体场景对单一职责的判定了，为了应用这个原则把一个模块拆的太细其实也不太好，所以需要我们在方便性和稳定性之间做一个权衡。\n\n之前讲的 代理模式、装饰器模式 都有体现。\n\n\n开闭原则 OCP(open–closed principle)#\n\n> Software entities should be open for extension, but closed for modification.\n\n定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原代码的情况下进行扩展。\n\n平常开发中，要把变的部分和不变的部分分离出来，设计一个结构的时候尽可能的考虑一下未来可能变化的部分。\n\n可以通过放置 hook 、使用回调函数的方式达到扩展的目的。\n\n之前讲的 发布订阅模式、模版方法模式、策略模式、职责链模式 都有体现。\n\n\n里氏替换原则 LSP(Liskov substitution principle)#\n\n> Functions that use pointers or references to base classes must be able to use\n> objects of derived classes without knowing it.\n\n定义：所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。\n\n举个例子就是如果某个地方可以用 A 类， B 类继承于 A 类，那么这个地方一定可以使用 B 类。\n\n这个原则告诉我们在继承类的时候，如果要实现一个新功能，不要去覆盖父类已经实现的方法，而应该去写一个新方法。\n\n平常前端开发中很少去写类和继承，这个原则用的比较少。\n\n\n接口隔离原则 ISP(Interface Segregation Principle)#\n\n> Many client-specific interfaces are better than one general-purpose interface.\n\n定义：客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的\n方法尽量少。\n\n举个例子就是 A 接口有 5 个方法，B 类实现 A 接口，但 B 类只用到其中的 3 个方法，此时可以考虑对 A 接口进行拆分。\n\njs 中没有接口，忽略。\n\n\n依赖倒转原则 DIP(Dependency Inversion Principle)#\n\n> Depend upon abstractions, not concretions\n\n定义： 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。\n\n其实就是经常说的面向接口（或者基类）编程。\n\n但 js 中没有接口和抽象类，这种原则也就用不到了。\n\n上边五个原则就是经常看到的 SOLID 原则，除了这些还有几个其他的原则。\n\n\n最小知道原则 LOD(principle of least knowledge)#\n\n定义：一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\n\n实体的话在前端中更多的对应对象、函数，门面模式 可以看作该原则的应用。\n\n最小知道原则又叫做迪米特法则 LOD(Law of Demeter)，迪米特其实是宙斯(Zeus) 的姐姐，名字来源的话这里截取下维基百科。\n\n> The Greek goddess of Agriculture.\n> \n> The Demeter project was named after Demeter because we were working on a\n> hardware description language Zeus and we were looking for a tool to simplify\n> the implementation of Zeus. We were looking for a tool name related to Zeus\n> and we chose a sister of Zeus: Demeter.\n> \n> Later we promoted the idea that Demeter-style software development is about\n> growing software as opposed to building software. We introduced the concept of\n> a growth plan which is basically a sequence of more and more complex UML class\n> diagrams.\n> \n> Growth plans are useful for building systems incrementally.\n\n大意就是当时是用一个叫做 Zeus 的硬件语言，然后找到了一个优化 Zens 的工具，为了让它们产生联系，就起了 Demeter 这个名字。\n\n\n\n另外截取一下 「JavaScript 设计开发与实现」书里提到的关于两个名字之间的建议：\n\n> 许多人更倾向于使用迪米特法则这个名字，也许是因为显得更酷一点。但本书参考 Head First\n> \n> Design Patterns 的建议，称之为最少知识原则。一是因为这个名字更能体现其含义，另一个原因\n> \n> 是“法则”给人的感觉是必须强制遵守，而原则只是一种指导，没有哪条原则是在实际开发中必\n> \n> 须遵守的。比如，虽然遵守最小知识原则减少了对象之间的依赖，但也有可能增加一些庞大到难\n> \n> 以维护的第三者对象。跟单一职责原则一样，在实际开发中，是否选择让代码符合最少知识原则，\n> \n> 要根据具体的环境来定。\n\n\n合成/聚合复用原则 CARP(Composite/Aggregate Reuse Principle)#\n\n定义：尽量使用合成/聚合，而不是通过继承达到复用的目的。\n\n\nKISS 原则#\n\n定义： Keep It Simple, Stupid，在设计中应当注重简约的原则。\n\n\nYAGNI 原则#\n\n定义：You aren't gonna need it，表示暂时不需要的就不要做。\n\n\nDRY 原则#\n\n定义：Don't Repeat Yourself，不要写重复的代码。\n\n\n总#\n\n所有的原则只是协助于我们写成易维护、易扩展的代码，不能为了去实现而实现、进行过度设计。\n\n一些代码如果未来完全不用改变，那就用最简单的方式实现即可，当第二次、第三次修改的时候再来重构也不迟。\n\n设计模式和基本原则的应用一定是结合具体场景的，空谈的话也没有任何意义。\n\n我们只需要先了解这些原则，然后在日常开发中慢慢进行体会。","routePath":"/posts/designPattern/basicPrinciple","lang":"","toc":[],"domain":"","frontmatter":{"title":"基本原则","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-08T07:27:19.000Z"},"version":""},{"id":279,"title":"桥接模式","content":"#\n\n组合模式要是用在复杂类的抽离、运行时切换不同方法等，比较难理解，这里 讲的不错。\n\n目前开发中也没有遇到过，此处留坑。","routePath":"/posts/designPattern/bridge","lang":"","toc":[],"domain":"","frontmatter":{"title":"桥接模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-06T16:12:19.000Z"},"version":""},{"id":280,"title":"建造者模式","content":"场景#\n\n如果我们定义了某个函数：\n\n\n\n如果这个函数很稳定那没什么问题，但如果经常变动，比如新增参数。\n\n\n\n此时我们如果想继续使用 price 的默认值，调用的时候还必须显性的传 undefined，getPhone(4.3, 'iOS', 'OLED',\nundefined, 0.8)。\n\n如果再增加一个带默认值的参数，就会看起来越来越怪。\n\n\n\n如果这个函数在很多地方都调用过，改的时候还需要保证修改后其他地方传参是正常的。\n\n此时可以借助建造者模式的思想去改造它。\n\n\n建造者模式#\n\n看下 维基百科 给的定义：\n\n> The builder pattern is a design pattern designed to provide a flexible\n> solution to various object creation problems in object-oriented programming.\n> The intent of the Builder design pattern is to separate the construction of a\n> complex object from its representation. It is one of the Gang of Four design\n> patterns.\n\n建造者模式属于创建型设计模式，也就是为了生成对象。它将复杂的创建过程从构造函数分离出来，然后就可以在不改变原有构造函数的基础上，创建各种各样的对象。\n\nGoF 书中提供的做法就是新创建一个 Builder 类，对象的创建委托给 Builder 类，原始的类不做操作，只负责调用即可。\n\n\n\nDirector 类在构造函数中持有一个 Builder 实例，然后调用 Builder 类的 buildPart 和 getResult\n即可创建对象。未来有新的对象需要创建的话，只需要实现新的 Builder 类即可，无需修改 Director 实例。\n\n原始的建造者模式把对象的创建完全抽离到了 Builder 类中，这可能会导致原始类没啥用了，也许我们可以不全部抽离，Builder 类只负责接收参数即可。\n\n以下示例来自极客时间的 设计模式之美\n\n\n\n上边的 ResourcePoolConfig 类构造函数需要 4\n个参数，如果经常变动，未来可能会越来越多，代码的可读性和易用性都会变差。因此这里可以用到建造者模式，但这里的建造者模式只用来传递参数，其他的逻辑还是维持在\nResourcePoolConfig 类中不变。\n\n\n\n这样的话我们可以通过 ResourcePoolConfig.Builder() 来设置参数，将生成的参数对象传递给 ResourcePoolConfig\n类的构造函数即可。\n\n这里可以看作是变种的建造者模式，我们不是创建不同的 Builder 类来创建对象，而是给 Builder 类传递不同的参数来创建不同的对象。\n\n\n代码实现#\n\n这里也只讨论变种的建造者模式。\n\n在 js 中，我们同样可以照猫画虎的引入一个 Builer 类来接受参数，然后将创建参数对象传递给原始类。\n\n但之所以在 Java 中引入新的 Builder 类是因为 Java 只能通过类来创建对象，但在 js 中我们是可以通过字面量来创建对象的，并且 ES6\n还提供了对象的解构语法，会让我们使用起来更加简洁。\n\n我们只需要将参数列表聚合为一个对象，然后通过解构取参数即可。\n\n\n\n我们只需要改成：\n\n\n\n上边的写法可以很方便的设置默认值，并且参数的顺序也不再重要，未来再扩展的时候也不需要太担心其他地方调用时候传参是否会引起问题。\n\n注意一下参数列表中 {...} = {} 后边的大括号最好写一下，不然如果用户调用函数的时候什么都没有传，解构就会直接失败了。\n\n\n\n\n\n\n更多场景#\n\n通过对象来传递参数除了用在函数中以外，设计组件的时候，如果组件的参数会经常变动，并且越来越多，我们不妨引入一个 Object 类型的参数，然后将相关的参数内聚到\nObject 中进行传递。\n\n\n总#\n\n原始的建造者模式不清楚有没有实际应用，目前还没遇到，未来有的话再补充吧。\n\n变种的建造者模式（只传递参数）在 js 中也很简单，直接通过对象传递参数即可。","routePath":"/posts/designPattern/build","lang":"","toc":[],"domain":"","frontmatter":{"title":"建造者模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-24T08:42:00.000Z"},"version":""},{"id":281,"title":"责任链模式","content":"场景#\n\nleetcode 65 题 判断是否是合法的数字：\n\n\n\n部分有效数字列举如下：[\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\",\n\"+6e-1\", \"53.5e93\", \"-123.456e789\"] 部分无效数字列举如下：[\"abc\", \"1a\", \"1e\", \"e3\",\n\"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"]\n\n我们可以依次遍历给定的字符串，然后各种 if 、else 来解决这个问题：\n\n\n\n如果只是为了刷题 AC 也没啥毛病，但如果在业务中写出这么多 if、else 大概就要被打了。\n\n为了让代码扩展性和可读性更高，我们可以通过责任链模式进行改写。\n\n\n责任链模式#\n\nGoF 介绍的责任链模式定义：\n\n> Avoid coupling the sender of a request to its receiver by giving more than one\n> object a chance to handle the request. Chain the receiving objects and pass\n> the request along the chain until an object handles it.\n\n避免请求者和接收者之间的耦合，让多个接收者都有机会去处理请求。将接收者组成链条，在链条中传递请求直到有接收者可以处理它。\n\n原始的定义中，当请求被处理后链条就终止了，但很多地方也会将请求一直传递下去，可以看作是责任链模式的变体。\n\n看一下 UML 类图和时序图：\n\n\n\nSender 无需关心哪一个 Receiver 去处理它，只需要通过 Handler 接口在 Receiver 链条中进行处理，每一个 Receiver\n处理结束后继续传给下一个 Receiver 。\n\n看起来比较抽象，看一个具体的例子，不同等级的日志进行不同的处理：\n\n\n\n输出：\n\n\n\n每个 logger 都继承了 message 方法，并且拥有的 next 也指向一个 logger 对象，通过 next 去调用下一个的 message 方法。\n\n\n\n让我们用 js 再来改写一下：\n\n我们先实现一个 Handler 对象，构建链条。\n\n\n\n接下来实现不同的 Logger 。\n\n\n\n然后进行测试：\n\n\n\n输出内容和 java 代码是一致的。\n\n\n代码实现#\n\n回到开头的场景中，判断是否是有效数字。\n\n我们可以抽离出不同功能，判断是否是整数、是否是科学记数法、是否是浮点数等等，然后通过职责链模式把它们链接起来，如果某一环节返回了 true\n就不再判断，直接返回最终结果。\n\n可以利用上边写的 Handler 对象，构建链条，此外可以通过返回值提前结束传递。\n\n\n\n数字预处理一下，去掉前后空白和 +、- 便于后续的判断。\n\n\n\n判断是否是整数：\n\n\n\n判断是否是小数：\n\n\n\n判断是否是科学计数法：\n\n\n\n判断是否是十六进制：\n\n\n\n然后通过 Handler 将上边的功能串联起来即可：\n\n\n\n通过责任链的设计模式，每一个函数都可以很好的进行复用，并且未来如果要新增一种类型判断，只需要加到责任链中即可，和之前的判断也完全独立。\n\n\n易混设计模式#\n\n说到沿着「链」执行，应该会想到 装饰器模式 。\n\n\n\n它和责任链模式看起来结构上是一致的，我的理解上主要有两点不同：\n\n 1. 装饰器模式是对已有功能的增强，依次包装起来形成链式调用。而责任链模式从一开始就抽象出了很多功能，然后形成责任链。\n 2. 装饰器模式会依次调用新增的功能直到最初的功能，责任链模式提供了一种中断的能力，调用到某个操作的时候可以直接终止掉，不是所有的功能都会调用。\n\n\n总#\n\n当处理一件事情的时候发现会分很多种情况去讨论，此时可以考虑使用责任链模式进行功能的拆分，提高代码的复用性、扩展性以及可读性。\n\n像 js 中底层的原型链、作用域链、Dom 元素的冒泡机制都可以看作是责任链模式的应用。","routePath":"/posts/designPattern/chainofresponsibility","lang":"","toc":[],"domain":"","frontmatter":{"title":"责任链模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-04T10:10:46.000Z"},"version":""},{"id":282,"title":"组合模式","content":"#\n\n组合模式主要应用在符合树状结构的场景中，父节点和子节点实现统一接口，父节点委托给子节点进行执行。\n\n其中父节点就可以当作组合对象，用户调用的时候无需关系是组合对象还是子对象，面向接口调用即可。\n\n目前开发中还没有遇到过，此处留坑。","routePath":"/posts/designPattern/combination","lang":"","toc":[],"domain":"","frontmatter":{"title":"组合模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":283,"title":"命令模式","content":"命令模式主要应用在需要延迟执行请求、支持撤回的场景中，可能在文本编辑器中有应用，我目前没有使用过，这里就留坑了。\n\n命令模式本质上就是将数据和操作封装为一个对象，实现操作的撤回、延迟等。\n\n这里贴一下 Youtube 一个博主举的 计算器例子。\n\n首先是一个支持加减乘除的计算器：\n\n\n\n如果需要给计算器增加撤回的功能，就可以使用命令模式了。\n\n我们把每一步操作都封装为一个类作为命令对象，类中包含了操作数和操作方法，然后用一个数组记录所有的命令对象。\n\n\n\n\n总#\n\n命令模式的思想比较有意思，将数据和操作封装，实现上在 js 中很简单，我们甚至也不需要 class ，直接通过字面量对象传递也可以。\n\n但实际开发中目前还没用到过，此处留坑。","routePath":"/posts/designPattern/command","lang":"","toc":[],"domain":"","frontmatter":{"title":"命令模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T09:27:19.000Z"},"version":""},{"id":284,"title":"装饰器模式","content":"场景#\n\n微信小程序定义一个页面是通过微信提供的 Page 方法，然后传入一个配置对象进去。\n\n\n\n如果我们有个需求是在每个页面加载的时候上报一些自定义数据。\n\n最直接的当然是去每个页面加就好了，但上报数据的逻辑是一致的，一个一个加有些傻了，这里就可以用到装饰器模式了。\n\n\n装饰器模式#\n\n看下维基百科的定义。\n\n> 装饰器（修饰）模式，是面向对象程式领域中，一种动态地往一个类别中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类别更为灵活，这样可以给某个对象而不是\n> 整个类别添加一些功能。\n\n看一下 UML 类图和次序图。\n\n\n\n当访问 Component1 中的 operation 方法时，会先调用预先定义的两个装饰器 Decorator1 和 Decorator2 中的\noperation 方法，执行一些额外操作，最后再执行原始的 operation 方法。\n\n举一个简单的例子：\n\n买奶茶的话可以额外加珍珠、椰果等，不同小料有不同的价格、也可以自由组合，此时就可以用到装饰器模式，对原始奶茶进行加料、算价。\n\n原始的奶茶有一个接口和类。\n\n\n\n下边引入装饰器，进行加料。\n\n\n\n让我们测试一下，\n\n\n\n未来如果需要新增一种小料，只需要新写一个装饰器类，并且可以和之前的小料随意搭配。\n\n\n\n让我们用 js 改写一下，达到同样的效果。\n\n\n\n没有再定义类和接口，js 中用函数直接表示。\n\n原始的 SimpleMilkTea 方法返回一个奶茶对象，然后又定义了三个装饰函数，传入一个奶茶对象，返回一个装饰后的对象。\n\n\n代码实现#\n\n回到文章最开头的场景，我们需要为每个页面加载的时候上报一些自定义数据。其实我们只需要引入一个装饰函数，将传入的 option 进行装饰返回即可。\n\n\n\n然后回到原始页面增加 Base 的调用即可。\n\n\n\n同理，利用装饰器模式我们也可以对其它生命周期统一插入我们需要做的事情，而不需要业务方自己再写一遍。\n\n在大团队的话，每个业务方可能都需要在小程序生命周期做一些事情，此时只需要利用装饰器模式，编写一个装饰函数，然后在业务代码中调用即可。\n\n最终的业务代码可能会装饰很多层，最终才传给小程序 Page 函数。\n\n\n\n\n易混设计模式#\n\n如果之前看过 代理模式，到这里可能会有一些困惑，因为和代理模式的作用很像，都是对原有对象进行包装，增强原有对象。\n\n但还是有很大的不同点：\n\n代理模式中，我们是直接将原对象封装到代理对象之中，对于业务方并不关心原始对象，直接使用代理对象即可。\n\n装饰器模式中，我们只提供了装饰函数，输入原始对象，输出增强对象。输出的增强对象，还可以接着传入到新的装饰器函数中继续增强。对于业务方，可以随意组合装饰函数，但得\n有一个最最开始的原始对象。\n\n再具体点：\n\n代理模式的话，对象之间的依赖关系已经写死了，原始对象 A，新增代理对象 A1， A1 的基础上再新增代理对象 A2。如果我们不想要 A1\n新增的功能了，我们并不能直接使用 A2 ，因为 A2 已经包含了 A1 的功能，我们只能在 A 的基础上再新写一个代理对象 A3。\n\n而装饰器模式，我们只提供装饰函数 A1，装饰函数 A2，然后对原始对象进行装饰 A2(A1(A))。如果不想要 A1 新增的功能，只需要把 A1\n这个装饰器去掉，调用 A2(A) 即可。\n\n所以使用代理模式还是使用装饰器模式，取决于我们是要把所有功能包装后最终产出一个对象给业务方使用，还是提供许多功能，让业务方自由组合。\n\n\n总#\n\n装饰器模式同样践行了「单一职责原则」，可以把对象/函数的各个功能独立出来，降低它们之间的耦合性。\n\n业务开发中，如果某个对象/函数拥有了太多功能，可以考虑使用装饰器模式进行拆分。","routePath":"/posts/designPattern/decorator","lang":"","toc":[],"domain":"","frontmatter":{"title":"装饰器模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-01-17T07:46:19.000Z"},"version":""},{"id":285,"title":"工厂模式","content":"#\n\n工厂模式是如果业务场景中需要创建多个类似的对象，然后充斥了大量的 if...else... ，此时可以将创建对象的部分抽离出来。\n\n简单工厂模式就是直接抽离，什么都不改，只是将 if..else... 进行了转移。\n\n工厂模式是每一个对象都创建一个工厂类，业务中先得到一个工厂，然后通过工厂得到对象。\n\n抽象工厂模式是每一个工厂类可以生成多种对象。\n\nGoF 中只有工厂模式和抽象工厂模式。\n\n目前开发中还没有遇到过，此处留坑。","routePath":"/posts/designPattern/factory","lang":"","toc":[],"domain":"","frontmatter":{"title":"工厂模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":286,"title":"享元模式","content":"#\n\n享元模式主要用于性能优化，当出现大量的重复对象时，为了防止内存被撑爆，可以抽离一些公共部分进行共享。\n\n目前开发中还没有遇到过，此处留坑。","routePath":"/posts/designPattern/flyweight","lang":"","toc":[],"domain":"","frontmatter":{"title":"享元模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-26T18:54:19.000Z"},"version":""},{"id":287,"title":"设计模式","content":" * 适配器模式\n * 外观模式\n * 基本原则\n * 桥接模式\n * 建造者模式\n * 责任链模式\n * 组合模式\n * 命令模式\n * 装饰器模式\n * 工厂模式\n * 享元模式\n * 中介者模式\n * 解释器模式\n * 迭代器模式\n * 备忘录模式\n * 观察者模式\n * 原型模式\n * 代理模式\n * 发布订阅模式\n * 单例模式\n * 状态模式\n * 策略模式\n * 模版模式\n * 访问者模式","routePath":"/posts/designPattern/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"diagram","order":1,"author":"h7ml","category":"design","tag":"design","title":"设计模式","index":false,"dir":{"order":1},"date":"2023-02-27T00:00:00.000Z"},"version":""},{"id":288,"title":"中介者模式","content":"#\n\n中介者模式用于解决多个对象之间交互过于复杂的问题，从多对多的关系转为一对多的关系。\n\n\n\n和 观察者 模式有些像，区别在于观察模式中的 EventBus 不处理业务逻辑，只是单纯的转发消息。\n\n但中介者对象需要知道各个对象的功能，处理相关逻辑。\n\n目前开发中还没有遇到过，此处留坑。","routePath":"/posts/designPattern/intermediary","lang":"","toc":[],"domain":"","frontmatter":{"title":"中介者模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":289,"title":"解释器模式","content":"#\n\n解释器模式应用在对自定义语法的解释上，自己规定一些新语法，然后通过解释器模式，语法的每种表达式进行细分，最终解释整个表达式。\n\n可能会用在编译器、规则引擎上。\n\n目前自己还没有遇到过，此处留坑。","routePath":"/posts/designPattern/interpreter","lang":"","toc":[],"domain":"","frontmatter":{"title":"解释器模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":290,"title":"迭代器模式","content":"场景#\n\nfor...of.... 的原理是？\n\n\n迭代器模式#\n\n看下 维基百科 给的定义：\n\n> In object-oriented programming, the iterator pattern is a design pattern in\n> which an iterator is used to traverse a container and access the container's\n> elements. The iterator pattern decouples algorithms from containers; in some\n> cases, algorithms are necessarily container-specific and thus cannot be\n> decoupled.\n\n说白了就是有个容器类，有一个迭代器类，容器类持有一个迭代器类的对象，然后我们不需要知道容器中元素的具体结构，通过迭代器对象就能够进行遍历。\n\n\n\n不妨可以看下 java 的具体实现：\n\n\n\n容器类使用 java 自带的 ArrayList 类，然后我们手动实现一个迭代器类 ArrayIterator。\n\n\njs 的迭代器模式#\n\njs 中我们不需要专门定义迭代器的类了，我们可以让容器包含一个 Symbol.iterator 方法，该方法返回一个迭代器对象。\n\n迭代器对象包含一个 next 方法用来获取元素，同时获取到的元素除了本身的 value 外，还返回一个布尔型变量代表是否有下一个元素。\n\n\n\n事实上，数组已经为我们提前实现了迭代器，我们直接通过 Symbol.iterator 方法拿到，不需要自己再实现了。\n\n\n\n还有字符串也为我们内置了迭代器。\n\n\n\n同理，Map、Set 都帮我们内置了 Symbol.iterator 方法，可以返回一个迭代器。\n\n此外，我们也不需要每次都去 while 循环、然后判断是否结束循环了，直接使用 for...of... 即可。\n\n\n\n\n注意#\n\n因为数组是通过 index 来获取元素的，如果在遍历过程中删除元素，可能会产生非预期内的事情。\n\n\n\n可以先思考下会怎么输出，然后看下结果：\n\n\n\n我们是成功删除了 wind ，但是原数组中 liang 就不会遍历到了，也比较好理解。\n\n开始的时候，指针 index 指向 wind，进行了输出 console.log(a); // wind\n\n\n\n此时删除了 wind ，array.splice(0, 1); 数组整体前移。\n\n\n\n然后指针后移，遍历下个元素。\n\n\n\n就直接走到 亮 了，而没有遍历 liang 。\n\n原因就是 liang 的位置之前是 wind ，wind 之前已经遍历过了，指针后移就把 liang 跳过了。\n\n\n总#\n\n迭代器模式的好处就是可以不知道容器中元素的结构就可以遍历，一般由容器提供一个迭代器供我们使用。为了实现不同的遍历顺序，只需要提供新的迭代器即可。\n\n一般编程语言中都内置了迭代器，js 也不例外，在 Array、String、Map、Set 中都内置了Symbol.iterator\n方法返回一个迭代器对象，同时提供了for...of... 语法统一了各个对象的遍历方式。","routePath":"/posts/designPattern/iteratorPattern","lang":"","toc":[],"domain":"","frontmatter":{"title":"迭代器模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-26T09:09:00.000Z"},"version":""},{"id":291,"title":"备忘录模式","content":"#\n\n备忘录模式主要是用于来防丢失、撤销、恢复等场景，定义是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状\n态。\n\n需要三个类， Memento 类提供保存对象和得到对象的方法， Originator 类利用 Memento 类提供保存和读取自身状态的方法，Caretaker\n类来记录所有的备份。\n\n把 维基百科 的例子贴过来。\n\n","routePath":"/posts/designPattern/memorandum","lang":"","toc":[],"domain":"","frontmatter":{"title":"备忘录模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":292,"title":"观察者模式","content":"场景#\n\n假设我们在开发一款外卖网站，进入网站的时候，第一步需要去请求后端接口得到用户的常用外卖地址。然后再去请求其他接口、渲染页面。如果什么都不考虑可能会直接这样写：\n\n\n\n此时页面里多了一个模块 D ，同样需要拿到地址后进行下一步操作，我们只好去翻请求地址的代码把 D 模块的调用补上。\n\n\n\n可以看到各个模块和获取地址模块耦合严重，A、B、C 模块有变化或者有新增模块，都需要深入到获取地址的代码去修改，一不小心可能就改出问题了。\n\n此时就需要观察者模式了。\n\n\n观察者模式#\n\n可以看下 维基百科的介绍：\n\n> The observer pattern is a software design pattern in which an object, named\n> the subject, maintains a list of its dependents, called observers, and\n> notifies them automatically of any state changes, usually by calling one of\n> their methods.\n\n很好理解的一个设计模式，有一个 subject 对象，然后有很多 observers 观察者对象，当 subject 对象有变化的时候去通知 observer\n对象即可。\n\n再看一下 UML 图和时序图：\n\n\n\n每一个观察者都实现了 update 方法，并且调用 Subject 对象的 attach 方法订阅变化。当 Subject 变化时，调用 Observer 的\nupdate 方法去通知观察者。\n\n先用 java 写一个简单的例子：\n\n公众号文章可以看作是 Subject ，会不定期更新。然后每一个用户都是一个 Observer ，订阅公众号，当更新的时候就可以第一时间收到消息。\n\n\n\n输出结果如下：\n\n\n\n上边的实现主要是为了符合最原始的定义，调用 update\n的时候没有传参。如果观察者需要的参数是一致的，其实这里也可以直接把更新后的数据传过去，这样观察者就不需要向上边一样再去调用 subject.getPost()\n手动拿更新后的数据了。\n\n这两种不同的方式前者叫做拉 (pull) 模式，就是收到 Subject 的通知后，通过内部的 Subject 对象调用相应的方法去拿到需要的数据。\n\n后者叫做推 (push) 模式，Subject 更新的时候就将数据推给观察者，观察者直接使用即可。\n\n下边用 js 改写为推模式：\n\n\n\n在 js 中，我们可以直接将 update 方法传给 Subject ，同时采取推模式，调用 update 的时候直接将数据传给观察者，看起来会简洁很多。\n\n\n代码实现#\n\n回到开头的场景，我们可以利用观察者模式将获取地址后的一系列后续操作解耦出来。\n\n\n\n通过观察者模式我们将获取地址后的操作解耦了出来，未来有新增模块只需要注册观察者即可。\n\n当 getAddress 很复杂的时候，通过观察者模式会使得未来的改动变得清晰，不会影响到 getAddress 的逻辑。\n\n必要的话也可以把 observers 抽离到一个新的文件作为一个新模块，防止让一个文件变得过于臃肿。\n\n\n总#\n\n观察者模式比较好理解，通过抽象出一个 Subject\n和多个观察者，减轻了它们之间的过度耦合。再说简单点就是利用回调函数，异步完成后调用传入的回调即可。但上边写的观察者模式还是有一些缺点：\n\n * Subject 仍需要自己维护一个观察者列表，进行 push 和 update。\n * 如果有其他的模块也需要使用观察者模式，还需要模块本身再维护一个新的观察者列表，而不能复用之前的代码。\n * Subject 需要知道观察者提供了什么方法以便未来的时候进行回调。\n\n下一篇文章会继续改进上边的写法，观察者模式的本质思想不变（某个对象变化，然后通知其他观察者对象进行更新）。\n\n但写法上会引入一个中间平台，便于代码更好的复用，使得 Subject 和观察者进行更加彻底的解耦，同时给了它一个新的名字「发布订阅模式」。","routePath":"/posts/designPattern/observer","lang":"","toc":[],"domain":"","frontmatter":{"title":"观察者模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-01-27T09:22:44.000Z"},"version":""},{"id":293,"title":"原型模式","content":"#\n\n原型模式在基于类的语言中作用大一些，当构造函数比较复杂，有一些耗时操作，此时通过 new 去创建对象不划算，可以通过 clone 的方法，直接基于已有对象\ncopy 一个。\n\njs 属于基于原型的面向对象的编程语言，本身就是基于一个对象来生成另一个对象，并没有真正的类。\n\n我们可以直接通过 Object.create 或者 json 序列化反序列化 copy 一个对象。","routePath":"/posts/designPattern/prototype","lang":"","toc":[],"domain":"","frontmatter":{"title":"原型模式","category":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","tag":["设计模式","frontend"],"date":"2022-02-27T11:53:19.000Z"},"version":""},{"id":294,"title":"代理模式","content":"场景#\n\n平常业务开发中， 对于网络请求，我们一般会封装成一个模块，并且暴露 get、post 方法供大家使用。\n\n\n\nHttp 模块主要是将 ajax 请求封装，填充一些 headers 等等，然后业务方使用的时候只需要引入上边的 get、post 即可。\n\n\n\n现在有了一个新需求，我们需要将第一次请求中，后端返回请求中的 graytype 字段塞到后续请求中的 headers ，也就是下边这样。\n\n\n\n如果只是一个请求的话就按上边这样改就可以了，但如果是多个请求一个一个这样去改就有些傻了。\n\n那直接去改 Http 模块？也是不行的，增加 graytype 字段只是我们负责业务的改变，而 Http 模块是所有业务线所共用的，我们并不能直接去改变它。\n\n此时就需要代理模式了。\n\n\n代理模式#\n\n贴一下 维基百科的一些解释：\n\n\n> What problems can the Proxy design pattern solve?\n> \n>  * The access to an object should be controlled.\n>  * Additional functionality should be provided when accessing an object.\n> \n> \n> What solution does the Proxy design pattern describe?\n> \n> Define a separate Proxy object that\n> \n>  * can be used as substitute for another object (Subject) and\n>  * implements additional functionality to control the access to this subject.\n\n代理模式就是对原有对象进行扩展，从而实现对原对象的控制或者进行额外的操作，不同场景下代理模式又可以细分出很多类别：\n\n 1. 远程代理：通过代理模式，实现像操作本地对象一样的操作远程对象。\n\n 2. 虚拟代理：In place of a complex or heavy object, a skeleton representation may be\n    advantageous in some cases. 常见的比如大图的加载，我们可以通过引入代理对象，先加载一张小图，大图加载完毕后再显示大图。\n\n 3. 保护代理：将原有对象的属性访问进行权限控制。\n\n 4. 缓存代理：引入缓存，将之前的结果进行缓存，常见的比如斐波那契数列。\n    \n    ...\n\n不管起了什么新名字，它们的本质都是一样的，如果用类图表示就是下边的样子：\n\n\n\n原对象 RealSubject 和 Proxy 对象都继承了 Subject 这个接口，客户端 Client 调用 DoAction() 方法，先经过代理对象\nProxy ，然后由 Proxy 做一些额外的操作，最终再委托给 RealSubject 进行执行。\n\n看一个 Java 的示例：\n\n\n\n原有的 RealImage 类在 new 对象的时候就会调用 loadImageFromDisk，如果之后没有调用 displayImage 并且\nloadImageFromDisk 比较占资源，那就会是一种浪费。\n\n通过 ProxyImage ，其内部持有 RealImage 的对象，当调用 displayImage 再去实例化对象，实现了对象的延迟加载。\n\n当然也带来了坏处，可能会导致第一次调用 displayImage 的时候比较耗时。因此，在这个示例下是否引入代理模式，就看实际场景下的取舍了。\n\n我们再用 js 来改写一下：\n\n\n\n整体思想是一样的，但 js 不用定义接口，也不用定义类，看起来精简了不少。只需要实现和原对象一样的返回即可。\n\n\n代码实现#\n\n回到最开始的场景：现在有了一个新需求，我们需要将第一次请求中，后端返回请求中的 graytype 字段塞到后续请求中的 headers 。\n\n我们可以通过代理模式将 request.js 中的 get 和 post 进行封装，然后同样暴露出 get 和post 即可。\n\n\n\n我们将原有的 get 和 post 导入，因为还需要导出 get 和 post ，所以将导入的重命名为 Get 和 Post 。\n\n然后在请求前将 grayType 塞入到 headers ，并且 get 和 post 的时候给 grayType 进行赋值。\n\n这样在实际业务中，如果需要 grayType ，我们只需要从新写的 src/util/requestNew.js 引入 get 和 post\n即可，其他什么都不需要改动。\n\n\n总#\n\n代理模式其实说简单了就是对原有对象/函数再包装一层，并且保持和原对象一致的行为。那么为什么不直接改原对象呢？\n\n第一，可能不方便直接改原对象，所以只能采取代理模式包一层了。\n\n第二，「单一职责原则」，如果直接修改原对象，会增加原有对象的复杂度，原对象如果负责的职责过多，引起对象改动的原因就会增多。\n\n第三，未来如果新功能要去掉，修改起来也不方便。如果使用了代理模式，只需要把原来引用的地方还原即可。","routePath":"/posts/designPattern/proxy","lang":"","toc":[],"domain":"","frontmatter":{"title":"代理模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-01-07T08:20:25.000Z"},"version":""},{"id":295,"title":"发布订阅模式","content":"建议先看一下上篇 观察者模式 ，发布订阅模式和观察者模式本质上还是一样的，并且发布订阅模式也没有在经典的设计模式书 GoF\n中出现，很多地方也直接把两者看成一种设计模式了。\n\nGoF 的名字也有个有趣的故事，这里 贴过来：\n\n> The authors of the DesignPatternsBook came to be known as the \"Gang of Four.\"\n> The name of the book (\"Design Patterns: Elements of Reusable Object-Oriented\n> Software\") is too long for e-mail, so \"book by the gang of four\" became a\n> shorthand name for it. After all, it isn't the ONLY book on patterns. That got\n> shortened to \"GOF book\", which is pretty cryptic the first time you hear it.\n\n\n场景#\n\n假设我们在开发一款外卖网站，进入网站的时候，第一步需要去请求后端接口得到用户的常用外卖地址。然后再去请求其他接口、渲染页面。如果使用了观察者模式可能会这样写：\n\n\n\ngetAddress 模块和其他 A 、B、C 三个模块已经实现了解耦，但仍需要维护 observers\n这个数组来注册观察者，同时还需要知道各个模块提供了什么方法用于回调。\n\n我们可以使用发布订阅模式，让 getAddress 模块和其他 A 、B、C 三个模块解耦的更加彻底。\n\n\n发布订阅模式#\n\n回忆一下观察者模式：\n\n> The observer pattern is a software design pattern in which an object, named\n> the subject, maintains a list of its dependents, called observers, and\n> notifies them automatically of any state changes, usually by calling one of\n> their methods.\n\n观察者模式中，Subject 自己维护观察者列表进行注册和通知。\n\n\n\n发布订阅模式的话，引入一个中间平台进行注册和通知，相当于从 Subject 中解耦出来。\n\n\n\n观察者通过 on 向 EventBus 注册事件，然后 Subject 通过 emit 向 EventBus 发射事件，由 EventBus 来向观察者更新。\n\n接下来实现一个简单的 EventBus 。\n\n\n\n我们通过 observersMap 将不同的事件保存为不同的数组，emit 的时候得到对应的数组去调用即可。看下例子：\n\n\n\n\n代码实现#\n\n让我们改造下开头写的观察者模式的代码：\n\n地址模块：\n\n\n\nA 模块\n\n\n\nB 模块\n\n\n\nC 模块\n\n\n\n可以看到 getAddress 模块不再需要关心观察者有谁，它只需要向 EventBus 发射更新事件即可。\n\n每个模块内部自己如果需要地址信息，只需要订阅相关事件，然后传入回调函数即可。\n\n\n特殊情况#\n\n实际工程中可能遇到一些特殊场景，由于 emit 一般在一个异步事件中执行，如果这个异步事件突然执行的变快了，就可能造成某个事件先 emit\n了，然后某个模块才进行了 on 。\n\n此时我们可以对 EventBus 进行一定的改写，使得先订阅事件，后触发事件成为可能。\n\n为了不改动原有逻辑，我们可以通过 代理模式 进行改写。\n\n\n\n在 trigger 的时候，如果 offlineStack 不为 null，说明还没有调用过 listen，此时将当前事件保存起来。\n\nlisten 的时候遍历之前保存的事件，并且将 offlineStack 置为 null，表示已经调用过 listen 了。\n\n看一下效果：\n\n\n\n虽然是先进行的 emit 后进行的 on 的，但依旧会正常执行。\n\n上边的解决方案很粗略，只适用于有一个事件并且只有一个 on 的场景，不然的话比如下边的情况：\n\n\n\n只有 XiaoMing.update 会执行，后边两句就会错过第一次的 emit ，因为执行一次 listen 就把缓存清空了。\n\n或者在 writePost 之前有了一次 on 了：\n\n\n\n同样只有 XiaoMing.update 会执行，后边两句就会错过第一次的 emit 了，因为执行一次 listen 就把缓存清空了。\n\n对于实际场景，我们还需要根据情况继续进行调整。\n\n\n总#\n\n发布订阅模式相对于最原始的观察者模式将 Subject 和 Observers 进行了彻底解耦，Subject 不再需要关心谁订阅了它，Observer\n只需要在自己内部订阅它所关心的事件即可。\n\n通过封装好的 EventBus 也实现了更好的复用，不需要每个模块都去维护自己的观察者列表。\n\n但同时也带来了坏处，所有的事件订阅分散在各个模块，没有一个全局视角知道某个事件被哪些模块订阅了，可能会导致程序难以理解和调试。","routePath":"/posts/designPattern/publishSubscribe","lang":"","toc":[],"domain":"","frontmatter":{"title":"发布订阅模式","category":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","tag":["设计模式","frontend"],"date":"2022-01-30T11:04:52.000Z"},"version":""},{"id":296,"title":"单例模式","content":"场景#\n\n如果需要实现一个全局的 loading 遮罩层，正常展示是这样的：\n\n\n\n但如果用户连续调用 loaing 两次，第二个遮罩层就会覆盖掉第一个：\n\n\n\n看起来就像出了 bug 一样，因此我们需要采用单例模式，限制用户同一时刻只能调用一个全局 loading 。\n\n\n单例模式#\n\n看下 维基百科 给的定义：\n\n> In software engineering, the singleton pattern is a software design pattern\n> that restricts the instantiation of a class to one \"single\" instance. This is\n> useful when exactly one object is needed to coordinate actions across the\n> system.\n\n可以说是最简单的设计模式了，就是保证类的实例只有一个即可。\n\n\n\n看一下 java 的示例：\n\n\n\n上边在初始化类的时候就进行了创建对象，并且将构造函数设置为 private 不允许外界调用，提供 getInstance 方法获取对象。\n\n还有一种 Lazy initialization 的模式，也就是延迟到调用 getInstance 的时候才去创建对象。但如果多个线程中同时调用\ngetInstance 可能会导致创建多个对象，所以还需要进行加锁。\n\n\n\n但单例模式存在很多争议，比如可测试性不强、对抽象、继承、多态都支持得不友好等等，但我感觉主要是基于 class 这类语言引起的问题，这里就不讨论了。\n\n回到 js ，模拟上边实现一下：\n\n\n\n但上边就真的是邯郸学步一样的模仿了 java 的实现，事实上，js 创建对象并不一定需要通过 new 的方式，下边我们详细讨论下。\n\n\njs 的单例模式#\n\n首先单例模式产生的对象一般都是工具对象等，比如 jQuery 。它不需要我们通过构造函数去传参数，所以就不需要去 new 一个构造函数去生成对象。\n\n我们只需要通过字面量对象， var a = {} ，a 就可以看成一个单例对象了。\n\n通常的单例对象可能会是下边的样子，暴露几个方法供外界使用。\n\n\n\n但如果Singleton 有私有属性，可以写成下边的样子：\n\n\n\n但此时外界就可以通过 Singleton 随意修改 privateVar 的值。\n\n为了解决这个问题，我们可以借助闭包，通过 IIFE (Immediately Invoked Function Expression) 将一些属性和方法私有化。\n\n\n\n但随着 ES6 、Webpack 的出现，我们很少像上边那样去定义一个模块了，而是通过单文件，一个文件就是一个模块，同时也可以看成一个单例对象。\n\n\n\n然后使用的时候 import 即可。\n\n\n\n即使有另一个文件也 import 了同一个文件。\n\n\n\n但这两个不同文件的 Singleton 仍旧是同一个对象，这是 ES Moudule 的特性。\n\n那如果通过 Webpack 将 ES6 转成 ES5 以后呢，这种方式还会是单例对象吗？\n\n答案当然是肯定的，可以看一下 Webpack 打包的产物，其实就是使用了 IIFE ，同时将第一次 import 的模块进行了缓存，第二次 import\n的时候会使用之前的缓存。可以看下 __webpack_require__ 的实现，和单例模式的逻辑是一样的。\n\n\n\n\n代码实现#\n\n回头开头我们说的全局 loading 的问题，解决起来也很简单，同样的，如果已经有了 loading 的实例，我们只需要直接返回即可。\n\n这里直接看一下 ElementUI 对于全局 loading 的处理。\n\n\n\n这样在使用 Element 的 loading 的时候，如果同时调用两次，其实只会有一个 loading 的遮罩层，第二个并不会显示。\n\n\n\n\n更多场景#\n\n如果使用了 ES6 的模块，其实就不用考虑单不单例的问题了，但如果我们使用的第三方库，它没有 export 一个实例对象，而是 export 一个\nfunction/class 呢？\n\n比如之前介绍的 发布-订阅模式 的 Event 对象，这个肯定需要是全局单例的，如果我们使用 eventemitter3 这个 node 包，看一下它的导出：\n\n\n\n可以看到它直接将 EventEmitter 这个函数导出了，如果每个页面都各自 import 它，然后通过 new EventEmitter()\n来生成对象，那发布订阅就乱套了，因为它们不是同一个对象了。\n\n此时，我们可以新建一个模块，然后 export 一个实例化对象，其他页面去使用这个对象就实现单例模式了。\n\n\n\n\n总#\n\n单例模式比较简单，主要是保证全局对象唯一，但相对于通过 class 生成对象的单例模式，js 就很特殊了。\n\n因为在 js 中我们可以直接生成对象，并且这个对象就是全局唯一，所以在 js 中，单例模式是浑然天成的，我们平常并不会感知到。\n\n尤其是现在开发使用 ES6 模块，每个模块也同样是一个单例对象，平常业务开发中也很少去应用单例模式，为了举出上边的例子真的是脑细胞耗尽了，哈哈。","routePath":"/posts/designPattern/singleton","lang":"","toc":[],"domain":"","frontmatter":{"title":"单例模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-06T17:31:00.000Z"},"version":""},{"id":297,"title":"状态模式","content":"状态模式主要应用在游戏、工作流引擎中，其实就是有限状态机的实现，目前开发中还没有遇到过，此处留坑。\n\n但状态模式也比较有意思，它可以将过多的 if...else... 或者 switch...case... 抽离出来，使得代码的扩展性更好一些。\n\n举个例子，详细解释可以查看极客时间的 设计模式之美 讲的。\n\n一个超级马里奥的例子，吃了蘑菇、吃了花都会有不同的状态进行转移。\n\n\n\n\n\n上边的实现没什么问题，通过 if 来进行状态的转移，并进行相关操作，但可维护性和扩展性都很差。\n\n我们可以通过状态模式进行改写，将每一种状态抽离出来，将状态的变更委托给状态类实现，原来的类不再处理。\n\n\n\n\n总#\n\n状态模式很巧妙，虽然实际开发中还没应用到，但还是很有意思的。","routePath":"/posts/designPattern/state","lang":"","toc":[],"domain":"","frontmatter":{"title":"状态模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-04T08:42:19.000Z"},"version":""},{"id":298,"title":"策略模式","content":"场景#\n\n进入一个营销活动页面，会根据后端下发的不同 type ，前端页面展示不同的弹窗。\n\n\n\n这个代码的话看了就想打人，未来新增一种弹窗类型的话，我们需要到 getMainData 内部去补一个 else\nif，一不小心可能就会影响到原有的逻辑，并且随着迭代函数会越来越大。但其实每种弹窗是相互独立的，我们并不关心其他弹窗的逻辑。\n\n此时，就需要策略模式了。\n\n\n策略模式#\n\n看下 维基百科 的定义。\n\n> 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在中国交个人所得税”和“在\n> 美国交个人所得税”就有不同的算税方法。\n> \n> 策略模式：\n> \n>  * 定义了一族算法（业务规则）；\n>  * 封装了每个算法；\n>  * 这族的算法可互换代替（interchangeable）。\n\n看一下如果是 Java 语言会怎么实现：\n\n\n\n主要是利用到类的多态，根据传入 Context 中不同的 strategy，来执行不同的 execute()。如果未来有新增算法的话，只需要新增一个类即可。\n\n那如果是 js 呢？众所周知，ES6 之前 js 是没有 class 关键字的，即使现在有了，也依然只是基于原型的语法糖，底层和 java 的类是完全不同的。\n\n此外，js 中函数是一等公民，可以当作参数传入和返回，因此实现策略模式我们完全不需要去定一个类，然后通过生成的对象调用方法。在 js\n中我们只需要将函数传入即可。\n\n\n\n上边主要演示了思想，实际开发中，我们完全可以把每种策略分文件单独写然后再 import。\n\n相对于 java，写法简单了很多，我们不需要定义各个类，只需要用一个对象来存储所有策略，再提供一个调用策略的函数，甚至这个函数也可以直接省略。\n\n\n优化代码#\n\n将所有弹窗方法从业务代码 getMainData 中抽离出来，只暴露一个打开弹窗的函数供业务调用。\n\n\n\n然后就是 popTypes.js 文件。\n\n\n\n\n更多场景#\n\n表单验证也是一个典型场景，常用的，我们需要验证用户输入字段是否是数字、是否必填、是否是数组，还有自定义的一些验证，同样可以通过策略模式实现，从而使得代码更易维护\n和扩展。\n\n如果使用过 Element UI，对下边表单的 rule 一定很熟悉。\n\n\n\nElement 会帮助我们校验 name 是否是 string、age 是否是 number。而 Element 其实是用的一个开源的\nasync-validator 校验库。\n\nasync-validator 内部会内置很多 type 的 validator，然后会根据 rule 中的 type 来帮我们填充相应的\nvalidator。让我们看一下相应的源码。\n\n首先是 validator 文件夹，会定义很多校验规则，date 类型、number 类型等等，相当于很多策略。\n\n\n\n然后是上边截图中的 validator/index.ts 文件，将这些策略导出。\n\n\n\n校验前会执行下边的代码，通过 type 填充相应的 validator。\n\n\n\n策略模式的体现就是 getValidationMethod 方法了，让我们看一下实现。\n\n\n\n填充相应的 validator 之后接下来只需要遍历相应的 rule 然后校验就可以了。\n\n\n总#\n\n当出现很多 if else 或者 switch 的时候，我们就可以考虑是否能使用策略模式了。\n\n通过策略模式，我们可以把策略从业务代码中抽离出来，未来扩展的话无需深入到业务代码修改，只需要新增需要的策略，不会使得业务代码变得越来越臃肿。\n\n甚至策略模式也可以更好的进行复用，如果其他业务场景需要类似的策略，直接引入即可，和原有的业务相互独立。","routePath":"/posts/designPattern/strategy","lang":"","toc":[],"domain":"","frontmatter":{"title":"策略模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-01-03T16:09:36.000Z"},"version":""},{"id":299,"title":"模版模式","content":"场景#\n\n示例代码来源于极客时间课程，React Hooks 核心原理与实战，顺便推荐一下，很不错的课程\n\n平常开发中一定遇到过这样的场景：发起异步请求，loading 状态显示，获取数据并显示在界面上，如果遇到错误还会显示错误状态的相关展示。\n\n为了方便运行，先写一个 mock 数据的方法：\n\n\n\n然后是列表组件：\n\n\n\n效果就是下边的样子：\n\n\n\n事实上，可能会有很多组件都需要这个过程，loading -> 展示数据 -> loading\n消失、错误展示，每一个组件单独维护这一套逻辑就太麻烦了，此时就可以用到模版模式了。\n\n\n模版模式#\n\n看下 维基百科 给到的定义：\n\n> The template method is a method in a superclass, usually an abstract\n> superclass, and defines the skeleton of an operation in terms of a number of\n> high-level steps. These steps are themselves implemented by additional helper\n> methods in the same class as the template method.\n> \n> The helper methods may be either abstract methods, in which case subclasses\n> are required to provide concrete implementations, or hook methods, which have\n> empty bodies in the superclass. Subclasses can (but are not required to)\n> customize the operation by overriding the hook methods. The intent of the\n> template method is to define the overall structure of the operation, while\n> allowing subclasses to refine, or redefine, certain steps.[2]\n\n简单来说，模版模式就是抽象父类提供一个骨架方法，里边会调用一些抽象方法或者空方法，抽象方法/空方法由子类自行去实现，可以看一下 UML 类图。\n\n\n\n举一个做饭的简单例子，看一下代码示例：\n\n\n\nCook 类提供骨架方法 startCook ，编写了做饭的主要流程，其他抽象方法 prepareIngredients 、 cooking\n下放给子类去实现自己独有的逻辑。\n\n让我们用 js 来改写一下：\n\n\n\n上边是 js 照猫画虎的去按照 java 的形式去实现模版方法，作为函数是一等公民的 js ，也许我们可以换一种方式。\n\n\njs 的模版模式#\n\n模板模式是一个方法中定义一个算法骨架，可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n\n原始定义中通过抽象类继承实现，但由于 js 并没有抽象类，实现起来也有些繁琐，也许我们可以通过组合的方式，将需要的方法以参数的形式传给算法骨架。\n\n\n\n通过组合的方式，代码会变得更加清爽简单，不需要再定义 TomatoEgg 类和 Potato 类，只需要简单的传参。\n\n但 js 实现的只能是带引号的模版方法了，一方面我们并没有通过继承去实现，另一方面 js\n并没有抽象类、抽象方法的功能，如果某些方法没有实现，并不能在代码编写阶段发现，到了运行阶段才会收到 Error。\n\n\n代码实现#\n\n回到开头异步请求的例子，我们可以定义一个请求 Hook ，将 loaing 处理、数据返回处理这些步骤封装起来，外界只需要传递请求的方法即可。\n\n\n\n业务调用的地方使用上边的 Hook 即可。\n\n\n\n完整代码放到 Sandxox 上了，感兴趣的同学也可以去运行下。\n\n\n更多场景#\n\n「模版方法」在框架中会更常见，比如我们平常写的 vue ，它的内部定义了各个生命周期的执行顺序，然后对我们开放了生命周期的钩子，可以执行我们自己的操作。\n\n\n\n「模版方法」如果再说的宽泛一点，ElementUI 的 dialog 也可以当作模版方法。\n\n\n\nel-dialog 实现了 Dialog 的基本样式和行为，并且通过 slot 以供扩展，让我们实现自己个性的东西。\n\n\n总#\n\n虽然在 js 中我们并不能真正实现模版模式，但模版模式的作用我们还是实现了，践行了「开放关闭原则」:\n\n * 对扩展开放: 可以通过传入不同的参数，实现不同的应用需求。\n\n * 对修改关闭: 模版方法通过闭包的形式，内部的属性、方法外界并不能修改。\n\n模版方法同样提升了复用能力，我们可以把公共的部分提取到模版方法中，业务方就不需要自己再实现一次了。","routePath":"/posts/designPattern/template","lang":"","toc":[],"domain":"","frontmatter":{"title":"模版模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-02-10T09:15:00.000Z"},"version":""},{"id":300,"title":"访问者模式","content":"#\n\n访问者模式主要作用是实现数据和操作的分离，可以在不改变数据类的同时，增加新的操作类型。\n\n其主要通过「双分派」的思想实现。给原数据类传入一个 Visitor 方法，原数据类调用 Visitor 提供的方法，并将自己通过 this 传给 Visitor\n，Vistior 实现相关操作。\n\n目前开发中还没有遇到过，此处留坑。","routePath":"/posts/designPattern/visitor","lang":"","toc":[],"domain":"","frontmatter":{"title":"访问者模式","category":["设计模式","frontend"],"tag":["设计模式","frontend"],"author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","date":"2022-03-03T08:12:19.000Z"},"version":""},{"id":301,"title":"JavaScript ES6 Array 数组新增方法","content":"#\n\n\nArray.of()#\n\n将参数中所有值作为元素形成数组。\n\n没有参数则返回空数组\n\n\n\n\nArray.from()#\n\n将类数组对象或可迭代对象转化为数组。\n\n\n\n\n转换类数组#\n\n\n\n\n转换 map#\n\n\n\n\n转换 set#\n\n\n\n\n转换字符串#\n\n\n\n\n方法#\n\n\nfind()查找#\n\n则返回符合条件的第一个元素。\n\n\n\n\nfindIndex() 查找索引#\n\n则返回符合条件的第一个元素的索引。\n\n\n\n\nfill()填充#\n\n\n\n\ncopyWithin() 覆盖#\n\n 1. 开始覆盖的位置索引\n 2. 复制起始位置\n 3. （可选）复制结束位置，默认为结尾\n\n\n\n\nentries() 遍历#\n\n\n\n不使用 for... of 循环\n\n\n\n\nkeys()遍历键名#\n\n\n\n\nvalues()遍历键值#\n\n\n\n\nincludes()查找#\n\n数组是否包含指定值\n\nSet 的 has 方法用于查找值，Map 的 has 方法用于查找键名。\n\n\n\n\nflat()嵌套数组转一维数#\n\n\n\n\nflatMap()#\n\n先遍历元素，再对数组执行 flat() 方法。\n\n","routePath":"/posts/ecmascript/Array","lang":"","toc":[{"text":"Array.of()","id":"arrayof","depth":2,"charIndex":3},{"text":"Array.from()","id":"arrayfrom","depth":2,"charIndex":49},{"text":"转换类数组","id":"转换类数组","depth":3,"charIndex":87},{"text":"转换 map","id":"转换-map","depth":3,"charIndex":98},{"text":"转换 set","id":"转换-set","depth":3,"charIndex":110},{"text":"转换字符串","id":"转换字符串","depth":3,"charIndex":122},{"text":"方法","id":"方法","depth":2,"charIndex":133},{"text":"find()查找","id":"find查找","depth":3,"charIndex":139},{"text":"findIndex() 查找索引","id":"findindex-查找索引","depth":3,"charIndex":169},{"text":"fill()填充","id":"fill填充","depth":3,"charIndex":210},{"text":"copyWithin() 覆盖","id":"copywithin-覆盖","depth":3,"charIndex":224},{"text":"entries() 遍历","id":"entries-遍历","depth":3,"charIndex":292},{"text":"keys()遍历键名","id":"keys遍历键名","depth":3,"charIndex":330},{"text":"values()遍历键值","id":"values遍历键值","depth":3,"charIndex":346},{"text":"includes()查找","id":"includes查找","depth":3,"charIndex":364},{"text":"flat()嵌套数组转一维数","id":"flat嵌套数组转一维数","depth":3,"charIndex":432},{"text":"flatMap()","id":"flatmap","depth":3,"charIndex":452}],"domain":"","frontmatter":{},"version":""},{"id":302,"title":"JavaScript ES6 Function 箭头函数","content":"测试","routePath":"/posts/ecmascript/Function","lang":"","toc":[{"text":"传参","id":"传参","depth":2,"charIndex":-1},{"text":"箭头函数","id":"箭头函数","depth":2,"charIndex":-1},{"text":"箭头函数不适用的场景","id":"箭头函数不适用的场景","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":303,"title":"JavaScript ES6 Generator 函数","content":"#\n\n * 执行机制\n\n 1. function 后加 *，函数执行后返回 Iterator 对象\n 2. 返回的对象调用 next 方法开始执行，遇到 yield 关键字会停止。\n 3. 再次调用 next 方法会从上一次的结束的地方继续执行，直到 yield\n 4. yield 后面的值会在 next 执行停止时返回\n 5. next 传的参数会在函数内传给 yield\n\n","routePath":"/posts/ecmascript/Generator","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":304,"title":"JavaScript ES6 Iterator 迭代器","content":"#\n\n核心概念：\n\n 1. 迭代器是一个统一的接口，作用是使各种数据结构可被便捷的访问\n 2. 是 Symbol.iterator 下的方法实现。提供这种接口的有 Array、String、arguments、Map、Set、Dom\n    元素（正在进行中）。可以被 for...of 遍历\n 3. Array 下有 Symbol 属性，所以arr[Symbol.iterator]()调用，返回 Iterator 对象\n 4. iterator 对象下 next 方法单次调用方法{value: '本次遍历的值', done: 是否遍历结束，返回 true/false }\n\n","routePath":"/posts/ecmascript/Iterator","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":305,"title":"JavaScript ES6 Map 对象","content":"#\n\n * 方法\n\nset()、get()、delete()、has()、clear()、size\n\n\nset，get 键值对#\n\nkey 是字符串\n\n\n\nkey 是对象\n\n\n\nkey 是函数时也与 key 是对象同理。\n\nkey 是 NaN ，NaN 作为 Map 的键没有区别。\n\n\n\n\nMap 的迭代 遍历#\n\n\n\n\nfor...of#\n\n\n\n\nforEach#\n\n\n\n\n对象操作#\n\n\n转换#\n\n\n\n\n克隆#\n\n\n\n\n合并#\n\n","routePath":"/posts/ecmascript/Map","lang":"","toc":[{"text":"set，get 键值对","id":"setget-键值对","depth":2,"charIndex":51},{"text":"Map 的迭代 遍历","id":"map-的迭代-遍历","depth":2,"charIndex":145},{"text":"for...of","id":"forof","depth":3,"charIndex":161},{"text":"forEach","id":"foreach","depth":3,"charIndex":175},{"text":"对象操作","id":"对象操作","depth":2,"charIndex":188},{"text":"转换","id":"转换","depth":3,"charIndex":196},{"text":"克隆","id":"克隆","depth":3,"charIndex":204},{"text":"合并","id":"合并","depth":3,"charIndex":212}],"domain":"","frontmatter":{},"version":""},{"id":306,"title":"JavaScript ES6 Object 对象","content":"#\n\n\n简写#\n\n\n对象简写#\n\n\n\n\n方法简写#\n\n\n\nGenerator 函数，要在前面加星号\n\n\n\n\n属性名表达式#\n\n * [变量]\n\n\n\n\n合并对象#\n\n\n\n:::tip 注意如果两个对象有同名的属性会被覆盖（数组也是同理） :::\n\n\nObject.assign()#\n\n\n\n将后面所有可枚举的属性赋值到 target 对象中。重复的值会覆盖\n\n\n\n只有一个参数不是对象，也会转换为对象返回\n\n\n\n第一个参数时 null 或 undefined 会报错\n\n\n\nnull 和 undefined 放第二个之后会跳过\n\n\n\n同名属性会被替换\n\n\n\n数组的处理\n\n\n\n\n链判断运算符#\n\n\n\n\n三种用法#\n\n","routePath":"/posts/ecmascript/Object","lang":"","toc":[{"text":"简写","id":"简写","depth":2,"charIndex":3},{"text":"对象简写","id":"对象简写","depth":3,"charIndex":9},{"text":"方法简写","id":"方法简写","depth":3,"charIndex":19},{"text":"属性名表达式","id":"属性名表达式","depth":3,"charIndex":53},{"text":"合并对象","id":"合并对象","depth":2,"charIndex":74},{"text":"Object.assign()","id":"objectassign","depth":3,"charIndex":123},{"text":"链判断运算符","id":"链判断运算符","depth":2,"charIndex":287},{"text":"三种用法","id":"三种用法","depth":3,"charIndex":299}],"domain":"","frontmatter":{},"version":""},{"id":307,"title":"JavaScript ES6 Promise","content":"#\n\n\nPromise 状态#\n\nPromise 状态\n\n * pending（进行中） ----> fulfilled/resolved（成功）\n * pending（进行中） ----> rejected（失败）\n\n只要处于 fulfilled/resolved [成功] 和 rejected [失败]，状态就不会再变。\n\n 1. 创建 Promise 参数内的函数会立即执行，并返回 Promise 对象\n 2. 两个参数代表状态，resolve 成功调用，reject 失败调用\n\n\n\n 3. 返回 Pormise 对象调用 then 方法，第一个参数对象 resolve 成功后的回调，第二个参数对应 reject 失败时回调。then\n    方法也会返回 Promise 对象\n\n\n\n 4. then 方法执行成功的回调时，如果发生错误，不会被第二个参数对应 reject 失败时回调捕捉到。\n 5. then 方法执行成功的回调发生错误是，链式调用 catch 方法可以捕捉前面 then 方法发生的错误\n\n\n\n\nPromise.all()与 Promise.race()#\n\n\n\n 1. 传入数组中包含多个 Promise 实例，也可以是别的值，all 包装成一个新的 Promise\n 2. 全部都成功后，返回每个 Promise 成功的值 [\"resolve 成功值 1\", \"resolve 成功值 1\"]\n 3. 任何一个失败，返回第一个失败的 Promise 结果\n\n\n\n不管成功还是失败、哪个结果获得的快，就返回那个结果。","routePath":"/posts/ecmascript/Promise","lang":"","toc":[{"text":"Promise 状态","id":"promise-状态","depth":2,"charIndex":3},{"text":"Promise.all()与 Promise.race()","id":"promiseall与-promiserace","depth":2,"charIndex":465}],"domain":"","frontmatter":{},"version":""},{"id":308,"title":"JavaScript ES6 Proxy","content":"#\n\n * target：即目标对象\n * handler：是一个对象，代理 target 的指定行为\n\n","routePath":"/posts/ecmascript/Proxy","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":309,"title":"JavaScript ES6 Set 对象","content":"#\n\n * 原型方法\n   * add()、delete()、has()、clear()、 size\n * Set 对象允许存储任何类型的唯一值，原始值或引用值都可。\n * 特殊值\n   * +0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复。\n   * undefined 与 undefined 是恒等的，所以不重复。\n   * NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。\n\n\n创建#\n\n\n\n\n转换#\n\n\n\n\n数组去重#\n\n\n\n\n并集#\n\n\n\n\n交集#\n\n\n\nSet.has(x) 是 set 中的一个方法。\n\n判断当前 set 对象 中是否含有 x，返回 true/false。\n\n\n\n[...a] 解构成数组。filter 过滤\n\n传入 x，返回 set 对象 b 中是否存在 x\n\n存在返回 true，不存在返回 false 被过滤掉\n\n\n差集#\n\n与交集同理\n\n","routePath":"/posts/ecmascript/Set","lang":"","toc":[{"text":"创建","id":"创建","depth":2,"charIndex":208},{"text":"转换","id":"转换","depth":2,"charIndex":216},{"text":"数组去重","id":"数组去重","depth":2,"charIndex":224},{"text":"并集","id":"并集","depth":2,"charIndex":234},{"text":"交集","id":"交集","depth":2,"charIndex":242},{"text":"差集","id":"差集","depth":2,"charIndex":392}],"domain":"","frontmatter":{},"version":""},{"id":310,"title":"JavaScript ES6 String 字符串新增方法","content":"#\n\n\n模板字面量#\n\n\n\n所有插入的值都会使用 toString()强制转型为字符串：\n\n\n\n也可以插入自己之前的值：\n\n\n\n\n标签函数#\n\n\n\n标签函数的表达式参数的个数始终是 n，传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。返回正常的字符串结果：\n\n\n\n\n字符串原始值#\n\n\n\n通过标签函数的第一个参数取得原始值：\n\n\n\n\n识别查找#\n\n\n\n\nrepeat()#\n\nrepeat()：返回新字符串，将字符串重复指定次数返回。\n\n\n\n0 至 -1 之间的小数，取整得到 -0 ，等同于 repeat 零次\n\nNaN，等同于 repeat 零次\n\n负数或者 Infinity ，会报错:\n\n\n\n传入字符串会隐式转换数字\n\n\n\n\n字符串补全#\n\npadStart：返回新的字符串，从头部（左侧）补全。\n\npadEnd：返回新的字符串，从尾部（右侧）补全。\n\n\n\n\n去除空格#\n\ntrimStart()：消除字符串头部的空格 trimEnd()：消除尾部的空格\n\n\n\n:::tip 提示浏览器还部署了额外的两个方法，trimLeft() 是 trimStart() 的别名，trimRight() 是 trimEnd()\n的别名。 :::\n\n\n替换#\n\nmatchAll()：方法返回一个正则表达式在当前字符串的所有匹配\n\n","routePath":"/posts/ecmascript/String","lang":"","toc":[{"text":"模板字面量","id":"模板字面量","depth":2,"charIndex":3},{"text":"标签函数","id":"标签函数","depth":2,"charIndex":64},{"text":"字符串原始值","id":"字符串原始值","depth":2,"charIndex":138},{"text":"识别查找","id":"识别查找","depth":2,"charIndex":172},{"text":"repeat()","id":"repeat","depth":2,"charIndex":182},{"text":"字符串补全","id":"字符串补全","depth":2,"charIndex":322},{"text":"去除空格","id":"去除空格","depth":2,"charIndex":389},{"text":"替换","id":"替换","depth":2,"charIndex":528}],"domain":"","frontmatter":{},"version":""},{"id":311,"title":"JavaScript ES6 Symbol 对象","content":"#\n\n符号本身是原始类型，所以 typeof 操作符对符号返回 symbol。\n\n\n\n\n声明#\n\n 1. 原始数据类型，不能使用 new\n 2. 括号内是备注的意思，独一无二的值，两个 Symbol 不相等\n 3. typeof 检测为 Symbol\n 4. 作为对象的键名独一无二、使用 [] 设置/获取，不能用.运算符获取设置\n 5. 作为对象属性名是，是共有属性，不是私有属性，可以在类的外部访问\n 6. 不能被枚举 for in、for of、Object.keys()、Object.getOwnPropertyNames() 返回\n 7. 可以被 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到\n\n\n\n作为属性名\n\n\n\n为了避免创建符号包装对象，Symbol()函数不能与 new 关键字一起作为构造函数使用。\n\n\n\n如果要包装对象\n\n\n\n * 全局符号注册表第一次调用会检查全局的注册表，不存在则生成新的符号添加到注册表，存在则会直接返回对于的。\n\n\n\n与 Symbol()定义的符号也并不等同\n\n\n\nSymbol.for()的任何值都会被转换为字符串\n\n\n\nSymbol.keyFor()来查询全局注册表\n\n\n\n计算属性语法中使用符号作为属性：\n\n\n\n如果没有保存 Symbol 的引用，需要遍历才能找到：\n\n\n\n\nSymbol.for()#\n\n\n\n 1. 全局搜索是否存在该名称\n 2. 有：返回本身，没有：新建一个返回\n 3. 使两个 Symbol 类型的变量相等，生成同一个 Hash 值\n\n\n\n\nSymbol.keyFor(sym)#\n\n 1. 查找键值的某个 Symbol\n 2. 找到返回该 Symbol 的 key 值，字符串类型。否则 undefined\n\n\n\n\nSymbol.asyncIterator#\n\n该方法返回对象默认的 AsyncIterator 由 for-await-of 语句使用。\n\n\n\n技术上来说，由 Symbol.asyncIterator 函数生成的对象应该通过 next()方法陆续返回 Promise 实例。\n\n也可以隐式通过异步生成器函数返回：\n\n\n\n\nSymbol.hasInstance#\n\nECMAScript 规范，这个符号作为一个属性表示“一个方法，传入对象返回该对象是否是它的实例。\n\ninstanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。\n\n\n\nES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系\n\n\n\nBaz 继承了 Bar 并覆写了 Symbol.hasInstance，instanceof\n操作符也会在原型链上寻找这个属性，所以说就就跟在原型链上寻找其他属性一样，这里重新定义了这个函数\n\n\n\n\nSymbol.isConcatSpreadable#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个布尔值”\n * 默认情况下则对象应该用 Array.prototype.concat()展开数组元素\n * 如果是 true，则被忽略\n\n\n\n\nSymbol.iterator#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器，由 for-of 语句使用”\n * for-of 循环时，会调用以 Symbol.iterator 为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。\n * 很多时候，返回的对象是实现该 API 的 Generator：\n\n\n\nSymbol.iterator 返回的对象可以通过 next()方法陆续返回值。也可以隐式地通过生成器函数返回：\n\n\n\n\nSymbol.match#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串。由\n   String.prototype.match()方法使用”\n * String.prototype.match() 会调用以 Symbol.match 为键的函数来正则求值\n * 正则表达式的原型上就有 Symbol.match 这个函数\n\n\n\nmatch 方法传入非正则表达式会被转为 RegExp 对象，如果要改变默认行为，需要重新定义 Symbol.match 函数。\n\nSymbol.match 接收一个参数，就是调用 match() 方法之前的字符串实例。\n\n\n\n\nSymbol.replace#\n\n * 这个符号作为一个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用”\n * String.prototype.replace() 会调用 Symbol.replace 为键的方法来正则求值\n * 正则表达式原型上也有 Symbol.replace\n\n\n\n这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象，可以重新定义 Symbol.replace 函数取代默认对正则表达式求值的行为。\n\nSymbol.replace 函数接收两个参数，即调用 replace()方法的字符串实例和替换字符串\n\n\n\n\nSymbol.search#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由\n   String.prototype.search()方法使用”\n * String.prototype.search() 会调用 Symbol.search 为键的方法来正则求值\n * 正则表达式原型上也有 Symbol.search\n\n\n\nsearch 方法传入非正则表达式值会被转换为 RegExp 对象，重新定义 Symbol.search 函数以取代默认对正则表达式求值的行为\n\nSymbol.search 函数接收一个参数，就是调用 search()方法\n\n\n\n\nSymbol.species#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。\n\n\n\n刚看到这有点懵，看下面例子：\n\n\n\n 1. MyArr 继承 Array，a 是 MyArr 构造的实例，b 又是 a 实例衍生的对象。\n 2. 按道理说 b 应该是 Array 构造出来的实例，但实际上 MyArr 构造的实例（instanceof 返回 true 说明 b 原型链上存在\n    MyArr）\n 3. 而 Symbol.species 属性就是为了解决这个问题而提供的：\n\n\n\n这样，衍生出来的 b 则不是 MyArray 构造出来的了，而是 return 返回 Array 的实例\n\n\nSymbol.split#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个正则表达式方法，方法匹配正则的索引位置拆分字符串。由\n   String.prototype.split()方法使用”。\n * String.prototype.split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值\n * 正则表达式原型上也有 Symbol.split\n\n\n\nSymbol.split 第一个参数就是调用 match()方法的字符串实例。\n\n\n\n\nSymbol.toPrimitive#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用”\n * 很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型\n * 重写 Symbol.toPrimitive 属性上的方法可以改变默认行为：\n\n\n\n\nSymbol.toStringTag#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法\n   Object.prototype.toString()使用”。\n * toString()获取对象标识时，会查找 Symbol.toStringTag 指定的实例标识符，默认为\"Object\"。\n\n\n\n内置类型已经定义了 Symbol.toStringTag 属性，但自定义类需要自己定义：\n\n\n\n\nSymbol.unscopables#\n\n * ECMAScript 规范，这个符号作为一个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除”\n * 让对应的属性值的键为 true，就可以阻止改属性出现在 with 中\n\n","routePath":"/posts/ecmascript/Symbol","lang":"","toc":[{"text":"声明","id":"声明","depth":2,"charIndex":43},{"text":"Symbol.for()","id":"symbolfor","depth":2,"charIndex":595},{"text":"Symbol.keyFor(sym)","id":"symbolkeyforsym","depth":2,"charIndex":689},{"text":"Symbol.asyncIterator","id":"symbolasynciterator","depth":3,"charIndex":777},{"text":"Symbol.hasInstance","id":"symbolhasinstance","depth":3,"charIndex":938},{"text":"Symbol.isConcatSpreadable","id":"symbolisconcatspreadable","depth":3,"charIndex":1205},{"text":"Symbol.iterator","id":"symboliterator","depth":3,"charIndex":1337},{"text":"Symbol.match","id":"symbolmatch","depth":3,"charIndex":1586},{"text":"Symbol.replace","id":"symbolreplace","depth":3,"charIndex":1900},{"text":"Symbol.search","id":"symbolsearch","depth":3,"charIndex":2217},{"text":"Symbol.species","id":"symbolspecies","depth":3,"charIndex":2534},{"text":"Symbol.split","id":"symbolsplit","depth":3,"charIndex":2863},{"text":"Symbol.toPrimitive","id":"symboltoprimitive","depth":3,"charIndex":3107},{"text":"Symbol.toStringTag","id":"symboltostringtag","depth":3,"charIndex":3289},{"text":"Symbol.unscopables","id":"symbolunscopables","depth":3,"charIndex":3524}],"domain":"","frontmatter":{},"version":""},{"id":312,"title":"JavaScript ES6 let、cont、解构","content":"#\n\n\nlet 和 const#\n\n 1. 遇到 {} 就形成作用域\n 2. 同一作用域不能重复声明变量或函数 [如：let 声明过不能用 const 和 var 声明相同名字]\n 3. 没有变量提升\n 4. const 必须初始化赋值，不能被修改，而 let 声明的变量不用\n 5. const 定义的对象或者数组，其实是可变的。\n\n * 可以修改添加属性\n\n\n\n * 不能赋值\n\n\n\n数组同理\n\n 6. 全局作用域 var 属于 window 对象。let 不属于 window 对象。\n 7. let 有暂时性死区、要先声明再使用。\n\n\n解构#\n\n[模式] = [数组];\n\n{模式} = {对象};\n\n * 完全解构\n * 不完全解构 [,可以被忽略 为赋值成功为 undefined ]\n * 嵌套\n * 默认值 , undefined 不会被赋值,null 可以被赋值\n\n数组解构\n\n\n\n 1. , 会忽略\n 2. [] 可以嵌套\n 3. undefined 不会赋值上去， m = 88 默认值，null 会被赋值\n 4. ...z 剩余运算符 收集对象/数组/值 或 展开数组/对象/值\n\n\n\n * 字符串\n\n\n\n * 对象\n\n\n\n * 解构默认值\n\n\n\n * 对象 = 数组\n\n\n\n\n运用#\n\n\n\n * 设置默认值，可以改变传入参数的顺序\n\n","routePath":"/posts/ecmascript/VariableDeclarationDestructuring","lang":"","toc":[{"text":"let 和 const","id":"let-和-const","depth":2,"charIndex":3},{"text":"解构","id":"解构","depth":2,"charIndex":271},{"text":"运用","id":"运用","depth":3,"charIndex":550}],"domain":"","frontmatter":{},"version":""},{"id":313,"title":"JavaScript ES6 async 函数","content":"#\n\n 1. async 函数返回 Promise 对象，用同步流程来表达异步操作\n 2. 虽然返回的是 Promise 对象，但不能在 async 函数中调用 resolve，reject 函数\n 3. async 可以单独使用，await 只能在 async 函数中使用\n 4. 调用 async 函数会立即执行，遇到 await 关键字会暂停执行，await 后的指向完成后，async 函数接着执行。\n 5. 如果 await 后的异步需要时间，await 下一行会接着执行，导致 await 的结果比下一行代码后得到\n 6. 解决异步需要时间的问题，await 等待的是 Promise 的结果。所以 await 后面配合 Promise 执行异步函数，但 await 不能处理\n    Promise 失败后的结果\n 7. 解决失败结果方法一：await prm().catch(e => {}); 阅读不方便\n 8. 解决方法二 ： 在 prm() 结果中不管成功还是失败,都调用 resolve 方法,成功传[null,数据]，失败传 [err]; await 执行后\n    [e,d]=await prm(); 结构判断 e 是否出错\n\n","routePath":"/posts/ecmascript/async","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":314,"title":"JavaScript ES6 class 类","content":"#\n\n 1. constructor内外都可以定义属性，前面加static为静态属性\n 2. 类里面，方法(){}为成员方法，加static为静态方法constructor内this.方法()为实例方法\n 3. 继承父类方法使用extends，子类没有constructor时会默认调用父类的constructor\n 4. 子类constructor内使用this之前必须调用super()方法把父类的this继承下来\n 5. 成员属性、方法、静态属性、方法也会继承下来。子类使用父类方法可以super.方法名，也可以this.方法\n 6. 子类用super.父类属性，也可以使用this来获取\n 7. 静态方法不能访问成员属性，成员方法不能访问静态属性\n\n","routePath":"/posts/ecmascript/class","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":315,"title":"posts","content":"#","routePath":"/posts/ecmascript/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":316,"title":"JavaScript ES6 模块化","content":"#\n\n 1. es6 模块语法无法在浏览器，vscode 直接运行。\n 2. 需要安装 npm 包：babel 将 es6 语法转换成 es5。browserify 后台代码编译成前端 npm 包\n\n单个暴露\n\n\n\n批量暴露\n\n\n\n暴露所有\n\n\n\n使用模块：导入单个对应 export\n\n\n\n引入所有：对应 export default\n\n","routePath":"/posts/ecmascript/modular","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":317,"title":"工程化","content":"editorconfig#\n\n\ngitattributes#\n\n\ngitignore#\n\n\nprettierrc#\n\n\nlicense#\n\n\npackage.json#\n\n\ntsconfig_json#\n\n\neslintrc#\n\n\n使用 husky、lint-staged、commitlint 构建前端工作流#\n\n\n作用#\n\n可以帮助我们在 commit 前，对代码和 commit messages 进行 lint\n\n\n介绍#\n\nhusky 是一个 Git Hooks 工具，让你操作 Git Hooks 变得更容易\n\nlint-staged 可以只对 git 暂存文件运行 lint 从而提高速度\n\ncommitlint 检查 git commit messages 是否符合规范\n\ncommitizen 获得有关提交消息格式的即时反馈，并提示您输入必填字段。\n\n\n安装#\n\n\n\n\n使用 commitlint#\n\n修改package.json\n\n\n\n * 根目录创建 commitlint.config.js\n\n\n\n\n@commitlint/config-conventional type 说明#\n\ntype 含义 feat 新功能 fix 修复 bug docs 修改文档 style 代码格式修改 refactor 重构（即不是新增功能，也不是修复\nbug） perf 更改代码以提高性能 test 增加测试 build 构建过程或辅助工具的变动 ci 修改项目持续集成流程 chore 其他类型的提交\nrevert 恢复上一次提交\n\n\n在项目中使用 ESLint 和 Prettier#\n\n\n全局安装依赖#\n\n\n\n\n\n它会问你一些问题，你可以按照你的喜好进行配置，我选的是 popular 下面的 standard，生成的文件是 js 格式，那么就会创建出\neslintrc.js 文件\n\n\n\n\n配置文件 .eslintrc.js 介绍#\n\n根目录新建 .eslintrc.js 文件 dgiot-dashboard .eslintrc.js\n\n\n\n.eslintrc.js 配置项说明\n\n\n添加脚本命令#\n\n在 package.json 的 scripts 配置项中写入\n\n\n\n\n使用 Prettier#\n\nPrettier 是一个代码格式化工具，它通过解析代码并使用自己的规则（考虑最大行长）重新格式化代码，从而实现一致的编码风格\n\n\n安装#\n\n\n\n * prettier代码格式化程序\n * eslint-config-prettier: 关闭 ESLint 中不必要的或可能与 Prettier 冲突的规则。\n * eslint-plugin-prettier: 将 Prettier 作为 ESLint 规则运行，并将差异报告为单个 ESLint 问题。\n\n\n修改 .eslintrc.js#\n\neslint-config-prettier 8.0.0 之后版本#\n\n在 extends 配置项中增加 prettier 和 plugin:prettier/recommended\n\neslint-config-prettier 8.0.0 之前版本#\n\n在 extends 配置项中增加 prettier/@typescript-eslint 和 plugin:prettier/recommended\n\n相关 CHANGELOG\n\n\n自定义 Prettier 风格规则#\n\n在根目录创建 prettier.config.js 文件和 .prettierignore\n\n.prettierrc dgiot-dashboard prettier\n\n自定义 Prettier 风格规则\n\n\n\n\n添加脚本命令#\n\n在 package.json 的 scripts 配置项中写入 \"prettier\": \"prettier --write ./src\"\n\nESLint Rules Prettier Options\n\n\n语义化版本控制#\n\n\n语义化版本说明#\n\n * 标准版本号表示: X.Y.Z\n   \n   \n   \n   * Y: 表示次版本号，在有向下兼容的新功能出现时递增\n   * Z: 表示修订版本号，在只做了向下兼容的修正时才递增\n\n * 先行版本号，在修订版本号使用连接号加上一连串以句点分隔的标识符来修饰。\n   \n   \n   \n   * 例子: 1.0.0-alpha 1.0.0-beta\n\n * 版本号优先级\n   \n   \n   \n   * 当主版本号、次版本号及修订版本号都相同时\n\n版本号优先级排序#\n\n 1. 要将版本号拆分为主版本号、次版本号、修订版本号及先行版本号\n 2. 由左到右依序比较每个标识符(主版本号、次版本号及修订版本号直接以数值比较)\n 3. 当主版本号、次版本号及修订版本号都相同时，以先行版本号来判断\n 4. 先行版本号判断通过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII\n    的排序来比较\n\n> 🌰 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2\n> < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\n\n\n使用 standard-version#\n\nstandard-version 可以进行语义化版本发布和 CHANGELOG 生成\n\n\n安装#\n\n\n\n\n使用#\n\n在 package.json 的 scripts 配置 \"release\": \"standard-version\"\n\n\n\n * 语义化版本 2.0.0\n * 语义版本控制程序 semver","routePath":"/posts/engineering/README","lang":"","toc":[{"text":"editorconfig","id":"editorconfig","depth":3,"charIndex":-1},{"text":"gitattributes","id":"gitattributes","depth":3,"charIndex":15},{"text":"gitignore","id":"gitignore","depth":3,"charIndex":32},{"text":"prettierrc","id":"prettierrc","depth":3,"charIndex":45},{"text":"license","id":"license","depth":3,"charIndex":59},{"text":"package.json","id":"packagejson","depth":3,"charIndex":70},{"text":"tsconfig_json","id":"tsconfig_json","depth":3,"charIndex":86},{"text":"eslintrc","id":"eslintrc","depth":3,"charIndex":103},{"text":"使用 `husky`、`lint-staged`、`commitlint` 构建前端工作流","id":"使用-huskylint-stagedcommitlint-构建前端工作流","depth":2,"charIndex":-1},{"text":"作用","id":"作用","depth":3,"charIndex":158},{"text":"介绍","id":"介绍","depth":3,"charIndex":211},{"text":"安装","id":"安装","depth":3,"charIndex":385},{"text":"使用 commitlint","id":"使用-commitlint","depth":3,"charIndex":393},{"text":"`@commitlint/config-conventional` type 说明","id":"commitlintconfig-conventional-type-说明","depth":3,"charIndex":-1},{"text":"在项目中使用 ESLint 和 Prettier","id":"在项目中使用-eslint-和-prettier","depth":2,"charIndex":674},{"text":"全局安装依赖","id":"全局安装依赖","depth":3,"charIndex":702},{"text":"配置文件 `.eslintrc.js` 介绍","id":"配置文件-eslintrcjs-介绍","depth":3,"charIndex":-1},{"text":"添加脚本命令","id":"添加脚本命令","depth":3,"charIndex":902},{"text":"使用 Prettier","id":"使用-prettier","depth":2,"charIndex":947},{"text":"安装","id":"安装-1","depth":3,"charIndex":1026},{"text":"修改 `.eslintrc.js`","id":"修改-eslintrcjs","depth":3,"charIndex":-1},{"text":"`eslint-config-prettier` 8.0.0 之后版本","id":"eslint-config-prettier-800-之后版本","depth":4,"charIndex":-1},{"text":"`eslint-config-prettier` 8.0.0 之前版本","id":"eslint-config-prettier-800-之前版本","depth":4,"charIndex":-1},{"text":"自定义 `Prettier` 风格规则","id":"自定义-prettier-风格规则","depth":3,"charIndex":-1},{"text":"添加脚本命令","id":"添加脚本命令-1","depth":3,"charIndex":1556},{"text":"语义化版本控制","id":"语义化版本控制","depth":2,"charIndex":1667},{"text":"语义化版本说明","id":"语义化版本说明","depth":3,"charIndex":1678},{"text":"版本号优先级排序","id":"版本号优先级排序","depth":4,"charIndex":1915},{"text":"使用 standard-version","id":"使用-standard-version","depth":2,"charIndex":2251},{"text":"安装","id":"安装-2","depth":3,"charIndex":2318},{"text":"使用","id":"使用","depth":3,"charIndex":2326}],"domain":"","frontmatter":{"icon":"proposal","fullscreen":false,"title":"工程化","breadcrumb":true,"contributors":true,"editLink":true,"lastUpdated":true,"prev":true,"next":true,"comment":true,"copyright":true,"article":true,"heroImage":"/logo.svg","heroText":"h7ml","tagline":"前端物语","link":"/intro.html#代码演示","date":"2021-05-27T00:00:00.000Z","author":"h7ml","index":false,"dir":{"order":2},"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml"},"version":""},{"id":318,"title":"editorconfig","content":"#\n\n跨编辑器/IDE 规范编码风格，使用 yaml 风格，配置文件为 .editorconfig\n\n官网\n\n注意在 VSCode 中需要下载一个插件，用于支持 editorconfigCore\n\n一个规范的 .editorconfig 通常是这样的：\n\n","routePath":"/posts/engineering/editorconfig","lang":"","toc":[],"domain":"","frontmatter":{"icon":"proposal","order":2,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"editorconfig","category":"engineering","tag":"editorconfig","star":true},"version":""},{"id":319,"title":"eslintrc","content":"用于配置 ESLint 规则的配置文件\n\n通常的表现形式有：\n\n * package.json 中配置 eslintConfig 字段\n * 使用 json、javascript、yaml 编写的 .eslintrc.* 文件\n\n有很多信息可以配置：\n\n * Environments - 指定脚本的运行环境。每种环境都有一组特定的预定义全局变量。\n * Globals - 脚本在执行期间访问的额外的全局变量。\n * Rules - 启用的规则及其各自的错误级别。\n\n\n例子#\n\n一个 .eslintrc 文件示例(使用 json 编写)\n\n\n\n\neslint 与 prettierrc 使用#\n\n\n安装#\n\n 1. vscode搜索插件eslint安装\n 2. 控制台运行npx i eslint --init安装并执行eslint初始化\n\n\n\n\n配置#\n\n * 依赖：npm i @vue/eslint-config-typescript -D.vue 文件的 ts 校验\n\n\n\n\n配置不要做格式校验的文件#\n\n根目录.eslintignore\n\n\n\n\n代码格式化#\n\n * vscode安装插件Prettier - Code formatter\n\n * 配置格式化规则\n\n\n\n * 配置不需要格式化的文件\n\n根目录.prettierignore\n\n\n\n\n配置prettier格式化与eslint一致#\n\n 1. vscode 快捷键 ctrl + , 打开设置\n 2. 搜索formatter\n 3. Editor:Default Formatter设置为Prettier - Code formatter\n 4. 搜索formatter on save打钩，在报存是自动格式化","routePath":"/posts/engineering/eslintrc","lang":"","toc":[{"text":"例子","id":"例子","depth":2,"charIndex":235},{"text":"安装","id":"安装","depth":2,"charIndex":300},{"text":"配置","id":"配置","depth":2,"charIndex":375},{"text":"配置不要做格式校验的文件","id":"配置不要做格式校验的文件","depth":2,"charIndex":443},{"text":"代码格式化","id":"代码格式化","depth":2,"charIndex":479},{"text":"配置`prettier`格式化与`eslint`一致","id":"配置prettier格式化与eslint一致","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"linter","order":8,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"eslintrc","category":"engineering","tag":"eslint","star":true},"version":""},{"id":320,"title":"gitattributes","content":"当执行 git 动作时，.gitattributes 文件允许你指定由 git 使用的文件和路径的属性，例如：git commit 等。\n\n比较常用的有 eol(end of line) 属性，主要原因在于 Windows 和 Unix like 的文件结尾行不同\n\n * windows 是 CRLF(Carriage Return Line Feed) 回车换行\n * 但在 unix like 系统中，使用 LF(Line Feed) 换行\n\n由于换行符不同，不同操作平台之间的开发者很容易导致 Git 提交的文件不一致(可能会从 LF 改为 CRLF 或者反之)，所以 gitattributes\n就可以排上用场了：\n\n一个规范的 .gitattributes 的文件可能是这样的：\n\n\n\n如果希望工作区的所有文本都是规范化的，可以采用\n\n\n\n在上面的配置文件中规范：\n\n * 所有文件是 auto\n * .js 是 lf\n * .ts 是 crlf\n * .sh 不进行格式化\n\n\n引用#\n\n * 详解","routePath":"/posts/engineering/gitattributes","lang":"","toc":[{"text":"引用","id":"引用","depth":2,"charIndex":445}],"domain":"","frontmatter":{"icon":"vue","order":"git","date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"gitattributes","category":"engineering","tag":"git","star":true},"version":""},{"id":321,"title":"gitignore","content":"配置此文件可以让 git 对某些特定文件不追踪变化\n\n\ngitignore 语法规则#\n\n * 空行不匹配任何文件，可以作为分隔符来提高可读性\n * # 为开头的行作为注释，若真的需要 #，则需要使用 \\#\n * / 作为目录分割\n * ! 用于排除已忽略目录中的某个子文件/目录（即再次追踪）\n * 如果在某个模式的开头或者中间（或者两者都有）存在 /，那么就是 gitignore 文件所在的根目录\n * 如果末尾存在 /，那么只匹配目录，不再匹配文件\n * * 匹配除了 / 之外的任何，? 匹配除 / 之外的一个字符，范围符号例如 [a-zA-Z] 匹配范围中的一个字符\n * ** 的意义就比较多了\n   * 例如 **/foo 匹配所有地方的 foo 文件或文件夹，与 foo 的模式相同\n   * **/foo/bar 匹配任何地方的 foo 目录下的 bar 文件或文件夹\n   * 后面的 /** 则匹配所有的子目录或者子文件，例如 a/** 匹配 a 下的所有目录和文件\n   * 中间的 ** 则表示无限深度的子目录，例如 a/**/b 匹配 a 下的所有子目录下的 b 文件或文件夹\n\n\n例子#\n\n","routePath":"/posts/engineering/gitignore","lang":"","toc":[{"text":"gitignore 语法规则","id":"gitignore-语法规则","depth":2,"charIndex":27},{"text":"例子","id":"例子","depth":2,"charIndex":505}],"domain":"","frontmatter":{"icon":"git","order":4,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"gitignore","category":"engineering","tag":"git","star":true},"version":""},{"id":322,"title":"工程化","content":"editorconfig#\n\n\ngitattributes#\n\n\ngitignore#\n\n\nprettierrc#\n\n\nlicense#\n\n\npackage.json#\n\n\ntsconfig_json#\n\n\neslintrc#\n\n\n使用 husky、lint-staged、commitlint 构建前端工作流#\n\n\n作用#\n\n可以帮助我们在 commit 前，对代码和 commit messages 进行 lint\n\n\n介绍#\n\nhusky 是一个 Git Hooks 工具，让你操作 Git Hooks 变得更容易\n\nlint-staged 可以只对 git 暂存文件运行 lint 从而提高速度\n\ncommitlint 检查 git commit messages 是否符合规范\n\ncommitizen 获得有关提交消息格式的即时反馈，并提示您输入必填字段。\n\n\n安装#\n\n\n\n\n使用 commitlint#\n\n修改package.json\n\n\n\n * 根目录创建 commitlint.config.js\n\n\n\n\n@commitlint/config-conventional type 说明#\n\ntype 含义 feat 新功能 fix 修复 bug docs 修改文档 style 代码格式修改 refactor 重构（即不是新增功能，也不是修复\nbug） perf 更改代码以提高性能 test 增加测试 build 构建过程或辅助工具的变动 ci 修改项目持续集成流程 chore 其他类型的提交\nrevert 恢复上一次提交\n\n\n在项目中使用 ESLint 和 Prettier#\n\n\n全局安装依赖#\n\n\n\n\n\n它会问你一些问题，你可以按照你的喜好进行配置，我选的是 popular 下面的 standard，生成的文件是 js 格式，那么就会创建出\neslintrc.js 文件\n\n\n\n\n配置文件 .eslintrc.js 介绍#\n\n根目录新建 .eslintrc.js 文件 dgiot-dashboard .eslintrc.js\n\n\n\n.eslintrc.js 配置项说明\n\n\n添加脚本命令#\n\n在 package.json 的 scripts 配置项中写入\n\n\n\n\n使用 Prettier#\n\nPrettier 是一个代码格式化工具，它通过解析代码并使用自己的规则（考虑最大行长）重新格式化代码，从而实现一致的编码风格\n\n\n安装#\n\n\n\n * prettier代码格式化程序\n * eslint-config-prettier: 关闭 ESLint 中不必要的或可能与 Prettier 冲突的规则。\n * eslint-plugin-prettier: 将 Prettier 作为 ESLint 规则运行，并将差异报告为单个 ESLint 问题。\n\n\n修改 .eslintrc.js#\n\neslint-config-prettier 8.0.0 之后版本#\n\n在 extends 配置项中增加 prettier 和 plugin:prettier/recommended\n\neslint-config-prettier 8.0.0 之前版本#\n\n在 extends 配置项中增加 prettier/@typescript-eslint 和 plugin:prettier/recommended\n\n相关 CHANGELOG\n\n\n自定义 Prettier 风格规则#\n\n在根目录创建 prettier.config.js 文件和 .prettierignore\n\n.prettierrc dgiot-dashboard prettier\n\n自定义 Prettier 风格规则\n\n\n\n\n添加脚本命令#\n\n在 package.json 的 scripts 配置项中写入 \"prettier\": \"prettier --write ./src\"\n\nESLint Rules Prettier Options\n\n\n语义化版本控制#\n\n\n语义化版本说明#\n\n * 标准版本号表示: X.Y.Z\n   \n   \n   \n   * Y: 表示次版本号，在有向下兼容的新功能出现时递增\n   * Z: 表示修订版本号，在只做了向下兼容的修正时才递增\n\n * 先行版本号，在修订版本号使用连接号加上一连串以句点分隔的标识符来修饰。\n   \n   \n   \n   * 例子: 1.0.0-alpha 1.0.0-beta\n\n * 版本号优先级\n   \n   \n   \n   * 当主版本号、次版本号及修订版本号都相同时\n\n版本号优先级排序#\n\n 1. 要将版本号拆分为主版本号、次版本号、修订版本号及先行版本号\n 2. 由左到右依序比较每个标识符(主版本号、次版本号及修订版本号直接以数值比较)\n 3. 当主版本号、次版本号及修订版本号都相同时，以先行版本号来判断\n 4. 先行版本号判断通过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：只有数字的标识符以数值高低比较，有字母或连接号时则逐字以 ASCII\n    的排序来比较\n\n> 🌰 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2\n> < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\n\n\n使用 standard-version#\n\nstandard-version 可以进行语义化版本发布和 CHANGELOG 生成\n\n\n安装#\n\n\n\n\n使用#\n\n在 package.json 的 scripts 配置 \"release\": \"standard-version\"\n\n\n\n * 语义化版本 2.0.0\n * 语义版本控制程序 semver","routePath":"/posts/engineering/","lang":"","toc":[{"text":"editorconfig","id":"editorconfig","depth":3,"charIndex":-1},{"text":"gitattributes","id":"gitattributes","depth":3,"charIndex":15},{"text":"gitignore","id":"gitignore","depth":3,"charIndex":32},{"text":"prettierrc","id":"prettierrc","depth":3,"charIndex":45},{"text":"license","id":"license","depth":3,"charIndex":59},{"text":"package.json","id":"packagejson","depth":3,"charIndex":70},{"text":"tsconfig_json","id":"tsconfig_json","depth":3,"charIndex":86},{"text":"eslintrc","id":"eslintrc","depth":3,"charIndex":103},{"text":"使用 `husky`、`lint-staged`、`commitlint` 构建前端工作流","id":"使用-huskylint-stagedcommitlint-构建前端工作流","depth":2,"charIndex":-1},{"text":"作用","id":"作用","depth":3,"charIndex":158},{"text":"介绍","id":"介绍","depth":3,"charIndex":211},{"text":"安装","id":"安装","depth":3,"charIndex":385},{"text":"使用 commitlint","id":"使用-commitlint","depth":3,"charIndex":393},{"text":"`@commitlint/config-conventional` type 说明","id":"commitlintconfig-conventional-type-说明","depth":3,"charIndex":-1},{"text":"在项目中使用 ESLint 和 Prettier","id":"在项目中使用-eslint-和-prettier","depth":2,"charIndex":674},{"text":"全局安装依赖","id":"全局安装依赖","depth":3,"charIndex":702},{"text":"配置文件 `.eslintrc.js` 介绍","id":"配置文件-eslintrcjs-介绍","depth":3,"charIndex":-1},{"text":"添加脚本命令","id":"添加脚本命令","depth":3,"charIndex":902},{"text":"使用 Prettier","id":"使用-prettier","depth":2,"charIndex":947},{"text":"安装","id":"安装-1","depth":3,"charIndex":1026},{"text":"修改 `.eslintrc.js`","id":"修改-eslintrcjs","depth":3,"charIndex":-1},{"text":"`eslint-config-prettier` 8.0.0 之后版本","id":"eslint-config-prettier-800-之后版本","depth":4,"charIndex":-1},{"text":"`eslint-config-prettier` 8.0.0 之前版本","id":"eslint-config-prettier-800-之前版本","depth":4,"charIndex":-1},{"text":"自定义 `Prettier` 风格规则","id":"自定义-prettier-风格规则","depth":3,"charIndex":-1},{"text":"添加脚本命令","id":"添加脚本命令-1","depth":3,"charIndex":1556},{"text":"语义化版本控制","id":"语义化版本控制","depth":2,"charIndex":1667},{"text":"语义化版本说明","id":"语义化版本说明","depth":3,"charIndex":1678},{"text":"版本号优先级排序","id":"版本号优先级排序","depth":4,"charIndex":1915},{"text":"使用 standard-version","id":"使用-standard-version","depth":2,"charIndex":2251},{"text":"安装","id":"安装-2","depth":3,"charIndex":2318},{"text":"使用","id":"使用","depth":3,"charIndex":2326}],"domain":"","frontmatter":{"icon":"proposal","fullscreen":false,"title":"工程化","breadcrumb":true,"contributors":true,"editLink":true,"lastUpdated":true,"prev":true,"next":true,"comment":true,"copyright":true,"article":true,"heroImage":"/logo.svg","heroText":"h7ml","tagline":"前端物语","link":"/intro.html#代码演示","date":"2021-05-27T00:00:00.000Z","author":"h7ml","index":false,"dir":{"order":2},"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml"},"version":""},{"id":323,"title":"license","content":"#\n\n开源协议文件\n\n * 开源许可证详解\n\n目前使用较多的开源协议为 MIT，同时该协议的最为自由","routePath":"/posts/engineering/license","lang":"","toc":[],"domain":"","frontmatter":{"icon":"license","order":5,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"license","category":"engineering","tag":"license","star":true},"version":""},{"id":324,"title":"prettierrc","content":"prettier 的配置文件\n\n通常的表现形式有：\n\n * package.json 中配置 prettier 字段\n * 用 JSON 或者 yaml 写 .prettierrc 文件\n * 一个 .prettierrc.json、.prettierrc.yaml、.prettierrc.yml、.prettierrc.json5 文件\n * 一个 .prettierrc.js、.prettierrc.cjs、prettier.config.js、prettier.config.cjs 文件用\n   module.exports 导出\n * 一个 .prettierrc.toml 文件\n\n\n例子#\n\n一个 .prettierrc 文件示例(使用 json 编写)\n\n","routePath":"/posts/engineering/prettierrc","lang":"","toc":[{"text":"例子","id":"例子","depth":2,"charIndex":299}],"domain":"","frontmatter":{"icon":"linter","order":3,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"prettierrc","category":"engineering","tag":"prettierrc","star":true},"version":""},{"id":325,"title":"tsconfig.json","content":"#\n\nTypescript 配置文件\n\n通过该配置文件可以指定 ts 编译的版本，编译的配置选项开关等\n\n文档","routePath":"/posts/engineering/tsconfig_json","lang":"","toc":[],"domain":"","frontmatter":{"icon":"json","order":7,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"tsconfig.json","category":"engineering","tag":"tsconfig","star":true},"version":""},{"id":326,"title":"es6","content":"es6 知识点#\n\nECMAScript 6 (简称 ES6) 是 JavaScript 语言的下一代标准\n\nECMAScript 的提案流程\n\n * Stage 0 - Strawman（展示阶段）\n * Stage 1 - Proposal（征求意见阶段）\n * Stage 2 - Draft（草案阶段）\n * Stage 3 - Candidate（候选人阶段）\n * Stage 4 - Finished（定案阶段）\n\n一个提案只要能进入 Stage 2 就差不多肯定会包括在以后的正式标准里面\n\nECMAScript 当前的所有提案\n\nES6 和 ES2015 的区别\n\nES2015 是一个年份标记，表示当年发布的 ECMAScript 标准的正式版本，其全称为《ECMAScript 2015 标准》（简称 ES2015）\nES6 是一个历史名词也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 ES2018\n等等\n\n\nlet const#\n\nES6 新增了 let 和 const 命令，用于声明变量，其声明的变量只在声明所在的块级作用域内有效\n\nlet const var 的区别\n * var 声明的变量会提升到作用域的顶部，let const 不存在变量提升\n * var 声明的全局变量会被挂载到全局对象 window 上，而 let const 不会\n * var 可以对一个变量进行重复声明，而 let const 不能重复声明\n * var 声明的变量作用域范围是函数作用域，let const 声明的变量作用域范围是块级作用域\n * const 声明的是一个只读的常量，一旦声明常量的值就不能改变(必须对变量进行初始化)\n   * 基本类型保证值不可变\n   * 引用类型保证内存指针不可变\n\n\n变量提升#\n\n\n\n为什么 let 和 const 不存在变量提升？ - 知乎\n\n\n挂载到全局对象#\n\n\n\n\n重复声明#\n\n\n\n\n作用域范围#\n\n\n\n\nconst 常量定义#\n\n\n\n\n模板字符串#\n\n模板字符串 (template string)\n是增强版的字符串，用反引号(`)标识。它可以当作普通字符串、定义多行字符串或者在字符串中嵌入变量、函数调用以及表达式\n\n\n\n\n解构赋值#\n\n\n解构对象#\n\n\n\n\n解构数组#\n\n\n\n\n函数的扩展#\n\n\n参数默认值#\n\n\n\n函数参数的默认值\n * 参数变量是默认声明的不能用 let或 const 再次声明，否则会报错\n * 使用参数默认值时函数不能有同名参数\n * 参数默认值的位置应该是函数的尾参数\n\n\n剩余参数(rest 参数)#\n\nES6 引入 rest 参数(形式为 ...变量名) 用于获取函数的剩余参数(可以替换 arguments 对象)\n\n\n\n剩余参数(rest 参数)\n * rest 参数是一个真正的数组，数组特有的方法都可以使用\n * rest 参数之后不能再有其他参数，否则会报错\n * 函数的 length 属性，不包括 rest 参数\n\n\n箭头函数#\n\nES6 允许使用箭头(=>)定义函数\n\n\n\n箭头函数与普通函数的区别\n * this\n   * 普通函数\n     * this 指向是动态的(取决于函数的调用方式)\n     * 可以用 call apply bind 改变 this 指向\n   * 箭头函数\n     * this 指向是固定的，指向定义时上层作用域中的 this(它没有自己的 this)\n     * call apply bind 无法改变箭头函数的 this 指向(上下文值始终按词法解析)\n     * 全局作用域下 this 指向全局对象\n * 箭头函数不可以当作构造函数(不能使用 new 运算符，否则会报错)\n * 箭头函数的函数体内不可以使用arguments super new.target\n * 箭头函数不可以使用 yield 命令(不能用作 Generator 函数)\n * 在 class 中使用箭头函数其 this 会和类实例进行绑定\n\n注意点(以下场合不应该使用箭头函数)\n * 定义对象方法且该方法内部包括 this 时\n * 定义原型方法且该方法内部包括 this 时\n * 需要动态 this 时\n\n利用 babel 编译箭头函数代码查看 this 的指向\n\n\n\n\n扩展运算符#\n\n扩展运算符 (spread)是三个点 (...) 它好比 rest 参数的逆运算\n\n\n函数调用#\n\n扩展运算符在函数调用时可以将一个数组变为参数序列，从而可以替代函数的 apply() 方法\n\n\n\n\n拷贝数组/对象#\n\n\n\n\n合并数组/对象#\n\n\n\n\n使用表达式#\n\n\n\n\n与解构赋值结合#\n\n\n\n扩展运算符\n * 使用扩展运算符拷贝数组或对象时其都是浅拷贝\n * 对象的扩展运算符等同于使用 Object.assign() 方法\n * 只有函数调用时扩展运算符才可以放在圆括号中，否则会报错\n * 扩展运算符用于赋值时只能放在参数的最后一位，否则会报错\n\n\n数组的扩展#\n\n\nArray.from()#\n\nArray.from() 用于将两类对象转为真正的数组\n\n * 类似数组的对象 (array-like object)\n   * DOM 操作返回的 NodeList\n   * arguments 对象\n * 可遍历 (iterable) 的对象 (包括 ES6 新增的数据结构 Set 和 Map)\n\n\n\nArray.from()\n\nArray.from() 可以接受一个函数作为第二个参数，作用类似于数组的map() 用来对每个元素进行处理，将处理后的值放入返回的数组\n\n在字符串转为数组时 Array.from() 能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于 \\uFFFF 的 Unicode\n字符算作两个字符的 bug\n\n\n\n\nArray.of()#\n\nArray.of() 用于将一组值转换为数组\n\n\n\nArray.of()\n\nArray.of() 方法的主要目的是弥补数组构造函数 Array() 的不足(因为参数个数的不同会导致Array()的行为有差异)\n\n\n\nArray.of() 总是返回参数值组成的数组。如果没有参数就返回一个空数组\n\n\n\n\n实例方法: includes()#\n\nincludes() 方法返回一个布尔值，表示某个数组是否包含给定的值(ES2016 引入)\n\n\n\nincludes() 和 indexOf() 的对比\n\nindexOf() 不够语义化，其含义是找到参数值的第一个出现位置，所以要去比较是否不等于 -1，表达起来不够直观 indexOf() 内部使用严格相等运算符\n(===) 进行判断，这会导致对 NaN 的误判\n\n\n实例方法: find() 和 findIndex()#\n\nfind() 方法用于找出第一个符合条件的数组成员，如果没有符合条件的成员则返回 undefined\n\nfindIndex() 方法用于找出第一个符合条件的数组成员的位置，如果没有符合条件的成员则返回 -1\n\n\n\n\n实例方法: at()#\n\nat() 方法接受一个整数(支持负数)作为参数返回对应位置的成员，如果参数位置超出了数组范围则返回 undefined\n\n\n\n\n实例方法: flat() 和 flatMap()#\n\nflat() 方法用于将嵌套的数组拍平变成一维的数组，该方法返回一个新数组不改变原数组\n\nflatMap() 方法会先对原数组的每个成员执行一个函数(相当于执行 Array.prototype.map()) 然后对返回值组成的数组执行 flat()\n方法，该方法返回一个新数组不改变原数组\n\n\n\nflat() 和 flatMap() 注意点\n * flat() 方法默认只会拉平一层\n * flat()方法会跳过原数组中的空位\n * flatMap() 只能展开一层数组\n\n\n对象的扩展#\n\n\n属性简写#\n\nES6 允许在大括号里面直接写入变量和函数作为对象的属性和方法\n\n\n\n属性简写\n\n简写的对象方法不能用作构造函数否则会报错\n\n\n\n\n属性名表达式#\n\n\n\n属性名表达式\n\n属性名表达式与属性简写不能同时使用否则会报错\n\n\n\n属性名表达式如果是一个对象会自动将其转为字符串 [object Object]\n\n\n\n\nObject.is()#\n\nObject.is() 方法用来比较两个值是否严格相等，严格比较运算符 (===) 的行为基本一致\n\n\n\nObject.is() 与 === 的不同之处\n\n+0不等于-0\n\n\n\n\nObject.assign()#\n\nObject.assign() 方法用于对象的合并，将源对象的所有可枚举属性复制到目标对象（第一个参数是目标对象后面的参数都是源对象）\n\n\n\n只有一个参数时会直接返回该参数#\n\n\n\n传入参数不是对象时会先转成对象再返回#\n\n\n\n传入非对象类型的场景#\n\n\n\n传入数组时会把数组当对象处理#\n\n\n\nObject.assign() 总结和应用场景\n\n总结\n\n * Object.assign() 是浅拷贝方法\n * 存在同名属性时，后面的属性会覆盖前面的属性\n * 只有一个参数时会直接返回该参数\n * 传入参数不是对象时会先转成对象再返回\n * 传入 undefined 和 null 时\n   * 如果为第一个参数会报错（无法转成对象）\n   * 如果不为第一个参数时会被忽略\n * 传入数组时会把数组当对象处理\n\n应用场景\n\n\n\n\nObject.keys() Object.value() Object.entries()#\n\nObject.keys() 方法返回一个数组，其成员为参数对象自身的（不含继承的）所有可遍历属性的键名(ES5 引入)\n\nObject.value() 方法返回一个数组，其成员为参数对象自身的（不含继承的）所有可遍历属性的键值(ES2017 引入)\n\nObject.entries() 方法返回一个数组（二维数组），其成员为参数对象自身的（不含继承的）所有可遍历属性的键值对数组(ES2017 引入)\n\n\n\n\nObject.fromEntries()#\n\nObject.fromEntries() 方法是 Object.entries() 的逆操作，用于将键值对的数据结构还原为对象\n\n\n\n\n对象遍历方法对比#\n\n方法名                            说明                                继承的原型属性   不可枚举属性   SYMBOL 属性   返回值\nfor...in                       遍历对象自身和继承的所有可枚举属性(不含 Symbol 属性)   ✅         ❌        ❌           key\nObject.keys                    遍历对象自身所有可枚举属性(不含 Symbol 属性)       ❌         ❌        ❌           [key...]\nObject.getOwnPropertyNames     遍历对象自身所有属性(不含 Symbol 属性)          ❌         ✅        ❌           [key...]\nObject.getOwnPropertySymbols   遍历对象自身所有的 Symbol 属性               ❌         ✅        ✅           [key...]\nReflect.ownKeys                遍历对象自身所有的属性(包含不可枚举和 Symbol 属性)    ❌         ✅        ✅           [key...]\nObject.values                  遍历对象自身所有可枚举属性(不含 Symbol 属性)       ❌         ❌        ❌           [value...]\nObject.entries                 遍历对象自身所有可枚举属性(不含 Symbol 属性)       ❌         ❌        ❌           [[key,value]...]\n\n遍历顺序\n\nES5 没有规定遍历顺序，其遍历顺序由浏览器厂商定义(可以简单理解为无序的)\n\nES6 之后规定遍历顺序将按如下规则进行\n\n 1. 首先遍历所有数值键，按照数值升序排列。\n 2. 其次遍历所有字符串键，按照加入时间升序排列。\n 3. 最后遍历所有 Symbol 键，按照加入时间升序排列。\n\nES6 内部定义了 [[OwnPropertyKeys]]() 方法对属性进行分类和排序\n\n\n运算符的扩展#\n\n\n?. 可选链操作符#\n\nES2020 引入了可选链操作符(又名链判断运算符)，其允许我们在读取对象内部的某个属性时，不需要判断属性的上层对象是否存在\n\n\n\n可选链操作符 ?. 的三种写法\n\n\n\n注意点\n 1. 可选链操作符相当于一种短路机制，只要不满足条件就不再往下执行\n 2. 当有括号时，可选链操作符对圆括号外部没有影响，只对圆括号内部有影响。\n 3. 右侧不得为十进制数值。为了保证兼容以前的代码，允许 foo?.3:0 会被解析成 foo ? .3 : 0，因此规定如果 ?.\n    后面紧跟一个十进制数字，那么 ?. 不再被看成是一个完整的运算符，而会按照三元运算符进行处理，即小数点会归属于后面的十进制数字形成一个小数。\n 4. 禁止使用以下写法\n\n\n\n\n?? 空值合并运算符#\n\nES2020引入了空值合并运算符，只有运算符左侧的值为 null 或 undefined 时才会返回右侧的值\n\n\n\n?? 和 || 的区别\n * ?? 运算符只有左侧是 null 或 undefined才会返回右侧的值\n * || 运算符只要左侧是 假值 就会返回右侧的值\n\n\n逻辑赋值运算符#\n\nES2021 引了入三个新的逻辑赋值运算符，用于将逻辑运算符与赋值运算符进行结合\n\n\n\n\nESModule#\n\nESModule 是 ES6 在语言标准的层面上实现的模块功能，其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系以及输入和输出的变量\n\n * ESModule 是编译时加载，使静态分析成为可能\n * 模块内部自动使用严格模式\n * 模块中的顶层 this 指向 undefined\n\n\nexport 命令#\n\nexport 命令用于规定模块的对外接口\n\n * 一个模块就是一个独立的文件，该文件内部的所有变量外部无法获取，如果希望外部可以获取必须使用 export 关键字输出该变量\n * 通常情况下 export 输出的变量就是本来的名字，但可以使用 as 关键字重命名\n * export 命令规定的是对外的接口其必须与模块内部的变量建立一一对应关系\n * export 命令输出的接口与其对应的值是动态绑定关系(可以取到模块内部实时的值)\n * export 命令可以出现在模块的任何位置，只要处于模块顶层就可以(在块级作用域内使用会报错)\n\n\n\n\nimport 命令#\n\nimport 命令用于输入其他模块提供的功能(变量、函数、class 等)\n\n * import 命令输入的变量都是只读的(类似于常量，即基本类型不可重新赋值，引用类型可修改属性)\n * import 命令具有提升效果，会提升到整个模块的头部首先执行\n   * import 命令是编译阶段执行的\n   * 不能使用表达式和变量\n * 重复执行同一句 import 命令只会执行一次\n * import 后面的 from 指定模块文件的位置，其可以是相对路径，也可以是绝对路径\n\n\n\n\nexport default 命令#\n\nexport default 命令可以为模块指定默认输出\n\n\n\nexport default 命令注意点\n * 一个模块只能有一个默认输出(export default 命令只能使用一次)\n * export default 命令本质上是输出一个叫做 default 的变量或方法，使用时可以为它取任意名字\n * export default 命令后面不能跟变量声明语句\n\n\n\n\nexport 与 import 的复合写法#\n\n如果在一个模块之中，需要先输入后输出同一个模块，import 命令可以与 export 命令写在一起\n\n\n\n注意点在\n\nexport 与 import 的复合写法时，输入的接口不能在当前模块中使用，只是相当于对外转发了接口\n\n\nimport()#\n\nES2020 引入 import() 函数支持动态加载模块\n\n * import() 函数可以用在任何地方，不仅仅是模块非模块的脚本也可以使用\n * import() 函数是运行时执行\n * import() 函数与所加载的模块没有静态连接关系\n * import() 函数类似于 Node.js 中的 require() 函数，区别主要是前者是异步加载后者是同步加载\n * import() 函数的返回值是 Promise 对象\n\n\n\nimport() 函数的使用场景\n * 按需加载\n * 条件加载\n * 动态的模块路径\n\n\n浏览器对 ESModule 的加载规则#\n\n浏览器加载 ESModule 同样使用\n\n当\n\n小技巧利用顶层的\n\nthis 等于 undefined 这个语法点可以判断当前代码是否在 ES6 模块之中\n\n\n\n\nPromise#\n\nPromise 是异步编程的一种解决方案，比传统的解决方案(回调函数和事件)更合理和更强大\n\nPromise 对象具有以下 3 种状态\n\n * pending 等待(初始)\n * fulfilled 成功\n * rejected 拒绝\n\nPromise 的特点\n * Promise 对象的状态不受外界影响\n * 状态一旦改变就不会再变(不可逆)，任何时候都可以得到这个结果\n * 无法取消 Promise，一旦新建就会立即执行无法中途取消\n * 当处于 pending 状态时，无法得知目前进展到哪一个阶段(刚刚开始还是即将完成)\n\n\n\n实例方法\n * Promise.prototype.then() 用于实例添加状态改变时的回调函数(第一个参数是 fulfilled 状态的回调函数，第二个参数是\n   rejected 状态的回调函数)，会返回的是一个新的 Promise 实例\n * Promise.prototype.catch() 用于指定 rejected 状态的回调函数(是 .then(null, rejection) 或\n   .then(undefined, rejection) 的别名)\n * Promise.prototype.finally() (ES2018) 用于指定不管 Promise 对象最后状态如何都会执行的操作 (finally\n   本质上是 then 方法的特例)\n\n\n\n静态方法\n * Promise.resolve()\n   * 将传入的参数转为 Promise 对象\n     * 参数是一个 Promise 实例则直接返回\n     * 参数是一个 thenable 对象(具有 then 方法的对象) 转为 Promise 对象再立即执行 thenable 对象的 then 方法\n     * 参数不是具有 then 方法的对象或根本就不是对象时返回一个 fulfilled 状态的新 Promise 对象\n     * 没有参数时返回一个 fulfilled 状态的新 Promise 对象\n * Promise.reject()\n   * 返回一个 rejected 状态的新 Promise 对象\n * Promise.all()\n   * 将多个 Promise 实例，包装成一个新的 Promise 实例，只有所有的 Promise 状态成功才会成功，如果其中一个 Promise\n     的状态失败就会失败\n * Promise.race()\n   * 将多个 Promise 实例，包装成一个新的 Promise 实例，新的 Promise\n     实例状态会根据最先更改状态的参数实例而更改状态(可以轻松实现超时方法)\n * Promise.allSettled() (ES2020)\n   * 将多个 Promise 实例，包装成一个新的 Promise 实例，新的 Promise 实例只有等到所有这些参数实例都返回结果，不管是\n     fulfilled 还是 rejected ，包装实例才会结束，一旦结束，状态总是 fulfilled\n * Promise.any() (ES2021)\n   * 将多个 Promise 实例，包装成一个新的 Promise 实例，只要参数实例有一个变成 fulfilled 状态，包装实例就会变成\n     fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例才会变成 rejected 状态","routePath":"/posts/es6","lang":"","toc":[{"text":"es6 知识点","id":"es6-知识点","depth":2,"charIndex":-1},{"text":"let const","id":"let-const","depth":2,"charIndex":455},{"text":"变量提升","id":"变量提升","depth":3,"charIndex":802},{"text":"挂载到全局对象","id":"挂载到全局对象","depth":3,"charIndex":843},{"text":"重复声明","id":"重复声明","depth":3,"charIndex":856},{"text":"作用域范围","id":"作用域范围","depth":3,"charIndex":866},{"text":"const 常量定义","id":"const-常量定义","depth":3,"charIndex":877},{"text":"模板字符串","id":"模板字符串","depth":2,"charIndex":893},{"text":"解构赋值","id":"解构赋值","depth":2,"charIndex":988},{"text":"解构对象","id":"解构对象","depth":3,"charIndex":996},{"text":"解构数组","id":"解构数组","depth":3,"charIndex":1006},{"text":"函数的扩展","id":"函数的扩展","depth":2,"charIndex":1016},{"text":"参数默认值","id":"参数默认值","depth":3,"charIndex":1025},{"text":"剩余参数(rest 参数)","id":"剩余参数rest-参数","depth":3,"charIndex":1127},{"text":"箭头函数","id":"箭头函数","depth":3,"charIndex":1308},{"text":"扩展运算符","id":"扩展运算符","depth":2,"charIndex":1853},{"text":"函数调用","id":"函数调用","depth":3,"charIndex":1904},{"text":"拷贝数组/对象","id":"拷贝数组对象","depth":3,"charIndex":1961},{"text":"合并数组/对象","id":"合并数组对象","depth":3,"charIndex":1974},{"text":"使用表达式","id":"使用表达式","depth":3,"charIndex":1987},{"text":"与解构赋值结合","id":"与解构赋值结合","depth":3,"charIndex":1998},{"text":"数组的扩展","id":"数组的扩展","depth":2,"charIndex":2141},{"text":"Array.from()","id":"arrayfrom","depth":3,"charIndex":2150},{"text":"Array.of()","id":"arrayof","depth":3,"charIndex":2500},{"text":"实例方法: includes()","id":"实例方法-includes","depth":3,"charIndex":2664},{"text":"实例方法: find() 和 findIndex()","id":"实例方法-find-和-findindex","depth":3,"charIndex":2868},{"text":"实例方法: at()","id":"实例方法-at","depth":3,"charIndex":3005},{"text":"实例方法: flat() 和 flatMap()","id":"实例方法-flat-和-flatmap","depth":3,"charIndex":3082},{"text":"对象的扩展","id":"对象的扩展","depth":2,"charIndex":3347},{"text":"属性简写","id":"属性简写","depth":3,"charIndex":3356},{"text":"属性名表达式","id":"属性名表达式","depth":3,"charIndex":3429},{"text":"Object.is()","id":"objectis","depth":3,"charIndex":3518},{"text":"Object.assign()","id":"objectassign","depth":3,"charIndex":3622},{"text":"只有一个参数时会直接返回该参数","id":"只有一个参数时会直接返回该参数","depth":4,"charIndex":3711},{"text":"传入参数不是对象时会先转成对象再返回","id":"传入参数不是对象时会先转成对象再返回","depth":4,"charIndex":3731},{"text":"Object.keys() Object.value() Object.entries()","id":"objectkeys-objectvalue-objectentries","depth":3,"charIndex":4007},{"text":"Object.fromEntries()","id":"objectfromentries","depth":3,"charIndex":4260},{"text":"对象遍历方法对比","id":"对象遍历方法对比","depth":3,"charIndex":4351},{"text":"运算符的扩展","id":"运算符的扩展","depth":2,"charIndex":5402},{"text":"?. 可选链操作符","id":"-可选链操作符","depth":3,"charIndex":5412},{"text":"?? 空值合并运算符","id":"-空值合并运算符","depth":3,"charIndex":5747},{"text":"逻辑赋值运算符","id":"逻辑赋值运算符","depth":3,"charIndex":5899},{"text":"ESModule","id":"esmodule","depth":2,"charIndex":5954},{"text":"export 命令","id":"export-命令","depth":3,"charIndex":6113},{"text":"import 命令","id":"import-命令","depth":3,"charIndex":6398},{"text":"export default 命令","id":"export-default-命令","depth":3,"charIndex":6653},{"text":"export 与 import 的复合写法","id":"export-与-import-的复合写法","depth":3,"charIndex":6863},{"text":"import()","id":"import","depth":3,"charIndex":7001},{"text":"浏览器对 ESModule 的加载规则","id":"浏览器对-esmodule-的加载规则","depth":3,"charIndex":7277},{"text":"在 script 中使用 ESModule","id":"在-script-中使用-esmodule","depth":4,"charIndex":-1},{"text":"Promise","id":"promise","depth":2,"charIndex":7381}],"domain":"","frontmatter":{"icon":"direction","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"es6","tag":"es6","title":"es6","star":true},"version":""},{"id":327,"title":"使用 Node.js 连接多种类型数据库","content":"#\n\n\n关系对比#\n\n数据库                    驱动/模块              连接方式                                                           优缺点\nMariaDB                mariadb            使用 mariadb.createConnection() 创建连接，或者使用 mariadb.createPool()   MariaDB 是 MySQL 的一个分支，与 MySQL 兼容。驱动程序相对较新，但已受到广泛认可和广泛使用。\n                                          创建连接池\nMongoDB                mongodb            使用 mongodb.MongoClient.connect() 创建连接                          MongoDB 是一个面向文档的 NoSQL 数据库，具有可伸缩性、灵活性和高速读写等特点。MongoDB\n                                                                                                         Node.js 驱动程序是官方支持的，并且易于使用。\nPostgreSQL             pg                 使用 new pg.Client() 创建连接                                        PostgreSQL 是一个功能强大的关系型数据库，具有高度的稳定性和可靠性。pg 驱动程序是 Node.js\n                                                                                                         中最流行的 PostgreSQL 驱动程序之一。\nOracle                 oracledb           使用 oracledb.getConnection() 创建连接                               Oracle 是一个功能强大的关系型数据库，主要用于企业级应用程序。oracledb\n                                                                                                         驱动程序是官方支持的，并且具有很好的性能和可靠性。\nMicrosoft SQL Server   mssql              使用 new mssql.ConnectionPool() 创建连接池                            Microsoft SQL Server 是一个功能强大的关系型数据库，主要用于企业级应用程序。mssql 驱动程序是\n                                                                                                         Node.js 中最流行的 Microsoft SQL Server 驱动程序之一。\nRedis                  ioredis            使用 new Redis() 创建连接                                            Redis 是一个内存数据结构存储系统，适用于需要快速读写和高并发的应用程序。ioredis 是一个支持 Redis\n                                                                                                         集群和复制功能的 Redis 驱动程序。\nSQLite                 better-sqlite3     使用 better-sqlite3() 创建连接                                       SQLite 是一个非常轻量级的嵌入式数据库，适用于小型项目。better-sqlite3 是官方 SQLite3\n                                                                                                         驱动程序的代替品，速度更快且易于使用。\nCouchbase              couchbase          使用 new couchbase.Cluster() 创建连接                                Couchbase 是一个面向文档的 NoSQL 数据库，适用于需要快速读写和高并发的应用程序。couchbase\n                                                                                                         驱动程序是官方支持的，并且具有很好的性能和可靠性。\nCassandra              cassandra-driver   使用 new cassandra.Client() 创建连接                                 Cassandra 是一个分布式的 NoSQL 数据库，适用于大规模数据存储和处理。cassandra-driver\n                                                                                                         是官方支持的驱动程序，并具有很好的性能和可靠性。\nNeo4j                  neo4j-driver       使用 neo4j.driver() 创建连接                                         Neo4j 是一个图形数据库，适用于需要处理高度连接数据的应用程序。neo4j-driver 是官方支持的\n                                                                                                         Node.js 驱动程序，并且易于使用。\nArangoDB               arangojs           使用 new arangojs.Database() 创建连接                                ArangoDB 是一个多模型数据库（支持文档、图形和键值数据），适用于需要存储多种类型数据的应用程序。ArangoJS\n                                                                                                         是一个用于 Node.js 的 ArangoDB 驱动程序。\nRethinkDB              rethinkdbdash      使用 rethinkdbdash() 创建连接                                        RethinkDB 是一个面向文档的 NoSQL 数据库，具有实时更新和可伸缩性等功能。它可以使用 RethinkDB\n                                                                                                         驱动程序或 rethinkdbdash。\n\n\ntypeorm#\n\nTypeORM 是一个基于 TypeScript 的 ORM（对象关系映射）框架，它支持多种不同类型的数据库，包括\nMySQL、PostgreSQL、SQLite、Microsoft SQL Server、Oracle 和 MongoDB 等。TypeORM\n提供了一套简单易用的 API，让开发者可以使用面向对象的方式来管理数据库表格和数据。\n\n\nTypeORM 具有以下特点：#\n\n * 支持 TypeScript：TypeORM 是使用 TypeScript 编写的，因此可以充分利用 TypeScript\n   的强类型特性来避免很多潜在的错误。\n * 支持多种数据库：除了传统的 SQL 数据库外，TypeORM 还支持 NoSQL 数据库 MongoDB。\n * 易于使用：TypeORM 提供了一套简洁而易于理解的 API，使得开发者可以自然而然地使用面向对象的方式来操作数据库。\n * 丰富的功能：TypeORM 不仅支持常见的 CRUD 操作，还提供了事务处理、迁移、查询构建器等丰富的功能。\n * 可扩展性：TypeORM 支持插件机制，开发者可以编写自己的插件来扩展 TypeORM 的功能。\n\n在使用 TypeORM 时，开发者需要定义实体类来映射数据库表格。实体类需要继承 BaseEntity 类，并使用装饰器来标记属性与表格字段的映射关系。例如：\n\n\n\n以上代码定义了一个名为 User 的实体类，用于映射数据库中的 user 表格。@Entity()\n装饰器表示该类是一个实体类，@PrimaryGeneratedColumn() 装饰器表示 id 属性是主键，并使用自动增长方式生成值。@Column()\n装饰器则表示该属性对应表格的一个字段。\n\n在定义完实体类后，就可以使用 TypeORM 提供的 API 来进行数据库操作了。例如，要查询所有用户的信息，可以使用以下代码：\n\n\n\nTypeORM 还提供了很多其他的 API，包括添加、更新和删除数据等操作。总之，TypeORM 是一个功能强大、易于使用的 ORM\n框架，适合用来开发各种类型的应用程序。\n\n除了基本的 CRUD 操作外，TypeORM 还提供了一些高级功能，例如事务处理、查询构建器、关系映射等。\n\n事务处理#\n\n在数据库操作中，有时需要执行多个操作，而这些操作必须要么全部成功，要么全部失败。这时就需要使用事务处理机制来实现。TypeORM 提供了\nEntityManager 类来支持事务处理。\n\n\n\n以上代码演示了一个简单的事务处理例子。在一个事务中，我们创建了一个新用户和一篇新文章，并将作者与文章关联起来。如果任何一个操作失败，整个事务都会被回滚。可以注意\n到，在 transaction 方法中传入的是一个回调函数，这个函数接收一个 EntityManager 对象，可以使用这个对象来执行数据库操作。\n\n查询构建器#\n\nTypeORM 的查询构建器提供了一种更加灵活的方式来构建查询语句，以便满足特定的查询需求。使用查询构建器，开发者可以将查询条件动态地构建成链式调用的方式。\n\n\n\n以上代码演示了一个使用查询构建器来查询用户信息的例子。该例子中，我们首先创建了一个基于 User 实体的查询构建器，并使用 where\n方法指定了查询条件，然后使用 leftJoinAndSelect 方法关联了用户和文章实体，并使用 orderBy 方法按照文章发布时间排序。最后，我们调用\ngetMany() 方法执行查询操作。\n\n关系映射#\n\n在数据库中，有时需要处理多个实体之间的关系。比如，在上面的例子中，一个用户可以拥有多篇文章。TypeORM\n提供了多种不同的关系映射方式来满足这种需求，包括一对一、一对多、多对一和多对多关系。\n\n以下是一个简单的例子，演示了如何使用 TypeORM 来定义一对多关系：\n\n\n\n以上代码中，我们使用 @OneToMany 和 @ManyToOne 装饰器来定义用户和文章之间的一对多关系。@OneToMany\n装饰器表示一个用户可以拥有多篇文章，而 @ManyToOne 装饰器则表示每篇文章都有一个作者。\n\n总之，TypeORM 是一个强大而灵活的 ORM 框架，支持多种不同类型的数据库，并提供了丰富的功能和易于使用的\nAPI。无论是开发小型应用还是大型企业级应用，TypeORM 都是一个值得考虑的选择。\n\n\n安装 TypeORM#\n\n\n\n以上命令会在当前项目中安装 TypeORM 依赖包，并将其添加到 package.json 文件的 dependencies 列表中。\n\n另外，TypeORM 还需要相应数据库的驱动程序。例如，如果要使用 MySQL 数据库，需要安装 mysql2 包；如果要使用 PostgreSQL\n数据库，需要安装 pg 包。以下是一些常用数据库的驱动程序依赖包：\n\n * MySQL: npm install mysql2 --save\n * PostgreSQL: npm install pg --save\n * SQLite: npm install sqlite3 --save\n * Microsoft SQL Server: npm install mssql --save\n * Oracle: npm install oracledb --save\n * MongoDB: npm install mongodb --save\n\n安装完成后，就可以在代码中使用 TypeORM 了。为了方便配置 TypeORM，建议在项目根目录下创建一个 ormconfig.json\n文件，用于存放数据库连接信息和其他相关配置。例如，以下是一个连接 MySQL 数据库的示例：\n\n\n\n以上配置文件中，我们指定了连接的数据库类型、主机地址、端口号、用户名、密码和数据库名称等信息。synchronize 属性表示 TypeORM\n是否自动创建数据库表格以及更新表格结构，logging 属性表示是否输出日志信息，entities、migrations 和 subscribers\n分别指定实体类、迁移文件和订阅者文件存放的位置。最后，cli 属性用于在命令行中使用 TypeORM CLI 工具时指定相关选项。\n\n总之，安装 TypeORM 很简单，只需要执行一条命令即可。不过，要使用 TypeORM 还需要根据具体情况安装相应数据库的驱动程序，并在项目根目录下创建一个\normconfig.json 文件来配置数据库连接信息和其他相关设置。\n\n\n使用 typeorm 封装通用连接方法#\n\n以下是通用的 TypeScript 连接方法：\n\n\n\n这是一个通用的 TypeORM 连接方法，适用于大多数关系型数据库。你只需要在环境变量中设置一些必要的连接参数，即可使用此方法连接到不同的数据库。\n\n\n对应不同数据库的连接方法#\n\n以下是连接不同类型数据库的示例代码方法和对应的依赖包安装步骤，使用 TypeScript 的格式返回，配置文件从 .env 文件读取。\n\n\nMySQL#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nMongoDB#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nPostgreSQL#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nOracle#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nMicrosoft SQL Server#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nRedis#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nSQLite#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nCouchbase#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nCassandra#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nNeo4j#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nArangoDB#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nRethinkDB#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nCouchDB#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nFirebase#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n\nMariaDB#\n\n依赖包：\n\n\n\n示例代码：\n\n\n\n注意，在使用以上代码前，需要先在 .env 文件中设置对应的环境变量。例如：\n\n\n\n这个示例中连接 MySQL 数据库时，使用的是 mysql2 包，因此需要安装该包。.env\n文件中设置的参数包括主机地址、用户名、密码和数据库名称。在连接数据库时，这些参数将从 .env 文件中读取。\n\n以上提供了连接不同类型数据库的示例代码方法和对应的依赖包安装步骤，都使用 TypeScript 的格式返回，并从 .env 文件读取配置文件。","routePath":"/posts/fullStackTale/Database","lang":"","toc":[{"text":"关系对比","id":"关系对比","depth":2,"charIndex":3},{"text":"typeorm","id":"typeorm","depth":2,"charIndex":3549},{"text":"TypeORM 具有以下特点：","id":"typeorm-具有以下特点","depth":3,"charIndex":3734},{"text":"事务处理","id":"事务处理","depth":4,"charIndex":4511},{"text":"查询构建器","id":"查询构建器","depth":4,"charIndex":4770},{"text":"关系映射","id":"关系映射","depth":4,"charIndex":5028},{"text":"安装 TypeORM","id":"安装-typeorm","depth":2,"charIndex":5392},{"text":"使用 typeorm 封装通用连接方法","id":"使用-typeorm-封装通用连接方法","depth":2,"charIndex":6278},{"text":"对应不同数据库的连接方法","id":"对应不同数据库的连接方法","depth":2,"charIndex":6403},{"text":"MySQL","id":"mysql","depth":3,"charIndex":6488},{"text":"MongoDB","id":"mongodb","depth":3,"charIndex":6514},{"text":"PostgreSQL","id":"postgresql","depth":3,"charIndex":6542},{"text":"Oracle","id":"oracle","depth":3,"charIndex":6573},{"text":"Microsoft SQL Server","id":"microsoft-sql-server","depth":3,"charIndex":6600},{"text":"Redis","id":"redis","depth":3,"charIndex":6641},{"text":"SQLite","id":"sqlite","depth":3,"charIndex":6667},{"text":"Couchbase","id":"couchbase","depth":3,"charIndex":6694},{"text":"Cassandra","id":"cassandra","depth":3,"charIndex":6724},{"text":"Neo4j","id":"neo4j","depth":3,"charIndex":6754},{"text":"ArangoDB","id":"arangodb","depth":3,"charIndex":6780},{"text":"RethinkDB","id":"rethinkdb","depth":3,"charIndex":6809},{"text":"CouchDB","id":"couchdb","depth":3,"charIndex":6839},{"text":"Firebase","id":"firebase","depth":3,"charIndex":6867},{"text":"MariaDB","id":"mariadb","depth":3,"charIndex":6896}],"domain":"","frontmatter":{"icon":"mysql","description":"本文介绍了如何使用 Node.js 连接多种不同类型的数据库，包括 MySQL、MongoDB、PostgreSQL、Oracle、Microsoft SQL Server、Redis、SQLite、Couchbase、Cassandra、Neo4j、ArangoDB、RethinkDB、CouchDB、Firebase 和 MariaDB，并提供了相应的示例代码和依赖包安装步骤。","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>在 Node.js 中连接 MySQL、MongoDB 和 PostgreSQL","order":3,"star":3,"date":"2024-04-10T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["Node.js","MySQL","MongoDB","PostgreSQL"],"tag":["数据库连接","Node.js"],"shortTitle":"使用 Node.js 连接多种类型数据库","head":[["meta",{"name":"keywords","content":"数据库, Node.js, MySQL, MongoDB, PostgreSQL, Oracle, Microsoft SQL Server, Redis, SQLite, Couchbase, Cassandra, Neo4j, ArangoDB, RethinkDB, CouchDB, Firebase, 示例代码, 依赖包, 配置文件, 环境变量"}]]},"version":""},{"id":328,"title":"posts","content":"#","routePath":"/posts/fullStackTale/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":329,"title":"Git","content":"Git 常用命令#\n\n\n初始化#\n\n\n\n\n克隆项目#\n\n\n\n\n长期保存密码#\n\n\n\n\n获取分支#\n\n\n\n\n合并分支#\n\n\n\n\n获取并且合并分支#\n\n\n\n\n切换分支#\n\n\n\n\n新建并切换到分支#\n\n\n\n\n删除分支#\n\n\n\n\n查看修改状态#\n\n\n\n\n查看所有的修改内容#\n\n\n\n\n查看指定文件修改内容#\n\n\n\n\n添加指定文件到暂存区#\n\n\n\n\n添加所有文件到暂存区#\n\n\n\n\n查看已经在提交区（即已经 add 了的）所有修改内容#\n\n\n\n\n提交暂存区修改到本地#\n\n\n\n\n修改刚才提交的描述#\n\n\n\n\n提交本地版本到远端#\n\n\n\n\n其他分支有紧急问题，需要马上切过去处理，但当前分支又只改了一半，又不想 commit#\n\n\n\n\n处理完其他分支的紧急问题以后，回到原先分支继续修改#\n\n\n\n\n清除所有没有 add 了的修改#\n\n\n\n\n清除指定没有 add 了的文件的修改#\n\n\n\n\n清除 untracked 的文件#\n\n\n\n\n清除 - git ignore了的文件#\n\n\n\n\ncommit 了修改到本地，想放弃这个 commit#\n\n\n\n\ncommit 了修改到本地，想放弃这个 commit，并清空修改#\n\n\n\n\ncommit 了修改到本地，想恢复特定文件成指定的历史版本#\n\n\n\n\n打标签#\n\n\n\n\n删除标签#\n\n\n\n\n列出所有标签#\n\n\n\n\n推送特定标签到远端#\n\n\n\n\n推送所有标签到远端#\n\n\n\n\n删除远端 tag#\n\n\n\n\n查看当前的 Git 配置#\n\n\n\n\n设置使用 Git 时的用户名称#\n\n\n\n\n设置使用 Git 时的邮箱地址#\n\n\n\n\n新建一个空白分支#\n\n\n\n\n显示所有远程仓库#\n\n\n\n\n取回远程仓库的变化，并与本地分支合并#\n\n\n\n\n强行推送当前分支到远程仓库，忽略冲突#\n\n\n\n\n只暂存被追踪的文件#\n\n\n\n\n\n\n\n\n查看 stash 列表#\n\n\n\n\n取出最近一次的 stash#\n\n\n\n\n取出并删除最近一次的 stash#\n\n\n\n\n清空所有 stash#\n\n\n\n\n查看提交过的完整日志#\n\n\n\n\n\n\n\n\n查看所有分支的所有操作记录（包括被删除的 commit 记录和 reset 操作）#\n\n\n\n\n撤销 commit 操作#\n\n\n\n\n撤销 commit 和 add 操作#\n\n\n\n\n撤销 commit 和 add 操作同时撤销本地已追踪内容的修改#\n\n\n\n\n删除 Git 中的所有提交历史记录#\n\n\n1. 创建 orphan 分支#\n\n\n\n\n2. 添加需要上传文件#\n\n\n\n\n3. 提交更改#\n\n\n\n\n4. 删除需要清空提交记录的分支#\n\n\n\n\n5. 将当前分支重命名为需要清空提交记录的分支名#\n\n\n\n\n6. 强制更新存储库#\n\n\n\n\n同步 github fork 项目上游更新#\n\n\n1. 添加上游仓库#\n\n\n\n\n2. 拉取上游变动#\n\n\n\n\n3. 合并(以 master 位置为例)#\n\n\n\n\n4. 更新远程 fork 仓库分支(以 master 位置为例)#\n\n\n\n\n将代码提交到 github 的 gh-pages 分支#\n\n\n1. 安装 gh-pages#\n\n\n\n\n2. 在 package.json 中添加如下脚本#\n\n\n\n\n3. 运行 deploy 脚本#\n\n\n\n\ngit log 格式化#\n\n\n\n * relative: 相对时间格式\n * local: 本地格式\n * iso OR iso8601: ISO8601 格式\n * rfc: RFC2822 格式\n * short: YYYY-MM-DD 格式\n * raw: 时间戳格式\n * default: 默认格式\n\n\n自定义输出格式#\n\n\n\n * %C(颜色值): 修改输出颜色\n * %H: 完整的 commit hash\n * %h: 缩写的 commit hash\n * %ad: 提交时间(绝对时间 可以使用 -date= 定制格式)\n * %ar: 提交时间(相对时间 按多久之前显示)\n * %s: commit message\n * %d: branch tag 信息\n * %an: 作者名称\n * %ae: 作者的邮箱地址\n\n\ngit 撤销#\n\n\n重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变#\n\n\n\n\n重置暂存区与工作区，与上一次 commit 保持一致#\n\n\n\n\n重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变#\n\n\n\n\n重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致#\n\n\n\n\n重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变#\n\n\n\n\n新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支#\n\n\n\n\n暂存操作#\n\n\n只暂存被追踪的文件#\n\n\n\n\n暂存所有文件并添加说明#\n\n\n\n\n查看 stash 列表#\n\n\n\n\n取出最近一次的 stash#\n\n\n\n\n取出 stash 列表里对应数字的暂存#\n\n\n\n\n取出并删除最近一次的 stash#\n\n\n\n\n清空所有 stash#\n\n","routePath":"/posts/git","lang":"","toc":[{"text":"Git 常用命令","id":"git-常用命令","depth":2,"charIndex":-1},{"text":"初始化","id":"初始化","depth":3,"charIndex":11},{"text":"克隆项目","id":"克隆项目","depth":2,"charIndex":20},{"text":"长期保存密码","id":"长期保存密码","depth":2,"charIndex":30},{"text":"获取分支","id":"获取分支","depth":2,"charIndex":42},{"text":"合并分支","id":"合并分支","depth":2,"charIndex":52},{"text":"获取并且合并分支","id":"获取并且合并分支","depth":2,"charIndex":62},{"text":"切换分支","id":"切换分支","depth":2,"charIndex":76},{"text":"新建并切换到分支","id":"新建并切换到分支","depth":2,"charIndex":86},{"text":"删除分支","id":"删除分支","depth":2,"charIndex":100},{"text":"查看修改状态","id":"查看修改状态","depth":2,"charIndex":110},{"text":"查看所有的修改内容","id":"查看所有的修改内容","depth":2,"charIndex":122},{"text":"查看指定文件修改内容","id":"查看指定文件修改内容","depth":2,"charIndex":137},{"text":"添加指定文件到暂存区","id":"添加指定文件到暂存区","depth":2,"charIndex":153},{"text":"添加所有文件到暂存区","id":"添加所有文件到暂存区","depth":2,"charIndex":169},{"text":"查看已经在提交区（即已经 add 了的）所有修改内容","id":"查看已经在提交区即已经-add-了的所有修改内容","depth":2,"charIndex":185},{"text":"提交暂存区修改到本地","id":"提交暂存区修改到本地","depth":2,"charIndex":217},{"text":"修改刚才提交的描述","id":"修改刚才提交的描述","depth":2,"charIndex":233},{"text":"提交本地版本到远端","id":"提交本地版本到远端","depth":2,"charIndex":248},{"text":"其他分支有紧急问题，需要马上切过去处理，但当前分支又只改了一半，又不想 commit","id":"其他分支有紧急问题需要马上切过去处理但当前分支又只改了一半又不想-commit","depth":2,"charIndex":263},{"text":"处理完其他分支的紧急问题以后，回到原先分支继续修改","id":"处理完其他分支的紧急问题以后回到原先分支继续修改","depth":2,"charIndex":311},{"text":"清除所有没有 add 了的修改","id":"清除所有没有-add-了的修改","depth":2,"charIndex":342},{"text":"清除指定没有 add 了的文件的修改","id":"清除指定没有-add-了的文件的修改","depth":2,"charIndex":363},{"text":"清除 untracked 的文件","id":"清除-untracked-的文件","depth":2,"charIndex":387},{"text":"清除 - `git ignore了的文件`","id":"清除---git-ignore了的文件","depth":2,"charIndex":-1},{"text":"commit 了修改到本地，想放弃这个 commit","id":"commit-了修改到本地想放弃这个-commit","depth":2,"charIndex":434},{"text":"commit 了修改到本地，想放弃这个 commit，并清空修改","id":"commit-了修改到本地想放弃这个-commit并清空修改","depth":2,"charIndex":466},{"text":"commit 了修改到本地，想恢复特定文件成指定的历史版本","id":"commit-了修改到本地想恢复特定文件成指定的历史版本","depth":2,"charIndex":504},{"text":"打标签","id":"打标签","depth":2,"charIndex":539},{"text":"删除标签","id":"删除标签","depth":2,"charIndex":548},{"text":"列出所有标签","id":"列出所有标签","depth":2,"charIndex":558},{"text":"推送特定标签到远端","id":"推送特定标签到远端","depth":2,"charIndex":570},{"text":"推送所有标签到远端","id":"推送所有标签到远端","depth":2,"charIndex":585},{"text":"删除远端 tag","id":"删除远端-tag","depth":2,"charIndex":600},{"text":"查看当前的 Git 配置","id":"查看当前的-git-配置","depth":2,"charIndex":614},{"text":"设置使用 Git 时的用户名称","id":"设置使用-git-时的用户名称","depth":2,"charIndex":632},{"text":"设置使用 Git 时的邮箱地址","id":"设置使用-git-时的邮箱地址","depth":2,"charIndex":653},{"text":"新建一个空白分支","id":"新建一个空白分支","depth":2,"charIndex":674},{"text":"显示所有远程仓库","id":"显示所有远程仓库","depth":2,"charIndex":688},{"text":"取回远程仓库的变化，并与本地分支合并","id":"取回远程仓库的变化并与本地分支合并","depth":2,"charIndex":702},{"text":"强行推送当前分支到远程仓库，忽略冲突","id":"强行推送当前分支到远程仓库忽略冲突","depth":2,"charIndex":726},{"text":"只暂存被追踪的文件","id":"只暂存被追踪的文件","depth":2,"charIndex":750},{"text":"查看 stash 列表","id":"查看-stash-列表","depth":2,"charIndex":769},{"text":"取出最近一次的 stash","id":"取出最近一次的-stash","depth":2,"charIndex":786},{"text":"取出并删除最近一次的 stash","id":"取出并删除最近一次的-stash","depth":2,"charIndex":805},{"text":"清空所有 stash","id":"清空所有-stash","depth":2,"charIndex":827},{"text":"查看提交过的完整日志","id":"查看提交过的完整日志","depth":2,"charIndex":843},{"text":"查看所有分支的所有操作记录（包括被删除的 commit 记录和 reset 操作）","id":"查看所有分支的所有操作记录包括被删除的-commit-记录和-reset-操作","depth":2,"charIndex":863},{"text":"撤销 commit 操作","id":"撤销-commit-操作","depth":2,"charIndex":910},{"text":"撤销 commit 和 add 操作","id":"撤销-commit-和-add-操作","depth":2,"charIndex":928},{"text":"撤销 commit 和 add 操作同时撤销本地已追踪内容的修改","id":"撤销-commit-和-add-操作同时撤销本地已追踪内容的修改","depth":2,"charIndex":952},{"text":"删除 Git 中的所有提交历史记录","id":"删除-git-中的所有提交历史记录","depth":2,"charIndex":990},{"text":"1. 创建 orphan 分支","id":"1-创建-orphan-分支","depth":3,"charIndex":1011},{"text":"2. 添加需要上传文件","id":"2-添加需要上传文件","depth":3,"charIndex":1032},{"text":"3. 提交更改","id":"3-提交更改","depth":3,"charIndex":1049},{"text":"4. 删除需要清空提交记录的分支","id":"4-删除需要清空提交记录的分支","depth":3,"charIndex":1062},{"text":"5. 将当前分支重命名为需要清空提交记录的分支名","id":"5-将当前分支重命名为需要清空提交记录的分支名","depth":3,"charIndex":1084},{"text":"6. 强制更新存储库","id":"6-强制更新存储库","depth":3,"charIndex":1114},{"text":"同步 github fork 项目上游更新","id":"同步-github-fork-项目上游更新","depth":2,"charIndex":1130},{"text":"1. 添加上游仓库","id":"1-添加上游仓库","depth":3,"charIndex":1155},{"text":"2. 拉取上游变动","id":"2-拉取上游变动","depth":3,"charIndex":1170},{"text":"3. 合并(以 master 位置为例)","id":"3-合并以-master-位置为例","depth":3,"charIndex":1185},{"text":"4. 更新远程 fork 仓库分支(以 master 位置为例)","id":"4-更新远程-fork-仓库分支以-master-位置为例","depth":3,"charIndex":1211},{"text":"将代码提交到 github 的 gh-pages 分支","id":"将代码提交到-github-的-gh-pages-分支","depth":2,"charIndex":1249},{"text":"1. 安装 gh-pages","id":"1-安装-gh-pages","depth":3,"charIndex":1280},{"text":"2. 在 package.json 中添加如下脚本","id":"2-在-packagejson-中添加如下脚本","depth":2,"charIndex":1300},{"text":"3. 运行 deploy 脚本","id":"3-运行-deploy-脚本","depth":2,"charIndex":1331},{"text":"git log 格式化","id":"git-log-格式化","depth":2,"charIndex":1352},{"text":"自定义输出格式","id":"自定义输出格式","depth":2,"charIndex":1509},{"text":"git 撤销","id":"git-撤销","depth":2,"charIndex":1723},{"text":"重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变","id":"重置暂存区的指定文件与上一次-commit-保持一致但工作区不变","depth":3,"charIndex":1733},{"text":"重置暂存区与工作区，与上一次 commit 保持一致","id":"重置暂存区与工作区与上一次-commit-保持一致","depth":3,"charIndex":1773},{"text":"重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变","id":"重置当前分支的指针为指定-commit同时重置暂存区但工作区不变","depth":3,"charIndex":1805},{"text":"重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致","id":"重置当前分支的-head-为指定-commit同时重置暂存区和工作区与指定-commit-一致","depth":3,"charIndex":1845},{"text":"重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变","id":"重置当前-head-为指定-commit但保持暂存区和工作区不变","depth":3,"charIndex":1900},{"text":"新建一个 commit，用来撤销指定 commit 后者的所有变化都将被前者抵消，并且应用到当前分支","id":"新建一个-commit用来撤销指定-commit-后者的所有变化都将被前者抵消并且应用到当前分支","depth":3,"charIndex":1939},{"text":"暂存操作","id":"暂存操作","depth":2,"charIndex":1995},{"text":"只暂存被追踪的文件","id":"只暂存被追踪的文件-1","depth":3,"charIndex":2003},{"text":"暂存所有文件并添加说明","id":"暂存所有文件并添加说明","depth":3,"charIndex":2018},{"text":"查看 stash 列表","id":"查看-stash-列表-1","depth":3,"charIndex":2035},{"text":"取出最近一次的 stash","id":"取出最近一次的-stash-1","depth":3,"charIndex":2052},{"text":"取出 stash 列表里对应数字的暂存","id":"取出-stash-列表里对应数字的暂存","depth":3,"charIndex":2071},{"text":"取出并删除最近一次的 stash","id":"取出并删除最近一次的-stash-1","depth":3,"charIndex":2096},{"text":"清空所有 stash","id":"清空所有-stash-1","depth":3,"charIndex":2118}],"domain":"","frontmatter":{"icon":"git","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"git","tag":"git","title":"Git","star":true},"version":""},{"id":330,"title":"github","content":" * action","routePath":"/posts/github/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"github","order":5,"author":"h7ml","category":"github","tag":"github","title":"github","index":false,"dir":{"order":1},"date":"2023-01-18T00:00:00.000Z"},"version":""},{"id":331,"title":"github action","content":"GitHub Actions#\n\nGitHub Actions 是一个持续集成和持续交付 (CI/CD)\n平台，可用于自动执行构建、测试和部署管道。您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。将 GitHub Actions\n命令保存为 main.yml，放于 .github\\workflows 目录下，repo 发生指定调节的改变时，Actions 会自动运行。[1]\n\n * GitHub Actions 官方市场 open in new window\n * Awesome Actionsopen in new window\n\n如果 GitHub Actions\n命令中有涉及密码等私密信息，则进入项目仓库的「setting」>「Secrets」>「Action」，添加密钥进行加密处理。比如新建密钥\nPERSONAL_TOKEN，Actions 命令中使用 ${{ secrets.PERSONAL_TOKEN }} 来指代该密钥。\n\n\n不同仓库间复制#\n\n复制文件到目的地，文档没变化则不会执行。案例为将当前仓库 main 分支下 docs 的 README.mdopen in new window\n文件复制到另一个仓库 rockbenben/LearnData/ 路径下，如果目标路径存在相同文件，则将覆盖。如果让 clean: true\n生效，Actions 会将目标路径情况，然后执行复制。\n\n此动作需按 Creating a personal access tokenopen in new window 建立 个人访问令牌 open in new\nwindow，勾选权限「repo Full control of private repositories」，然后将该 token 值其保存在项目仓库的\nAction 密钥。\n\n\n\n\nActions 失败重试#\n\n在 job 和 step 中使用 if 语句，只有满足条件时才执行具体的 job 或 step。[2]\n\n\n\nfirst_step 会总是执行，second_step 需要上一步 first_step 执行成功才会执行，third_step 只有上一步\nsecond_step 执行失败才执行。当 third_step 与 second_step 命令相同时，就可以达到失败重试的效果了。\n\n\n\n\nuses 版本号#\n\nuses: SamKirkland/FTP-Deploy-Action@4.3.1：uses 会指定此步骤运行\nSamKirkland/FTP-Deploy-Action 存储库中的 4.3.1 版本。\n\n但有时 Actions 的版本不会这么快更新，又必须使用最新版，可以将版本号改为 branch name，比如 uses:\nSamKirkland/FTP-Deploy-Action@master。\n\n\n常见问题#\n\n\nGitHub 忽略指定文件#\n\n项目路径新建一个命名为 .gitignore 的文件，将想要忽略的文件夹和文件写入 .gitignore 文件，换行分隔。\n\n比如要忽略 node_modules 文件夹，就直接在文件中输入 node_modules。\n\n--------------------------------------------------------------------------------\n\n 1. 了解 GitHub Actionsopen in new window ↩︎\n\n 2. 最全总结，GitHub Action 自动化部署 open in new window ↩︎","routePath":"/posts/github/action","lang":"","toc":[{"text":"GitHub Actions","id":"github-actions","depth":2,"charIndex":-1},{"text":"不同仓库间复制","id":"不同仓库间复制","depth":3,"charIndex":444},{"text":"Actions 失败重试","id":"actions-失败重试","depth":3,"charIndex":798},{"text":"uses 版本号","id":"uses-版本号","depth":3,"charIndex":1012},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":1228},{"text":"GitHub 忽略指定文件","id":"github-忽略指定文件","depth":3,"charIndex":1236}],"domain":"","frontmatter":{"icon":"github","order":1,"date":"2023-01-18T00:00:00.000Z","author":"h7ml","title":"github action","category":"github","tag":"github","star":true,"lastUpdated":false},"version":""},{"id":332,"title":"github","content":" * action","routePath":"/posts/github/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"github","order":5,"author":"h7ml","category":"github","tag":"github","title":"github","index":false,"dir":{"order":1},"date":"2023-01-18T00:00:00.000Z"},"version":""},{"id":333,"title":"图形学","content":" * svg\n\n * canvas\n\n * webgl\n\n * baiduMap\n\n * erharts\n\n * openlayers\n\n * three\n\n * fabric\n\n * konva","routePath":"/posts/graphics/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":5,"author":"h7ml","category":"graphics","tag":"graphics","title":"图形学","index":false,"dir":{"order":2},"date":"2021-01-17T00:00:00.000Z"},"version":""},{"id":334,"title":"baiduMap","content":"#","routePath":"/posts/graphics/baiduMap","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":5,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":335,"title":"canvas","content":"#","routePath":"/posts/graphics/canvas","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":3,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":336,"title":"erharts","content":"#","routePath":"/posts/graphics/erharts","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":4,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":337,"title":"fabric","content":"#","routePath":"/posts/graphics/fabric","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":8,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":338,"title":"图形学","content":" * svg\n\n * canvas\n\n * webgl\n\n * baiduMap\n\n * erharts\n\n * openlayers\n\n * three\n\n * fabric\n\n * konva","routePath":"/posts/graphics/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":5,"author":"h7ml","category":"graphics","tag":"graphics","title":"图形学","index":false,"dir":{"order":2},"date":"2021-01-17T00:00:00.000Z"},"version":""},{"id":339,"title":"konva","content":"#\n\n\n前言#\n\n用过 Canvas 的都知道它的 API 比较多，使用起来也很麻烦，比如我想绘制一个圆形就要调一堆 API，对开发算不上友好。\n\n\n\n为了解决这个痛点，诞生了例如 PIXI、ZRender、Fabric 等 Canvas 库。今天要讲的 Konva 也是一个很优秀的 Canvas 框架，API\n封装简洁易懂，基于 TypeScript 实现，有 React 和 Vue 版本。\n\n\n\n\n架构设计#\n\n\nKonva Tree#\n\n从前言里面给的那段代码可以看出来，Konva 有一定的嵌套结构，有些类似 DOM 结构。通过 add 和 remove 就能实现子节点的添加和删除。 Konva\nTree 主要包括这么几部分：\n\n 1. Stage 根节点：这是应用的根节点，会创建一个 div 节点，作为事件的接收层，根据事件触发时的坐标来分发出去。一个 Stage 节点可以包含多个\n    Layer 图层。\n 2. Layer 图层：Layer 里面会创建一个 Canvas 节点，主要作用就是绘制 Canvas 里面的元素。一个 Layer 可以包含多个 Group\n    和 Shape。\n 3. Group 组：Group 包含多个 Shape，如果对其进行变换和滤镜，里面所有的 Shape 都会生效。\n 4. Shape：指 Text、Rect、Circle 等图形，这些是 Konva 封装好的类。\n\n\nbuild dom#\n\nStage 创建的时候会去创建两个 Canvas 节点以及 content 容器节点，这两个 Canvas 节点是用于 perfectDrawEnabled\n的，后面会讲到。这里需要注意的就是这个 content 节点，作为整个 Konva 画布的容器，之后的 Layer 都会被 append 进去。\n\n\n\n在调用 Stage.add 的时候，不仅会调用 Layer 的绘制方法，还会把 Layer 的 Canvas 节点 append 进去。\n\n\n\n\n渲染#\n\n\n批量渲染#\n\n从前面的代码中可以看到，没有手动调用绘制方法，但依然会进行绘制，说明会在一定的时机进行渲染。 这个时机就在 add 方法里面，不管\nGroup、Layer、Stage 哪个先 add，最终都会触发渲染。他们三个都继承了 Container 类，在 Container 类里面有一个 add\n方法，我们来一探究竟。\n\n\n\n除了一些常规的处理之外，渲染的关键就在 _requestDraw 方法里面。这里调用了 Layer 上面的 batchDraw 进行批量重绘。\n\n\n\n这个批量重绘的原理是利用 requestAnimationFrame 方法将要绘制的内容放到下一帧来绘制。这样同时修改多个图形多个属性就不需要反复绘制了。\n\n\n\n\nShape 绘制#\n\n所有涉及到图形绘制的地方都是调用 Shape 实现类上的 _sceneFunc 方法，以 Circle 为例：\n\n\n\n在 Shape 和 Node 两个基类上面只负责调用，具体的实现放到具体的 Shape\n实现上面。这样带来两个好处，一个是可以实现自定义图形，另一个是以后要是支持 SVG、WebGL 会很方便。\n\n\n离屏渲染#\n\n什么是离屏渲染？就是在屏幕之外预渲染一个 Canvas，之后通过 drawImage 的形式将其绘制到屏幕要显示的 Canvas\n上面，对形状相似或者重复的对象绘制性能提升非常高。假设我们有个列表页，每次滚动的时候全部重新绘制开销会比较大。但如果我们实现一个 Canvas\n池，把已经绘制过的列表项存起来。下次滚动到这里的时候，就可以直接从 Canvas 池里面取出来 drawImage 到页面上了。在 Node 类上面有个\ncache 方法，这个方法可以实现细粒度的离屏渲染。 cache 方法内部会创建三个 canvas，分别是：\n\n 1. cachedSceneCanvas：用于绘制图形的 canvas 的离屏渲染。\n 2. cachedFilterCanvas：用于处理滤镜效果。\n 3. cachedHitCanvas：用于处理 hitCanvas 的离屏渲染。\n\n\n\n\nperfectDrawEnabled#\n\nCanvas 在绘制 stroke 和 fill 的时候，如果遇到透明度的时候，stroke 会和 fill\n的一部分重合到一起，就不符合我们的预期了。比如下面这段代码：\n\n\n\n它的实际展示效果是这样的，中间的 stroke 和 fill 有一部分重叠。 在这种情况下，KonvaJS 实现了一个 perfectDrawEnabled\n功能，它会这样做：\n\n 1. 在 bufferCanvas 上绘制 Shape\n 2. 绘制 fill 和 stroke\n 3. 在 layer 上应用透明度\n 4. 将 bufferCanvas 绘制到 sceneCanvas 上面可以看到开启 perfectDrawEnabled 和关闭\n    perfectDrawEnabled 的区别很明显： 它会在 Stage 里面创建一个 bufferCanvas 和\n    bufferHitCanvas，前者就是针对 sceneCanvas 的，后者是针对 hitCanvas 的。在 Shape 的 drawScene\n    方法里面，会判断是否使用 bufferCanvas：\n\n\n\n\n事件#\n\nKonva 里面的事件是在 Canvas 外层创建了一个 div 节点，在这个节点上面接收了 DOM 事件，再根据坐标点来判断当前点击的是哪个\nShape，然后进行事件分发。所以关键就在如何判断当前点击的 Shape 是哪个？相比 ZRender 里面比较复杂的计算，Konva\n使用了一个相当巧妙的方式。\n\n\n事件分发#\n\nKonva 目前支持下面这么多事件，EVENTS 是 事件名-事件处理方法 的映射。\n\n\n\n我们以 mousedown 这个具体的事件作为例子来分析，它的处理方法在 _pointerdown 里面。 _pointerdown 先执行了\nsetPointersPositions，计算当前鼠标点击的坐标，减去 content 相对页面的坐标，得到了当前点击相对于 content\n的坐标。同时将其存入了 _changedPointerPositions 里面。 然后遍历 _changedPointerPositions，通过\ngetIntersection 获取到了点击的 Shape 图形。这个 getIntersection 遍历调用了每个 Layer 的\ngetIntersection 方法，通过 Layer 获取到了对应的 Shape。因为可以存在多个 Layer，每个 Layer 也可以在同一个位置绘制多个\nShape，所以理论上可以获取到多个 Shape，Konva 这里只取了第一个 Shape，按照 Layer -Shape 的顺序来的。 然后 Stage\n会调用 Shape 上面的 _fireAndBubble 方法，这个方法调用 _fire 发送 Konva 自己的事件，此时通过 on\n绑定的事件回调就会触发，有点儿像 jQuery 那样。然后 Konva 会继续往上找到父节点，继续调用父节点的 _fireAndBubble\n方法，直到再也找不到父节点为止，这样就实现了事件冒泡。对于不想被点击到的 Shape 来说，可以设置 isListening 属性为\nfalse，这样事件就不会触发了。\n\n\n匹配 Shape#\n\n那么 Layer 是怎么根据点击坐标获取到对应的 Shape 呢？如果是规则的图形（矩形、圆形）还比较容易计算，要是下面这种不规则图形呢？ 众所周知，在\nCanvas 里面有个 getImageData 方法，它会根据传入的坐标来返回一个 ImageData\n信息，里面有当前坐标对应的色值。那么我们能不能根据这个色值来获取到对应的 Shape 呢？ 因此，Konva 在创建 Layer 的时候会创建两个\nCanvas，一个用于 sceneCanvas 用于绘制 Shape，另一个 hitCanvas 在内存里面，用于判断是否被打击。\n\n\n\n当 Shape 初始化的时候，会生成一个随机的颜色，以这个颜色作为 key 存入到 shapes 数组里面。\n\n\n\n每次在 sceneCanvas 上面绘制的时候，同样会在内存中的 hitCanvas 里面绘制一遍，并且将上面随机生成的色值作为 fill 和 stroke\n的颜色填充。当点击 sceneCanvas 的时候，获取到点击的坐标点，通过调用 hitCanvas 的 getImageData 就可以获取到\ncolorKey，然后再通过 colorKey 就能找到对应的 Shape 了，真是相当巧妙的实现。 但这种方式也有缺陷，因为生成的随机 hex\n颜色是有上限的，最多会会有 256256 256 = 16777216 种，如果超过了这么多就会导致匹配不准确。不过考虑一下如果有 16777216 个 DOM\n节点，浏览器就会卡爆了，换成这么多 Canvas 图形一样会导致性能爆炸。\n\n\n自定义 hitFunc#\n\n如果你想自定义事件响应区域，Konva 也提供了 hitFunc 方法给你实现。在绘制 hitCanvas 的时候，原本的绘制 sceneFunc\n就失效了，取而代之的是绘制 hitFunc。\n\n\n\n\n拖拽事件#\n\nKonva 的拖拽事件没有使用原生的方法，而是基于 mousemove 和 touchmove 来计算移动的距离，进而手动设置 Shape\n的位置，实现逻辑比较简单，这里不细说。\n\n\n滤镜#\n\nKonva 支持多种滤镜，在使用滤镜之前需要先将 Shape cache 起来，然后使用 filter() 方法添加滤镜。 在 cache\n里面除了创建用于离屏渲染的 Canvas，还会创建滤镜 Canvas。滤镜处理在 _getCachedSceneCanvas 里面。 首先将\nsceneCanvas 通过 drawImage 绘制到 filterCanvas 上面，接着 filterCanvas 获取所有的\nImageData，遍历所有设置的滤镜方法，将 ImageData 传给滤镜方法来处理。处理完 ImageData 之后，再将其通过 putImageData\n绘制到 filterCanvas 上面。\n\n\n\n那滤镜效果怎么画上去的呢？在 konva 里面进行了特殊处理，如果存在 filterCanvas，那就不会使用 cacheCanvas\n了，也就是我们原本用于缓存的离屏 Canvas 会被 filterCanvas 进行替代。最终 filterCanvas 会通过 drawImage\n的方式绘制到 sceneCanvas 上面。\n\n\n选择器#\n\nKonva 实现了选择器，方便我们快速查找到某个 Shape。目前主要有三种选择器，分别是 id 选择器、name 选择器、type\n选择器。前两者需要在实例化的时候传入一个 id 或者 name 属性，后者则是根据类名（Rect、Line 等）来查找的。选择器查找的时候需要调用 find\n方法，这个 find 方法挂载在 Container 类上面。它调用了 _descendants 进行子节点的遍历，将遍历的 node 节点调用 isMatch\n方法来判断是否匹配上。\n\n\n\n在 isMatch 里面可以看到后根据是什么类型的选择器来分别进行匹配。\n\n\n\n\n序列化#\n\nKonva 还支持对 Stage 的序列化和反序列化，简单来说就是把 Stage 的数据导出成一份 JSON 数据以及把 JSON 数据导入，方便我们在\nNodeJS 端进行服务端渲染。序列化主要在 toObject 方法里面，它会对函数和 DOM 节点进行过滤，只保留一份描述信息，比如 Layer\n的信息、Shape 的信息等等，有点儿类似 React 里面的 Virtual DOM。\n\n\n\n而反序列化则是对传入的 JSON 信息进行解析，根据 className 来创建不同的对象，对深层结构进行递归，然后 add 到父节点里面。\n\n\n\n\nReact#\n\nKonva 和 React 绑定没有使用重新封装一遍组件的方式，而是采用了和 react-dom、react-native 一样的形式，基于\nreact-reconciler 来实现一套 hostConfig，从而定制自己的 Host Component（宿主组件）。\n\n\nreact-reconciler#\n\nReact Fiber 架构诞生之后，他们就将原来的 React 核心代码做了抽离。主要包括 react、react-reconciler 和 platform\n实现（react-dom、react-native 等）三部分。在 react-reconciler 里面实现了大名鼎鼎的 Diff\n算法、时间切片、调度等等，它还暴露给了我们一个 hostConfig 文件，允许我们在各种钩子函数中实现自己的渲染。在 React 里面，有两种组件类型，一种是\nHost Component（宿主组件），另一种是 Composition Component（复合组件）。在 DOM 里面，前者就是 h1、div、span\n等元素，在 react-native 里面，前者就是 View、Text、ScrollView 等元素。后者则是我们基于 Host Component\n自定义的组件，比如 App、Header 等等。在 react-reconciler 里面，它允许我们去自定义 Host Component\n的渲染（增删查改），这也意味着跨平台的能力。我们只需要编写一份 hostConfig 文件，就能够实现自己的渲染。 参考上面的架构图，会发现不管是渲染到\nnative、canvas，甚至是小程序都可以。业界已经有方案是基于这个来实现了，可以参考蚂蚁金服的 remax：Remax - 使用真正的 React\n构建小程序\n\n\nreact-konva#\n\nreact-konva 的主要实现就在 ReactKonvaHostConfig.js 里面，它利用 Konva 原本的 API 实现了对 Virtual\nDOM 的映射，响应了 Virtual DOM 的增删查改。这里从中抽取了部分源码：\n\n\n\n\nvue-konva#\n\n在 Vue 上面，Konva 通过 Vue.use 注册了一个插件，这个插件里面分别注册了每个组件。\n\n\n\n再来看看 KonvaNode 的实现，在 KonvaNode 里面，对于节点的增删查改都在 Vue 的生命周期里面实现的。 在 Vue 的 created\n生命周期里面调用 initKonva 去 new 一个 NodeClass，和上面 React 的方式几乎一样。\n\n\n\n而在 Updated 的时候去进行 Props 的更新，在 destroyed 里面对节点进行 destroy，实现上更加简洁一些。\n\n\n\n\n缺陷#\n\n\n脏矩形#\n\n在性能方面，Konva 对比 PIXI、ZRender 这些库还是不太够看。如果我们 Layer 上有非常多的 Shape，如果想更新某个 Shape，按照\nKonva 的实现方式依然会全量绘制。虽然 Konva 支持单个 Shape\n重绘，但实现上是无脑覆盖原来的位置，这也意味着如果你的图形在其他节点图形下面，就会出现问题。所以这里缺少非常重要的局部更新能力，也就是我们常说的脏矩形。脏矩形就\n是指当我们更新一个 Shape 的时候，利用碰撞检测计算出和他相交的所有 Shape，将其进行合并，计算出一块儿脏区域。然后我们通过 clip 限制\nCanvas 只在这块儿脏区进行绘制，这样就实现了局部更新。 可惜 Konva 的包围盒实现的非常简单，不适合做碰撞检测，它也没有提供脏矩形的能力。","routePath":"/posts/graphics/konva","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"架构设计","id":"架构设计","depth":2,"charIndex":202},{"text":"Konva Tree","id":"konva-tree","depth":3,"charIndex":210},{"text":"build dom","id":"build-dom","depth":3,"charIndex":619},{"text":"渲染","id":"渲染","depth":2,"charIndex":859},{"text":"批量渲染","id":"批量渲染","depth":3,"charIndex":865},{"text":"Shape 绘制","id":"shape-绘制","depth":3,"charIndex":1189},{"text":"离屏渲染","id":"离屏渲染","depth":3,"charIndex":1359},{"text":"perfectDrawEnabled","id":"perfectdrawenabled","depth":3,"charIndex":1759},{"text":"事件","id":"事件","depth":2,"charIndex":2272},{"text":"事件分发","id":"事件分发","depth":3,"charIndex":2433},{"text":"匹配 Shape","id":"匹配-shape","depth":3,"charIndex":3155},{"text":"自定义 hitFunc","id":"自定义-hitfunc","depth":3,"charIndex":3843},{"text":"拖拽事件","id":"拖拽事件","depth":3,"charIndex":3958},{"text":"滤镜","id":"滤镜","depth":2,"charIndex":4057},{"text":"选择器","id":"选择器","depth":2,"charIndex":4542},{"text":"序列化","id":"序列化","depth":2,"charIndex":4831},{"text":"React","id":"react","depth":2,"charIndex":5111},{"text":"react-reconciler","id":"react-reconciler","depth":3,"charIndex":5256},{"text":"react-konva","id":"react-konva","depth":3,"charIndex":5893},{"text":"vue-konva","id":"vue-konva","depth":2,"charIndex":6032},{"text":"缺陷","id":"缺陷","depth":2,"charIndex":6307},{"text":"脏矩形","id":"脏矩形","depth":3,"charIndex":6313}],"domain":"","frontmatter":{"icon":"card","order":9,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":340,"title":"openlayers","content":"#","routePath":"/posts/graphics/openlayers","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":6,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":341,"title":"svg","content":"#\n\n可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形。\n\n\n网格#\n\n计算机绘图都差不多使用网格系统。这种系统以页面的左上角为(0,0)坐标点，坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下.\n\n\n\n\n像素#\n\n基本上，在 SVG 文档中的 1 个像素对应输出设备（比如显示屏）上的 1 个像素。SVG 也可以定义绝对大小，来实现 svg\n中可缩放的特性。只需给出数字，不标明单位，输出时就会采用用户的单位。\n\n * 定义了一个 50*50px 的 SVG 画布，这里 1 用户单位等同于 1 屏幕单位。\n\n\n\n * 这里定义的画布尺寸是 100*100px。但是，viewBox 属性定义了画布上可以显示的区域：从(0,0)点开始，50宽*50\n   高的区域。这个50*50的区域，会放到100*100的画布上显示。于是就形成了放大两倍的效果。\n\n\n\n\n基本形状#\n\nsvg 有不同的形状，并且使用不同的属性来定义图形的大小和位置\n\n\n矩形#\n\nrect 元素会在屏幕上绘制一个矩形 。其 6 个基本属性就可以控制它在屏幕上的位置和形状。\n\n * x: 矩形左上角的 x 位置\n * y: 矩形左上角的 y 位置\n * width: 矩形的宽度\n * height: 矩形的高度\n * rx: 圆角的 x 方位的半径\n * ry: 圆角的 y 方位的半径\n\n\n\n\n圆形#\n\ncircle 只有 3 个属性用来设置圆形。\n\n * r: 圆的半径\n * cx: 圆心的 x 位置\n * cy: 圆心的 y 位置\n\n\n\n\n椭圆#\n\nEllipse 是 circle 元素更通用的形式,以分别缩放圆的 x 半径和 y 半径（通常称之为长轴半径和短轴半径）。\n\n * rx: 椭圆的 x 半径\n * ry: 椭圆的 y 半径\n * cx: 椭圆中心的 x 位置\n * cy: 椭圆中心的 y 位置\n\n\n\n\n线条#\n\nLine 绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。\n\n * x1: 起点的 x 位置\n * y1: 起点的 y 位置\n * x2: 终点的 x 位置\n * y2: 终点的 y 位置\n\n\n\n\n折线#\n\nPolyline 是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个 points 属性中：\n\n\n\n\n多边形#\n\npolygon 和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon\n的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。\n\n\n\n\n路径#\n\npath 可能是 SVG 中最强大的基本形状。你可以用 path 元素绘制任何形状。另外，path\n只需要设定很少的点，就可以创建平滑流畅的线条（比如曲线）。path 元素的形状是通过属性 d 定义的，属性 d 的值是一个“命令+参数”的序列。\n\n\n直线命令#\n\n元素里有 5 个画直线的命令：\n\nM#\n\n画笔当前位于一个点，在使用 M 命令移动画笔后，只会移动画笔，但不会在两点之间画线\n\n\n\nL & H & V#\n\nL 命令将会在当前位置和新位置（L 前面画笔所在的点）之间画一条线段。L 需要两个参数，分别是一个点的 x 轴和 y 轴坐标，L 命令将会在当前位置和新位置（L\n前面画笔所在的点）之间画一条线段。\n\n\n\n另外还有两个简写命令，用来绘制水平线和垂直线。H，绘制水平线。V，绘制垂直线。这两个命令都只带一个参数，标明在 x 轴或 y\n轴移动到的位置，因为它们都只在坐标轴的一个方向上移动。\n\n\n\n\n\n\n曲线命令#\n\n绘制平滑曲线的命令有三个，其中两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说是圆的一部分。\n\n三次贝塞尔曲线需要定义一个点和两个控制点，所以用 C 命令创建三次贝塞尔曲线，需要设置三组坐标参数：\n\nC 命令#\n\n\n\n这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，\n会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程.\n\n\n\nS#\n\nS 命令可以用来创建与前面一样的贝塞尔曲线，但是，如果 S 命令跟在一个 C 或 S\n命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。果 S 命令单独使用，前面没有 C 或 S\n命令，那当前点将作为第一个控制点。相当于 C 的快捷命令。\n\n\n\n\nQ#\n\n二次贝塞尔曲线 Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。\n\n\n\n\nT#\n\n快捷命令 T 会通过前一个控制点，推断出一个新的控制点。在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T 命令前面必须是一个\nQ 命令，或者是另一个 T 命令，才能达到这种效果。如果 T 单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。\n\n\n\n\nFill 和 Stroke 属性#\n\n大多数基本的涂色可以通过在元素上设置两个属性来搞定：fill 属性和 stroke 属性。\n\n * fill 属性设置对象内部的颜色\n * stroke 属性设置绘制对象的线条的颜色\n\n\n\n\nFill#\n\nfill-opacity 控制填充色的不透明度，属性 stroke-opacity 控制描边的不透明度。\n\n\nStroke#\n\n * stroke-width 属性定义了描边的宽度.\n\nstroke-linecap#\n\n属性控制边框终点的形状,有三个值：\n\n * butt 用直边结束线段，它是常规做法，线段边界 90 度垂直于描边的方向、贯穿它的终点。\n * square 的效果差不多，但是会稍微超出实际路径的范围，超出的大小由 stroke-width 控制。\n * round 表示边框的终点是圆角，圆角的半径也是由 stroke-width 控制的。\n\n\n\nstroke-linejoin#\n\n用来控制两条描边线段之间，用什么方式连接。每条折线都是由两个线段连接起来的，连接处的样式由 stroke-linejoin 属性控制，它有三个可用的值:\n\n * miter 是默认值，表示用方形画笔在连接处形成尖角\n * round 表示用圆角连接，实现平滑效果。\n * bevel，连接处会形成一个斜接。\n\n\n\nstroke-dasharray#\n\n通过指定 stroke-dasharray 属性，将虚线类型应用在描边上。stroke-dasharray 是一组用逗号分割的数字组成的数列, 和 path\n不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。第二个路径会先做 5\n个像素单位的填色，紧接着是 5 个空白单位，然后又是 5 个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。第一个例子指定了 3\n个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染 5 个填色单位，10 个空白单位，5\n个填色单位，然后回头以这 3 个数字做一次循环，但是这次是创建 5 个空白单位，10 个填色单位，5\n个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复。\n\n\n\n\n渐变#\n\n\n线性渐变#\n\n线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在 SVG 文件的 defs 元素内部，创建一个 节点。\n\n基础示例#\n\n下面是一个应用了线性渐变的 元素的示例。线性渐变内部有几个 结点，这些结点通过指定位置的 offset（偏移）属性和\nstop-color（颜色中值）属性来说明在渐变的特定位置上应该是什么颜色；可以直接指定这两个属性值，该示例中指明了渐变开始颜色为红色，到中间位置时变成半透明的\n黑色，最后变成蓝色。渐变的方向可以通过两个点来控制，它们分别是属性 x1、x2、y1、y2，这些属性定义了渐变路线走向。\n\n\n\n\n径向渐变#\n\n径向渐变与线性渐变相似，只是它是从一个点开始发散绘制渐变。创建径向渐变需要在文档的 defs 中添加一个 元素,\n中值（stops）的使用方法与之前一致，但是现在这个对象的颜色是中间是红色的，且向着边缘的方向渐渐的变成蓝色。跟线性渐变一样，\n节点可以有多个属性来描述其位置和方向，但是它更加复杂。径向渐变也是通过两个点来定义其边缘位置，两点中的第一个点定义了渐变结束所围绕的圆环，它需要一个中心点，由\ncx 和 cy 属性及半径 r 来定义，通过设置这些点我们可以移动渐变范围并改变它的大小。\n\n\n\n\n中心和焦点#\n\n\n\n\nxml#\n\n\n\nxml 是浏览器能读取的格式，但如果希望 svg 能在浏览器中渲染出来，需要使用 xmlns 声明渲染规则。\n\n所以必须使用 xmlns=\"http://www.w3.org/2000/svg\"。","routePath":"/posts/graphics/svg","lang":"","toc":[{"text":"网格","id":"网格","depth":2,"charIndex":58},{"text":"像素","id":"像素","depth":3,"charIndex":134},{"text":"基本形状","id":"基本形状","depth":2,"charIndex":412},{"text":"矩形","id":"矩形","depth":3,"charIndex":453},{"text":"圆形","id":"圆形","depth":3,"charIndex":617},{"text":"椭圆","id":"椭圆","depth":3,"charIndex":693},{"text":"线条","id":"线条","depth":3,"charIndex":833},{"text":"折线","id":"折线","depth":3,"charIndex":945},{"text":"多边形","id":"多边形","depth":3,"charIndex":1013},{"text":"路径","id":"路径","depth":2,"charIndex":1131},{"text":"直线命令","id":"直线命令","depth":3,"charIndex":1261},{"text":"M","id":"m","depth":4,"charIndex":1285},{"text":"L & H & V","id":"l--h--v","depth":4,"charIndex":1334},{"text":"曲线命令","id":"曲线命令","depth":3,"charIndex":1545},{"text":"C 命令","id":"c-命令","depth":4,"charIndex":1653},{"text":"S","id":"s","depth":4,"charIndex":1800},{"text":"Q","id":"q","depth":3,"charIndex":1943},{"text":"T","id":"t","depth":3,"charIndex":2017},{"text":"Fill 和 Stroke 属性","id":"fill-和-stroke-属性","depth":2,"charIndex":2175},{"text":"Fill","id":"fill","depth":3,"charIndex":2290},{"text":"Stroke","id":"stroke","depth":3,"charIndex":2352},{"text":"stroke-linecap","id":"stroke-linecap","depth":4,"charIndex":2390},{"text":"stroke-linejoin","id":"stroke-linejoin","depth":4,"charIndex":2581},{"text":"渐变","id":"渐变","depth":2,"charIndex":3160},{"text":"线性渐变","id":"线性渐变","depth":3,"charIndex":3166},{"text":"基础示例","id":"基础示例","depth":4,"charIndex":3229},{"text":"径向渐变","id":"径向渐变","depth":3,"charIndex":3441},{"text":"中心和焦点","id":"中心和焦点","depth":3,"charIndex":3699},{"text":"xml","id":"xml","depth":3,"charIndex":3710}],"domain":"","frontmatter":{"icon":"card","order":2,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":342,"title":"three","content":"#","routePath":"/posts/graphics/three","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":7,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":343,"title":"webgl","content":"#","routePath":"/posts/graphics/webgl","lang":"","toc":[],"domain":"","frontmatter":{"icon":"card","order":3,"date":"2021-01-17T00:00:00.000Z","author":"h7ml","category":"graphics","tag":"graphics","star":true},"version":""},{"id":344,"title":"JavaScript ajax 封装","content":"#\n\n","routePath":"/posts/html/ajax/ajax封装","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":345,"title":"JavaScript ajax 状态码、json 对象、http 状态码","content":"#\n\n\nreadyState#\n\n * open：之前是 0\n * send：发送请求之后是 1\n * send：方法完成，已经接受到所有的响应内容 2\n * 正在解析下载到的数据 3\n * 解析完成 4\n\n\nState HTTP 常见状态码#\n\n * 200：交易成功\n * 301：永久重定向\n * 302：临时重定向\n * 304：使用缓存文件\n * 400：错误请求，如语法错误\n * 404：没有发现文件、查询或 URl\n * 405：请求方式错误\n * 500：后端错误\n * 1**：请求收到，继续处理\n * 2**：操作成功收到，分析、接受\n * 3**：完成此请求必须进一步处理\n * 4**：请求包含一个错误语法或不能完成\n * 5**：服务器执行一个完全有效请求失败\n\n\njson 对象#\n\n\n\n\n数组深拷贝#\n\n","routePath":"/posts/html/ajax/ajax状态","lang":"","toc":[{"text":"readyState","id":"readystate","depth":2,"charIndex":3},{"text":"State HTTP 常见状态码","id":"state-http-常见状态码","depth":2,"charIndex":104},{"text":"json 对象","id":"json-对象","depth":2,"charIndex":346},{"text":"数组深拷贝","id":"数组深拷贝","depth":3,"charIndex":359}],"domain":"","frontmatter":{},"version":""},{"id":346,"title":"html","content":"#","routePath":"/posts/html/ajax/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":347,"title":"posts","content":"#","routePath":"/posts/html/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":348,"title":"JavaScript 原生 touch","content":"#\n\n\n事件#\n\n * touchstart：手指按下\n * touchmove：手指移动\n * touchend：手指抬起\n\nPC 端事件，比移动端事件略慢，大概慢 300ms\n\n * 点透问题：\n   \n   * 在 300ms 之内，如果上层元素消失或隐藏，目标就会漂移到下层元素身上，就会触发点击行为。\n\n * 解决办法：\n   \n   * 下层元素不要使用有点击特性的元素\n\n\n事件对象#\n\nev 不需要兼容\n\nev 主要使用的 3 个属性：\n\n * touches: 所有在屏幕上的手指的一个列表\n * targetTouches: 当前在目标元素上的手指的列表\n * changedTouches: 当前在目标元素上发生变化（触发当前事件）的手指的列表 最常用\n   * clientX: 事件触发到可视区左边的距离\n   * clientY:事件触发到可视区上边的距离\n   * identifier: 标识符 第几个手指 0-n\n   * pageX: 事件触发到页面的左边的距离\n   * pageY: 事件触发到页面的上边的距离\n   * radiusX: x 轴的旋转半径\n   * radiusY: y 轴的旋转半径\n   * rotationAngle: 旋转角度 deg\n   * screenX: 事件触发到屏幕的左边距离\n   * screenY: 事件触发到屏幕的上边距离","routePath":"/posts/html/原生touch","lang":"","toc":[{"text":"事件","id":"事件","depth":2,"charIndex":3},{"text":"事件对象","id":"事件对象","depth":2,"charIndex":193}],"domain":"","frontmatter":{},"version":""},{"id":349,"title":"html","content":"#","routePath":"/posts/html/面向对象/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":350,"title":"JavaScript 面向对象-原型继承","content":"#\n\n\n原型链继承#\n\n\n\n\n对象冒充继承（借用构造函数#\n\n\n\n\n组合继承#\n\n\n\n\n寄生式组合继承#\n\n\n\n\nfor...in 继承#\n\n\n\n\nObject.create()继承#\n\ncreate 创建新对象\n\n","routePath":"/posts/html/面向对象/原型继承","lang":"","toc":[{"text":"原型链继承","id":"原型链继承","depth":2,"charIndex":3},{"text":"对象冒充继承（借用构造函数","id":"对象冒充继承借用构造函数","depth":2,"charIndex":14},{"text":"组合继承","id":"组合继承","depth":2,"charIndex":33},{"text":"寄生式组合继承","id":"寄生式组合继承","depth":2,"charIndex":43},{"text":"for...in 继承","id":"forin-继承","depth":2,"charIndex":56},{"text":"Object.create()继承","id":"objectcreate继承","depth":2,"charIndex":73}],"domain":"","frontmatter":{},"version":""},{"id":351,"title":"JavaScript 检查来自实例还是原型","content":"#\n\n\n方法#\n\n\n\n\n检查来自实例还是原型#\n\n\n\n\n返回实例或原型#\n\n将实例保存为数组\n\n","routePath":"/posts/html/面向对象/检查来自实例还是原型","lang":"","toc":[{"text":"方法","id":"方法","depth":2,"charIndex":3},{"text":"检查来自实例还是原型","id":"检查来自实例还是原型","depth":3,"charIndex":11},{"text":"返回实例或原型","id":"返回实例或原型","depth":3,"charIndex":27}],"domain":"","frontmatter":{},"version":""},{"id":352,"title":"概览","content":"#","routePath":"/posts/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"sidebar_label":"概览","sidebar_position":1},"version":""},{"id":353,"title":"探索数据可视化：前端工程师的视角","content":"#\n\n\n概述#\n\n说到可视化，大家可能会想到表格、饼图、柱状图、三维大屏图、建筑图等等，或者会想到excel、matlab、echarts等工具，但可视化真的仅限于此吗？本章将从\n前端工程师的角度，结合《数据可视化》，对可视化的基础、架构以及选型做一次探讨。\n\n\n数据可视化简介#\n\n可视化的定义\n\n * 动词：生成符合人类感知的图像。\n * 名词：使某物、某事可见的动作或事实。\n\n可视化的作用\n\n * 发现、决策、解释、分析、探索和学习。\n * 通过可视化提高人们完成某些任务的效率。\n\n可视化简史：略\n\n说到数据可视化，不得不说到数据科学：DIKW模型\n\n\n\n\n\n而这个模型，也是我们数据处理的标准流程，完成从原始数据的转化。\n\n数据可视化的意义：用户通过对可视化的感知，使用可视化交互工具进行数据分析，获取知识，并进一步提升为智慧。\n\n数据可视化分类\n\n * 科学可视化：主要面向自然科学，如物理、化学、气象气候、航空航天、医学、生物等学科。研究的重点是带有空间坐标和几何信息的医学影像数据、三维空间信息测量数据、\n   流体计算模拟数据等。核心问题是如何快速有效的呈现数据中包含的几何、拓补、形状特征和演化规律。\n * 信息可视化：处理抽象的、非结构化数据集合（如文本、图表、层次结构、地图、软件、复杂系统等）。核心问题是处理高维数据可视化、数据间抽象关系的可视化、用户的敏\n   捷交互和可视化有效性的评断。\n * 可视化分析：是一门以可视交互界面为基础的分析推理科学。综合了图形学、数据挖掘和人机交互等技术。本质是可视化的完成机器智能和人脑智能的双向转换。如：tabl\n   eau、graphic、万能表、s2\n\n数据可视化与其他学科领域的关系\n\n * 计算机图形学、人机交互：计算机图形学为可视化提供了编码和图形呈现的理论基础。在数据可视化中，通过人机界面实现用户的数据的理解和操纵，数据可视化的质量和效率\n   也需要最终的用户评判，因此，数据、人、机器之间的交互是数据可视化的核心。\n * 数据库与数据仓库：数据可视化通过数据的有效呈现，有助于对复杂关系和规则的理解。而大数据可视化方法中，就必须考虑新型的数据组织管理和数据仓库技术，因此是相辅\n   相成的关系。\n * 数据分析和数据挖掘：数据挖掘领域提出了可视化挖掘的方法，核心是将原始数据和数据挖掘的结果，用可视化方法呈现。配合人眼这个天生高带宽的巨量视觉并行处理器来达\n   到挖掘效果。\n\n可视化方法与技术：目前有生命科学可视化、表意性可视化、地理信息可视化、产品可视化、教育可视化、系统可视化、商业智能可视化、知识可视化等方法与技术，每一个名词都可\n以展开一篇巨大的篇幅，本篇只做一个概念梳理，读者可对其中感兴趣的方向做具体研究。\n\n设计数据可视化系统面临的挑战\n\n * 计算能力的可扩展性：由于有限的时间和存储资源，面向大数据的数据清洗、转换、布局和绘制算法的计算复杂度是主要关注对象。\n * 感知和认知能力的局限性：人类的记忆容量和注意力是宝贵且有限的资源，比如人类在执行视觉搜索的时候，前几分钟的警觉性是远超于之后的时间的。\n * 显示能力的局限性：屏幕的分辨率已经不能同时显示所有想表达的信息。为了尽可能多地显示以减少导航，但显示代价较高，用户也会产生视觉混乱，所以需要综合权衡。\n\n\n前端领域的可视化#\n\n那Web前端和可视化到底有什么区别呢？\n\n\n技术栈的区别：#\n\n\n\n\n领域与工具的区别：#\n\n众所周知，前端三剑客 html+css+js 即可解决 web 前端所有功能，而相关领域的 js 库目前最流行的莫过于 react、vue、angular\n以及相对较古老的 jQuery，这些框架或者 js 库即可辅助你完成 web 前端所遇到的大部分需求，但可视化领域呢？\n\n统计数据图表库：主要为统计数据做可视化展示，主要涉及柱状图、折线图、饼图等，目前开源图表库有\nPlotly、G2、Echarts、Chartist、Chart.js 等。\n\n\n\nGIS地图库：处理地图地理信息可视化相关的库。常见的有 L7、Mapbox、Leaflet、Deck.gl、CesiumJS 等。\n\n\n\n图可视化绘图库：主要描述点边关系图，流程图等带有边概念的图。如 G6、cytoscape.js、mxGraph 等。\n\n\n\n通用渲染库：绘制更加灵活的图形、图像或者物理模型，比如游戏模型、建筑模型、复杂图表等功能，当你在上述领域找不到对应工具时，即可选择此类 js\n库，但灵活的同时带来的就是困难度的提升。主要有 Pixi.js、SpriteJS、P5.js、Rough.js、G、ThreeJS、D3.js 等。\n\n\n\n\n可视化技术选型#\n\n首先浏览器实现可视化的方式目前有4种，分别是 HTML + CSS、SVG、Canvas2D、WebGL，其中 WebGL 利用了 GPU\n并行处理的特性，在大数据场景下，性能大大优于前3种绘图方式。具体渲染流程如下：\n\n\n\n选型\n\n当然，Canvas 和 SVG 的对比不能简单看图形复杂度和性能，在强调操作的准确性以及对字体的清晰度要求较高的场景，或许你该从 SVG 下手。\n\n\n结尾#\n\n最后，我再补充一些有关 CPU 和 GPU 交互的概念，从计算机角度看看如何渲染图形。\n\n图形是如何绘制的\n\n\n\n渲染流程（渲染管线）\n\n\n\n参考资料：\n\n《数据可视化》第2版 - 陈为、沈则潜、陶煜波 等编著\n\nps：本章节有部分图片是作者在以前做笔记的时候保存的，为了方便理解添加至文中。如有侵权，请联系作者删除，谢谢。","routePath":"/posts/javascript/ExploringDataVisualizationFromFrontEndEngineerPerspective","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"数据可视化简介","id":"数据可视化简介","depth":2,"charIndex":131},{"text":"前端领域的可视化","id":"前端领域的可视化","depth":2,"charIndex":1388},{"text":"技术栈的区别：","id":"技术栈的区别","depth":3,"charIndex":1421},{"text":"领域与工具的区别：","id":"领域与工具的区别","depth":3,"charIndex":1434},{"text":"可视化技术选型","id":"可视化技术选型","depth":3,"charIndex":1955},{"text":"结尾","id":"结尾","depth":3,"charIndex":2157}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2024-06-19T00:00:00.000Z","author":"h7ml","title":"探索数据可视化：前端工程师的视角","description":"本文深入研究数据可视化，介绍了可视化的定义、作用、历史，以及它与数据科学的联系。我们还探讨了前端领域的可视化，讲述了技术栈、领域、工具以及可视化技术选型的不同之处。此外，我们解释了如何选择适当的可视化方法，以满足特定需求。","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>探索数据可视化的奥秘，了解前端和可视化领域之间的差异，为您的数据呈现提供更多可能性。","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"数据可视化:前端视角","category":["数据可视化","前端开发","可视化工具"],"tag":["数据科学","DIKW模型","前端工程","可视化方法","技术选型","渲染流程","WebGL","SVG"],"head":[["meta",{"name":"keywords","content":"数据可视化、前端工程、DIKW模型、可视化方法、WebGL、SVG、技术选型、渲染流程"}]]},"version":""},{"id":354,"title":"微前端架构：拆分前端应用的艺术","content":" 1. 什么是微前端架构？他是如何形成的，以及有什么优缺点。\n 2. 如何设计一个微前端架构的系统？\n 3. 如何合理的拆分前端应用？\n 4. 引入”微“害架构的概念，即不合理的实施微架构将对系统产生什么影响\n\n\n1. 微前端#\n\n微前端是一种类似于徽服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为把多个小型前端应用聚合为一的应用\n\n各个前端应用还可以独立开发、独立部署。同时，它们也可以进行并行开发，这些组件可以通过 NPM、Git TagGit 或者 Submodule 来管理\n\n1.1 微前端架构#\n\n微前端的实现意味着对前端应用的拆分，它可以提升开发效率。比如 10 万行的代码拆成 10 个项目，每个项目一万行，要独立维护就会更容易。\n\n我们只需要实现应用的自治---应用的独立开发和独立部署，就可以某种程度上实现微前端架构的目的。\n\n1. 应用自治#\n\n微前端架构是多个应用组件的统一应用，每个应用都可以由多个团队开发。要遵循统一的接口规范或者框架，以便于集成到一起，因此相互之间是不存在依赖关系的。\n\n我们可以在适当的时候，替换其中任意一个前端应用，而整体不受影响。这也意味着我们可以使用各式各样的前端框架，而不会互相影响。\n\n2. 单一职责#\n\n与微服务类似，微前端架构满足理应满足单一职责的原则。\n\n一旦业务上关联紧密，如 B 页面依赖 A 页面，A 又在一定程度上依赖 B 页面，拆分开来就没那么容易。\n\n如果业务关联少，如一些”我们的联系方式“等的页面，使用的不多，就没有太大难度\n\n3. 技术栈无关#\n\n在后端微服务架构中，技术栈无关是一个很重要的特性，后端可以选用合适的语言和框架来开发最合适的服务，服务之间通过 API 进行通过即可。\n\n但是对于微前端架构来说，前端框架是有限的，且框架间的差距并不大，一个框架能做的事情，其他框架也都能做，与后端不同，java 解决不了 AI 部分，可以交给\nPython，觉得 java 繁琐，可以使用 Scala。\n\n\n\n对于大部分公司和团队来说，如果一开始使用了 React，除非新的框架能解决 React 不能解决的问题，否则大概率会一直沿用 React。\n\n此外，技术栈无关也有一系列的缺点：\n\n * 应用的拆分基础依赖于基础设施的构建，如果大量应用依赖于同一基础设施，那么维护就变成了一个挑战。\n * 拆分的粒度越小，意味着架构变得越复杂，维护成本越高。\n * 技术栈一旦多样化，意味着技术栈是混乱的。\n\n那么我们到底应该在什么时候采用微前端架构呢？\n\n1.2 为什么需要微前端#\n\n * 遗留系统迁移\n * 聚合前端应用\n * 热闹驱动开发\n\n1. 遗留系统迁移#\n\n存在大量使用 Backbone.js、Angular.js 等框架所编写的单页应用，且已经在线上稳定运行了，也没有新的功能。\n\n2. 后端解耦，前端聚合#\n\n后端微服务的初期最大的卖点是可以使用不同的语言、技术栈来开发后端应用，可以发挥不同技术栈的优势，也可以解耦各服务间的依赖。\n\n而前端微服务化上是相反的，人们想要的结果是聚合前端应用，尤其是 To B 的应用。\n\n类似移动应用，用户不想装太多应用，觉得关联性强的业务应该整合到一起。桌面 Web 端也类似，实现前端聚合的就是微前端架构\n\n3. 热闹驱动开发#\n\n软件开发团队可能存在很多没有经过踏实研究和实践的决策，而是一些不准确的意见，或者社交媒体的信息，称为”热闹“的东西。\n\n那么对于这样一个”热闹“的技术，可能会导致项目的失败，合理的拆分可以避免较大的损失。\n\n同样微前端也是”热闹“的技术，意味着也可能会积极的促进技术的发展更新。\n\n\n2. 微前端的技术拆分方式#\n\n * 路由式分法\n * 前端微服务化\n * 微应用\n * 微件化\n * 前端容器化\n * 应用组件化\n\n2.1 路由式分法#\n\n通过 HTTP 服务的反向代理，将请求路由到对应的应用上。\n\n\n\n这是采用最多、最容易的”微前端“方式。\n\n但这种方式看上去更像是多个前端应用的聚合，看起来像是一个整体，实则每当用户从 A 切换到 B 的时候，往往需要刷新一下页面、重新加载资源。\n\n在这个架构中，只需要关注应用间的数据传递方式，通常只需要关注当前的用户状态，从 A 传到 B 即可，如果是同一个域下的话，就更加方便了，可以使用\nLocalStorage、Cookies、IndexedDB 等。\n\n缺点则是缺少了应用级别的状态处理，例如需要用户重新登录等。\n\n2.2 前端微服务化#\n\n每个前端应用都是完全独立的（技术栈、开发、部署、构建独立）、自主运行的，最后通过模块化的方式组合出完整的前端应用。\n\n\n\n采用这种方式意味着一个页面存在多少个前端应用，而路由分法方案是一个页面只有一个应用。\n\n我们只需要做到以下两点：\n\n 1. 在页面合适的地方引入或者创建 DOM\n 2. 用户操作时，加载对应的应用（触发应用的启动），并且能卸载应用。\n\n创建 DOM 是容易的，但是第二点不容易，特别是移除 DOM 和相应应用的监听，当我们拥有不同技术栈时，需要针对性的设计出这样一套逻辑。\n\n同时还需要保证应用间的第三方依赖不冲突，如 A 使用的 z 插件，B 也使用了 z 插件，如果一个页面多次引入 z 插件则会发生冲突，那么这也需要去解决。\n\n2.3 组合式集成：微应用化#\n\n在开发时应用都是单一、微小应用的形式存在，在运行时则是通过构建系统合并这些应用，组合成一个新的应用。\n\n\n\n微应用化大都是以软件工程的方式来完成前端应用的开发的，因此又可以称之为组合式集成。对于一个大型的前端应用来说，采用的架构方式往往是通过业务作为主目录的，然后在业\n务目录中放置相关的组件，同时拥有一些通用的共享模板，例如：\n\n\n\n当我们开发一个这样的应用时，从目录结构上看，业务本身已经被拆分了。我们所要做的是，让每个模块都成为一个单独的项目，如将仪表盘功能提取出来，加上共享部分的代码、应\n用的基本脚手架，便可以成为一个单独的应用。拆分出每个模块之后，便只需要在构建的时候复制所有的模块到一个项目中，再进行集成构建。\n\n微应用化与前端微服务化类似，在开发时都是独立应用的，在构建时又可以按照需求单独加载。如果以微前端的单独开发、单独部署、运行时聚合的基本思想来看，微应用化就是微前\n端的一种实践。\n\n只是使用微应用化意味着我们只能使用唯一的一种前端框架。大团队通常是不会同时支持多个前端框架的。\n\n2.4 微件化#\n\n微件（Widget），是一段可以直接嵌入应用上运行的代码，它由开发人员预先编译好，在加载时不需要再做任何修改或编译。\n\n而微前端下的微件化则指的是，每个业务团队编写自己的业务代码，并将编译好的代码部署（上传或者放置）到指定的服务器上。在运行时，我们只需要加载相应的业务模块即可。在\n更新代码的时候，我们只需要更新相应的模块即可。\n\n\n\n在非单页面应用时代，要实现微件化方案是一件特别容易的事。从远程加载 JavaScript\n代码并在浏览器上执行，生成对应的组件嵌入页面。对于业务组件也是类似的，提前编写业务组件，当需要对应的组件时再响应和执行。在未来，我们也可以采用\nWebComponents 技术来做这样的事情。\n\n而在单页面应用时代，要实现微件化就没有那么容易了。为了支持微件化，我们需要做下面一些事情。\n\n * 持有一个完整的框架运行时及编译环境。这用于保证微件能正常使用，即可调用框架 API 等。\n * 性能受影响。应用由提前编译变成运行时才编译，会造成一些性能方面的影响——具体视组件的大小而定。\n * 提前规划依赖。如果一个新的微件想使用新的依赖，需要从上游编译引入。\n\n此外，我们还需要一个支持上述功能的构建系统，它用于构建一个独立的微件模块。这个微件的形式如下：\n\n * 分包构建出来的独立代码，如 webpack 构建出来的 chunk 文件。\n * 使用 DSL 的方式编写出来的组件。\n\n为了实现这种方式，我们需要对前端应用的构建系统进行修改，如 webpack，使它可以支持构建出单个的代码段。\n\n这种方式的实施成本比微应用化成本高\n\n2.5 前端容器：iframe#\n\niframe 作为一个非常“古老”的、人人都觉得普通的技术，却一直很管用。它能有效地将另一个网页/单页面应用嵌入当前页面中，两个页面间的 CSS 和\nJavaScript 是相互隔离的——除去 iframe 父子通信部分的代码，它们之间的代码完全不会相互干扰。\n\n当然采用 iframe 有几个重要的前提：\n\n * 网站不需要 SEO 支持。\n * 设计相应的应用管理机制。\n\n如果我们做一个应用平台，会在系统中集成第三方系统，或多个不同部门团队下的系统，显然这仍然是一个非常靠谱的方案。\n\n此外，在上述几个微前端方案中，难免会存在一些难以解决的依赖问题，那么可以引入 iframe\n来解决。无论如何当其他方案不是很靠谱时，或者需要一些兼容性支持的时候，可以再度试试 iframe。\n\n2.6 结合 Web Components 构建#\n\nWeb Components 是一套不同的技术，允许开发者创建可重用的定制元素（它们的功能封装在代码之外），并且在 Web 应用中使用它们。\n\n真正在项目上使用 Web Components 技术，离现在的我们还有些距离，可是结合 Web Components\n来构建前端应用，是一种面向未来演进的架构。或者说在未来，可以采用这种方式来构建应用。比如 Angular 框架，已经可以将当前应用构建成一个 Web\nComponents 组件，并在其他支持引入 Web Components 组件的框架中使用，如 React。我们还可以使用 Web Components\n构建出组件，再在其他框架中引入。\n\n为此，我们只需要在页面中通过 Web Components 引入业务模块即可，其使用方式类似于微件化的方案\n\n\n\n目前困扰 Web Components 技术推广的主要因素在于浏览器的支持程度。在 Chrome 和 Opera 浏览器上，对 Web Components\n支持良好，而对 Safari、IE、Firefox 浏览器的支持程度，并不是很理想。有些不兼容的技术，可以引入 polyfill 来解决，有些则需要浏览器支持。\n\n\n3. 微前端的业务划分方式#\n\n以下整理了常见的划分微前端的方式：\n\n * 按照业务划分\n * 按照权限拆分\n * 按照变更的频率拆分\n * 按照组织结构拆分\n * 跟随后端微服务拆分\n\n3.1 按照业务划分#\n\n在大型的前端应用里，往往包含了多个业务。这些业务往往在某种程度上存在一定的关联，但并非是强关联。如图所示是一个常见的电商系统的相关业务。\n在这样的一个系统里，同时存在多个子系统：电子商务系统、物流系统、库存系统等。\n\n每个系统都代表自己的业务，它们之间的关联可能并不是很紧密——对于前端应用来说，只需要一个系统内对象的 ID，加上用户的\nToken，便能轻松地从一个系统跳转到另外一个系统中。这种业务本身的高度聚合，使得前端应用的划分也变得更加轻松。\n\n如果业务间本身的耦合就比较严重（如一个电子商务的运营人员，可能需要同时操作订单、物流等多个系统)，那么要从前端业务上分离它们，就不是很容易。\n\n因此，对于由业务性质决定的应用，往往只能依据业务是否隔离来进行拆分。\n\n3.2 按照权限拆分#\n\n对于一个同时存在多种角色及多种不同权限的网站来说，最容易采用的方案就是通过权限来划分服务和应用。\n\n尤其这些权限在功能上是分开的，也就没有必要集中在一个前端应用中。\n\n3.3 按照变更的频率拆分#\n\n在一个前端应用中，并非所有模块和业务代码都在不断地修改、添加新的功能。不同的业务模块拥有不同的变更频率。\n\n有些功能可能在上线之后，因为用户少而几乎不修改；有些功能则可能为了做而做，即证明有这个技术能力，或者有这个功能。而有一些功能，因为是用户最常用的，所以在不断迭代\n和优化中。因此，可以依照变更频率来拆分前端应用。\n\n不常用的功能，虽然业务少、变更少导致代码也相对较小，但是因为非核心业务数量多，从应用中拆分出去也更容易维护。比如 Word\n这样的文字处理软件，我们日常使用的功能可能不到 10%。而其他一些专业性的需求，则仍然有\n90%的空间，它们也需要花费大量的开发时间。若是将应用中频繁变更的部分拆分出来，不仅更容易维护其他部分的代码，还可以减少频繁的业务修改给其他部分带来的问题。\n\n经常变更的业务也可以进一步进行拆分——拆分成更多的前端应用或者服务。使用变更的频率进行拆分的前提是，我们使用数据统计来计算各部分的使用情况。对于一个大型的前端应\n用来说，这部分几乎是不存在问题的\n\n3.4 按照组织结构拆分#\n\n团队的组织方式必然会对它产生的代码有影响，既然如此，就会存在一种合理的微前端划分方式，即根据不同团队来划分不同的微前端应用及服务。\n\n对于后端来说，按照组织结构拆分服务，几乎是一个默认的做法。团队之间使用 API 文档和契约，就可以轻松地进行协作。\n\n对于前端应用来说，同样可以采用这种方式来进行。\n\n当作为架构的提出方和主要的核心技术团队，我们需要提供微前端的架构方案。如使用路由分发式微前端，需要提供一个 URL 入口；使用前端微服务化，需要提供一个 API\n或者接入方式，以集成到系统中。\n\n值得注意的是，它与业务划分方式稍有区别，一个团队可能维护多个业务。如果某些业务是由一个团队来维护的，那么在最开始的阶段，他们可能倾向于将这些业务放在同一应用中。\n然后，由于业务的增多或者业务变得复杂，则会进一步拆分成多个应用。\n\n对于跨团队协作来说，集成永远都是一个复杂的问题。尤其在团队本身是异地开发的情况下，沟通就变成一个麻烦的问题。技术问题更适合于当面讨论，如指着代码或页面进行讨论。\n一旦有一方影响了系统构建，就需要优先去解决这个问题。\n\n3.5 跟随后端微服务拆分#\n\n微架构相关的实施，并不只有前端才有，往往是后端拥有相应的实施，前端项目才会进行进一步的拆分。而一旦后端拥有相关的服务，前端也可以追随后端的拆分方式。\n\n然而，后端采用的拆分方式，并不都适合于前端应用——可能多数时候都不适合。如后端可能采取聚合关系来划分微服务，这时对于前端应用来说并没有多大的启发，但是有些时候还\n是可以直接采用一致的拆分模型。毕竟如果在后端服务上是解耦的，那么在前端业务上也存在一定解耦的可能性。\n\n3.6 DDD 与事件风暴#\n\n在后端微服务（MicroServices）架构实践中，常常借助于领域驱动设计（Domain Driven Design，DDD）进行服务划分。DDD\n是一套综合软件系统分析和设计的面向对象建模方法。DDD 中的一个限界上下文（Bounded\nContext），相当于一个微服务。而识别限界上下文的核心是，识别出领域的聚合根，这时便依赖于事件风暴来进行。\n\n事件风暴（Event\nStorming）是一项团队活动，旨在通过领域事件识别出聚合根，进而划分微服务的限界上下文。事件风暴就是把所有的关键参与者都召集到一个很宽敞的屋子里来开会，并且\n使用便利贴来描述系统中发生的事情。它们会通过以下步骤来确定各个业务的边界，同时划分出每个服务：\n\n * 寻找领域事件\n * 寻找领域命令\n * 寻找聚合\n * 划分子域和限界上下文\n\n\n4. 微前端的架构设计#\n\n在有了微前端之后，我们是否真的需要微前端？我们能否应对微前端带来的技术挑战？\n\n4.1 构建基础设施#\n\n在基础设施上，微前端架构与单体应用架构有相当大的差异。在单体应用里，共享层往往只有一个。而在微前端架构里，共享层则往往存在多个，有的是应用间共用的共享层，有的是\n应用内共用的共享层。在微前端设计初期，构建基础设施要做如下几件事情：\n\n * 组件与模式库。在应用之间提供通用的 UI 组件、共享的业务组件，以及相应的通用函数功能模块，如日期转换等。\n * 应用通信机制。设计应用间的通信机制，并提供相应的底层库支持。\n * 数据共享机制。对于通用的数据，采取一定的策略来缓存数据，而不是每个应用单独获取自己的数据。\n * 专用的构建系统（可选）。在某些微前端实现里，如微件化，构建系统用于构建出每个单独的应用，又可以构建出最后的整个应用。\n\n针对不同的微前端方案会有不同的差异。\n\n4.2 提取组件与模式库#\n\n系统内有多个应用采用同一框架的微前端架构，模式库作为微前端架构的核心基础，可以用于共享代码。在这个库里，它会包含我们所需要的基础组件，可以在多个前端应用中使用。\n\n1. 样式#\n\n在实施微前端的过程中经常会遇到一个头疼的问题：样式冲突。如果在一个页面里同时有多个前端应用，那么就会存在以下几种形式的样式：\n\n * 组件级样式，只能用于某一特定组件的样式。\n * 应用级样式，在某一个前端应用中使用的样式。\n * 系统级样式，可在该页面中使用的样式，往往会影响多个应用。\n\n对于组件级样式来说，有些框架可以从底层上直接支持组件模式隔离，只要在开发的过程中多加注意即可。\n\n对于应用级样式而言，则需要制定一个统一的规范，可以根据应用名加前缀，如\ndashboard-，也可以根据路由来增加相应的前缀，以确保应用本身的样式不会影响到其他应用。此外，我们往往会为这些应用，创建一个统一的样式库，以提供一致的用户\n体验。\n\n系统级样式，大抵只存在于基座模式设计的微前端架构里。在这种方案里，由基座应用来控制其他应用，也存在部分的样式。在编写这些样式的时候，需要注意对其他应用的影响。此\n外，它也可以作为统一的样式库承载的应用来使用。\n\n2. 业务组件及共享库#\n\n对于在多个应用中使用的业务组件和共享函数，我们既可以提供 NPM 包的方式，又可以提供 git submodule 的方式，引入其他应用中。\n\n对于通用的组件，它在开发的前期需要频繁地改动，这时可以将其抽取成为子模块（Submodule）的形式在项目中使用。当我们需要的时候，可以轻松地修改，并在其他应用\n中更新。当这些组件趋于稳定的时候，可以尝试将其作为 NPM 包发布。如果有这种打算，就需要在这个子模块中使用 package.json 及 NPM\n的管理方式，方便后期直接扩展。\n\n此外，不得不提及的是，这种类型的修改应当是兼容式修改。在难以兼容的情况下，需要对系统中使用到的部分，逐一进行排查，直到确认已更新下游\nAPI。然后，还要进行相应部分的测试，以确保组件修改带来的影响都已经被修复。\n\n4.3 应用通信机制#\n\n解决了应用间共享代码的问题，我们还需要设计出一个应用间通信的机制。在微前端架构里，从应用间的关系来看，存在如下两种类型的通信：\n\n * 同级通信，即挂载在同一个 HTML Document 下的应用间的通信。\n * 父子级通信，即采用 iframe 形式来加载其他应用。\n\n前者往往通过全局的自定义事件（CustomEvent）便可以实现。值得一提的是，在 IE 浏览器上需要使用 Polyfill 兼容库。此外，由于应用之间共享一个\nWindow，所以我们还可以开发自己的发布-订阅模式组件。与自定义事件相比，它拥有更高的可定制度。如果采用父子级通信机制，则稍显麻烦一些。普通的父子级通信可以做\n到以下几方面：\n\n * 通过 PostMessage 在父子窗口之间进行通信。\n * 透过 parent.window 寻找到父窗口，再发出全局的自定义事件。\n * 当其他应用加载时，将消息发送给父窗口，由父窗口发出自定义事件。\n * 当其他应用未加载时，先将消息传递给父窗口，再由父窗口进行存储，提供一个获取通信的机制。\n\n在实施过程中，具体采用哪种或哪几种方式，取决于我们在设计的时候有哪些需要。也可以在前期设计出所有的机制，方便后期使用。值得注意的是，在实现的过程中往往会出现两种\n结果：\n\n * 嵌入业务的特定通信机制。\n * 剥离业务的通用通信机制。\n\n后者是一个通用的通信机制，开发成本相对较高。前者则是一个业务绑定的模式，一旦添加新功能，便需要进行修改。\n\n4.4 数据管理#\n\n单页面应用是指对于业务状态的管理及处理。前端在与后端进行交互时，需要传递大量的状态，这时的状态主要由两个部分来组成：URI（GET 的传递参数会转换到 URI\n中）+请求 body。由于一个应用持有这些状态，所以为了实现方便，需要在应用间共享这些数据。\n\n应用的数据管理可以分为两部分，一部分是状态，另一部分则是应用数据。只是从某种意义上来说，状态是一种特殊的应用数据，它更加显式地展示数据。通过上部分的应用通信机制\n，可以解决部分数据共享问题，通用部分的数据，则可以选择一个合适的数据管理策略。为此，我们需要一个去中心化的管理数据，或者基于基座应用的数据管理机制。\n\n常见的数据交互方式，有以下几种：\n\n * URI 参数传递。\n * 使用 LocalStorage 共享数据。\n * 其他客户端存储，如 IndexedDB、Web SQL 等。\n * 服务端存储客户端状态，可以采用 JSON 格式存储。\n\n在这方面，我们很难通过实施一套有效的方案来管理，往往是通过规范来保持一致，如在某些情况下使用 URI 传递参数，在某些情况下应用自身从 LocalStorage\n获取。如果设计了自己的安全存储策略，就另当别论了。\n\n4.5 专用的构建系统#\n\n首先需要声明一下，并非所有的微前端架构都需要一个专用的构建系统。只有那些依赖于构建及构建工具创建出来的微前端应用，才需要设计出一个专用的构建系统，以支撑系统的开\n发。\n\n如果我们采用了微应用化、微件化的架构方案，就需要设计自己的构建流程、构建系统，每种方式在具体实现上各有差异。\n\n * 微件化需要修改构建工具，如添加对应的构建插件，使它能支持构建出组件包\n\n * 微应用化则依赖于设计构建流程，而不需要对构建工具进行修改\n\n\n5. 微前端的架构模式#\n\n5.1 基座模式#\n\n在这种模式的微前端架构中，基座承担了微前端应用的基础与技术核心。\n\n基座模式，是由一个主应用和一系列业务子应用构成的系统，并由这个主应用来管理其他子应用，包括从子应用的生命周期管理到应用间的通信机制。\n\n基座模式中的主应用，类似于 API Gateway\n的概念，它作为系统的统一入口，负责将对应的请求指向对应的服务。子应用，则是负责各个子模块的业务实现，如图所示。\n\n\n\n这个主应用，既可以只带有单纯的基座功能，也可以带有业务功能。它所处理的业务功能指的是核心部分的业务功能，如：\n\n * 用户的登录、注册管理。\n * 系统的统一鉴权管理。\n * 导航菜单管理。\n * 路由管理。\n * 数据管理。\n * 通信代理。 ……\n\n作为应用的基础核心，它还需要：\n\n * 维护应用注册表。在应用注册表上表明系统有多少个服务、能否找到对应的应用等。\n * 管理其他子应用。如在何时加载应用、何时卸载应用等。\n\n要实现这种模式的微前端架构，只需要设计好对应的应用加载机制即可，因此在实施的时候也比较方便。\n\n5.2 自组织模式#\n\n自组织指的是，系统内部各子系统之间能自行按照某种规则形成一定的结构或功能。采用这种模式可以使系统内的各种前端应用，都各自拥有一个小型的基座管理功能，也相当于每个\n应用都可以是基座。\n\n在采用基座模式时，用户要想访问 A 应用需要先加载主应用，然后才能加载 A 应用。采用自组织模式时，用户想要访问 A 应用则只访问 A\n应用，不需要加载主应用，这也因此使它拥有了更高的自主性。\n\n不过多数时候，我们并不需要自组织模式的微前端架构，因为它设计起来复杂、拥有大量的重复代码。\n\n\n6. 微前端的设计理念#\n\n在笔者实践微前端的过程中，发现以下几点是我们在设计时需要关注的内容。\n\n * 中心化：应用注册表\n * 标识化应用\n * 应用生命周期管理\n * 高内聚，低耦合\n\n它们也是我们在实践微前端的过程中所要考虑的要点。\n\n6.1 中心化：应用注册表#\n\n微服务从本质上说应该是去中心化的。但是，它又不能完全去中心化。因为对于一个微服务来说，它需要一个服务注册中心：服务提供方要注册通告服务地址，服务的调用方要能发现\n目标服务。\n\n对于一个前端应用来说，我们也需要拥有一个应用注册表，它将拥有每个应用及对应的入口。在前端领域里，入口的直接表现形式可以是路由，或是对应的应用映射。应用在构建完成\n，或者部署到服务器后，应该在这个应用注册表中注册，才能及时地向其他应用提供访问的权限。以路由形式的注册表为例，当我们添加了一个新的应用时，就相当于在网页上添加了\n一个菜单链接，用户就能知道哪个页面是可以使用的，也就能访问到这个新的应用。从代码上来说，就是我们需要有一个地方来管理应用：目前存在哪些应用，哪个应用使用哪个路由\n。\n\n应用注册表可以是一个配置件，也可以是一个后端服务。由于它是面向前端提供的，其表现形式往往是 JSON，在这个文件中，可以配置微前端加载规则。\n\n6.2 标识化应用#\n\n标识化应用是指，建立某种规则来区分不同的应用，类似于唯一标识符，即 ID。我们需要这个 ID 来标识不同的应用，以便在安装和卸载的时候，能寻找到指定的应用。\n\n对于第三方应用来说，我们往往会给它们添加对应的前缀，如 3rd-xxx，以区分不同的应用。并且第三方应用需要向系统申请，才能接入这个系统中。\n\n如果存在大量的不需要审核的应用，那么可以由系统后台来生成唯一的标识符。\n\n6.3 生命周期#\n\n前端微架构与后端微架构的最大不同之处则是生命周期。微前端应用作为一个客户端应用拥有自己的生命周期，生命周期包括如下 3 个部分：\n\n 1. 加载应用\n 2. 运行应用\n 3. 卸载应用\n\n在微前端框架 Single-SPA 中设计了一个基本的生命周期，其包含如下 5 种状态。\n\n * load：决定加载哪个应用，并绑定生命周期。\n * bootstrap：获取静态资源。\n * mount：安装应用，如创建 DOM 节点。\n * unload：删除应用的生命周期。\n * unmount：卸载应用，如删除 DOM 节点、取消事件绑定。\n\n这部分的内容事实上就是微前端的一个难点所在，如何以合适的方式来加载应用呢？每个前端框架都各不相同，其所需要的加载方式也是不同的。当我们决定支持多个框架的时候，便\n需要在这一部分进行更细致的研究。\n\n6.4 高聚合，低耦合#\n\n最后，在设计各个子应用及主应用的过程中，需要遵循高内聚、低耦合的原则。\n\n高内聚，即模块内的关系，一个软件模块只由相关性很强的代码组成。设计的过程就是识别、度量模块内的联系，再将相关的行为聚集在一起，把不相关的行为放在别处。如果想要修\n改模块中某一部分的行为，只需要修改一处代码即可，而不需要修改多处。在实践的过程中，主要基于单一职责和关注点分离两个原则来实现。\n\n低耦合，即模块间的关系。对于微架构系统来说，在服务之间、应用之间如果实现了松耦合，那么修改一个服务和应用就不需要修改另一个服务和应用。除了基座应用，每个应用都不\n应该关心协作应用的相关信息。\n\n应用之间往往存在一定的依赖关系，要解耦这些依赖，就需要将数据独立出来，并使用通信的方式来传递状态。\n\n\n7. “微”害架构#\n\n一个架构有好的一方面，实施不好则有害。\n\n“微”害架构，即微架构以不合理的方式运行着，它采用“微架构”（微服务、App\n插件化、微前端等）技术拆分臃肿的单体应用，导致软件架构进一步复杂化，难以维护，使得原本具有优势的微架构出现一些问题。\n\n为什么一个设计良好的架构，会变成一个人人嫌弃的架构呢？我们可以轻松地列举出如下理由：\n\n * 架构的设计不符合演进的需求。\n * 开始设计时，架构就不合理。\n * 架构本身是合理的，后继的开发者能力不足。\n * 架构本身是合理的，然而开发的过程中走歪了。\n\n关于能力不足导致的架构问题就不进一步展开讨论了，我们主要讨论的是“走歪了的流程”，它才是导致“微”害架构的元凶。在开发能力完备的情况下，架构走向不合理的原因是\nKPI。由 KPI 导向的系统架构设计，必然会出现一定的不合理性。\n\n * “我们的竞争对手采用了微服务架构，你看看我们有没有办法也用这个架构？”\n * “隔壁开发小组的团队使用了微前端架构，我们也上这个架构吧？”\n * “小李啊，听说最近微服务很火啊，你看能不能用到我们的项目上？” ……\n\n问题的原因多种多样，如没有因地制宜地实施架构——A 项目有 50 个后端开发，后端由 20 个微服务组成；B 项目有 10 个后端开发，也由 20\n个微服务组成。每次上线的时候，不得不出动所有的人，上线到半夜才算完成。下面让我们了解、回顾一下系统的架构形成。\n\n7.1 微架构#\n\n在过去的几年里，笔者曾参与了一系列“微架构”相关系统的开发。对于不同类型的应用程序，它们的改变方式也有所不同。后端应用从单体应用拆分成一个一个微服务，它们对于用\n户来说是不可见的，但对于自身的客户端而言，仍然是一个整体；前端和移动应用则正在从一个一个的应用，整合成一个大的整体。然而客户端又稍有不同，它们需要实现在开发时拆\n分，构建时聚合。与微架构开发类似的有：\n\n * 后端拆分。其典型的形式是微服务，以微服务的实现来说，不同部门的服务也往往是独立存在的，在架构上后台本身也是互不干扰的。只要保证接口 API\n   是正常的，就不需要关心其项目背后的技术栈。将其与 App 和前端进行对比，就会发现后端微服务是特别容易实现的。组织内部的不同开发团队，只需要保障 API\n   是稳定可用的、API 是丰富的，不需要过多地讨论会议。\n * App 拆分。App 存在多种容器，有插件化、组件化、小程序等不同的方案。由于一个大型组织的 App\n   所承载的功能相当丰富，其有可能拥有不逊色于操作系统的代码量。要实现跨团队共同在一个代码库开发，并不是一件容易的事。因此采用一个 App\n   平台的方案，让不同部分的业务可以在上面运行，是一个更符合组织架构的开发模式。\n * 前端拆分。大规模前端应用的开发历史要比 App\n   短得多，但是也出现了一系列的拆分方案：前端微服务化、微应用化、微件化，等等。前端走向微前端架构的原因，除了庞大的单体应用，还有一部分是要聚合旧的遗留应用。\n   我们希望旧的遗留应用，能不经修改或者少量的修改，就可以嵌入新的系统中。\n\n7.2 架构的演进#\n\n回过头来看，大型项目的架构演进，无非就是：\n\n 1. 我有了一个 Idea，快速地设计出原型 1.0 版本，并推向市场，效果还不错，赚到一些钱。\n 2. 市面上的竞争对手越来越多，为了赢得这场战争，我们在 2.0 版本的系统里添加了越来越多的功能，一个臃肿的单体应用。\n 3. 随着时间的推移，添加新功能的难度越来越大，于是我们设计出了 3.0 版本的系统——在今天这个节点里，就是微服务架构。\n\n这就是《Linux/Unix 设计思想》一书中所提到的三个系统，毫无维和感：\n\n 1. 在背水一战的情况下，人类设计出了第一个系统。\n 2. 专家们在第一个系统的基础上，做出了伟大而臃肿的第二个系统。\n 3. 受累于第二个系统的人，设计出了第三个系统。\n\n可故事并不能因此而结束。随着时间的推移，受益于第三个系统的人们，又有一部分组织会回到第二个系统。\n\n大部分组织会意识到三个系统的存在。于是，在根据 Idea\n设计一个新系统的同时，采用了第三个系统的架构，然后出错了——因为他们缺少专家。这里的专家并非单纯指技术方面的专家，而是技术专家+业务专家，他/她可以是一个懂业务\n的技术专家，或者是一个懂技术的业务专家。架构在底层是由技术实现的，而在顶层则是由业务代码实现的。\n\n业务层的耦合直接影响了技术上的耦合。这个困境导致了技术架构在不断变化\n\n7.3 微架构带来的问题#\n\n在不同的微架构领域里，他们有着不同的问题。在考察是否使用某项技术的时候，我们就会考虑这些问题。而在这个时候，我们的第一答案是：“直接使用这种架构，具体遇到什么问\n题再解决”。是的，现在让我们来戳破这些问题，看看有没有对应的解决方式。\n\n1. 后端：微服务到应用#\n\n实施过后端微服务的开发人员，想必对微服务也有一系列的看法。在不正确的实施之后，不少人会对微服务有所不满。尽管如此，他们都会承认微服务在隔离服务之间的价值。但是当\n带来的问题远大于收益时，微服务就变得不值得采用了——要么问题不好解决，要么问题解决不了。\n\n在项目上实施的时候，笔者发现有一些额外的问题：\n\n * 代码架构。在不同的组织之间采用微服务架构，对于相互之间都是有好处的。但是在一个小型的内部组织里，掌握代码独立的微服务数量就值得考虑了——既然不需要和别人沟\n   通，为什么需要在十多个 repo 间切换？\n * 部署流程。微服务讲究独立开发、独立部署，如果一个微服务不能独立部署（有些固定的上线周期），那么部署就变成一件痛苦的事。如果在一次 release\n   计划里，我们需要同时上线十几个服务，就变得……\n\n那么，在这种情况下，这些开发者就在考虑，采用微服务架构是否值得。实际上这个问题的本质可能是，是否有独立拆分微服务的必要？或者采取集成构建的方式，在开发和构建时来\n独立两个应用，在部署时只部署一个应用。\n\n2. 客户端：插件化、组件化#\n\nApp 可以分为插件化和组件化两种方式。插件化是集成构建完成后的 APK 包，而组件化（Module）则是集成构建后的模块（Lib）。Web\n前端的拆分则可以是微前端、微应用和跨框架组件化几种形式。\n\n不论采用哪种方式，每一个微小的部分，最后都可以在同一框架内运行。不同的实现方式，稍有一些区别。有些架构实施起来很轻松，但是在维护后却变得相当麻烦。实际上往往有很\n多架构在实施的时候就很麻烦，更不用说在后期维护了。\n\n业务的价值往往以大前端的形式呈现，因此移动应用在代码的拆分上，往往比后端容易。不论采用动态加载、UI\n跳转、路由或者其他形式，都要考虑如何来拆分代码。于是我们就遇到问题了：\n\n一个简单的业务，是否有必要成为一个简单的服务？当我们有一系列简单的功能时，它们真的要独立运行。它们是否有必要成为多个简单的组件？它们不能是一个组件来接受多个参数\n吗？\n\n面对这些问题，我们可以采取合适的代码拆分策略，以便在未来合适的时候进行拆分。限制我们这么做的主要原因是，后期拆分的时候会面临巨大的挑战。\n\n7.4 解决方式：可拆分式微架构#\n\n要合并多个后端服务，就要统一它们的技术栈，但是他们的技术栈会是一样的吗？在多数组织里，技术异构是存在的——只存在于少量数据服务中。在大多数情况下，他们都是使用同\n一种技术进行构建的。同一个语言或同一个框架，可以降低学习成本。一些不易实现的特性如机器学习、深度学习等，则使用 Python 等拥有丰富 AI\n生态的技术栈来构建。\n\n此时，我们只需要保证可以成功构建即可，如微应用化就是一种构建时集成的方式。当然，这有可能又一次回到“锤子定律”的问题中了。这种方式并不违反微服务的一系列原则，服\n务自治、专注的服务等。如果我们主要修改的代码在某一个特定的服务里，那么我们只需要将它们拆分出来独立部署。\n\n同样的道理适用于 App 插件化和前端微应用化。如果没有规范化的开发流程，架构之间可能会出现进一步的耦合。\n\n阅读资料：\n\n《前端架构：从入门到微前端》- 黄峰达（Phodal）编著\n\nps：本章节图片是笔者书中的截图，如有侵权，请联系作者删除，谢谢。","routePath":"/posts/javascript/MicroFrontendArchitecture","lang":"","toc":[{"text":"1. 微前端","id":"1-微前端","depth":2,"charIndex":106},{"text":"1.1 微前端架构","id":"11-微前端架构","depth":4,"charIndex":261},{"text":"1.2 为什么需要微前端","id":"12-为什么需要微前端","depth":4,"charIndex":1083},{"text":"2. 微前端的技术拆分方式","id":"2-微前端的技术拆分方式","depth":2,"charIndex":1542},{"text":"2.1 路由式分法","id":"21-路由式分法","depth":4,"charIndex":1610},{"text":"2.2 前端微服务化","id":"22-前端微服务化","depth":4,"charIndex":1886},{"text":"2.3 组合式集成：微应用化","id":"23-组合式集成微应用化","depth":4,"charIndex":2227},{"text":"2.4 微件化","id":"24-微件化","depth":4,"charIndex":2697},{"text":"2.5 前端容器：iframe","id":"25-前端容器iframe","depth":4,"charIndex":3390},{"text":"2.6 结合 Web Components 构建","id":"26-结合-web-components-构建","depth":4,"charIndex":3751},{"text":"3. 微前端的业务划分方式","id":"3-微前端的业务划分方式","depth":2,"charIndex":4299},{"text":"3.1 按照业务划分","id":"31-按照业务划分","depth":4,"charIndex":4393},{"text":"3.2 按照权限拆分","id":"32-按照权限拆分","depth":4,"charIndex":4741},{"text":"3.3 按照变更的频率拆分","id":"33-按照变更的频率拆分","depth":4,"charIndex":4838},{"text":"3.4 按照组织结构拆分","id":"34-按照组织结构拆分","depth":4,"charIndex":5301},{"text":"3.5 跟随后端微服务拆分","id":"35-跟随后端微服务拆分","depth":4,"charIndex":5789},{"text":"3.6 DDD 与事件风暴","id":"36-ddd-与事件风暴","depth":4,"charIndex":6014},{"text":"4. 微前端的架构设计","id":"4-微前端的架构设计","depth":2,"charIndex":6393},{"text":"4.1 构建基础设施","id":"41-构建基础设施","depth":4,"charIndex":6447},{"text":"4.2 提取组件与模式库","id":"42-提取组件与模式库","depth":4,"charIndex":6800},{"text":"4.3 应用通信机制","id":"43-应用通信机制","depth":4,"charIndex":7693},{"text":"4.4 数据管理","id":"44-数据管理","depth":4,"charIndex":8341},{"text":"4.5 专用的构建系统","id":"45-专用的构建系统","depth":4,"charIndex":8866},{"text":"5. 微前端的架构模式","id":"5-微前端的架构模式","depth":2,"charIndex":9094},{"text":"5.1 基座模式","id":"51-基座模式","depth":4,"charIndex":9108},{"text":"5.2 自组织模式","id":"52-自组织模式","depth":4,"charIndex":9569},{"text":"6. 微前端的设计理念","id":"6-微前端的设计理念","depth":2,"charIndex":9819},{"text":"6.1 中心化：应用注册表","id":"61-中心化应用注册表","depth":4,"charIndex":9941},{"text":"6.2 标识化应用","id":"62-标识化应用","depth":4,"charIndex":10363},{"text":"6.3 生命周期","id":"63-生命周期","depth":4,"charIndex":10564},{"text":"6.4 高聚合，低耦合","id":"64-高聚合低耦合","depth":4,"charIndex":10944},{"text":"7. “微”害架构","id":"7-微害架构","depth":2,"charIndex":11290},{"text":"7.1 微架构","id":"71-微架构","depth":4,"charIndex":11909},{"text":"7.2 架构的演进","id":"72-架构的演进","depth":4,"charIndex":12601},{"text":"7.3 微架构带来的问题","id":"73-微架构带来的问题","depth":4,"charIndex":13186},{"text":"7.4 解决方式：可拆分式微架构","id":"74-解决方式可拆分式微架构","depth":4,"charIndex":14267}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2024-09-07T00:00:00.000Z","author":"h7ml","title":"微前端架构：拆分前端应用的艺术","description":"深入了解微前端架构：探讨它的定义、形成背景、优缺点，以及如何设计和实施微前端系统，包括技术拆分方式、业务划分方式、架构设计、模式、设计理念和\"微\"害架构的影响。","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>了解前沿的前端架构技术，提高应用程序的可维护性和可扩展性。","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"微前端架构:拆分前端应用","category":["javascript","前端开发"],"tag":["javascript","微前端","前端架构","微前端设计","前端应用拆分","微前端模式"],"head":[["meta",{"name":"keywords","content":"微前端、前端架构、微前端设计、前端应用拆分、微前端模式"}]]},"version":""},{"id":355,"title":"javascript","content":" * JavaScript 基本概念\n * JavaScript 数据类型\n * JavaScript 面向对象\n * JavaScript BOM\n * JavaScript DOM\n * JavaScript 事件\n * JavaScript 动画\n * JavaScript 高级程序设计读书笔记\n * JavaScript 原型与继承\n * JavaScript 数据类型\n * JavaScript 类型转换","routePath":"/posts/javascript/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript","index":false,"dir":{"order":1}},"version":""},{"id":356,"title":"读懂React的Transition实现原理","content":"Transition 使用姿势#\n\nTransition 是 react18 引入的新概念，用来区分紧急和非紧急的更新。\n\n * 紧急的更新，指的是一些直接的用户交互，如输入、点击等；\n * 非紧急的更新，指的是 UI 界面从一个样子过渡到另一个样子；\n\nreact 官方的 demo 如下：\n\n\n\n有 2 个 API：\n\n * useTransition：hook，用在 function 组件或其他 hooks 中，能返回 isPending；\n * startTransition：用在不能使用 hooks 的场景，如 class 组件中，相比 useTransition 不能获取 isPending\n   状态；\n\n2 个 API 还有一个差别：当进行连续快速输入时，使用  startTransition  是无法触发类似 throttle 的效果的。\n\n\nTransition VS throttle、debounce#\n\n[react] throttle demo\n\n\n\n存在的问题：\n\n * 到达指定时间后，更新开始处理，渲染引擎会被长时间阻塞，页面交互会出现卡顿；\n * throttle 的最佳时间不易掌握，是由开发者设置的时间。而这个预设的时间，在不同性能的设备上不一定能带来最佳的体验；\n\n[react] debounce demo\n\n\n\n存在的问题：\n\n * 会出现用户输入长时间得不到响应的情况，如上例中虽然输入框中内容一直在变但下面区域内一直不变；\n * 更新操作正式开始以后，渲染引擎仍然会被长时间阻塞，依旧会存在页面卡死的情况；\n\n::: react-demo [react] useTransition demo\n\n\n\n\n\n::: 用 transition 机制的效果：\n\n * 用户可以及时看到输入内容，交互也较流畅；\n * 用户连续输入时，不会一直得不到响应(最迟 5s 必会开始更新渲染列表)；\n * 开始更新渲染后，协调过程是可中断的，不会长时间阻塞渲染引擎（进入浏览器渲染阶段依然会卡住）；\n\ntransition 相比前两种方案的优势：\n\n * 更新协调过程是可中断的，渲染引擎不会长时间被阻塞，用户可以及时得到响应；\n * 不需要开发人员去做额外的考虑，整个优化过程交给 react 和浏览器即可；\n\n\ntransition 实现原理#\n\n\nisPending 实现原理#\n\n我们看到页面首先进入了 pending 状态，然后才显示为 transition 更新后的结果。这里发生了 2 次 react 更新。但我们只写了一个\nsetState。\n\n\n\n我们看一下 useTransition 源码：\n\n\n\n当调用 startTransition 时，会先通过 setPending 将 isPending 改为 true，然后再通过 setPending 将\nisPending 改为 false，并在 callback 中触发我们自己定义的更新。 这里有一个奇怪的地方，3 次 setState\n并没有合并在一起，而是触发了 2 次 react 更新，setPending(true) 为 1 次，setPending(false) 和\ncallback() 为第二次。 这是因为\n\n\n\n这句语句将更新的上下文变更为了 transition。使得 setPending(true) 和 后面的 2 次更新的上下文不同了。\n\n为什么更新的上下文变化会影响 setState 的合并呢，下面简单展开讲一讲 setState 时 react 在干什么。\n\n\nWorkLoop#\n\n一次 react 更新，主核心的过程是 fiber tree 的协调（reconcile），协调的作用是找到 fiber tree 中发生变化的 fiber\nnode，最小程度地对页面的 dom tree 结构进行调整。\n\n在进行协调时，react 提供了两种模式：Legacy mode - 同步阻塞模式和 Concurrent mode - 并行模式。 这两种模式，区别在于\nfiber tree 的协调过程是否可中断。 Legacy mode，协调过程不可中断；Concurrent mode，协调过程可中断。 Legacy\nmode：\n\n\n\nConcurrent mode：\n\n\n\nConcurrent mode 的意义在于：\n\n * 协调不会长时间阻塞浏览器渲染；\n * 高优先级更新可以中断低优先级更新，优先渲染；\n\nreact 的调度机制是 workLoop 机制。伪代码实现如下：\n\n\n\n这里借用《漫谈 react 系列(三): 三层 loop 弄懂 Concurrent 模式》这篇文章中的图来说明 loop 和 task\n的关系，文章链接见最下方的参考资料\n\n\n\nworkLoop 有 2 种，Legacy 模式下，是 workLoopSync；Concurrent 模式下，是\nworkLoopConcurrent。workLoopSync 中每个任务都要完成后才会释放主进程，workLoopConcurrent\n中每个任务在时间片耗尽后会释放主进程等待下一个时间片继续执行任务。\n\nworkLoopSync 对应 Legacy 模式。如果是在 event、setTimeout、network request 的 callback\n中触发更新，那么协调时会启动 workLoopSync。在协调过程中，需要对 fiber tree 做深度优先遍历，处理每一个 fiber\nnode。workLoopSync 开始工作以后，要等到 stack 中收集的所有 fiber node 都处理完毕以后，才会结束工作，也就是 fiber\ntree 的协调过程不可中断。\n\nworkLoopConcurrent 对应 Concurrent 模式。如果更新与 Suspense、useTransition、OffScreen\n相关，那么协调时会启动 workLoopConcurrent。 workLoopConcurrent 开始工作以后，每次协调 fiber node\n时，都会判断当前时间片是否到期。如果时间片到期，会停止当前 workLoopConcurrent、workLoop，让出主线程，然后请求下一个时间片继续协调。\n\n相关源码如下：\n\n\n\n\n任务优先级#\n\nreact 有 3 套优先级机制：\n\n * React 事件优先级\n * Scheduler 优先级\n * Lane 优先级\n\nReact 事件优先级如下：\n\n\n\nreact 在内部定义了 5 种类型的调度（Scheduler）优先级：\n\n * ImmediatePriority, 直接优先级，对应用户的 click、input、focus 等操作；\n * UserBlockingPriority，用户阻塞优先级，对应用户的 mouseMove、scroll 等操作；\n * NormalPriority，普通优先级，对应网络请求、useTransition 等操作；\n * LowPriority，低优先级(未找到应用场景)；\n * IdlePriority，空闲优先级，如 OffScreen;\n\n5 种优先级的顺序为: ImmediatePriority > UserBlockingPriority > NormalPriority >\nLowPriority > IdlePriority。\n\nreact 内部定义了 31 条 lane，lane 可以理解为每个任务所处的赛道。用二进制表示，按优先级从低到高依次为:\n\nlane 对应的位数越小，优先级最高。如 SyncLane 为 1，优先级最高； OffscreenLane 为 31， 优先级最低。\n\nreact 先将 lane 的优先级转换为 React 事件的优先级，然后再根据 React 事件的优先级转换为 Scheduler 的优先级。\n\n当通过 startTransition 的方式触发更新时，更新对应的优先级等级为 NormalPriority。而在 NormalPriority 之上，还存在\nImmediatePriority 、UserBlockingPriority 这两种级别更高的更新。通常，高优先级的更新会优先级处理，这就使得尽管\ntransition 更新先触发，但并不会在第一时间处理，而是处于 pending - 等待状态。只有没有比 transition\n更新优先级更高的更新存在时，它才会被处理。\n\nConcurrent 模式下，如果在低优先级更新的协调过程中，有高优先级更新进来，那么高优先级更新会中断低优先级更新的协调过程。\n\n每次拿到新的时间片以后，workLoopConcurrent\n都会判断本次协调对应的优先级和上一次时间片到期中断的协调的优先级是否一样。如果一样，说明没有更高优先级的更新产生，可以继续上次未完成的协调；如果不一样，说明有更\n高优先级的更新进来，此时要清空之前已开始的协调过程，从根节点开始重新协调。等高优先级更新处理完成以后，再次从根节点开始处理低优先级更新。\n\n\nsetState 机制#\n\n调用 setState，并不会立即更新组件 state。state 的更新，其实是发生在 fiber tree 的协调过程中，这个过程如下：\n\n 1.  调用 setState\n 2.  生成 update 对象：调用 setState 时传入的 new state 会存储在 update 对象的 payload 属性上\n 3.  将 update 对象收集到 组件的 Fiber node 内部的 updateQueue 中\n 4.  为更新创建 task：新建的 task 会添加到 taskQueue 堆顶\n 5.  workLoop 处理 task\n 6.  协调 fiber tree\n 7.  协调组件 fiber node\n 8.  生成 new state：遍历 updateQueue 中所有的 update 对象，读取 payload 属性\n 9.  执行组件 render\n 10. fiber tree 协调完成\n 11. 浏览器渲染\n\n上面 useTransition 的例子中，连续 3 次 setState，会生成 3 个 update 对象 -\nupdate1（setPending(true)），update2（setPending(false)），update3（callback 里的\nsetState 调用）。这三个 update 对象会按照创建的先后顺序依次添加到 updateQueue 中。\n\nupdate 对象结构：\n\n\n\n由于创建 update 对象的上下文不相同，导致 update 对象处理的时机不相同。第一次协调时，处理 update1；第二次协调时，处理 update2 和\nupdate3。之所以这样，是因为不同的上下文，为 update 对象绑定了的不同的 lane。\n\nlane 决定了 update 对象的处理时机。\n\n所以如上，update1 被分配的 lane 为 InputContinuousLane，而 update2、update3 被分配的 lane 为\nTransitionLane。为每个 update 生成 lane 的源码如下：\n\n\n\n至此，已经可以看到，update2 和 update3 被分配了较低的优先级，因此 3 次 setState 被分开成了 2 次更新。\n\n了解了上面的原理，就可以来回答这几个问题了：\n\nuseTransition 为何能表现出 debounce 效果\n\n高优先级更新会中断低优先级更新，优先处理。\n\nstartTransition 方法执行过程中， setPending(true) 触发的更新优先级较高，而\nsetPending(false)、callback 触发的更新优先级较低。当 callback\n触发的更新进入协调阶段以后，由于协调过程可中断，并且用户一直在输入导致一直触发 setPending(true)，使得 callback\n触发的更新一直被中断，直到用户停止输入以后才能被完整处理。\n\nuseTransition 为何能表现出 throttle 效果\n\n如果你一直输入，最多 5s，长列表必然会渲染，和 防抖 - throttle 效果一样。\n这是因为为了防止低优先级更新一直被高优先级更新中断而得不到处理，react 为每种类型的更新定义了最迟必须处理时间 - timeout。如果在 timeout\n时间内更新未被处理，那么更新的优先级就会被提升到最高 - ImmediatePriority，优先处理。\n\ntransition 更新的优先级为 NormalPriority，timeout 为 5000ms 即 5s。如果超过 5s， transition\n更新还因为一直被高优先级更新中断而没有处理，它的优先级就会被提升为 ImmediatePriority，优先处理。这样就实现了 throttle 的效果。\n\nuseTransition 和 startTransition 区别\n\n用户连续输入时，使用 useTransition 会出现 debounce 的效果，而直接使用 startTransition 则不会。\n\n因为 startTransition 的源码：\n\n\n\n对比 useTransition 的 startTransition， 我们会发现 startTransition 中少了 setPending(true)\n的过程。\n\n使用 useTransition 时，transition 更新会一直被连续的 setPending(true) 中断，每次中断时都会被重置为未开始状态，导致\ntransition 更新只有在用户停止输入(或者超过 5s)时才能得到有效处理，也就出现了类似 debounce 的效果。\n\n而直接使用 startTransition 时， 尽管协调过程会每隔 5ms 中断一次，但由于没有 setPending(true) 的中断，\n连续的输入并不会重置 transition 更新。当 transition 更新结束协调时，自然而然地就会开始浏览器渲染过程，不会出现类似 debounce\n的效果。\n\n\nTransition API 由来#\n\n\nReact 如何优化性能#\n\nReact ，它本身的思路是纯 JS 写法，这种方式非常灵活，但是，这也使它在编译时很难做太多的事情，像上面这样的编译时优化是很难实现的。所以，我们可以看到\nReact 几个大版本的的优化主要都在运行时。 进行运行时优化，关注的主要问题就是 CPU 和 IO。\n\n * 首先，就是 CPU 的问题，主流浏览器的刷新频率一般是 60Hz，也就是每秒刷新 60 次，大概 16.6ms 浏览器刷新一次。由于 GUI 渲染线程和\n   JS 线程是互斥的，所以 JS 脚本执行和浏览器布局、绘制不能同时执行。在这 16.6ms 的时间里，浏览器既需要完成 JS\n   的执行，也需要完成样式的重排和重绘，如果 JS 执行的时间过长，超出了\n   16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，于是在页面上就会表现为卡顿。\n * IO 的问题就比较好理解了，很多组件需要等待一些网络延迟，那么怎么样才能在网络延迟存在的情况下，减少用户对网络延迟的感知呢？就是 react\n   需要解决的问题。 React 引入 fiber 机制，可中断协调阶段，就是在 CPU 角度优化运行时性能。而 Suspense API 则是 IO\n   角度的优化，让新内容替换成旧内容的过程不闪屏，内容切换更流畅。\n\n\nTransition API 登场#\n\nSuspense 的作用，主要是 react 优化切换内容效果。而 Transition API 的最初提出，是为了配合 Suspense API 进行 IO\n角度的优化。\n\n官方文档：https://17.reactjs.org/docs/concurrent-mode-patterns.html\n\nuseTransition 的前身是 withSuspenseConfig。Sebmarkbage 在 19 年五月份提的一个 PR 中引进了它。在 19 年\n11 月更名为 useTransition。\n\nTransition Hook 的作用是告诉 React，延迟更新 State 也没关系。\n\n初版的 useTransition 的实现源码如下：\n\n\n\n划重点，虽然跟现在的版本有一些差别，但主要的思想依然是：以较低的优先级运行后 2 次 setState。\n\n一路以来，主要的修改包含：在做兼容数据流状态库如 redux，修改优先级的实现方案。\n\nreact 关于 Suspense 的讨论帖：https://github.com/facebook/react/issues/13206\n\n\n参考资料#\n\n * 《漫谈 react 系列(三): 三层 loop 弄懂 Concurrent\n   模式》：https://juejin.cn/post/7022992730343079966#1\n * 《漫谈 React 系列(四): React18 自己的防抖节流 -\n   useTransition》：https://juejin.cn/post/7037765018313555982#1-1\n * 《React 源码解析之优先级 Lane 模型上》：https://juejin.cn/post/7008802041602506765\n * 《https://juejin.cn/post/6844903986420514823》：https://juejin.cn/post/684490398\n   6420514823\n * 《React 运行时优化方案的演进》：https://juejin.cn/post/7010539227284766751","routePath":"/posts/javascript/UnderstandingReactTransitionImplementation","lang":"","toc":[{"text":"isPending 实现原理","id":"ispending-实现原理","depth":2,"charIndex":996},{"text":"WorkLoop","id":"workloop","depth":2,"charIndex":1503},{"text":"任务优先级","id":"任务优先级","depth":2,"charIndex":2650},{"text":"setState 机制","id":"setstate-机制","depth":2,"charIndex":3812},{"text":"React 如何优化性能","id":"react-如何优化性能","depth":2,"charIndex":6002},{"text":"Transition API 登场","id":"transition-api-登场","depth":2,"charIndex":6569}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2024-05-03T00:00:00.000Z","author":"h7ml","title":"读懂React的Transition实现原理","description":"读懂React的Transition实现原理","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>读懂React的Transition实现原理","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"读懂React的Transition实现原理","category":["javascript","react"],"tag":["react"],"head":[["meta",{"name":"keywords","content":"读懂React的Transition实现原理"}]]},"version":""},{"id":357,"title":"javascript 事件","content":"","routePath":"/posts/javascript/animation/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 事件","index":false,"dir":{"order":6}},"version":""},{"id":358,"title":"javascript 事件","content":"","routePath":"/posts/javascript/animation/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 事件","index":false,"dir":{"order":6}},"version":""},{"id":359,"title":"JavaScript 拖拽效果-动画","content":"#\n\n鼠标按下 onmousedown，onmousedown 里边鼠标移动 onmousemove，鼠标释放 onmouseup\n\n","routePath":"/posts/javascript/animation/拖拽效果","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":360,"title":"JavaScript 碰撞检测-动画","content":"#\n\n","routePath":"/posts/javascript/animation/碰撞检测","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":361,"title":"JavaScript 链式运动-动画","content":"#\n\n缓动运动框架\n\n每次的步长 = （总路程 - 当前位置） / 运动系数（6-10）\n\n","routePath":"/posts/javascript/animation/链式运动","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":362,"title":"javascript 基本概念","content":" * JavaScript 变量\n * JavaScript 严格模式及运算问题\n * JavaScript 数值转换\n * JavaScript 数据类型检测\n * JavaScript 运算符\n * JavaScript 语句\n * JavaScript 变量、作用域、内存","routePath":"/posts/javascript/basic/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 基本概念","index":false,"dir":{"order":2}},"version":""},{"id":363,"title":"JavaScript 变量","content":"#\n\n\nvar 关键字#\n\n\n\n声明后可以改变类型，但不推荐\n\n\n\nvar 声明作用域，一个函数内部定义一个变量，在函数退出时被销毁\n\n\n\n在函数内定义变量时省略 var 操作符，可以创建一个全局变量：\n\n\n\n定义多个变量\n\n\n\nvar 声明提升\n\n\n\n关键字声明的变量会自动提升到函数作用域顶部，相当于：\n\n\n\n反复多次使用 var 声明同一个变量也没有问题\n\n\n\n\nlet 声明#\n\nlet 声明的范围是块作用域：\n\n\n\n不能重复声明\n\n\n\n块作用域没有重复声明则使用相同标识符则不会报错\n\n\n\n两个关键字不能重复声明\n\n\n\n\n暂时性死区#\n\n\n\n\n全局声明#\n\nlet 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会）\n\n\n\n注意\n\n不过 let 声明还是在全局作用域中发生的，变量会在整个页面生命周期内续存。所以不要重复声明同一个变量，避免 SyntaxError\n\n\n条件声明#\n\n\n\nJavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。但是 let 是块级作用域，所以检查不到之前是否声明过。\n\n\n\ntry/catch 语句或 typeof 操作符也不能解决\n\n\n\n\nfor 循环中的 let 声明#\n\n使用 var 时变量会渗透到外面\n\n\n\nlet 之后则不会，因为遇到 {} 就会形成作用域块\n\n\n\n常见的异步循环问题\n\n\n\n在延迟定时器执行时，他是异步的，循环已经结束了，最后的值始终都是 5。\n\n使用 let 才是期望的值\n\n\n\n每次迭代循环声明一个新的迭代变量，每个 setTimeout 引用的都是不同的变量实例。这种风格也适用于 for in、for of。\n\n\nconst 声明#\n\nconst 的行为与 let 基本相同，但是他是常量，声明之后不能修改，尝试修改 const 声明的变量会导致运行时错误。\n\n\n\n但是 const 声明只限制声明的引用：\n\n\n\n如果想让整个对象都不能修改，可以使用 Object.freeze()\n\n\n\n在 for 中 const 与 let 一样分别独立创建变量的实例，但是不能用 const 来迭代变量（因为变量 i 要自增）\n\n\n\n只想用 const 声明一个不会被修改的 for 循环变量，那也是可以的\n\n\n\n最佳实践\n\n不使用 var，const 优先，let 次之\n\n\n函数声明提升与 var 声明提升#\n\n\n\nfunction与var都存在变量提升，但function比var优先级高。上面的代码就相当于：\n\n","routePath":"/posts/javascript/basic/basic","lang":"","toc":[{"text":"var 关键字","id":"var-关键字","depth":2,"charIndex":3},{"text":"let 声明","id":"let-声明","depth":2,"charIndex":184},{"text":"暂时性死区","id":"暂时性死区","depth":3,"charIndex":265},{"text":"全局声明","id":"全局声明","depth":3,"charIndex":276},{"text":"条件声明","id":"条件声明","depth":3,"charIndex":406},{"text":"for 循环中的 let 声明","id":"for-循环中的-let-声明","depth":3,"charIndex":517},{"text":"const 声明","id":"const-声明","depth":2,"charIndex":722},{"text":"函数声明提升与 var 声明提升","id":"函数声明提升与-var-声明提升","depth":2,"charIndex":999}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":364,"title":"javascript 基本概念","content":" * JavaScript 变量\n * JavaScript 严格模式及运算问题\n * JavaScript 数值转换\n * JavaScript 数据类型检测\n * JavaScript 运算符\n * JavaScript 语句\n * JavaScript 变量、作用域、内存","routePath":"/posts/javascript/basic/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 基本概念","index":false,"dir":{"order":2}},"version":""},{"id":365,"title":"JavaScript 运算符","content":"#\n\nECMAScript 中的操作符比较独特，包括字符串、数值、布尔值，甚至还有对象。应用给对象时通常会调用会调用valueOf()或toString()方法。\n\n\n一元运算符#\n\n\n递增/递减#\n\n\n\n操作符在前，先自递增/递减后再进行运算。\n\n\n\n操作符在后，先运算再进行自递增/递减。\n\n\n\n\n\n\n一个变量同时等于两个值#\n\n参考上面所说的，如果是对象，操作符会先调用 valueOf 取值，重写 valueOf 即可使 o == 1 且 o == 2\n\n\n\n\n一元加和减#\n\n\n\n\n算术运算符#\n\n * + 加法比较特殊\n   \n   * 两边都是数字时，做数学运算\n   * 一边为字符串，进行字符串连接\n   * 一边为对象类型 object，将对象使用 toString 方法转换为字符串，进行连接\n\n * - * / % 只能数学运算 隐式用 Number 转换 不能转 ---> NaN\n\n\n\n\n比较运算符#\n\n * 大于 >，小于 <，大于等于 >=，小于等于 <=， 等于 ==，全等 ===，不等于 !=，不全等 !==。\n * == 等于时：只需要值相等，不用管数据类型，实际上也是通过 Number 进行类型转换\n * === 全等时：不会进行数据类型转换 那么需要两边的数据类型和值都相等\n * 特例 undefined == null 为真（ js 真理）undefined 值是由 null 值派生而来的，因此 ECMA-262\n   将它们定义为表面上相等\n\n\n\n\n逻辑运算符#\n\n * 非 ! 取反 非真为假 非假为真\n * 与 && 与运算见假则假\n * 或 || 或运算见真则真\n\n\n\n\n短路运算#\n\n * 短路与： 第一个值为 true 返回第二个值， 第一个值为 false，则返回第一个值\n * 短路或： 第一个值为 true 返回第一个值， 第一个值为 false，则返回第二个值\n\n\n\n\n三目运算符#\n\n * 方法: ? : ---> 判断条件 ? 当条件为真时 返回的值 ： 当条件为假时返回的值\n\n\n\n\n赋值运算符#\n\n * = 赋值 += -= *= /= %=\n\n\n\n\n隐式类型转换#\n\n * + - * / %\n * + 转换方式比较多\n * - * / % 都是使用 Number 转数字 能转数字就运算 不能转数字就 NaN\n\n\n括号/逗号运算符#\n\n\n\n * 应用\n\n\n\n\n指数运算符#\n\n * ES2016 新增了一个指数运算符（**）\n\n\n\n\n位操作符#\n\n * ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储\n\n * 但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，位操作之后再把结果转换为 64 位。（所以只需要考虑 32 位）\n\n * 32 位，前面 31 位表示数值，32 位表示数值的符号，0 表示正，1 表示负。（称为符号位）\n\n * 正值以二进制格式存储，31 位都是 2 的幂。（第一位 2º，第二位 2¹，以此类推）\n\n数值 18 用二进制来表示为 00000000000000000000000000010010（32 位数），前面的 0 可以省略 10010。\n\n10010 = (2^4 1)+(2^3 0)+(2^2 0)+(2^1 1)+(2^0 * 0) = 18\n\n * 负数以二补数（补码）储存\n   1. 以绝对值的二进制表示（-18 先确定 18 的二进制）\n   2. 0 变成 1，1 变成 0（称为补数/补码）\n   3. 给结果加 1\n\n按上述步骤表示 -18：\n\n第一步：表示绝对值 18\n\n0000 0000 0000 0000 0000 0000 0001 0010\n\n第二步：补码\n\n1111 1111 1111 1111 1111 1111 1110 1101\n\n第三部：给补数加 1\n\n1111 1111 1111 1111 1111 1111 1110 1110 （这就是 -18 的二进制表示）\n\n\n\n输出'-10010'，这个过程会求处二补数，然后符合逻辑的表示出来。ECMA\n中存在无符号的整数，也就是说无符号的整数比有符号的范围更大，因为符号位可以用来表示数值。\n\n\n按位非#\n\n~ 来表示，作用是返回数值的补数。\n\n\n\n这样的结果比-num1 - 1结果更快，位操作符是在底层表示进行的。\n\n应用\n\n\n\n~a 反补减 1 得 -26，再~ 反补得到正 26 减 1 得到 25。\n\n\n按位与#\n\n& 来表示，两个数的位 1 1 得 1，0 1 得 0， 0 0 得 0。\n\n\n\n25 = 0000 0000 0000 0000 0000 0000 0001 1001\n\n  3 = 0000 0000 0000 0000 0000 0000 0000 0011\n\n只有都为 1 时二进制位才取 1\n\n0000 0000 0000 0000 0000 0000 0000 0001\n\n所以结果就是 1\n\n\n按位或#\n\n| 来表示，看懂了按位与那么按位或也是同理。有一个位为 1 则为 1，都为 0 时则为 0。\n\n\n\n\n按位异或#\n\n^ 来表示，它只有在一位是 1，一位是 0 时才会得 1。都是 0 或都是 1 则得 0。\n\n\n\n相同的两个值，按位异或比按位或得出的结果小 1\n\n\n左移#\n\n<< 表示，二进制位向左移动的位数\n\n\n\n2 的二进制 10，向左移 5，补了 5 个 0,1000000 即为 64。\n\n但是左移会保留符号，-2 左移 5 得到 -64，并不是 64\n\n\n有符号右移#\n\n>> 表示，与左移同理，也会保留符号。\n\n\n\n\n无符号右移#\n\n>>> 表示，\n\n","routePath":"/posts/javascript/basic/operator","lang":"","toc":[{"text":"一元运算符","id":"一元运算符","depth":2,"charIndex":83},{"text":"递增/递减","id":"递增递减","depth":3,"charIndex":92},{"text":"一个变量同时等于两个值","id":"一个变量同时等于两个值","depth":3,"charIndex":152},{"text":"一元加和减","id":"一元加和减","depth":3,"charIndex":234},{"text":"算术运算符","id":"算术运算符","depth":2,"charIndex":245},{"text":"比较运算符","id":"比较运算符","depth":2,"charIndex":407},{"text":"逻辑运算符","id":"逻辑运算符","depth":2,"charIndex":651},{"text":"短路运算","id":"短路运算","depth":2,"charIndex":715},{"text":"三目运算符","id":"三目运算符","depth":2,"charIndex":820},{"text":"赋值运算符","id":"赋值运算符","depth":2,"charIndex":880},{"text":"隐式类型转换","id":"隐式类型转换","depth":2,"charIndex":915},{"text":"括号/逗号运算符","id":"括号逗号运算符","depth":2,"charIndex":998},{"text":"指数运算符","id":"指数运算符","depth":2,"charIndex":1021},{"text":"位操作符","id":"位操作符","depth":2,"charIndex":1058},{"text":"按位非","id":"按位非","depth":3,"charIndex":1779},{"text":"按位与","id":"按位与","depth":3,"charIndex":1888},{"text":"按位或","id":"按位或","depth":3,"charIndex":2098},{"text":"按位异或","id":"按位异或","depth":3,"charIndex":2155},{"text":"左移","id":"左移","depth":3,"charIndex":2237},{"text":"有符号右移","id":"有符号右移","depth":3,"charIndex":2338},{"text":"无符号右移","id":"无符号右移","depth":3,"charIndex":2370}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":366,"title":"JavaScript 判断、循环语句","content":"#\n\n\nif#\n\n\n\n如果只有一条可以省略 {}，但容易导致错误，应该避免\n\n\n\n\ndo-while#\n\n * 语句最少执行一次\n\n\n\n\nwhile#\n\n\n\n\nfor#\n\n\n\n\nfor in#\n\n * 遍历数组/对象\n\n\n\n\nfor of#\n\n\n\n * break;停止循环\n * continue;停止这次循环\n\n\nwith#\n\n * 改变代码块的作用域，查找变量会先找 obj 里面的\n * 大量使用 with 会导致性能下降，不建议使用（因为修改了作用域链）\n\n\n\n\nswitch#\n\n\n\n\n关键字与保留字#\n\nECMA-262 第 6 版规定的所有关键字如下：\n\nbreak do in typeof case else instanceof var catch export new void class extends\nreturn while const finally super with continue for switch yield debugger\nfunction this default if throw delete import try\n\n始终保留：enum\n\n严格模式下保留：\n\nimplements package public interface protected static let private\n\n模块代码中保留：await\n\n这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说最好不要用","routePath":"/posts/javascript/basic/statement","lang":"","toc":[{"text":"if","id":"if","depth":2,"charIndex":3},{"text":"do-while","id":"do-while","depth":2,"charIndex":41},{"text":"while","id":"while","depth":2,"charIndex":68},{"text":"for","id":"for","depth":2,"charIndex":79},{"text":"for in","id":"for-in","depth":2,"charIndex":88},{"text":"for of","id":"for-of","depth":2,"charIndex":112},{"text":"with","id":"with","depth":2,"charIndex":158},{"text":"switch","id":"switch","depth":2,"charIndex":236},{"text":"关键字与保留字","id":"关键字与保留字","depth":2,"charIndex":248}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":367,"title":"JavaScript 严格模式及运算问题","content":"#\n\n\n严格模式#\n\n\n\n 1. 全局变量声明必须加 var。 必须先声明再使用。\n 2. 函数内重名属性\n 3. arguments 对象不被允许修改，只会是传进来的数值\n 4. fn.caller，arguments.callee 不可用\n 5. 函数本身不能使用 this 关键字\n 6. eval() 里存在作用域\n 7. 新增保留字：implements，interface，let，package，private，protected，public，static，yield\n    。\n\n\n运算的问题#\n\n\n\n\nJavaScript 在 HTML 中的引入#\n\nscript 这个元素是由网景公司创造出来，最早在 Netscape Navigator 2 中实现。\n\n * charset：src 属性指定的代码字符集。大多数浏览器无视它的值。\n\n * crossorigin：配置\n   CORS（跨域）设置，\"anonymous\"请求不设置凭据标志，\"use-credentials\"设置凭据标志，跨域请求会包含凭据。\n\n * defer：脚本延迟到文档被解析和显示之后再执行! defer 属性只适用于外部脚本文件\n\n * async：表示立即下载脚本，页面其他操作不影响! async 属性只适用于外部脚本文件\n\n * integrity：验证子资源完整性。\n\n * language：废弃。表示代码块中的脚本语言\n\n * src：要执行的代码的外部文件\n\n * type：代替 language，表示代码块中的 MIME\n   类型。默认\"text/javascript\"，实际上\"text/javascript\"和\"text/ecmascript\"已经废弃了。JavaScript\n   文件的 MIME 类型通常是\"application/x-javascript\"，不过给 type 属性这个值有可能导致脚本被忽略。如果这个值是\n   module，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 import 和 export 关键字。\n\n * 不能再任何地方出现，浏览器遇到时会认为这是结束的标签\n\n * 解决方法 通过转义字符 \\ 解决这个问题\n\n\n\n\n异步脚本#\n\n\n\n\n推迟脚本#\n\n\n\n\n动态脚本#\n\n\n\n统一动态脚本加载行为（不一定都支持 async 属性）：\n\n\n\n * 让浏览器预先加载 js 文件，js 动态加载 js 脚本浏览器并不知道，想要浏览器知道这个文件的存在可以在文档头部添加：\n\n","routePath":"/posts/javascript/basic/strict","lang":"","toc":[{"text":"严格模式","id":"严格模式","depth":2,"charIndex":3},{"text":"运算的问题","id":"运算的问题","depth":2,"charIndex":250},{"text":"JavaScript 在 HTML 中的引入","id":"javascript-在-html-中的引入","depth":2,"charIndex":261},{"text":"异步脚本","id":"异步脚本","depth":3,"charIndex":949},{"text":"推迟脚本","id":"推迟脚本","depth":3,"charIndex":959},{"text":"动态脚本","id":"动态脚本","depth":2,"charIndex":969}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":368,"title":"JavaScript 数值转换","content":"#\n\n数据类型        转换为 TRUE 的值   转换为 FALSE 的值\nBoolean     True          False\nString      非空字符串         ''\nNumber      非 0 数字        0 和 NaN\nObject      任何对象          null\nUndefined   n/a（不适用）      Undefined\n\n\nisNaN#\n\n * 不能被 number 转换为数字 ----> true\n * 能被 number 转换为数字 ----> false\n\n\n\nisNaN 首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值\n\n\nisFinite#\n\n * 除 NaN 与 Infinity 都返回 true\n\n\n\n\nNumber#\n\n * 转换为为数值 无法转换 ---> NaN（不是一个数字）\n\n\n\n\nparseInt#\n\n * 转换为整数\n   * 参数 1：要转换的变量\n   * 参数 2：以什么进制来转换这个数值，默认 10 进制，0 也是 10 进制\n\n\n\n\nparseFloat#\n\n * 转换为小数，只解析 10 进制，没有小数点或小数点后面都是 0 会返回整数\n\n\n\n\ntoString#\n\n * 转换为字符串 不能转换 null 和 undefined\n\n\n\n\nString#\n\n * 转型函数 能转换 null 和 undefined\n\n\n\n * +'' 拼接也可以转换为 string","routePath":"/posts/javascript/basic/type-check","lang":"","toc":[{"text":"isNaN","id":"isnan","depth":2,"charIndex":205},{"text":"isFinite","id":"isfinite","depth":2,"charIndex":358},{"text":"Number","id":"number","depth":2,"charIndex":402},{"text":"parseInt","id":"parseint","depth":2,"charIndex":447},{"text":"parseFloat","id":"parsefloat","depth":2,"charIndex":531},{"text":"toString","id":"tostring","depth":2,"charIndex":589},{"text":"String","id":"string","depth":2,"charIndex":636}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":369,"title":"javascript 数据类型","content":"#\n\n温馨提示阅读\n\n《JavaScript 高级程序设计（第 4 版）》和各个大佬的文章所归纳的总结，如有异议按你的理解为主\n\nJavaScript 中的数据类型分为基本数据类型和引用数据类型\n\n\n基本类型#\n\n> 注: 基本数据类型也可以叫原始数据类型\n\n在 ES2020 标准下的 JavaScript 一共有以下 7 种基本类型\n\n * undefined 未定义\n * null 空指针\n * boolean 布尔值\n * string 字符串\n * number 数值\n * symbol 独一无二的值 (ES6 引入)\n * bigint 大整数 (ES2020 引入)\n\n基本类型总结\n * 基本类型仅保存原始值，不存在属性和方法\n * 基本类型存储在 栈内存 中\n * 保存基本类型的变量是 按值 (by value) 访问 的，操作的就是存储在变量中的实际值\n * 复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)\n\n为什么原始值不存在属性和方法，但 'hello world'.toString() 可以正确执行为了方便操作原始值\n\nECMAScript 提供了 3 种特殊的引用类型：Boolean Number\nString，每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，在执行完后再销毁这个包装对象\n\n\n\n\n引用类型#\n\n在 JavaScript 中除了基本类型，其他的都是引用类型，常见的引用类型如下\n\n * Object 对象\n * Array 数组\n * Function 函数\n * Date 日期与时间\n * RegExp 正则表达式\n * Set 类似于数组但成员的值都是唯一的 (ES6 引入)\n * WeakSet (ES6 引入)\n * Map 类似于对象也是键值对的集合 (ES6 引入)\n * WeakMap (ES6 引入)\n\n引用类型总结\n * 因为 JavaScript 不允许直接访问内存位置(不能直接操作对象所在的内存空间)，所以引用类型在 栈内存\n   中存储的是地址(内存指针)，而引用类型中的数据(方法或属性)是存储在 堆内存 中\n * 保存引用类型的变量是 按引用 (by reference) 访问 ，实际上操作的是对该对象的引用而非实际的对象本身\n * 复制引用类型时只会复制内存指针\n\n栈内存和堆内存\n * 栈内存\n   * 存储基本数据类型和堆内存地址\n   * 是连续的内存空间\n * 堆内存\n   * 存储引用数据类型和闭包中的变量\n   * 不是连续的内存空间\n * 了解更多请点击 JS 中的栈内存和堆内存\n\n\n类型判断#\n\n常见的五种判断方式\n\n * typeof\n * instanceof\n * constructor\n * Array.isArray()\n * Object.prototype.toString\n\n\ntypeof#\n\n * 除 null 外的基本类型都能准确判断\n\n\n\n为什么 typeof null === 'object' 在\n\nJavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null\n代表的是空指针（大多数平台下值为 0x00），因此null 的类型标签是 0，typeof null 也因此返回 \"object\" —— MDN\n\n * 除 function 外的引用类型均返回 object\n\n\n\n\ninstanceof#\n\ninstanceof 用于检测构造函数的 prototype 属性是否存在于实例对象的原型链上\n\n\n\ninstanceof 总结\n * instanceof 不能判断基本类型，对于引用类型只能判断原型链上的从属关系\n * instanceof 并不完全可靠，因为构造函数的 prototype 属性可能会被修改\n   * 修改原型的方法\n     * 使用 ES6 提供的 Reflect.setPrototypeOf() 方法\n     * 借助于非标准的 __proto__ 伪属性\n\n\nconstructor#\n\n实例对象可以通过 constructor 属性去访问它的构造函数\n\n\n\nconstructor 总结\n * constructor 可以判断除 undefined 和 null 外的所有基本类型和引用类型(undefined 和 null 不存在构造函数)\n * constructor 并不完全可靠，因为构造函数的 prototype 属性可能会被修改，从而造成 constructor 属性指向不准确\n\n\nArray.isArray()#\n\nArray.isArray() 用于判断一个值是否是数组 (Array)\n\n\n\n\nObject.prototype.toString#\n\n * 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，默认情况下 toString()\n   方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖 toString() 返回 \"[object type]\" 其中 type\n   是对象的类型\n * 为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者\n   Function.prototype.apply() 的形式来调用\n\n\n\ntoString 方法的在 ECMAScript 5 下的大致执行过程\n\n 1. 如果 this 是 undefined 返回 [object Undefined]\n 2. 如果 this 是 null 返回 [object Null]\n 3. 让 O 成为 ToObject(this) 的结果\n 4. 让 class 成为 O 的内部属性 [[Class]] 的值\n 5. 返回由 \"[object \" class \"]\" 三个部分组成的字符串\n\n注意点\n\n不同 ECMAScript 版本对 toString 方法的规范都有所不同\n\nObject.prototype.toString 方法的原理","routePath":"/posts/javascript/basic/types","lang":"","toc":[{"text":"基本类型","id":"基本类型","depth":2,"charIndex":99},{"text":"引用类型","id":"引用类型","depth":2,"charIndex":587},{"text":"类型判断","id":"类型判断","depth":2,"charIndex":1117},{"text":"typeof","id":"typeof","depth":3,"charIndex":1224},{"text":"instanceof","id":"instanceof","depth":3,"charIndex":1472},{"text":"constructor","id":"constructor","depth":3,"charIndex":1731},{"text":"Array.isArray()","id":"arrayisarray","depth":3,"charIndex":1950},{"text":"Object.prototype.toString","id":"objectprototypetostring","depth":3,"charIndex":2009}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2019-08-16T00:00:00.000Z","author":"h7ml","category":"javascript 数据类型","tag":"javascript","star":true},"version":""},{"id":370,"title":"JavaScript 变量、作用域、内存","content":"#\n\n\n原始值与引用值#\n\nECMAScript 分为两种数据类型： 1、原始值：最简单的数据（undefined null boolean number string symbol）。\n2、引用值：由多个值构成的对象，保存在内存中的对象（js 不能直接访问内存地址，也就不能操作对象所在内存空间，所以实际操作只是对该对象的引用操作）。\n\n\n原始值不能有属性#\n\n\n\n\n复制值#\n\n\n\n\n函数传参#\n\n * 原始值传递\n\n\n\n * 引用值传递\n\n\n\n例 2：\n\n\n\n\n上下文#\n\n“上下文”在 js 中非常重要。它决定了变量和函数访问的数据以及行为，上下文储存在variable object对象上，但无法通过代码访问，后台处理时会用到它。\n\n全局上下文：在 ECMA\n所述的宿主环境，全局上下文对象可能不一样，浏览器中为window对象，node.js环境下则是global对象。通过var声明的全局变量都会成为window对象\n的属性或方法。let、const 则不会，但是在作用域链效果是一样的。\n\neval()调用内部存在第三种上下文。\n\n\n\n\n改变作用域#\n\n\n\nwith语句将Promise作为当前作用域的上下文。这里的all访问的就是Promise中的实例对象（不能是原型对象上的属性或方法）。\n\n\n变量声明#\n\n\n\n\n标识符查找#\n\n\n\n\n垃圾回收#\n\nJavaScript\n通过自动内存管理内存的分配和闲置资源的回收：确定哪个变量不会再使用，释放它的内存。这个过程每隔一段时间或预定时间就会自动运行。但这个过程是不完美的方案，在一个代\n码块内哪些变量是否还有用是一个“无法判定”的问题。\n\n以一个函数作用域周期为例，执行函数时，会分配该函数到栈或堆内存中保存对应的值，函数内部使用了变量，退出。此时就可以释放局部的变量了。但并不会这么明显，垃圾回收需\n要跟踪哪些变量还会继续使用：在浏览器的发展史上，用到过标记清理和引用计数。\n\n\n标记清理#\n\n当变量在进入上下文时，从逻辑上讲只要在上下文中就不应该释放它们的内存，只要上下文在运行就可能用到它。当离开上下文时就会被加上离开上下文的标记。如“在上下文中”和\n“不在上下文中”两个列表。\n\n在垃圾回收程序运行时，它会将所有在当前上下文中变量及被上下文中引用的变量标记去掉，之后再被加上标记的变量就是待删除了，原因是在任何上下文中的变量都访问不到它们了\n。之后垃圾回收程序会做一次清理，清除带有标记的值并回收它们的内存。\n\n\n引用计数#\n\n引用计数没有标记清理那么常用。在声明一个变量时，这个值引用次数为 1。如果这个值被赋值到另一个值，引用数就会加 1。相反，这个值被新的值覆盖，引用数就会减\n1。但引用数为 0 时就没办法访问这个值了。等待垃圾回收程序运行时就会释放引用数为 0 的值。\n\n但引用计数有一个严重的问题：循环引用\n\n\n\n上面的两个变量互相引用，引用数都是 2。在标记清理策略下会被回收，但在引用计数下，这两个值还会存在。他们的引用数永远不会变成\n0。这个函数被调用多次就会造成很多内存不会释放。因此，早期的网景浏览器就放弃了引用计数。\n\n但引用计数的问题在 IE8 之前也有许多问题，BOM 和 DOM 对象是 C++实现的，并非 js 引擎的标记清理，只要设计了 DOM 和 BOM\n对象就无法避开引用的问题。\n\n\n\n在 IE9 中把 BOM 和 DOM 对象都改成了 js 对象，从而避免了两套垃圾回收算法与内存泄露的问题。\n\n警告在 IE 中\n\nwindow.CollectGarbage()方法会立即触发垃圾回收。在 Opera 7\n及更高版本中，调用window.opera.collect()也会启动垃圾回收程序。这些方法有可能触发垃圾回收（不推荐）。\n\n\n内存管理#\n\n在系统中，分配给浏览器的内存一般比桌面软件要少很多。\n\n如果数据不再需要，那么把它赋值为null。\n\n\n\n使用const与let可以更早的让垃圾回收程序处理。\n\n\n隐藏类#\n\n在chrome的 V8 JavaScript 引擎解释 js 时会利用隐藏类。\n\n\n\no1和o2共享相同的隐藏类、构造函数以及原型。\n\n如果后续代码做了添加操作：\n\n\n\n此时两个类的实例就会对应不同的隐藏类。\n\n解决方案（避免先创建再新增）：\n\n\n\n如果后续代码做了删除操作：\n\n\n\n此时两个类的实例就会对应不同的隐藏类（与动态添加的后果是一样的）。\n\n解决方案（把不想要的属性设置为null）：\n\n\n\n\n内存泄露#\n\n * 没有加声明关键字会导致属性被添加到window上，只要window没有被清除属性就不会消失。\n\n\n\n * 定时器也会导致内存泄漏\n\n\n\n定时器一直执行就会导致name一直被引用。\n\n * 闭包也会造成内存泄漏\n\n\n\n调用globalFun方法返回的函数只要一直引用它，内部的obj也不会被清理掉。","routePath":"/posts/javascript/basic/variable","lang":"","toc":[{"text":"原始值与引用值","id":"原始值与引用值","depth":2,"charIndex":3},{"text":"原始值不能有属性","id":"原始值不能有属性","depth":3,"charIndex":170},{"text":"复制值","id":"复制值","depth":3,"charIndex":184},{"text":"函数传参","id":"函数传参","depth":3,"charIndex":193},{"text":"上下文","id":"上下文","depth":2,"charIndex":233},{"text":"改变作用域","id":"改变作用域","depth":3,"charIndex":476},{"text":"变量声明","id":"变量声明","depth":3,"charIndex":556},{"text":"标识符查找","id":"标识符查找","depth":3,"charIndex":566},{"text":"垃圾回收","id":"垃圾回收","depth":2,"charIndex":577},{"text":"标记清理","id":"标记清理","depth":3,"charIndex":824},{"text":"引用计数","id":"引用计数","depth":3,"charIndex":1044},{"text":"内存管理","id":"内存管理","depth":2,"charIndex":1575},{"text":"隐藏类","id":"隐藏类","depth":3,"charIndex":1664},{"text":"内存泄露","id":"内存泄露","depth":3,"charIndex":1873}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2023-01-11T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":371,"title":"JavaScript BOM 常用方法","content":"#\n\n\n\n\n系统对话框#\n\n\n\n\nconsole.time()#\n\n\n\n测试从上一个 test1 到这行代码运行所用的时间\n\n\nopen 及 close#\n\n","routePath":"/posts/javascript/bom/BOM常用方法","lang":"","toc":[{"text":"系统对话框","id":"系统对话框","depth":2,"charIndex":5},{"text":"console.time()","id":"consoletime","depth":3,"charIndex":16},{"text":"open 及 close","id":"open-及-close","depth":2,"charIndex":63}],"domain":"","frontmatter":{},"version":""},{"id":372,"title":"javascript Bom","content":"","routePath":"/posts/javascript/bom/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript Bom","index":false,"dir":{"order":5}},"version":""},{"id":373,"title":"JavaScript history 历史记录","content":"#\n\n","routePath":"/posts/javascript/bom/history","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":374,"title":"javascript Bom","content":"","routePath":"/posts/javascript/bom/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript Bom","index":false,"dir":{"order":5}},"version":""},{"id":375,"title":"JavaScript location URL 地址对象","content":"#\n\n完整的 URL 地址：\n\n协议：// 主机名：端口号 /路径/ ？查询字符串 #锚点\n\n如：https://127.0.0.1:5500/javascript.html/?a=ssa&bd=asd#aaa\n\n","routePath":"/posts/javascript/bom/location","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":376,"title":"JavaScript navigator 浏览器信息","content":"#\n\n","routePath":"/posts/javascript/bom/navigator","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":377,"title":"JavaScript client、client、scroll 窗口位置","content":"#\n\n\n\n","routePath":"/posts/javascript/bom/窗口位置","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":378,"title":"JavaScript 类型转换","content":"#\n\n温馨提示阅读\n\n《你不知道的 JavaScript（中卷）》和各个大佬的文章所归纳的总结，如有异议按你的理解为主\n\n将值从一种类型转换为另一种类型称为类型转换 在 JavaScript 中进行类型转换时，根据调用形式的不同可以分为以下两种:\n\n * 显式类型转换\n * 隐式类型转换\n\n\n抽象操作 (内部的类型转换规则)#\n\n在了解类型转换前我们需要知道 JavaScript 的 抽象操作 (类型转换规则)\n\n> 抽象操作 是指仅供内部使用的操作\n\n * ToPrimitive 将引用类型转换成相应的基本类型值\n * ToString 将非字符串值转换成字符串\n * ToBoolean 将非布尔值转换成布尔值\n * ToNumber 将非数字值转换成数字值\n\n\nToPrimitive#\n\nToPrimitive 用来处理引用类型到基本类型的类型转换\n\nToPrimitive 转换规则\n * 检查是否存在 Symbol.toPrimitive()\n   * 基本类型直接返回\n   * 引用类型抛出 TypeError 错误\n * 检查是否存在 valueOf()\n   * 基本类型直接返回\n   * 引用类型则继续调用 toString()\n * 调用 toString()\n   * 基本类型直接返回\n   * 引用类型抛出 TypeError 错误\n\n注意点\n * 使用 Object.create(null) 创建的对象没有原型，即不存在 valueOf() 和 toString()，当对其进行类型转换时会抛出\n   TypeError 错误\n * 在做显式类型转换时 valueOf() 和 toString() 的调用顺序会根据转换目标不同去做相应调整\n   * 默认情况下都是先调用 valueOf() 再调用 toString()\n   * 当需要转换的目标为字符串时，会先调用 toString() 再调用 valueOf()\n\n\n\n\nToString#\n\nToString 用来处理非字符串到字符串的类型转换\n\nToString 转换规则\n * 基本类型\n   * undefined => 'undefined'\n   * null => 'null'\n   * true => 'true'\n   * false => 'false'\n   * number\n     * 普通数值直接加引号\n     * 极小和极大的数字将转换成指数形式的字符串\n     * +0 0 -0 => '0'\n     * Infinity => 'Infinity'\n * 引用类型会先调用 ToPrimitive 逻辑将其转换成基本类型，如果返回的基本类型不是字符串，再遵循以上规则进行转换\n\n\nToBoolean#\n\nToBoolean 用来处理非布尔值到布尔值的类型转换，在 JavaScript 中，布尔类型分为真值(true)和假值(false)\n\n * 假值：可以被强制类型转换为 false 的值\n * 真值：除假值之外的值\n\nToBoolean 转换规则\n * 以下值会被转换成假值(false)\n   * undefined\n   * null\n   * false\n   * +0 0 -0 NaN\n   * ''\n * 除假值之外的值都会被转换成真值(true)\n\n\nToNumber#\n\nToNumber 用来处理非数字值到数字值的类型转换\n\nToNumber 转换规则\n * 基本类型\n   * undefined => NaN\n   * null => 0\n   * true => 1\n   * false => 0\n   * string\n     * 空字符串('') => 0\n     * 非数字字符串 => NaN\n * 引用类型会先调用 ToPrimitive 逻辑将其转换成基本类型，如果返回的基本类型不是数值，再遵循以上规则进行转换\n\n\n显式类型转换#\n\n显式类型转换是指显式的去调用类型转换方法\n\n * 转换成布尔值\n   * Boolean()\n * 转换成数值\n   * Number()\n   * parseInt()\n   * parseFloat()\n * 转换成字符串\n   * String()\n\n注意点\n * Number() 转换的是整个值\n * parseInt() 和 parseFloat() 转换的是部分值，是对字符串逐个进行解析和转换，如果传入的参数不是字符串，会先对其进行字符串的转换\n\n\n隐式类型转换#\n\n隐式类型转换是指在执行过程中，当实际操作的值与 JavaScript 内部期望得到的值不同时，就会对其做隐式类型转换(即不易察觉的类型转换) 在\nJavaScript 中有以下场景会发生隐式类型转换\n\n * 四则运算符 (+ - * /)\n * 相等运算符 (==)\n * 关系运算符 (> < >= <=)\n * 逻辑操作符 (&& ||)\n * 条件判断语句\n   * if()\n   * while()\n   * 三元运算符\n\n四则运算符运算规则\n * -(减) *(乘) /(除) 运算符: 先对操作数做 ToNumber 处理再执行运算\n * +(加) 运算符\n   * 做一元运算时，对操作数做 ToNumber 处理\n   * 做二元运算时\n     * 当其中一个操作数为 string 时，将另一个操作数做 ToString 处理再执行字符串拼接\n     * 当一个操作数为 number 另一个操作数为基本类型时，将基本类型做 ToNumber 处理再执行运算\n     * 当一个操作数为 number 另一个操作数为引用类型时，都会先做 ToString 处理再执行字符串拼接\n\n相等运算符运算规则\n * boolean 与其它类型进行比较时，将 boolean 做 ToNumber 处理\n * string 与 number 进行比较时，将 string 做 ToNumber 处理\n * undefined 与 null 比较时返回 true\n * undefined null 与其它类型的比较时都返回 false\n * 引用类型 与 基本类型 进行比较时，将 引用类型 做 ToPrimitive 处理\n * 引用类型 与 引用类型 比较时，直接判断引用地址是否一致\n\n关系运算符运算规则\n * 将引用类型做 ToPrimitive 处理\n * 如果两个参数都是 string 类型时进行 Unicode 编码 大小比较\n * 否则将两个参数做 ToNumber 处理，再进行数值大小比较\n\n在\n\n逻辑操作符与条件判断语句中都是做 ToBoolean 处理","routePath":"/posts/javascript/conversions","lang":"","toc":[{"text":"抽象操作 (内部的类型转换规则)","id":"抽象操作-内部的类型转换规则","depth":2,"charIndex":146},{"text":"ToPrimitive","id":"toprimitive","depth":3,"charIndex":336},{"text":"ToString","id":"tostring","depth":3,"charIndex":835},{"text":"ToBoolean","id":"toboolean","depth":3,"charIndex":1162},{"text":"ToNumber","id":"tonumber","depth":3,"charIndex":1408},{"text":"显式类型转换","id":"显式类型转换","depth":2,"charIndex":1655},{"text":"隐式类型转换","id":"隐式类型转换","depth":2,"charIndex":1897}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2019-08-16T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","star":true},"version":""},{"id":379,"title":"javascript Dom","content":"","routePath":"/posts/javascript/dom/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript Dom","index":false,"dir":{"order":6}},"version":""},{"id":380,"title":"JavaScript attribute 属性操作","content":"#\n\n","routePath":"/posts/javascript/dom/attribute","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":381,"title":"JavaScript classList 属性","content":"#\n\n","routePath":"/posts/javascript/dom/classList","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":382,"title":"javascript Dom","content":"","routePath":"/posts/javascript/dom/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript Dom","index":false,"dir":{"order":6}},"version":""},{"id":383,"title":"JavaScript 获取 CSS 样式","content":"#\n\n","routePath":"/posts/javascript/dom/样式操作","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":384,"title":"JavaScript 获取节点，操作节点","content":"#\n\n\n获取节点#\n\n父节点.childNodes 获取子节点（包含一切节点）\n\n\n\n\n操作节点#\n\n","routePath":"/posts/javascript/dom/节点操作","lang":"","toc":[{"text":"获取节点","id":"获取节点","depth":2,"charIndex":3},{"text":"操作节点","id":"操作节点","depth":2,"charIndex":43}],"domain":"","frontmatter":{},"version":""},{"id":385,"title":"JavaScript document 获取元素（选择符）","content":"#\n\n\n\n::: tip 注意 querySelector 系列是静态的，在获取元素之后新添加的节点不会加进来 :::","routePath":"/posts/javascript/dom/获取元素","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":386,"title":"JavaScript 表格操作","content":"#\n\n","routePath":"/posts/javascript/dom/表格操作","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":387,"title":"javascript 动画","content":"","routePath":"/posts/javascript/event/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 动画","index":false,"dir":{"order":7}},"version":""},{"id":388,"title":"JavaScript UI 事件","content":"#\n\n属性/方法                        类型             说明\nbubbles                      Boolean        事件是否冒泡\nstopPropagation()            Function       Firefox chrome 取消捕捉/冒泡，bubbles 为 true\ncancelable                   Boolean        IE8 chrome 取消默认行为\npreventDefault()             Function       Firefox chrome 取消默认行为。cancelable 为 true，\ncurrentTarget                Element        全等 === this\ndefaultPrevented             Boolean        是否调用 preventDefalt()\ndetail                       integer        Firefox 滚动滚轮相关信息\neventPhase                   integer        调用事件处理程序阶段：1 表示捕捉阶段 2 表示处于目标 3 表示冒泡阶段\nstopImmediatePropagation()   Function       取消捕捉/冒泡，同时阻止任何事件处理程序被调用\ntarget                       Element        当前触发的元素\ntrusted                      Boolean        为 true 表示事件是浏览器生成的，false 表示 js 生成写的\ntype                         String         被触发事件的类型\nview                         AbstractView   与事件关联的抽象视图。等同于发生事件的 window 对象","routePath":"/posts/javascript/event/UI事件","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":389,"title":"JavaScript event 事件对象","content":"#\n\n早期火狐不兼容 event 需要传参 ev\n\n\n\n * 鼠标按下/单击：mousedown，支持\n   * e.button：0 左键 1 滚轮 2 右键\n * 鼠标位置：鼠标事件支持\n   * e.offsetX/Y：距离当前触发元素的 left/top 值\n   * e.clientX/Y：可视区 left/top 值\n   * e.pageX/Y：页面文档的 top/left 值\n   * e.screenX/Y：屏幕左上角 left/top 值\n * 热键：keydown 支持，按下为 true\n   * e.shiftkey：Boolean\n   * e.altKey：Boolean\n   * e.ctrlKey：Boolean\n   * e.metakey：windows ---> windows 键，macos ---> command 键\n * 键盘按下：keydown/keyup 支持\n   * e.which/e.keycode：返回按下的 ascll 码值，不区分大小写\n   * enter：13\n   * shift：16\n   * ctrl：17\n   * alt：18\n   * a：65\n   * 上下左右：37 38 39 40\n * 键盘按下：keypress 仅支持字符键（DOM3 被弃用）\n   * e.which/e.charCode：返回按下的 ascll 码值，区分大小写\n * 滚动\n   * e.wheelDelta：chrome IE 向下 -120 向上 120\n   * e.datail：firefox 向下 3 向上 -3\n\n兼容:\n\n","routePath":"/posts/javascript/event/event事件对象","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":390,"title":"javascript 动画","content":"","routePath":"/posts/javascript/event/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 动画","index":false,"dir":{"order":7}},"version":""},{"id":391,"title":"JavaScript 鼠标事件、键盘事件、表单事件、window 事件","content":"#\n\n\n鼠标事件#\n\n * click：单击\n * dblclick：双击\n * mouseover：移入（子节点会触发）\n * mouseout：移出（子节点会触发）\n * mousemove：移动（会不停的触发）\n * mouseenter：移入（子节点不会触发）IE8+\n * mouseleave：移出（子节点不会触发）IE8+\n * mousedown：按下（左右键）\n * mouseup：抬起（左右键）\n * contextmenu：右键单击（上下文环境菜单）\n * onmousewheel：chrome ie 滚轮滚动\n   * e.wheelDalta：向下 -120 向上 120\n * DOMMouseScroll：firefox 只能事件绑定 滚轮滚动\n   * e.detail：向下 3 向上 -3\n\n\n键盘事件#\n\n * keydown：键盘按下（按下不动会一直触发）\n * keyup：键盘抬起\n * keypress：键盘按下（只支持字符键）\n\n\nwindow 事件#\n\n * load：当页面加载完成以后会触发\n * unload：当页面解构的时候触发（刷新页面，关闭当前页面）IE 浏览器兼容\n * scroll：页面滚动 不停的触发\n * resize：窗口大小发生变化 不停的触发\n * visibilitychange：标签显示或隐藏时触发\n * blur：获取焦点时触发\n * focus：失去焦点时触发\n\n\n表单事件#\n\n * input：value 值发生改变\n * blur：失去焦点\n * focus：获取焦点\n * select：输入框中文本被选中触发\n * change：当输入框被修改且失去焦点必须添加到 form 表单元素上\n * submit：点击 submit 按钮才触发\n * reset：点击 reset 按钮才触发","routePath":"/posts/javascript/event/事件分类","lang":"","toc":[{"text":"鼠标事件","id":"鼠标事件","depth":2,"charIndex":3},{"text":"键盘事件","id":"键盘事件","depth":2,"charIndex":366},{"text":"window 事件","id":"window-事件","depth":2,"charIndex":441},{"text":"表单事件","id":"表单事件","depth":2,"charIndex":628}],"domain":"","frontmatter":{},"version":""},{"id":392,"title":"JavaScript 事件委托","content":"#\n\n * e.target：chrome\n * e.srcElement：IE8-\n\n兼容：\n\n\n\n利用 e.target.nodeName 或当前节点的 id 来委托事件","routePath":"/posts/javascript/event/事件委托","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":393,"title":"JavaScript IE、chrome 事件监听","content":"#\n\n\n绑定事件#\n\nchrome\n\n\n\n * 事件（不带 on），函数\n * 默认 false 冒泡触发，true 捕捉阶段触发\n\nIE\n\n\n\n * 事件（带 on），函数\n\n\n解绑事件#\n\n\n\n区别：\n\n * 事件：chrome 不带 on IE 带 on\n * 函数执行顺序：chrome 顺序执行 IE 逆序执行\n * 是否支持捕捉触发：chrome 支持 IE 只支持冒泡\n * this 指向：chrome 调用对象 IE window 对象\n\n兼容\n\n","routePath":"/posts/javascript/event/事件监听","lang":"","toc":[{"text":"绑定事件","id":"绑定事件","depth":2,"charIndex":3},{"text":"解绑事件","id":"解绑事件","depth":2,"charIndex":89}],"domain":"","frontmatter":{},"version":""},{"id":394,"title":"JavaScript 阻止冒泡及默认行为","content":"#\n\n\n阻止冒泡#\n\n * e.cancalBubble = true：IE8- chrome\n * e.stopPropagation()：firefox chrome\n\n兼容：\n\n\n\n\n阻止默认行为#\n\n * 普通函数: return false\n * addEventListener：e.preventDefault() // chrome\n * attachEvent：e.returnValue = false // IE\n\n兼容：\n\n\n\n\n阻止 IE 选择事件#\n\n * onmousedown：setCapture() 设置捕获\n * onkeydown：releaseCapture() 释放捕获","routePath":"/posts/javascript/event/阻止冒泡及默认行为","lang":"","toc":[{"text":"阻止冒泡","id":"阻止冒泡","depth":2,"charIndex":3},{"text":"阻止默认行为","id":"阻止默认行为","depth":2,"charIndex":94},{"text":"阻止 IE 选择事件","id":"阻止-ie-选择事件","depth":2,"charIndex":226}],"domain":"","frontmatter":{},"version":""},{"id":395,"title":"javascript EventSource：实时服务器端推送","content":"#\n\n当涉及到向前端应用程序提供实时数据时，Web\n开发人员需要一种可以无缝工作的解决方案。一般情况下，前端应用程序会定期向服务器发送请求以获取更新，但是这会浪费宝贵的带宽资源和服务器资源。在这种情况下，java\nscript EventSource 就成为了一种更为高效的解决方案。\n\n\n背景#\n\n在使用 chatgpt 时。实时的获取到 chatgpt 的回复。但是我发现在输入 prompt 后,只有一个请求。但是他的消息是实时动态显示的，起初以为使用了\nWebSocket，但经过查看源码发现并没有使用 WebSocket。而是使用了 EventSource。\n\n\n什么是 EventSource？#\n\njavascript EventSource 是一个内置在现代浏览器中的 API，它允许服务器向客户端发送实时事件。该 API\n建立一个持久化的连接，通过该连接，服务器可以随时向客户端推送数据。该 API 建立的连接基于 HTTP 协议，而不是\nWebSocket，因此不需要使用其他库或框架，即可在应用程序中使用它。\n\n\nEventSource 的工作原理#\n\nEventSource 基于 HTTP 协议实现，通过与服务器建立一个持续连接，实现了服务器向客户端推送事件数据的功能。在客户端，EventSource\n对象通过一个 URL 发起与服务器的连接。连接成功后，服务器可以向客户端发送事件数据。在客户端，通过 EventSource\n对象注册事件处理函数，以接收来自服务器的事件数据。\n\n以下是 EventSource 的工作原理：\n\n 1. 客户端向服务器发起 HTTP GET 请求，请求一个特定的 URL。\n\n 2. 服务器接收请求，并在 HTTP 头中添加 \"Content-Type: text/event-stream\"。\n\n 3. 服务器建立一个持续的 HTTP 连接，向客户端发送数据，直到连接被关闭。\n\n 4. 当服务器有新的事件数据要发送时，它将这些数据以特定的格式发送给客户端。事件数据格式如下：\n    \n    \n\n其中，event 字段表示事件名，data 字段表示事件数据。\n\n 5. 客户端通过 EventSource 对象注册事件处理函数，以接收来自服务器的事件数据。当客户端接收到来自服务器的事件数据时，它将创建一个 Event\n    对象，并触发相应的事件处理函数，传递 Event 对象作为参数。Event 对象包含以下属性：\n    \n    \n\n 6. 当连接出现错误或被关闭时，客户端将触发 \"error\" 事件或 \"close\" 事件，以便进行错误处理或重新连接。总的来说，EventSource\n    建立了一种持久化的 HTTP 连接，实现了服务器向客户端实时推送事件数据的功能。它非常适合于需要实时更新的应用程序，例如聊天室、股票市场等等。\n\n\n如何使用 javascript EventSource？#\n\n使用 EventSource 非常简单。在前端，我们只需要使用它提供的构造函数，指定从服务器接收事件的 URL 即可：\n\n\n\n在这个例子中，我们将通过一个名为\"my-endpoint”的 URL 从服务器获取事件。服务器应该根据需要设置此 URL 并在客户端上公开它。\n\n一旦建立连接，服务器就可以使用以下语法向客户端发送事件：\n\n\n\n这将向所有当前连接到 EventSource 实例的客户端发送一个名为\"eventName”的事件，并附带一个包含\"eventData”的数据对象。\n\n客户端可以使用以下语法来监听事件：\n\n\n\n这将为名为\"eventName”的事件注册一个侦听器。每当服务器发送此事件时，客户端都会接收到一个带有事件数据的 Event\n对象。在此例中，我们将其打印到控制台中。\n\n此外，EventSource 还提供了其他一些有用的功能，例如错误处理和自定义事件重试。例如，我们可以使用以下语法来处理与 EventSource 相关的错误：\n\n\n\n这将为所有 EventSource 错误注册一个处理程序。每当出现错误时，客户端都会接收到一个带有错误信息的 Event\n对象。在这个例子中，我们将其打印到控制台中。\n\n\n总结#\n\n总体来说，javascript EventSource\n是一种非常有用的技术，可以使前端应用程序获得实时数据而无需频繁地从服务器获取更新。由于其内置于现代浏览器中，因此使用 EventSource\n非常容易，而且不需要使用额外的库或框架。\n\n\nEventSource 与 WebSocket Http 的对比#\n\nEventSource 和 WebSocket 都是用于实现客户端与服务器之间实时双向通信的技术，但它们在很多方面有着不同的特点和适用场景。\n\n 1. 协议 EventSource 基于 HTTP 协议，使用的是 HTTP 的长连接机制，而 WebSocket 则是一种独立的协议，与 HTTP\n    没有关系。\n\n 2. 双向通信 WebSocket 支持双向通信，客户端和服务器都可以主动发送数据。而 EventSource\n    只支持服务器向客户端的单向通信，客户端只能接收数据，不能主动发送数据。\n\n 3. 数据格式 WebSocket 可以发送任意格式的数据，包括文本、二进制等。而 EventSource\n    仅支持纯文本格式，采用了一种特殊的格式来传输事件数据。\n\n 4. 浏览器兼容性 WebSocket 是 HTML5 新增的标准，兼容性相对较差，在一些旧版本的浏览器中不支持。而 EventSource\n    的兼容性相对较好，在大多数现代浏览器中都能够正常工作。\n\n 5. 实时性 WebSocket 的实时性更高，它的通信速度和性能都比 EventSource 更优秀。因为 WebSocket\n    是双向通信，数据传输的效率更高，而 EventSource 由于是单向通信，数据传输的速度会稍慢一些。\n\n 6. 跨域 WebSocket 和 EventSource 都可以跨域使用，但跨域的设置方式有所不同。\n    \n    * WebSocket 需要在服务器端进行配置，允许客户端连接。服务器需要在 HTTP 头中添加\n      \"Access-Control-Allow-Origin\" 字段，允许来自指定域名的客户端连接。\n    \n    * EventSource 跨域时默认使用 CORS 机制。服务器只需在 HTTP 头中添加 \"Access-Control-Allow-Origin\"\n      字段，允许来自指定域名的客户端连接即可。\n\n 7. 浏览器兼容性\n    \n    WebSocket 和 EventSource 在浏览器兼容性方面有所不同。\n    \n    * WebSocket 在一些较老版本的浏览器中不被支持，例如 IE9 及以下版本。但在现代浏览器中，WebSocket 已经得到了广泛的支持。\n    \n    * EventSource 则在较早的浏览器版本中也能够正常工作，包括 IE10 及以上版本、Firefox 6.0 及以上版本、Chrome 13.0\n      及以上版本等等。但在一些较老的浏览器中，如 Safari 5.1.7 及以下版本，EventSource 可能会遇到一些问题。\n\n总的来说，WebSocket 和 EventSource\n在跨域和浏览器兼容性方面都有一些不同。在选择使用哪种技术时，需要根据具体的需求和目标浏览器版本来进行选择\n\n总的来说，WebSocket 和 EventSource 都有着自己的优点和适用场景。WebSocket\n更适合需要双向通信的应用场景，例如实时游戏、在线协作等等。而 EventSource\n则更适合需要单向数据推送的应用场景，例如实时监控、股票行情等等。因此，在选择使用哪种技术时，需要根据具体的需求进行选择。\n\n\n实例#\n\n","routePath":"/posts/javascript/eventSource","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":144},{"text":"什么是 EventSource？","id":"什么是-eventsource","depth":2,"charIndex":286},{"text":"EventSource 的工作原理","id":"eventsource-的工作原理","depth":2,"charIndex":467},{"text":"如何使用 javascript EventSource？","id":"如何使用-javascript-eventsource","depth":2,"charIndex":1212},{"text":"总结","id":"总结","depth":2,"charIndex":1763},{"text":"EventSource 与 WebSocket Http 的对比","id":"eventsource-与-websocket-http-的对比","depth":3,"charIndex":1890},{"text":"实例","id":"实例","depth":2,"charIndex":3318}],"domain":"","frontmatter":{"icon":"javascript","description":"javascript EventSource实时服务器端推送","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>EventSource实时服务器端推送","order":3,"star":3,"date":"2023-03-03T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["javascript","eventsource"],"tag":["javascript","eventsource"],"shortTitle":"javascript EventSource实时服务器端推送","head":[["meta",{"name":"keywords","content":"javascript EventSource实时服务器端推送"}]]},"version":""},{"id":396,"title":"javascript","content":"#","routePath":"/posts/javascript/file/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":397,"title":"javascript文件上传","content":"交互#\n\n\n点击上传多个文件 multiple#\n\n用户可以选择多个文件，然后文件列表会显示出来。需要注意的是，文件的选择是通过标签来实现的，其中multiple属性允许选择多个文件。\n\n点击上传多个文件\n\n\n\n\n点击上传文件夹 odirectory#\n\n允许用户上传整个文件夹，而不仅仅是单个文件。使用标签来启用文件夹上传功能。在处理时，代码会检查文件是否为文件夹，然后递归读取文件夹中的文件列表。\n\nwebkitdirectory、mozdirectory和odirectory是用于HTML文件输入元素的属性，用于启用文件夹上传功能。它们是浏览器厂商引入的一\n些非标准属性，因此在不同浏览器中的支持程度可能会有所不同。#\n\nwebkitdirectory：#\n\n支持浏览器： WebKit内核的浏览器，如Google Chrome和Safari。作用：\n当设置webkitdirectory属性时，文件输入框会打开一个文件选择对话框，允许用户选择文件夹而不仅仅是单个文件。这允许用户选择整个文件夹中的所有文件，而不\n必一个一个地选择。\n\n * 兼容性\n\nmozdirectory：#\n\n支持浏览器： Mozilla Firefox浏览器。作用：\n类似于webkitdirectory，mozdirectory属性用于启用文件夹上传功能。它允许用户在Firefox浏览器中选择整个文件夹进行上传。\n\n * 兼容性\n\nodirectory：#\n\n支持浏览器： 这是Opera浏览器引入的一个属性。作用： 类似于前两者，odirectory属性用于启用文件夹上传功能。用户可以在 Opera\n浏览器中选择整个文件夹。需要注意的是，由于这些属性不是 HTML\n标准的一部分，因此在不同浏览器中的支持可能不稳定。它们主要用于特定浏览器内核的实现，因此在跨浏览器应用程序中使用时，需要小心检查并处理不同浏览器的兼容性。在现代\nWeb 开发中，通常使用其他更标准的方法，如使用JavaScript来处理文件上传和文件夹选择，以确保跨浏览器兼容性。\n\n * 兼容性\n * ::: react-demo 点击上传文件夹\n\n\n\n\n拖拽上传文件和文件夹dataTransfer#\n\n::: react-demo 拖拽上传文件和文件夹\n\n用户可以将文件或文件夹拖拽到指定区域进行上传。代码使用onDragOver和onDrop事件来处理拖拽操作，并通过e.dataTransfer.items来获取\n拖拽的文件和文件夹列表。\n\n\n\n\n如何实现多文件上传#\n\n 1. 把选择的文件放到一个数组里 files 一次性发送到服务器，服务器接收到后，再一次性处理\n 2. 把选择的文件形成不同的请求，每个请求只处理一个文件一般会选择第二种，第一种方式，如果文件很多，其中一个文件上传失败，需要重新上传所有文件，很难保证对每一\n    个文件的独立控制。第二种方式，需要控制并发数，如果并发数太大，可能会导致服务器崩溃，可以对于每个文件进行单独的控制，比如上传进度，上传取消等。\n\n\n上传进度progress#\n\n使用XMLHttpRequest对象来发送文件，并通过xhr.upload.onprogress事件来监听上传进度。上传进度以百分比形式显示给用户。 :::\nreact-demo 上传进度\n\n\n\n\n如何实现上传进度追踪#\n\n::: react-demo\n上传进度追踪用户可以点击Cancel按钮来中止上传操作，这对于用户体验和控制非常有用。代码使用xhr.abort()方法来中止上传操作。\n\n","routePath":"/posts/javascript/file/文件上传","lang":"","toc":[{"text":"交互","id":"交互","depth":2,"charIndex":-1},{"text":"点击上传多个文件 `multiple`","id":"点击上传多个文件-multiple","depth":3,"charIndex":-1},{"text":"点击上传文件夹 `odirectory`","id":"点击上传文件夹-odirectory","depth":3,"charIndex":-1},{"text":"`webkitdirectory`、`mozdirectory`和`odirectory`是用于`HTML`文件输入元素`<input type=\"file\">`的属性，用于启用文件夹上传功能。它们是浏览器厂商引入的一些非标准属性，因此在不同浏览器中的支持程度可能会有所不同。","id":"webkitdirectorymozdirectory和odirectory是用于html文件输入元素input-typefile的属性用于启用文件夹上传功能它们是浏览器厂商引入的一些非标准属性因此在不同浏览器中的支持程度可能会有所不同","depth":4,"charIndex":-1},{"text":"拖拽上传文件和文件夹`dataTransfer`","id":"拖拽上传文件和文件夹datatransfer","depth":3,"charIndex":-1},{"text":"如何实现多文件上传","id":"如何实现多文件上传","depth":3,"charIndex":1057},{"text":"上传进度`progress`","id":"上传进度progress","depth":2,"charIndex":-1},{"text":"如何实现上传进度追踪","id":"如何实现上传进度追踪","depth":3,"charIndex":1391}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2024-09-03T00:00:00.000Z","author":"h7ml","title":"javascript文件上传","description":"javascript文件上传","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>javascript文件上传","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"javascript文件上传","category":["javascript"],"tag":["javascript"],"head":[["meta",{"name":"keywords","content":"javascript文件上传"}]]},"version":""},{"id":398,"title":"javascript","content":"#","routePath":"/posts/javascript/form/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":399,"title":"JavaScript 表单属性、方法","content":"#\n\n\n对象属性，方法#\n\n * acceptCharset：服务器能够处理的字符集，等价于 HTML 中的 accept-charset\n * action：接受请求的 URL，等价于 HTML 中的 action 特性\n * elements：表单中所有控件（HTMLCollection）\n * enctype：请求编码类型\n * length：表单中控件的数量\n * method：要发送的 HTTP 请求类型，通常是 get、post\n * name：表单名称\n * target：用于发送请求和接收响应的窗口名称\n * reset()：讲所有表单域重置为默认值\n * submit()：提交表单\n\n\n\n\n\n\n获取元素#\n\n\n\n\n事件#\n\n事件也对应的有方法，form.submit() 为提交\n\n * 表单事件\n   * input：value 值发生改变\n   * onpropertychange: IE value 值改变时\n   * blur：失去焦点\n   * focus：获取焦点\n   * select：输入框中文本被选中触发\n   * change：当输入框被修改 且 失去焦点\n\n必须添加到 form 表单元素上\n\n * submit：点击 submit 按钮才触发\n * reset：点击 reset 按钮才触发\n\n\n字段属性#\n\n共有字段属性\n\n * disabled：布尔值，表示当前字段是否被禁用\n * form：指向当前字段所在的表单，只读\n * name：当前字段名称\n * readOnly：布尔值，表示当前字段是否只读\n * tabIndex：表示当前字段 tab 序号\n * type：当前字段类型\n * value：当前字段将被提交给服务器的值","routePath":"/posts/javascript/form/属性方法事件","lang":"","toc":[{"text":"对象属性，方法","id":"对象属性方法","depth":2,"charIndex":3},{"text":"获取元素","id":"获取元素","depth":2,"charIndex":309},{"text":"事件","id":"事件","depth":2,"charIndex":319},{"text":"字段属性","id":"字段属性","depth":2,"charIndex":574}],"domain":"","frontmatter":{},"version":""},{"id":400,"title":"JavaScript 文本选中检测","content":"#\n\n\n选中文本#\n\n\n\n\n输入检测#\n\n检测浏览器是否支持 pattern 属性\n\n\n\n * customError：如果设置了 setCustomValidity()，则为 true，否则返回 false\n * patternMismatch：如果值与指定的 pattern 属性不匹配，返回 true\n * reangeOverflow：如果值比 max 值大，返回 true\n * rangeUnderflow：如果值比 min 值小，返回 true\n * stepMisMatch：如果 min 和 max 直接的步长值不合理，返回 true\n * tooLong：值的长度超过了 maxlenght 属性指定的长度，返回 true。火狐会自动约束字符数量，所以会永远返回 true\n * typeMismatch：如果值不是 'mail' 或 'url' 要求的格式，返回 true\n * valid：如果这里的属性都是 false，返回 true。checkValidity() 也要求相同的值\n * valueMissing：如果标注为 required 的字段中没有值，返回 true\n\n\n选择框脚本#\n\n * add（new option, relOption）：向控件中插入行的\n * multiple：布尔值，是否允许多选\n * options：控件中所有 元素的 HTMLCollection\n * remove(index)：移除给定位置的选项\n * selectedIndex：选中的索引，从 0 开始，没有则是 -1\n * size：选择框可见的行数\n\n每个 都有一个 HTMLOptionElement 对象\n\n * index：当前选项在 option 集合中的索引\n * label：当前选择的标签；等价于 html 中 label 的特性\n * selected：布尔值，表示当前选项是否被选中，设为 true 可以选中当前选项\n * text：选项的文本\n * value：选项的值","routePath":"/posts/javascript/form/文本选中检测","lang":"","toc":[{"text":"选中文本","id":"选中文本","depth":2,"charIndex":3},{"text":"输入检测","id":"输入检测","depth":2,"charIndex":13},{"text":"选择框脚本","id":"选择框脚本","depth":2,"charIndex":503}],"domain":"","frontmatter":{},"version":""},{"id":401,"title":"javascript","content":" * JavaScript 基本概念\n * JavaScript 数据类型\n * JavaScript 面向对象\n * JavaScript BOM\n * JavaScript DOM\n * JavaScript 事件\n * JavaScript 动画\n * JavaScript 高级程序设计读书笔记\n * JavaScript 原型与继承\n * JavaScript 数据类型\n * JavaScript 类型转换","routePath":"/posts/javascript/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript","index":false,"dir":{"order":1}},"version":""},{"id":402,"title":"JavaScript 原型与继承","content":"简单讲讲 js 的继承，也是 js 的原型链问题的实际应用。\n\n\n原型#\n\n原型和原型链都是来源于对象而服务于对象的概念：\n\nJavaScript 中一切引用类型都是对象，对象就是属性的集合。\n\nArray 类型、Function 类型、Object 类型、Date 类型、RegExp 类型等都是引用类型。\n\n\n原型与原型链#\n\n每一个对象从被创建开始就和另一个对象关联，从另一个对象上继承其属性，这个另一个对象就是原型。\n\n当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型的原型上找，如此继续，直到找到为止。如果在最顶层的原型对象也没\n有找到，就返回undefined。这条由对象及其原型组成的链就叫做原型链。\n\n\n原型的意义#\n\n * 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。就是一个对象可以访问其他对象的属性。\n * 继承存在的意义就是属性共享：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性。\n\n\n访问原型链#\n\n__proto__属性虽然在 ECMAScript 6 语言规范中标准化，但是不推荐被使用，现在更推荐使用 Object.getPrototypeOf，\n\n\n\n * 模拟原型链的查找\n\n\n\n\n原型链示意图#\n\n\n\n从上图我们可以看出\n\n * 引用类型都是对象，每个对象都有原型对象。\n * 对象都是由构造函数创建，对象的__proto__属性指向其原型对象，构造函数的prototype属性指向其创建的对象实例的原型对象，所以对象的__prot\n   o__属性等于创建它的构造函数的prototype属性。\n * 所有通过字面量表示法创建的普通对象的构造函数为 Object\n * 所有原型对象都是普通对象，构造函数为 Object\n * 所有函数的构造函数是 Function\n * Object.prototype 没有原型对象\n\n\n简单总结#\n\n原型链就是多个对象通过 __proto__ 的方式连接了起来的一个链表结构。\n\n * Object 是所有对象的父节点，所有对象都可以通过 __proto__ 找到它\n * Function 是所有函数的父节点，所有函数都可以通过 __proto__ 找到它\n * 函数的 prototype 是一个对象\n * 对象的 __proto__ 属性指向原型, __proto__ 将对象和原型连接起来组成了原型链\n\n\n创建对象#\n\n在理解对象继承之前得先弄明白创建对象这回事儿。\n\n\n工厂模式#\n\n\n\n工厂模式很好理解，实例化一个对象，在把传入的参数放入该对象，再返回。\n\n\n\n缺点：无法进行对象识别。由于返回的对象都是由 Object\n对象实例化出来的，但是开发过程中，需要创建很多种对象，肯定会有进行对象识别的需求，工厂模式显然无法完成我们这样的诉求。我们继续探索。\n\n\n构造函数模式#\n\n\n\n\n\n从打印中可以看到 car1 与 car 的区别。\n\n构造函数模式能够很好的使用 instanceof 进行对象的识别，Object\n对象是所有对象的顶层对象类，所有的对象都会继承他。对对象进行操作的各类方法就存放在 Object 对象里面。function实际上也是一个对象，从typeof\n方法中可以体现出来\n\n缺点：但是无法解决引用类型的创建问题，我们每次对 Car 对象进行实例化的时候，都需要对 printBrand\n方法进行创建，无法复用，浪费内存。要解决只能把他放到全局作用域。但是在全局作用域中定义的函数一般来说只能被某个对象调用，这会让全局作用域名不副实。并且也会失去封\n装性，我们来想象一下，如果该对象中有很多方法，那会让全局作用域充满了单独拎出来的方法，让代码可读性变差。\n\n\ninstanceof 原理#\n\ninstanceof 主要用来判断对象是否属于某构造函数\n\n * 利用原型链，不停向上查找\n * 利用 __proto__ 访问实例原型\n\n\n\n\n原型模式#\n\n\n\n这个模式利用了对象的原型,将基本参数挂载在原型上面。\n\n缺点：省去了初始化参数，这一点有好有坏。最大的问题是对引用类型值的共享，car1 和 car2 实例在实例化以后还会与 Car\n类存在关系。如果对其赋值基本类型值的话，会在实例化的对象当中创建，并且调用时会首先在实例化对象中寻找。而对引用类型值进行操作的时候，会直接在原型对象的引用类型值\n上进行操作，所以会在所有实例中共享。\n\n\n组合构造函数#\n\n\n\n利用原型自定义构造函数，每个实例都会存在一份实例的副本，同时利用原型方法共享的特性，最大程度节省了内存，也提供了向构造函数中传递参数的功能。为最佳实践。\n\n\n创建对象总结#\n\n * 我们在使用工厂模式的时候，发现了对象识别的问题，于是使用构造函数模式去解决这个问题。\n * 在使用构造函数时，发现了引用类型值创建的问题，无法对其复用。于是使用了原型模式。\n * 在原型模式中，引用类型值共享的问题又出现了。于是组合构造函数模式\n * 组合构造函数模式中，结合构造函数模式和对引用类型操作的良好处理和原型模式对方法的共享，达到了最佳方案。\n\n\n继承#\n\n\n原型链继承#\n\n\n\n原型链继承通俗易懂，利用原型链将两个类串起来。\n\n缺点\n\n * 要新增原型中属性或方法，必须要先 new 一个实例, 函数无法复用，造成内存的浪费。\n * 无法多继承\n * 创建子类实例时，无法向父类构造函数传参\n\n\n借用构造函数#\n\n\n\n基本思路就是在子类的构造函数的内部调用超类的构造函数。因为函数只是在特定的环境中执行代码的对象。借用构造函数的方式可以解决引用类型的问题。使用 call()和\napply()方法，在子类中调用超类。这样每个实例都会有自己的引用类型的副本了。\n\n缺点：和构造函数创建对象一致的问题，方法都得在构造函数中定义，导致函数无法复用，造成内存的浪费。\n\n\n组合继承#\n\n\n\n组合继承集借用构造函数方法和原型链继承两者之长，复用了方法，也解决了引用类型的问题。\n\n缺点：需要调用两次超类的构造函数，第一次是OldCar.call(this,name),第二次是new\nOldCar()。下一步我们需要解决的是超类的两次调用问题。\n\n\n\n上面的例子中，上半部分是最基本的对原型的赋值，而下班部分的对原型的赋值 A 的原型的构造函数会变成 Object（先 new Object\n然后再赋值参数），所以需要显式的去增强构造函数。\n\n\n寄生组合继承#\n\n为了解决组合继承的痛点，出现了寄生组合继承。\n\n\n\n\n\n那么，我们来看看继承的过程中发生了什么。先对超类的原型进行一次浅复制。然后将中间对象的构造函数替换为普通类。为什么要进行这一步？因为对超类的原型进行浅复制以后，\n中间对象的构造函数变成了 Object，需要对该对象进行增强处理。最后将普通类的原型指向中间变量，这样就只需要调用一次超类就可以完成继承。\n\n\n继承的总结#\n\n * 在原型链继承中，我们又遇到了老对手引用类型值的共享问题。\n * 在借用构造函数进行继承中，方法共享问题，这个老对手又出现了。\n * 按照创建对象的经验，组合两者优点的组合继承将成为最佳方式，但是我们却发现了超类会被调用两次的问题。\n * 为了解决超类被调用两次的问题，寄生组合继承成为了最佳方案。","routePath":"/posts/javascript/inheritance","lang":"","toc":[{"text":"原型","id":"原型","depth":2,"charIndex":32},{"text":"原型与原型链","id":"原型与原型链","depth":2,"charIndex":156},{"text":"原型的意义","id":"原型的意义","depth":3,"charIndex":334},{"text":"访问原型链","id":"访问原型链","depth":3,"charIndex":472},{"text":"原型链示意图","id":"原型链示意图","depth":3,"charIndex":576},{"text":"简单总结","id":"简单总结","depth":3,"charIndex":850},{"text":"创建对象","id":"创建对象","depth":2,"charIndex":1064},{"text":"工厂模式","id":"工厂模式","depth":3,"charIndex":1097},{"text":"构造函数模式","id":"构造函数模式","depth":3,"charIndex":1243},{"text":"instanceof 原理","id":"instanceof-原理","depth":3,"charIndex":1605},{"text":"原型模式","id":"原型模式","depth":3,"charIndex":1694},{"text":"组合构造函数","id":"组合构造函数","depth":3,"charIndex":1897},{"text":"创建对象总结","id":"创建对象总结","depth":3,"charIndex":1987},{"text":"继承","id":"继承","depth":2,"charIndex":2179},{"text":"原型链继承","id":"原型链继承","depth":3,"charIndex":2185},{"text":"借用构造函数","id":"借用构造函数","depth":3,"charIndex":2304},{"text":"组合继承","id":"组合继承","depth":3,"charIndex":2488},{"text":"寄生组合继承","id":"寄生组合继承","depth":3,"charIndex":2724},{"text":"继承的总结","id":"继承的总结","depth":3,"charIndex":2914}],"domain":"","frontmatter":{"icon":"javascript","order":3,"date":"2019-09-16T00:00:00.000Z","author":"h7ml","title":"JavaScript 原型与继承","category":"javascript","tag":"javascript","star":true},"version":""},{"id":403,"title":"JavaScript audio 音频 API","content":"#\n\n\n标签相关属性#\n\n * src：要播放的音频/视频的 URL\n * controls：显示音频/视频播放控件\n * loop：音频/视频结束后重新播放\n * muted：音频/视频静音\n\n\n只读属性#\n\n * duration：文件的播放时长，单位 s，无法获取则 NaN，当触发 canplay 事件后可以获取\n * paused：是否暂停，返回 true/false\n * ended：是否播放完毕 true/false\n * error：发现错误后返回错误代码\n * currentSrc：返回字符串形式正在播放或已加载文件，对应浏览器 source 元素中选择的文件\n * buffered：获取当前缓冲区大小，返回 TimeRanges 对象\n\n\n可控制属性#\n\n * src：指定音频文件位置\n * autoplay：是否自动播放\n * preload：是否预加载\n * loop：是否循环播放\n * controls：显示/隐藏用户控制界面\n * muted：设置是否静音\n * volume：当前音量值，0-1 之间\n * currentTime：返回/设置当前播放的时间，单位 s\n\n\n方法#\n\n * load()：加载视频、音频软件\n * play()：播放\n * pause()：暂停\n * canPlayType(obj)：测试播放后指定的 Mime 类型文件\n\n\n事件#\n\n * loadstart：客户端开始请求数据\n * progress：正在播放的时候不停触发，暂停不会触发，触发事件间隔较大\n * play：play() 和 autoplay 时触发，类似 onplaying\n * pause：pause() 方法时触发\n * ended：结束播放时触发\n * timeupdate：播放时间发生改变时触发，暂停不触发，触发事件间隔较小\n * canplaythrough：歌曲载入完成\n * canplay：缓存至可播放状态，类似事件 onloadedmetadata\n * onloadedmetadata：当元数据（如分辨率和时长）被加载时触发","routePath":"/posts/javascript/media/audio","lang":"","toc":[{"text":"标签相关属性","id":"标签相关属性","depth":2,"charIndex":3},{"text":"只读属性","id":"只读属性","depth":2,"charIndex":98},{"text":"可控制属性","id":"可控制属性","depth":2,"charIndex":332},{"text":"方法","id":"方法","depth":2,"charIndex":505},{"text":"事件","id":"事件","depth":2,"charIndex":598}],"domain":"","frontmatter":{},"version":""},{"id":404,"title":"javascript","content":"#","routePath":"/posts/javascript/media/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":405,"title":"JavaScript video 视频 API","content":"#\n\n\n标签属性#\n\n * src：要播放的音频/视频的 URL。\n * controls：显示音频/视频播放控件\n * loop：音频/视频结束后重新播放\n * muted：音频/视频静音\n * width：播放区宽度\n * height：播放区高度\n * poster：预览图片\n\n\n属性#\n\n * audioTracks：返回可用音频轨道的 Audio TrackList 对象\n * autoplay：设置/返回是否在加载完成后播放视频/音频\n * buffered：返回音频/视频已缓存部分的 timeRanges 对象\n * controller：返回音频/视频当前媒体控制器的 MediaController 对象\n * controls：设置/返回音频/视频是否显示控件\n * crossOrigin：设置/返回音频/视频的 CORS 设置\n * curretSrc：返回当前音频/视频的 URL\n * currentTime：设置/返回音频/视频中当前播放位置（以秒）\n * defaultMuted：设置/返回音频/视频默认是否静音\n * defaultPlaybackRate：设置/返回音频/视频的默认播放速度\n * duration：返回当前音频/视频的长度 s\n * ended：返回音频/视频是否播放结束\n * error：返回音频/视频发生错误状态的 MediaError 对象\n * loop：设置/返回是否应在结束时重新播放\n * mediaGroup：设置/返回音频/视频所属的组合\n * muted：设置/返回是否静音\n * networkState：返回当前音频/视频网络状态\n * paused：设置/返回是否暂停\n * playbackRate：设置/返回音频/视频播放速度\n * palyed：返回音频/视频已播放部分 TimeRanges 对象\n * repload：设置/返回是否在页面加载后加载\n * readyState：返回音频/视频当前的就绪状态\n * seekable：返回音频/视频可寻址部分的 TimeRanges 对象\n * seeking：返回用户是否在音频/视频中进行查找\n * src：设置/返回当前来源\n * startDate：返回当前时间偏移的 date 对象\n * textTracks：返回可用文本轨道的 TextTrackList 对象\n * videoTracks:返回可用视频轨道的 VideoTrackList 对象\n * volume:设置/返回音量\n\n\n方法#\n\n * addTextTrack()：向音频/视频添加新的文本轨道\n * canPlayType()：检测浏览器是够能播放指定的音频/视频类型\n * load()：重新加载音频/视频\n * play()：开始播放音频/视频\n * pause()：暂停音频/视频\n\n\n事件#\n\n * abort：当音频/视频的加载已放弃时触发\n * canplay：当浏览器可以开始播放音频/视频时触发\n * canplaythrough：当浏览器在不因缓冲而停顿的视口下进行播放时触发\n * durationchange：音频/视频的时长发生改变时触发\n * emptied：目前播放列表为空时触发\n * ended：播放列表结束时触发\n * error：音频/视频加载期间发生错误时触发\n * loadeddata：当音频/视频已加载当前帧时触发\n * loadedmetadata：当浏览器已加载音频/视频的元数据时触发\n * loadstart：当浏览器开始查找音频/视频时触发\n * pause：音频/视频暂停时触发\n * play：音频/视频一开始或不在暂停时触发\n * playing：音频/视频因缓冲而暂停或停止后已就绪时触发\n * progress：当浏览器正在下载音频/视频时触发\n * ratechange：音频/视频的播放速度已更改时触发\n * seeked：用户开始移动/跳跃到音频/视频新的位置时触发\n * seeking：开始移动到/跳跃到音频/视频新的位置时触发\n * stalled：当浏览器尝试获取媒体数据，但数据不可用时触发\n * suspend：浏览器刻意不获取媒体数据时触发\n * timeupdate：当目前播放位置已更改时触发\n * volumechange：当音量已更改时触发\n * waiting：当视频由于需要缓冲下一帧而停止时触发","routePath":"/posts/javascript/media/video","lang":"","toc":[{"text":"标签属性","id":"标签属性","depth":2,"charIndex":3},{"text":"属性","id":"属性","depth":2,"charIndex":143},{"text":"方法","id":"方法","depth":2,"charIndex":1074},{"text":"事件","id":"事件","depth":2,"charIndex":1211}],"domain":"","frontmatter":{},"version":""},{"id":406,"title":"javascript 面向对象","content":"","routePath":"/posts/javascript/object-oriented/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 面向对象","index":false,"dir":{"order":4}},"version":""},{"id":407,"title":"javascript 面向对象","content":"","routePath":"/posts/javascript/object-oriented/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 面向对象","index":false,"dir":{"order":4}},"version":""},{"id":408,"title":"JavaScript 高级程序设计读书笔记","content":"This page requires a JavaScript-enabled browser.","routePath":"/posts/javascript/professional-js","lang":"","toc":[{"text":"2. HTML 中的 JavaScript","id":"2-html-中的-javascript","depth":2,"charIndex":-1},{"text":"2.1 元素","id":"21-元素","depth":3,"charIndex":-1},{"text":"2.1.1 标签的放置","id":"211-标签的放置","depth":4,"charIndex":-1},{"text":"2.1.2 推迟的脚本","id":"212-推迟的脚本","depth":4,"charIndex":-1},{"text":"2.1.3 异步脚本","id":"213-异步脚本","depth":4,"charIndex":-1},{"text":"2.1.4 动态脚本加载","id":"214-动态脚本加载","depth":4,"charIndex":-1},{"text":"2.1.5XHTML 中的改变","id":"215xhtml-中的改变","depth":4,"charIndex":-1},{"text":"2.2 内联代码与外部文件","id":"22-内联代码与外部文件","depth":3,"charIndex":-1},{"text":"2.3 文档模式","id":"23-文档模式","depth":3,"charIndex":-1},{"text":"2.4THE <NOSCRIPT> ELEMENT","id":"24the-noscript-element","depth":3,"charIndex":-1},{"text":"3.语言基础","id":"3语言基础","depth":2,"charIndex":-1},{"text":"3.1 语法","id":"31-语法","depth":3,"charIndex":-1},{"text":"3.1.1 大小写敏感(Case-Sensitivity)","id":"311-大小写敏感case-sensitivity","depth":4,"charIndex":-1},{"text":"3.1.2 Identifiers","id":"312-identifiers","depth":4,"charIndex":-1},{"text":"3.1.3 注释","id":"313-注释","depth":4,"charIndex":-1},{"text":"3.1.4 严格模式(Strict Mode)","id":"314-严格模式strict-mode","depth":4,"charIndex":-1},{"text":"3.1.5 陈述(Statements)","id":"315-陈述statements","depth":4,"charIndex":-1},{"text":"3.2 关键字与保留字(Keywords and Reserved Words)","id":"32-关键字与保留字keywords-and-reserved-words","depth":3,"charIndex":-1},{"text":"3.3 变量","id":"33-变量","depth":3,"charIndex":-1},{"text":"3.3.1 var 关键词","id":"331-var-关键词","depth":4,"charIndex":-1},{"text":"3.3.2 let 定义","id":"332-let-定义","depth":4,"charIndex":-1},{"text":"3.3.2 const 定义","id":"332-const-定义","depth":4,"charIndex":-1},{"text":"3.3.3 声明风格","id":"333-声明风格","depth":4,"charIndex":-1},{"text":"3.4 数据类型","id":"34-数据类型","depth":3,"charIndex":-1},{"text":"3.4.1 Undefined 类型","id":"341-undefined-类型","depth":4,"charIndex":-1},{"text":"3.4.2 Null 类型","id":"342-null-类型","depth":4,"charIndex":-1},{"text":"3.4.3 Boolean 类型","id":"343-boolean-类型","depth":4,"charIndex":-1},{"text":"3.4.4 Number 类型","id":"344-number-类型","depth":4,"charIndex":-1},{"text":"3.4.5 String 类型","id":"345-string-类型","depth":4,"charIndex":-1},{"text":"3.4.6 Symbol 类型","id":"346-symbol-类型","depth":4,"charIndex":-1},{"text":"3.4.7 Object 类型","id":"347-object-类型","depth":4,"charIndex":-1},{"text":"3.5 操作符","id":"35-操作符","depth":3,"charIndex":-1},{"text":"3.5.1 一元操作符（跳过）","id":"351-一元操作符跳过","depth":4,"charIndex":-1},{"text":"3.5.2 位操作符","id":"352-位操作符","depth":4,"charIndex":-1},{"text":"3.5.3 布尔操作符","id":"353-布尔操作符","depth":4,"charIndex":-1},{"text":"3.5.6 Multiolicative Operators","id":"356-multiolicative-operators","depth":4,"charIndex":-1},{"text":"3.5.7 指数操作符","id":"357-指数操作符","depth":4,"charIndex":-1},{"text":"3.5.8 加法类运算符","id":"358-加法类运算符","depth":4,"charIndex":-1},{"text":"3.5.9 关系操作符(Relational Operators)","id":"359-关系操作符relational-operators","depth":4,"charIndex":-1},{"text":"3.5.10 相等操作符","id":"3510-相等操作符","depth":4,"charIndex":-1},{"text":"3.5.11 条件操作符","id":"3511-条件操作符","depth":4,"charIndex":-1},{"text":"3.5.12 赋值操作符(Assignment Operators)","id":"3512-赋值操作符assignment-operators","depth":4,"charIndex":-1},{"text":"3.5.13 注释(Comma Operator)","id":"3513-注释comma-operator","depth":4,"charIndex":-1},{"text":"3.6 陈述(Statement)","id":"36-陈述statement","depth":3,"charIndex":-1},{"text":"3.7 函数","id":"37-函数","depth":3,"charIndex":-1},{"text":"4. 变量、域与内存","id":"4-变量域与内存","depth":2,"charIndex":-1},{"text":"4.1 原始值与引用值(PRIMITIVE AND REFERENCE VALUES)","id":"41-原始值与引用值primitive-and-reference-values","depth":3,"charIndex":-1},{"text":"4.1.1 动态属性(Dynamic Properties)","id":"411-动态属性dynamic-properties","depth":4,"charIndex":-1},{"text":"4.1.2 拷贝值(Copying Values)","id":"412-拷贝值copying-values","depth":4,"charIndex":-1},{"text":"4.1.5 参数传递(Argument Passing)","id":"415-参数传递argument-passing","depth":4,"charIndex":-1},{"text":"4.1.6 确定类型","id":"416-确定类型","depth":4,"charIndex":-1},{"text":"4.2 执行上下文与值域(跳过)","id":"42-执行上下文与值域跳过","depth":3,"charIndex":-1},{"text":"4.3 垃圾回收(GARBAGE COLLECTION)","id":"43-垃圾回收garbage-collection","depth":3,"charIndex":-1},{"text":"4.3.1 标记-清除算法 Mark-and-Sweep 机制","id":"431-标记-清除算法-mark-and-sweep-机制","depth":4,"charIndex":-1},{"text":"4.3.2 引用计数算法 (Reference Counting)","id":"432-引用计数算法-reference-counting","depth":4,"charIndex":-1},{"text":"5 基本引用类型(Basic Reference Types)(快速过)","id":"5-基本引用类型basic-reference-types快速过","depth":2,"charIndex":-1},{"text":"5.1 Date 类型","id":"51-date-类型","depth":3,"charIndex":-1},{"text":"5.1.1 继承工具","id":"511-继承工具","depth":4,"charIndex":-1},{"text":"5.1.2 时间格式工具","id":"512-时间格式工具","depth":4,"charIndex":-1},{"text":"5.2 Regexp 类型","id":"52-regexp-类型","depth":3,"charIndex":-1},{"text":"6 引用类型 (Collection Reference Types)","id":"6-引用类型-collection-reference-types","depth":2,"charIndex":-1},{"text":"6.1 Object 类型","id":"61-object-类型","depth":3,"charIndex":-1},{"text":"6.2 Array 类型","id":"62-array-类型","depth":3,"charIndex":-1},{"text":"6.2.1 创建 Array","id":"621-创建-array","depth":4,"charIndex":-1},{"text":"6.2.2 Array Holes","id":"622-array-holes","depth":4,"charIndex":-1},{"text":"6.2.3 Indexing into Arrays","id":"623-indexing-into-arrays","depth":4,"charIndex":-1},{"text":"6.2.4 Detecting Arrays","id":"624-detecting-arrays","depth":4,"charIndex":-1},{"text":"6.2.5 迭代工具(Iterator Methods)","id":"625-迭代工具iterator-methods","depth":4,"charIndex":-1},{"text":"6.2.6 复制与填充(Copy and Fill Method)","id":"626-复制与填充copy-and-fill-method","depth":4,"charIndex":-1},{"text":"6.2.7 转换工具","id":"627-转换工具","depth":4,"charIndex":-1},{"text":"6.2.8 栈工具","id":"628-栈工具","depth":4,"charIndex":-1},{"text":"6.2.9 队列工具","id":"629-队列工具","depth":4,"charIndex":-1},{"text":"6.2.10 Recordering Methods","id":"6210-recordering-methods","depth":4,"charIndex":-1},{"text":"6.2.11 操作工具(Manipulation Methods)","id":"6211-操作工具manipulation-methods","depth":4,"charIndex":-1},{"text":"6.2.12 查找定位工具(Search and Location Methods)","id":"6212-查找定位工具search-and-location-methods","depth":4,"charIndex":-1},{"text":"6.2.13 Iterative Methods","id":"6213-iterative-methods","depth":4,"charIndex":-1},{"text":"6.3 类型化数组(TYPED ARRAYS)","id":"63-类型化数组typed-arrays","depth":3,"charIndex":-1},{"text":"6.3.1 使用 ArrayBuffers","id":"631-使用-arraybuffers","depth":4,"charIndex":-1},{"text":"6.3.2 数据视图(DataViews)","id":"632-数据视图dataviews","depth":4,"charIndex":-1},{"text":"6.3.3 类型化数组(Typed Arrays)","id":"633-类型化数组typed-arrays","depth":4,"charIndex":-1},{"text":"6.4 Map 类型","id":"64-map-类型","depth":3,"charIndex":-1},{"text":"6.4.1 基本借口","id":"641-基本借口","depth":4,"charIndex":-1},{"text":"6.4.2 顺序与迭代","id":"642-顺序与迭代","depth":4,"charIndex":-1},{"text":"6.4.3 Obiects 与 Maps 之间选择","id":"643-obiects-与-maps-之间选择","depth":4,"charIndex":-1},{"text":"6.5 WeakMap 类型","id":"65-weakmap-类型","depth":3,"charIndex":-1},{"text":"6.5.1 基本接口","id":"651-基本接口","depth":4,"charIndex":-1},{"text":"6.5.2 Weak 键值","id":"652-weak-键值","depth":4,"charIndex":-1},{"text":"6.5.3 不可迭代键值","id":"653-不可迭代键值","depth":4,"charIndex":-1},{"text":"6.6 Set 类型","id":"66-set-类型","depth":3,"charIndex":-1},{"text":"6.6.1 基本接口","id":"661-基本接口","depth":4,"charIndex":-1},{"text":"6.7 WeakSet 类型","id":"67-weakset-类型","depth":3,"charIndex":-1},{"text":"8 Objects, Classes, and Object-Oriented Programming","id":"8-objects-classes-and-object-oriented-programming","depth":2,"charIndex":-1},{"text":"8.1 理解 Objects","id":"81-理解-objects","depth":3,"charIndex":-1},{"text":"8.1.1 属性的类型(Types of Properties)","id":"811-属性的类型types-of-properties","depth":4,"charIndex":-1},{"text":"8.1.2 定义多个属性","id":"812-定义多个属性","depth":4,"charIndex":-1},{"text":"8.1.3 阅读属性值(Reading Property Attributes)","id":"813-阅读属性值reading-property-attributes","depth":4,"charIndex":-1},{"text":"8.1.4 合并 Objects","id":"814-合并-objects","depth":4,"charIndex":-1},{"text":"8.1.5 Object Identity and Equality","id":"815-object-identity-and-equality","depth":4,"charIndex":-1},{"text":"8.1.6 Enhanced Object Syntax","id":"816-enhanced-object-syntax","depth":4,"charIndex":-1},{"text":"8.1.7 Object 结构","id":"817-object-结构","depth":4,"charIndex":-1},{"text":"8.2 Object 创建","id":"82-object-创建","depth":3,"charIndex":-1},{"text":"8.2.1 工厂方法(The Factory Pattern)","id":"821-工厂方法the-factory-pattern","depth":4,"charIndex":-1},{"text":"8.2.2 函数构建模式(The Function Constructor Pattern)","id":"822-函数构建模式the-function-constructor-pattern","depth":4,"charIndex":-1},{"text":"8.2.3 原型模式","id":"823-原型模式","depth":4,"charIndex":-1},{"text":"8.3 继承","id":"83-继承","depth":3,"charIndex":-1},{"text":"8.3.1 原型链","id":"831-原型链","depth":4,"charIndex":-1},{"text":"8.3.2 借用构造函数(Constructor Stealing)","id":"832-借用构造函数constructor-stealing","depth":4,"charIndex":-1},{"text":"8.3.3 组合继承","id":"833-组合继承","depth":4,"charIndex":-1},{"text":"8.3.4 原型继承","id":"834-原型继承","depth":4,"charIndex":-1},{"text":"8.3.5 寄生继承","id":"835-寄生继承","depth":4,"charIndex":-1},{"text":"8.3.6 寄生组合继承","id":"836-寄生组合继承","depth":4,"charIndex":-1},{"text":"8.4 Class","id":"84-class","depth":3,"charIndex":-1},{"text":"8.4.1 class 定义基础","id":"841-class-定义基础","depth":4,"charIndex":-1},{"text":"8.4.2 class 构造函数","id":"842-class-构造函数","depth":4,"charIndex":-1},{"text":"8.4.3 实例，原型与 class 成员","id":"843-实例原型与-class-成员","depth":4,"charIndex":-1},{"text":"8.4.4 继承","id":"844-继承","depth":4,"charIndex":-1},{"text":"10 函数","id":"10-函数","depth":2,"charIndex":-1},{"text":"10.1 箭头函数(Arrow Function)","id":"101-箭头函数arrow-function","depth":3,"charIndex":-1},{"text":"10.2 函数名","id":"102-函数名","depth":3,"charIndex":-1},{"text":"10.3 理解 Argument","id":"103-理解-argument","depth":3,"charIndex":-1},{"text":"10.3.1 箭头函数中的 arguments","id":"1031-箭头函数中的-arguments","depth":4,"charIndex":-1},{"text":"10.4 不重载(No Overloading)","id":"104-不重载no-overloading","depth":3,"charIndex":-1},{"text":"10.5 初始参数值","id":"105-初始参数值","depth":3,"charIndex":-1},{"text":"10.5.1 参数初始化范围与暂时死区(Default Parameter Scope and Temporal Dead Zone)","id":"1051-参数初始化范围与暂时死区default-parameter-scope-and-temporal-dead-zone","depth":4,"charIndex":-1},{"text":"10.6 参数传递与剩余参数(SPREAD ARGUMENTS AND REST PARAMETERS)","id":"106-参数传递与剩余参数spread-arguments-and-rest-parameters","depth":3,"charIndex":-1},{"text":"10.6.1 参数传递","id":"1061-参数传递","depth":4,"charIndex":-1},{"text":"10.6.2 剩余参数","id":"1062-剩余参数","depth":4,"charIndex":-1},{"text":"10.7 函数声明与函数表达","id":"107-函数声明与函数表达","depth":3,"charIndex":-1},{"text":"10.8 函数与值","id":"108-函数与值","depth":3,"charIndex":-1},{"text":"10.9 函数内部","id":"109-函数内部","depth":3,"charIndex":-1},{"text":"10.9.1 this","id":"1091-this","depth":4,"charIndex":-1},{"text":"10.9.2 caller","id":"1092-caller","depth":4,"charIndex":-1},{"text":"10.9.3 new.target","id":"1093-newtarget","depth":4,"charIndex":-1},{"text":"10.10 函数属性与工具(FUNCTION PROPERTIES AND METHODS)","id":"1010-函数属性与工具function-properties-and-methods","depth":3,"charIndex":-1},{"text":"10.11 函数表达","id":"1011-函数表达","depth":3,"charIndex":-1},{"text":"10.12 递归","id":"1012-递归","depth":3,"charIndex":-1},{"text":"10.13 尾调用优化","id":"1013-尾调用优化","depth":3,"charIndex":-1},{"text":"10.13.1 尾调用优化的条件","id":"10131-尾调用优化的条件","depth":4,"charIndex":-1},{"text":"10.13.2 尾调用优化代码","id":"10132-尾调用优化代码","depth":4,"charIndex":-1},{"text":"10.14 闭包(CLOSURES)","id":"1014-闭包closures","depth":3,"charIndex":-1},{"text":"10.14.1 The this object","id":"10141-the-this-object","depth":4,"charIndex":-1},{"text":"10.14.2 内存泄漏","id":"10142-内存泄漏","depth":4,"charIndex":-1},{"text":"10.15 立刻调用函数表达(IMMEDIATELY INVOKED FUNCTION EXPRESSIONS)","id":"1015-立刻调用函数表达immediately-invoked-function-expressions","depth":3,"charIndex":-1},{"text":"10.16 模块模式","id":"1016-模块模式","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2019-08-16T00:00:00.000Z","author":"h7ml","title":"JavaScript 高级程序设计读书笔记","category":"javascript","tag":"javascript","star":true},"version":""},{"id":409,"title":"javascript","content":"#","routePath":"/posts/javascript/regx/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":410,"title":"正则表达式的前瞻、负前瞻、后顾和负后顾","content":"在逛github的时候，发现一个很有意思的utils userhjp/datav-react\n\n\n\n/(?=(\\B)(\\d{3})+$)/g\n\n * (\\B)：这是一个捕获组，表示匹配位置的前一个字符必须不是一个单词边界（非单词字符和单词字符之间的位置）。\n\n * (\\d{3})+：这是另一个捕获组，表示匹配连续的三个数字。\n\n * (?=：这是一个正向前瞻，它要求匹配位置的后面必须满足捕获组 (\\B)(\\d{3})+ 的模式。\n\n * g：这是全局标志，表示查找所有匹配项而不仅仅是第一个。\n\n因此，这个正则表达式的作用是，在每三个数字之前插入一个逗号 ,，并确保它们之前不是单词边界。这正是您在示例中的预期输出：1,000,000,000。它将\n1000000000 转换为格式化的金额字符串。\n\n\n前瞻 (?=exp)#\n\n前瞻是一种正向查找，它用于查找匹配的内容后面必须满足某个条件（exp）的情况。\n\n\n示例：#\n\n\n\n\n负前瞻 (?!exp)#\n\n负前瞻是一种负向查找，它用于查找匹配的内容后面必须不满足某个条件（exp）的情况。\n\n\n示例：#\n\n\n\n\n后顾 (?<=exp)#\n\n后顾是一种正向查找，它用于查找匹配的内容前面必须满足某个条件（exp）的情况。\n\n\n示例：#\n\n\n\n\n负后顾 (?#\n\n负后顾是一种负向查找，它用于查找匹配的内容前面必须不满足某个条件（exp）的情况。\n\n\n示例：#\n\n\n\n正则表达式的前瞻、负前瞻、后顾和负后顾是一些强大的技巧，用于在文本中查找特定的模式，\n\n前瞻运算符在许多情况下都非常有用，其中一个明显的应用场景是校验密码强度。密码强度校验是确保用户创建安全密码的关键任务之一。通过使用前瞻运算符，我们可以更精确地定\n义密码规则，这比传统的正则表达式方式更为强大。\n\n假设我们有以下密码规则：\n\n * 必须包含至少一个大写字母。\n * 必须包含至少一个小写字母。\n * 必须包含至少一个数字。\n * 必须包含至少一个特殊字符（例如：!@#$）。\n * 密码长度必须在 8 到 16 个字符之间。\n\n若使用前瞻运算符，我们可以更精确地定义密码规则，如下所示：\n\n\n\n这个前瞻运算符的工作原理是：\n\n * ^：这是正则表达式的开始锚点，它表示匹配必须从字符串的开头开始。\n * (?=.*[A-Z]) 这是一个前瞻运算符，用于检查密码中是否至少包含一个大写字母 A-Z。 如果是，则匹配成功，否则匹配失败。 '._'\n   表示匹配任何字符零次或多次。所以，(?=._[A-Z]) 表示匹配任何包含至少一个大写字母的字符串。\n * (?=.*[a-z]) 这是另一个前瞻运算符，用于检查密码中是否至少包含一个小写字母 a-z。 如果是，则匹配成功，否则匹配失败。 '._'\n   表示匹配任何字符零次或多次。所以，(?=._[a-z]) 表示匹配任何包含至少一个小写字母的字符串。\n * (?=.*\\d)这是又一个前瞻运算符，用于检查密码中是否至少包含一个数字 0-9。 如果是，则匹配成功，否则匹配失败。 '._'\n   表示匹配任何字符零次或多次。所以，(?=._\\d) 表示匹配任何包含至少一个数字的字符串。\n * (?=.*[!@#\\$%^&*])这是另一个前瞻运算符，用于检查密码中是否至少包含一个特殊字符 !@#\\$%^&*。 如果是，则匹配成功，否则匹配失败。\n   '._' 表示匹配任何字符零次或多次。所以，(?=._[!@#\\$%^&*]) 表示匹配任何包含至少一个特殊字符的字符串。\n * [A-Za-z\\d!@#\\$%^&*]{8,16}：这是密码的实际匹配部分。它表示密码必须包含大小写字母、数字和特殊字符，且长度必须在 8 到 16\n   个字符之间。\n * $：这是正则表达式的结束锚点，它表示匹配必须在字符串的结尾结束。","routePath":"/posts/javascript/regx/正则表达式的前瞻、负前瞻、后顾和负后顾","lang":"","toc":[{"text":"前瞻 (?=exp)","id":"前瞻-exp","depth":2,"charIndex":353},{"text":"示例：","id":"示例","depth":3,"charIndex":408},{"text":"负前瞻 (?!exp)","id":"负前瞻-exp","depth":2,"charIndex":417},{"text":"示例：","id":"示例-1","depth":3,"charIndex":475},{"text":"后顾 (?<=exp)","id":"后顾-exp","depth":2,"charIndex":484},{"text":"示例：","id":"示例-2","depth":3,"charIndex":540},{"text":"负后顾 (?<!exp)","id":"负后顾-exp","depth":2,"charIndex":-1},{"text":"示例：","id":"示例-3","depth":3,"charIndex":602}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2024-09-04T00:00:00.000Z","author":"h7ml","title":"正则表达式的前瞻、负前瞻、后顾和负后顾","description":"正则表达式的前瞻、负前瞻、后顾和负后顾","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>正则表达式的前瞻、负前瞻、后顾和负后顾","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"正则表达式的前瞻、负前瞻、后顾和负后顾","category":["javascript"],"tag":["javascript"],"head":[["meta",{"name":"keywords","content":"正则表达式的前瞻、负前瞻、后顾和负后顾"}]]},"version":""},{"id":411,"title":"JavaScript cookie","content":"#\n\n\n存储格式#\n\n\n\n键 = 值; 后续中括号的内容，都是可选项。\n\n火狐支持缓存 cookie，谷歌只支持服务器缓存 cookie\n\n * [expires=date]：'expires=过期时间'\n * [path=path]：设置的 cookie 的路径\n   * 如果不设置，默认是加载当前.html 文件的路径\n   * 设置的 cookie 的路径，和加载当前文件的路径，必须一致，如果不一致，cookie 访问失败。\n\n\n\n * [domain=somewhere.com]：domain 限制访问域名\n   * 如果不去设置，默认是加载当前 .html 文件的服务器域名 /ip\n   * 如果加载当前文件域名和设置的域名不一致，设置 cookie 失败。不能设置\n\n\n\n * secure\n   * 如果不设置，设置 cookie，可以通过 http/https 协议加载文件设置\n   * 设置字段后，只能 https 协议加载 cookie.\n\n\n\n\n获取 cookie#\n\n\n\n\n设置 cookie#\n\n\n\n\n转码储存#\n\n * encodeURIComponent()：将中文编译成对应的字符\n * decodeURIComponent()：将对应的字符编译成中文\n\n\n\n\n转码获取#\n\n\n\n\n删除 cookie#\n\n\n\n\nsetCookie 封装#\n\n\n\n\ngetCookie 封装#\n\n\n\n\nremoveCookie 封装#\n\n\n\n\ncookie 封装#\n\n","routePath":"/posts/javascript/store/cookie","lang":"","toc":[{"text":"存储格式","id":"存储格式","depth":2,"charIndex":3},{"text":"获取 cookie","id":"获取-cookie","depth":2,"charIndex":438},{"text":"设置 cookie","id":"设置-cookie","depth":2,"charIndex":453},{"text":"转码储存","id":"转码储存","depth":2,"charIndex":468},{"text":"转码获取","id":"转码获取","depth":2,"charIndex":551},{"text":"删除 cookie","id":"删除-cookie","depth":2,"charIndex":561},{"text":"setCookie 封装","id":"setcookie-封装","depth":2,"charIndex":576},{"text":"getCookie 封装","id":"getcookie-封装","depth":2,"charIndex":594},{"text":"removeCookie 封装","id":"removecookie-封装","depth":2,"charIndex":612},{"text":"cookie 封装","id":"cookie-封装","depth":2,"charIndex":633}],"domain":"","frontmatter":{},"version":""},{"id":412,"title":"javascript","content":"#","routePath":"/posts/javascript/store/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":413,"title":"JavaScript localStorage","content":"#\n\n\n存储时间#\n\n * localStorage（IE8 以下不兼容）\n   \n   * 永久存储\n   * 最大存储 5M 客户端的微型数据库\n   * 只能存储 string\n\n * cookie\n   \n   * 可以设置过期时间\n   * 最大存 4KB\n   * 每一个域名下面最多可以存储 50 条数据\n\n * sessionStorage（结合后台使用、关闭窗口存储的数据清空）\n\n\nlocalStorage 对象#\n\n","routePath":"/posts/javascript/store/localStorage","lang":"","toc":[{"text":"存储时间","id":"存储时间","depth":2,"charIndex":3},{"text":"localStorage 对象","id":"localstorage-对象","depth":2,"charIndex":200}],"domain":"","frontmatter":{},"version":""},{"id":414,"title":"JavaScript sessionStorage","content":"#\n\n * 常用于后台服务端控制前端存储数据\n * 或用户登录信息，但与 localstore 主要不同的是只在会话期间有效\n\n","routePath":"/posts/javascript/store/sessionStorage","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":415,"title":"javascript 数据类型","content":"#\n\n温馨提示阅读\n\n《JavaScript 高级程序设计（第 4 版）》和各个大佬的文章所归纳的总结，如有异议按你的理解为主\n\nJavaScript 中的数据类型分为基本数据类型和引用数据类型\n\n\n基本类型#\n\n> 注: 基本数据类型也可以叫原始数据类型\n\n在 ES2020 标准下的 JavaScript 一共有以下 7 种基本类型\n\n * undefined 未定义\n * null 空指针\n * boolean 布尔值\n * string 字符串\n * number 数值\n * symbol 独一无二的值 (ES6 引入)\n * bigint 大整数 (ES2020 引入)\n\n基本类型总结\n * 基本类型仅保存原始值，不存在属性和方法\n * 基本类型存储在 栈内存 中\n * 保存基本类型的变量是 按值 (by value) 访问 的，操作的就是存储在变量中的实际值\n * 复制基本类型时会创建该值的第二个副本 (独立使用，互不干扰)\n\n为什么原始值不存在属性和方法，但 'hello world'.toString() 可以正确执行为了方便操作原始值\n\nECMAScript 提供了 3 种特殊的引用类型：Boolean Number\nString，每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，在执行完后再销毁这个包装对象\n\n\n\n\n引用类型#\n\n在 JavaScript 中除了基本类型，其他的都是引用类型，常见的引用类型如下\n\n * Object 对象\n * Array 数组\n * Function 函数\n * Date 日期与时间\n * RegExp 正则表达式\n * Set 类似于数组但成员的值都是唯一的 (ES6 引入)\n * WeakSet (ES6 引入)\n * Map 类似于对象也是键值对的集合 (ES6 引入)\n * WeakMap (ES6 引入)\n\n引用类型总结\n * 因为 JavaScript 不允许直接访问内存位置(不能直接操作对象所在的内存空间)，所以引用类型在 栈内存\n   中存储的是地址(内存指针)，而引用类型中的数据(方法或属性)是存储在 堆内存 中\n * 保存引用类型的变量是 按引用 (by reference) 访问 ，实际上操作的是对该对象的引用而非实际的对象本身\n * 复制引用类型时只会复制内存指针\n\n栈内存和堆内存\n * 栈内存\n   * 存储基本数据类型和堆内存地址\n   * 是连续的内存空间\n * 堆内存\n   * 存储引用数据类型和闭包中的变量\n   * 不是连续的内存空间\n * 了解更多请点击 JS 中的栈内存和堆内存\n\n\n类型判断#\n\n常见的五种判断方式\n\n * typeof\n * instanceof\n * constructor\n * Array.isArray()\n * Object.prototype.toString\n\n\ntypeof#\n\n * 除 null 外的基本类型都能准确判断\n\n\n\n为什么 typeof null === 'object' 在\n\nJavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null\n代表的是空指针（大多数平台下值为 0x00），因此null 的类型标签是 0，typeof null 也因此返回 \"object\" —— MDN\n\n * 除 function 外的引用类型均返回 object\n\n\n\n\ninstanceof#\n\ninstanceof 用于检测构造函数的 prototype 属性是否存在于实例对象的原型链上\n\n\n\ninstanceof 总结\n * instanceof 不能判断基本类型，对于引用类型只能判断原型链上的从属关系\n * instanceof 并不完全可靠，因为构造函数的 prototype 属性可能会被修改\n   * 修改原型的方法\n     * 使用 ES6 提供的 Reflect.setPrototypeOf() 方法\n     * 借助于非标准的 __proto__ 伪属性\n\n\nconstructor#\n\n实例对象可以通过 constructor 属性去访问它的构造函数\n\n\n\nconstructor 总结\n * constructor 可以判断除 undefined 和 null 外的所有基本类型和引用类型(undefined 和 null 不存在构造函数)\n * constructor 并不完全可靠，因为构造函数的 prototype 属性可能会被修改，从而造成 constructor 属性指向不准确\n\n\nArray.isArray()#\n\nArray.isArray() 用于判断一个值是否是数组 (Array)\n\n\n\n\nObject.prototype.toString#\n\n * 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用，默认情况下 toString()\n   方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖 toString() 返回 \"[object type]\" 其中 type\n   是对象的类型\n * 为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者\n   Function.prototype.apply() 的形式来调用\n\n\n\ntoString 方法的在 ECMAScript 5 下的大致执行过程\n\n 1. 如果 this 是 undefined 返回 [object Undefined]\n 2. 如果 this 是 null 返回 [object Null]\n 3. 让 O 成为 ToObject(this) 的结果\n 4. 让 class 成为 O 的内部属性 [[Class]] 的值\n 5. 返回由 \"[object \" class \"]\" 三个部分组成的字符串\n\n注意点\n\n不同 ECMAScript 版本对 toString 方法的规范都有所不同\n\nObject.prototype.toString 方法的原理","routePath":"/posts/javascript/types","lang":"","toc":[{"text":"基本类型","id":"基本类型","depth":2,"charIndex":99},{"text":"引用类型","id":"引用类型","depth":2,"charIndex":587},{"text":"类型判断","id":"类型判断","depth":2,"charIndex":1117},{"text":"typeof","id":"typeof","depth":3,"charIndex":1224},{"text":"instanceof","id":"instanceof","depth":3,"charIndex":1472},{"text":"constructor","id":"constructor","depth":3,"charIndex":1731},{"text":"Array.isArray()","id":"arrayisarray","depth":3,"charIndex":1950},{"text":"Object.prototype.toString","id":"objectprototypetostring","depth":3,"charIndex":2009}],"domain":"","frontmatter":{"icon":"javascript","order":1,"date":"2019-08-16T00:00:00.000Z","author":"h7ml","category":"javascript 数据类型","tag":"javascript","star":true},"version":""},{"id":416,"title":"JavaScript Array 数组对象-数据类型","content":"#\n\n\n创建#\n\n\n\n * 利用 length 可以在末尾添加一项\n\n\n\n * 转换方法\n\n\n\n\n改变原数组（7 个方法）#\n\n\n\n\n不改变原数组#\n\n\n\n\n数组迭代#\n\n\n\n * reduce 计算数组总和\n\n\n\n * 利用 reduce 第二个参数，计算对象下某个值的总和\n\n\n\n如果没有 reduce 第二个参数，prev 初始值会是数组的第一项，设置初始值为 0 与下一项累加即可\n\n\n类数组#\n\n\n\n条件:\n\n 1. 键为 0 1 2 3 的数字字符串（数组 0 1 2 也会被默认调用 tostring 以字符串存储为键）\n 2. 有 length 属性\n 3. 绑定 splice 为 Array 原型上的方法此时输出的 obj 为数组","routePath":"/posts/javascript/types/Array","lang":"","toc":[{"text":"创建","id":"创建","depth":2,"charIndex":3},{"text":"改变原数组（7 个方法）","id":"改变原数组7-个方法","depth":2,"charIndex":48},{"text":"不改变原数组","id":"不改变原数组","depth":2,"charIndex":66},{"text":"数组迭代","id":"数组迭代","depth":2,"charIndex":78},{"text":"类数组","id":"类数组","depth":2,"charIndex":196}],"domain":"","frontmatter":{},"version":""},{"id":417,"title":"JavaScript Date 时间对象-数据类型","content":"#\n\n\n创建日期#\n\n\n\n如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()\n\n\n时间格式化#\n\n\n\n\n时间组件#\n\n\n\n\n利用 Date 对象获取某个月有多少天#\n\n\n\n获取 2021 年 9 月份有多少天，字符串 10 月，天数 -1 时会退回至 9 月，getDate 获取当前天数即可，而不再是使用 switch","routePath":"/posts/javascript/types/Date","lang":"","toc":[{"text":"创建日期","id":"创建日期","depth":2,"charIndex":3},{"text":"时间格式化","id":"时间格式化","depth":2,"charIndex":63},{"text":"时间组件","id":"时间组件","depth":2,"charIndex":74},{"text":"利用 Date 对象获取某个月有多少天","id":"利用-date-对象获取某个月有多少天","depth":2,"charIndex":84}],"domain":"","frontmatter":{},"version":""},{"id":418,"title":"JavaScript Error 错误对象-数据类型","content":"#\n\n * EvalError：eval()的使用与定义不一致\n * RangeError：数值越界 一个数字超出它的边界时抛出。该错误在正常的代码执行中非常罕见\n * ReferenceError：非法或不能识别的引用 期望的对象不存在时抛出\n * SyntaxError：有语法错误时抛出\n * TypeError：变量不是期望的类型时抛出\n * URIError：URI 处理函数使用不当给 encodeURI(), encodeURIComponent(), decodeURI() 或者\n   decodeURIComponent() 等函数传递格式非法的 URI 字符串时抛出","routePath":"/posts/javascript/types/Error","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":419,"title":"JavaScript function 函数对象-数据类型","content":"#\n\n * 函数分类\n   * 普通命名函数\n   * 通过名字调用执行\n\n\n\n * 事件处理函数\n   * 可以是匿名函数也可以是匿名函数，通过元素对象的事件触发来执行\n\n\n\n * 构造函数\n   * 通过 new 运算符来执行\n\n\n\n * 回调函数\n   * 在主函数中满足一定条件调用执行 匿名函数也可以是命名函数\n * 表达式函数：将一个函数 赋值给一个变量 通过函数名的调用执行\n\n\n\n * 匿名函数：闭包\n\n\n\n\ncallee 与 caller#\n\n\n\n\n改变 this 指向#\n\n\n\n:::tip 注意第一个参数传 null 为不改变 this 指向 :::\n\n\n函数的 length 属性#\n\n\n\n\nname 属性#\n\n","routePath":"/posts/javascript/types/Function","lang":"","toc":[{"text":"callee 与 caller","id":"callee-与-caller","depth":2,"charIndex":212},{"text":"改变 this 指向","id":"改变-this-指向","depth":2,"charIndex":233},{"text":"函数的 length 属性","id":"函数的-length-属性","depth":2,"charIndex":288},{"text":"name 属性","id":"name-属性","depth":2,"charIndex":307}],"domain":"","frontmatter":{},"version":""},{"id":420,"title":"JavaScript Math 数学对象-数据类型","content":"#\n\n\n最大最小值#\n\n\n\n\n舍入#\n\n\n\n\n其他方法#\n\n\n\n\nES6 扩展方法#\n\n","routePath":"/posts/javascript/types/Math","lang":"","toc":[{"text":"最大最小值","id":"最大最小值","depth":2,"charIndex":3},{"text":"舍入","id":"舍入","depth":2,"charIndex":14},{"text":"其他方法","id":"其他方法","depth":2,"charIndex":22},{"text":"ES6 扩展方法","id":"es6-扩展方法","depth":2,"charIndex":32}],"domain":"","frontmatter":{},"version":""},{"id":421,"title":"JavaScript Number 数字对象-数据类型","content":"#\n\n\n\n * 浮点值\n\n科学记数法的格式跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂，浮点值的精确度最高可达 17 位小数\n\n\n\n * 方法\n\n\n\n * NaN\n\n分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 Infinity 或-Infinity\n\n\n\nisNaN 首先会调用对象的 valueOf() 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString() 方法，并测试其返回值\n\n\nNumber.isFinite()#\n\n * 没有隐式的 Number() 类型转换，所有非数值都返回 false\n * 检查一个数值是否为有限的（ finite ），即不是 Infinity\n\n\n\n\nNumber.isInteger()#\n\n * 判断一个数是不是整数\n\n\n\n\n数值转换#\n\n * null，返回 0。\n * undefined，返回 NaN。\n * 字符串：\n   * Number(\"1\")返回 1，Number(\"123\")返回 123，Number(\"011\")返回 11\n   * 浮点数同样忽略前面的 0\n   * 16 进制转换为对应的 10 进制整数值\n * 对象，调用 valueOf()方法，再执行上面的规则。如果是 NaN，则调用 toString()方法，再按照字符串的规则转换。\n\n\n\n * parseInt()\n   * 字符串最前面的空格会被忽略\n   * 第一个字符不是数值、加号或减号，立即返回 NaN\n\n\n\n * parseInt()也接收第二个参数，指定进制数\n\n\n\n * parseFloat 解析到一个无效的浮点数值字符为止\n   * 始终忽略字符串开头的零\n   * 十六进制数值始终会返回 0，因为 parseFloat() 只解析十进制值\n\n","routePath":"/posts/javascript/types/Number","lang":"","toc":[{"text":"Number.isFinite()","id":"numberisfinite","depth":2,"charIndex":224},{"text":"Number.isInteger()","id":"numberisinteger","depth":2,"charIndex":325},{"text":"数值转换","id":"数值转换","depth":2,"charIndex":364}],"domain":"","frontmatter":{},"version":""},{"id":422,"title":"JavaScript Object 对象-数据类型","content":"#\n\n\nObject.create()#\n\n\n\n * 返回一个新对象\n * 新对象的proto指向第一个参数。参数可以为 null,即没有原型对象\n * 要添加的属性以及配置\n\n\n\n\nObject.defineProperty()#\n\n\n\n * 直接操作参数 1 obj 地址\n * propName: 添加的键名[两个参数时 = 配置选项的 value 值]\n * descriptor: 配置选项\n\n\n\n 1. 可以多次调用 Object.defineProperty() 方法修改同一个属性，但把 configurable 设置为 false 之后就会报错。\n 2. 当使用了 getter 或 setter 方法，不允许使用 writable 和 value 这两个属性。如果使用，会直接报错\n\n\nObject.defineProperties()#\n\nObject.defineProperties(obj, props)\n\n * obj：要修改的对象\n * props：属性值\n\n\n\n\nObject.assign()#\n\n\n\n * 后面的 sources 源对象 拷贝到 target 目标对象上\n * 返回 target 对象\n\n\n\n * 会调用源对象的 [[Get]]\n * 和目标对象的 [[Set]]\n\n\nObject.keys()#\n\n\n\n\nObject.values()#\n\n\n\n\nObject.entries()#\n\n * 遍历键和值\n\n * 以二维数组的形式，将对象中的每个键名和键值，进行数组分解。\n\n\n\n\nObject.getOwnPropertyNames()#\n\n\n\n包含 constructor\n\n不包含 Symbol 属性\n\n\nObject.getOwnPropertySymbols()#\n\n\n\n\nObject.getOwnPropertyDescriptors()#\n\n返回同时包含常规和符号(symbol)属性描述符的对象，都没有则返回空对象\n\n\n\n\nObject.is()#\n\n\n\n\nObject.getPrototypeOf()#\n\n\n\n\nObject.freeze()#\n\n\n\n\nObject.seal()#\n\n\n\n\nObject.hasOwnProperty()#\n\n返回属性名是否在实例属性上\n\n","routePath":"/posts/javascript/types/Object","lang":"","toc":[{"text":"Object.create()","id":"objectcreate","depth":2,"charIndex":3},{"text":"Object.defineProperty()","id":"objectdefineproperty","depth":2,"charIndex":91},{"text":"Object.defineProperties()","id":"objectdefineproperties","depth":2,"charIndex":352},{"text":"Object.assign()","id":"objectassign","depth":2,"charIndex":448},{"text":"Object.keys()","id":"objectkeys","depth":2,"charIndex":562},{"text":"Object.values()","id":"objectvalues","depth":2,"charIndex":581},{"text":"Object.entries()","id":"objectentries","depth":2,"charIndex":602},{"text":"Object.getOwnPropertyNames()","id":"objectgetownpropertynames","depth":2,"charIndex":668},{"text":"Object.getOwnPropertySymbols()","id":"objectgetownpropertysymbols","depth":2,"charIndex":733},{"text":"Object.getOwnPropertyDescriptors()","id":"objectgetownpropertydescriptors","depth":2,"charIndex":769},{"text":"Object.is()","id":"objectis","depth":2,"charIndex":848},{"text":"Object.getPrototypeOf()","id":"objectgetprototypeof","depth":2,"charIndex":865},{"text":"Object.freeze()","id":"objectfreeze","depth":2,"charIndex":894},{"text":"Object.seal()","id":"objectseal","depth":2,"charIndex":915},{"text":"Object.hasOwnProperty()","id":"objecthasownproperty","depth":2,"charIndex":934}],"domain":"","frontmatter":{},"version":""},{"id":423,"title":"javascript 数据类型","content":"","routePath":"/posts/javascript/types/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 数据类型","index":false,"dir":{"order":3}},"version":""},{"id":424,"title":"JavaScript RegExp 正则表达式对象-数据类型","content":"#\n\n修饰符\n\n * g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。\n * i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。\n * m：多行模式，表示查找到一行文本末尾时会继续查找。\n * y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。\n * u：Unicode 模式，启用 Unicode 匹配。\n * s：dotAll 模式，表示元字符,匹配任何字符（包括\\n 或\\r）。\n\n\n实例属性#\n\n * global：布尔值，表示是否设置了 g 标记。\n * ignoreCase：布尔值，表示是否设置了 i 标记。\n * unicode：布尔值，表示是否设置了 u 标记。\n * sticky：布尔值，表示是否设置了 y 标记。\n * lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。\n * multiline：布尔值，表示是否设置了 m 标记。\n * dotAll：布尔值，表示是否设置了 s 标记。\n * source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。\n * flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。\n\n\n方法#\n\n\ntest()#\n\n * test：检测字符串是否匹配正则 如果匹配 返回 true 不匹配返回 false 表单验证的返回值\n\n\n\n\nmacth()#\n\n * 全局 返回所有匹配字符串组成的一个数组。\n * 非全局 返回匹配到的第一个字符串数组，且会返回该字符串的下标及相关信息。\n\n\n\n\nexec()#\n\n * 全局模式 有一个自己的 lastIndex 值 引导下次进行 exec 匹配的起始位置。\n * 非全局模式下进行字符串的匹配 结果和 macth 一样\n\n\n\n\n正则预查询#\n\n判断括号内表达式\n\n返回 ---> 括号外表达式\n\n * 正向肯定\n\n(?=):\n\n表达式 1(?= 表达式 2)\n\n返回 --> 前面是表达式 1\n\n后面是表达式 2\n\n\n\n * 正向否定\n\n(?!):\n\n表达式 1(?!表达式 2)\n\n返回 ---> 前面是表达式 1\n\n后面不是表达式 2\n\n\n\n * 反向肯定\n\n(?<=):\n\n(?<=表达式 2)表达式 1\n\n前面是表达式 2\n\n返回 ---> 后面是表达式 1\n\n\n\n * 反向否定\n\n(?\n\n(?\n\n前面不是表达式 2\n\n返回 ----> 表达式 1\n\n\n\n\n元字符#\n\n * 单个字符\n   \n   * . 匹配除换行外单个的任意字符\n   * [范围] 匹配单个范围内的字符\n   * [0-9] 匹配单个 数字\n   * [^范围] 匹配单个范围内除括号内的字符\n   * [^0-9] 匹配单个 非数字\n   * [a-zA-Z0-9_] 匹配单个 数字、字母、下划线_\n   * \\w 匹配单个 数字、字母、下划线 等价于 [a-zA-Z0-9_]\n   * \\W 匹配单个 非数字、字母、下划线\n   * \\d 匹配单个 数字 等价于 [0-9]\n   * \\D 匹配单个 非数字 等价于 [^0-9]\n\n * 重复字符\n   \n   * x 代表任意的单个字符\n   * x? 匹配 0 个或 1 个 x /goog?le/ 要么是 google 要么是 goole\n   * x+ 匹配最少 1 个字符\n   * x* 匹配任意个 x 字符\n   * x{m,n} 匹配至少 m 个，最多 n 个（包括 n\n   * x{n} 必须匹配 n 个字符\n   * (xyz)+ 小括号括起来的部分是当做单个字符处理\n\n * 空白字符\n   \n   * \\s 匹配任意单个空白字符（空格 制表 回车\n   * \\S 匹配任意单个非空白字符\n   * \\b 单词边界\n   * \\B 非单词边界\n\n * 锚字符\n   \n   * ^ 行首匹配/^google/\n   * $ 行尾匹配/google$/\n\n * 替代字符\n   \n   * | 或 /google|baidu|bing/\n\n * 转义字符\n   \n   * \\.\n   * \\*\n\n * 验证字符串是否存中文\n   \n   ","routePath":"/posts/javascript/types/RegExp","lang":"","toc":[{"text":"实例属性","id":"实例属性","depth":2,"charIndex":228},{"text":"方法","id":"方法","depth":2,"charIndex":564},{"text":"test()","id":"test","depth":3,"charIndex":570},{"text":"macth()","id":"macth","depth":3,"charIndex":637},{"text":"exec()","id":"exec","depth":3,"charIndex":715},{"text":"正则预查询","id":"正则预查询","depth":3,"charIndex":807},{"text":"元字符","id":"元字符","depth":2,"charIndex":1077}],"domain":"","frontmatter":{},"version":""},{"id":425,"title":"JavaScript String 字符串对象-数据类型","content":"#\n\n\n\n字符串是不可变的，一旦创建，值就不能变了。字符串的方法都是返回新的值。\n\n\n\n刚开始 lang 包含字符串\"Java\"，接着，lang\n被重新定义为包含\"Java\"和\"Script\"的组合\"JavaScript\"。整个过程首先会分配一个足够容纳 10\n个字符的空间，然后填充上\"Java\"和\"Script\"。最后销毁原始的字符串\"Java\"和字符串\"Script\"，所有处理都是在后台发生的。\n\n\n转换为字符串#\n\n几乎所有值都有的 toString()方法，字符串 toString()方法只是简单地返回自身的一个副本，null 和 undefined 值没有\n\n\n\n * String()\n\n因为 null 和 undefined 没有 toString()方法，就直接返回了字面量文本。\n\n\n\n注意用加号操作符给一个值加上一个空字符串\"\"也可以将其转换为字符串 :::\n\n\n取值#\n\n\n\n\n截取#\n\n * 不会对原始字符串修改，返回值的副本\n * 只有一个参数，截取到字符结束\n\n\n\n 1. 起始下标，结束下标 -1\n 2. 起始大于结束，会互换\n 3. 起始为负数，默认变 0\n\n\n\n 1. 起始下标，结束下标-1\n 2. 起始大于结束，不换位，返回空字符串\n 3. 出现负值，为倒数 = length + 负数\n\n\n\n 1. 起始下标，截取位数\n 2. 出现负值，为倒数 = length + 负数\n\n\n位置查询#\n\n\n\n\n分隔/拼接#\n\n\n\n\n编辑/替换#\n\n\n\n\n大小写转换#\n\n\n\n带 Locale 是针对地区的转换，Unicode 码可能存在不同，如土耳其地区需要对应的特殊规则才能转换，所以最好使用地区特定的转换方法。\n\n\nURI 编码方法#\n\n\n\n\neval()#\n\n * 解析字符串 js 代码\n\n\n\n::: warning 注意\n\n当开启严格模式后 eval 会存在作用域\n\n\nlocaleCompare()#\n\n * 比较字符串在字母表的前后\n * 在前面返回 1\n * 在后面返回 -1\n\n","routePath":"/posts/javascript/types/String","lang":"","toc":[{"text":"转换为字符串","id":"转换为字符串","depth":2,"charIndex":203},{"text":"取值","id":"取值","depth":2,"charIndex":394},{"text":"截取","id":"截取","depth":2,"charIndex":402},{"text":"位置查询","id":"位置查询","depth":2,"charIndex":611},{"text":"分隔/拼接","id":"分隔拼接","depth":2,"charIndex":621},{"text":"编辑/替换","id":"编辑替换","depth":2,"charIndex":632},{"text":"大小写转换","id":"大小写转换","depth":2,"charIndex":643},{"text":"URI 编码方法","id":"uri-编码方法","depth":2,"charIndex":726},{"text":"eval()","id":"eval","depth":2,"charIndex":740},{"text":"localeCompare()","id":"localecompare","depth":2,"charIndex":806}],"domain":"","frontmatter":{},"version":""},{"id":426,"title":"javascript 数据类型","content":"","routePath":"/posts/javascript/types/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"javascript","date":"2022-03-30T00:00:00.000Z","author":"h7ml","category":"javascript","tag":"javascript","title":"javascript 数据类型","index":false,"dir":{"order":3}},"version":""},{"id":427,"title":"JavaScript 数组去重排序","content":"#\n\n\n数组去重#\n\n\n\n\n冒泡排序#\n\n\n\n\n选择排序#\n\n\n\n\n递归排序#\n\n","routePath":"/posts/javascript/types/数组去重排序","lang":"","toc":[{"text":"数组去重","id":"数组去重","depth":2,"charIndex":3},{"text":"冒泡排序","id":"冒泡排序","depth":2,"charIndex":13},{"text":"选择排序","id":"选择排序","depth":2,"charIndex":23},{"text":"递归排序","id":"递归排序","depth":2,"charIndex":33}],"domain":"","frontmatter":{},"version":""},{"id":428,"title":"JavaScript 数据类型分类","content":"#\n\n 1. 变量声明分为字面量创建和构造函数（实例化）创建\n 2. 构造函数创建 typeof 检测数据类型都为 object\n 3. 原生对象：String，Number，Boolean，Function，object，Array，Date，Error，RegExp，global，Ma\n    th\n 4. 内置对象：global，Math\n 5. 宿主对象：DOM，BOM\n 6. 全局对象：window（document 属于 window 下）\n\n事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global\n对象的属性。（包括isNaN()、isFinite()、parseInt()和 parseFloat()）","routePath":"/posts/javascript/types/类型分类","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":429,"title":"深度解析 URL Scheme","content":"#\n\n当我们使用移动应用时，我们通常会通过点击链接或按钮来跳转到其他页面或应用。在 iOS 和 Android 系统中，这些链接或按钮是通过 URL Scheme\n实现的。\n\nURL Scheme 是一种在移动设备上通过链接或按钮调用应用程序的机制。它允许开发者在应用程序内部注册特殊的 URL，当用户点击带有该 URL\n的链接或按钮时，系统会自动打开相应的应用程序，并执行相应的操作。\n\n从前端角度来看，当我们在网页中包含了带有 URL Scheme 的链接或按钮时，我们可以使用以下代码来触发它们：\n\n> URL Scheme（Uniform Resource Locator\n> Scheme）是一种标准化的协议，可以用于在应用程序之间传递数据和命令。它在移动应用程序中得到广泛应用，可以让不同应用程序之间实现无缝集成。本文将深入探讨\n> URL Scheme 在前端开发中的应用及其实现方式。\n\n\n\n其中，urlscheme 是应用程序的 URL Scheme，action 是应用程序内部的操作。\n\n除此之外，我们还可以通过 JavaScript 来触发 URL Scheme。例如，以下代码将通过 JavaScript 调用 URL Scheme\n打开邮件应用程序：\n\n\n\n从应用角度来看，URL Scheme 可以实现很多有趣的功能。以下是一些常见的应用场景：\n\n 1. 打开特定的页面\n\n应用程序可以注册一个特定的 URL Scheme，以便在应用程序内部打开特定的页面。例如，Facebook 应用程序可以注册\nfb://scheme，以便在应用程序内部打开用户的个人资料页面：\n\n\n\n 2. 向应用程序传递参数\n\n应用程序可以通过 URL Scheme 接收参数，以便在打开应用程序时执行特定的操作。例如，支付宝可以接收一个参数来打开特定的收款页面：\n\n\n\n 3. 调用其他应用程序\n\n应用程序可以通过 URL Scheme 调用其他应用程序。例如，一个应用程序可以调用地图应用程序来显示某个地点的位置：\n\n\n\n 4. 打开系统设置页面\n\n应用程序可以通过 URL Scheme 打开系统设置页面，以便让用户修改应用程序的设置。例如，以下代码将打开 Wi-Fi 设置页面：\n\n\n\n总的来说，URL Scheme 是移动应用程序中非常有用的机制。它可以使应用程序更加智能化和高效化，同时也为开发者提供了更多的灵活性和创造力。\n\n\nURL Scheme 的基本原理#\n\nURL Scheme 是一种特殊的 URL，它不是用于访问 Web 页面的，而是用于唤起移动应用程序并传递参数。一个 URL Scheme\n包含两个主要部分：Scheme 和 Host。例如，myapp://action?param1=value1¶m2=value2 就是一个 URL\nScheme，其中 Scheme 是 myapp，Host 是 action。\n\n当用户点击一个 URL Scheme\n链接时，操作系统会检查是否有已经安装了该应用程序。如果已经安装，则会打开该应用程序，并将链接中的参数传递给应用程序。如果应用程序没有安装，则无法执行该操作。\n\n\nURL Scheme 的用途#\n\nURL Scheme 可以用于实现许多有用的功能。以下是一些常见的应用：\n\n\n打开应用程序#\n\nURL Scheme 可以用于打开应用程序，这通常用于应用程序之间的集成。例如，如果您的应用程序需要与另一个应用程序共享数据，您可以使用 URL Scheme\n打开该应用程序并将数据传递给它。\n\n\n执行操作#\n\nURL Scheme 还可以用于执行应用程序中的操作。例如，您可以使用 URL Scheme 执行搜索操作、分享操作、支付操作等等。\n\n\n激活特定页面#\n\nURL Scheme 还可以用于激活应用程序中的特定页面。例如，您可以使用 URL Scheme 打开应用程序并转到用户的购物车页面。\n\n\nURL Scheme 的实现方式#\n\nURL Scheme 的实现方式取决于您正在开发的平台和编程语言。以下是一些常见的实现方式：\n\n\nHTML 中使用#\n\n在 HTML 中，您可以使用 标签来创建一个 URL Scheme 链接。例如：\n\n\n\n\nJavaScript 中使用#\n\n在 JavaScript 中，您可以使用 window.location.href 属性来打开一个 URL Scheme 链接。例如：\n\n\n\n\niOS 中使用#\n\n在 iOS 中，您可以使用 UIApplication 类的 openURL: 方法来打开一个 URL Scheme 链接。例如：\n\n\n\n\nAndroid 中使用#\n\n在 Android 中，您可以使用 Intent 类来打开一个 URL Scheme 链接。例如：\n\n\n\n\nURL Scheme 的注冊#\n\n在 iOS 中，要注册自定义的 URL Scheme，需要在 Xcode 中进行以下配置：\n\n 1. 在项目的 Info.plist 文件中，添加一个新的 key，CFBundleURLTypes。\n\n 2. 在 CFBundleURLTypes 中添加一个新的 CFBundleURLName key，用于指定 URL Scheme 的名称。\n\n 3. 在 CFBundleURLTypes 中添加一个新的 CFBundleURLSchemes key，用于指定 URL Scheme 的字符串，例如\n    myapp。\n\n 4. 在 CFBundleURLTypes 中添加一个新的 CFBundleURLTypes key，用于指定 URL Scheme 支持的 URL\n    类型，例如 public.url。\n\n完成以上配置后，就可以在应用程序中使用自定义的 URL Scheme 来进行跳转了。\n\n在 Android 中，要注册自定义的 URL Scheme，需要在 AndroidManifest.xml 文件中进行以下配置：\n\n在 AndroidManifest.xml 文件中添加一个新的 元素，用于指定 URL Scheme 支持的协议。\n\n\n\n其中， 元素用于指定 URL Scheme 的名称， 元素用于指定动作为 VIEW，表示浏览操作， 元素用于指定类别为 DEFAULT 和\nBROWSABLE，表示该 URL Scheme 可以被浏览器调用。\n\n完成以上配置后，就可以在应用程序中使用自定义的 URL Scheme 来进行跳转了。\n\n需要注意的是，自定义的 URL Scheme 可能存在安全隐患，因此建议在使用时进行相应的安全措施，例如限制特定来源的 URL Scheme 调用，对 URL\n参数进行验证等。\n\n除了在应用程序中注册 URL Scheme 以外，还可以通过以下方式进行拓展：\n\n 1. 深度链接深度链接是指将应用程序内的特定内容与 URL Scheme\n    关联起来，以便用户在从其他应用程序或网站中点击链接时，可以直接跳转到对应的内容。深度链接需要在应用程序中进行特定的处理，例如解析 URL\n    参数、显示对应的页面等。\n\n 2. Universal Links Universal Links 是一种新的跳转方式，它能够在应用程序内通过 HTTP/HTTPS\n    协议直接访问应用程序内的特定内容，无需通过 URL Scheme 进行跳转。Universal Links\n    需要在应用程序中进行特定的配置，并在对应的域名中添加特定的配置文件，以便系统能够识别并跳转到应用程序内的内容。\n\n 3. 应用内搜索应用内搜索是指在应用程序内搜索特定的内容，例如商品、文章等，而不需要从其他应用程序或网站中跳转过来。应用内搜索需要在应用程序中进行特定的处理，\n    例如实现搜索逻辑、显示搜索结果等。\n\n总的来说，通过拓展 URL Scheme 的应用，可以实现更加丰富的应用间跳转和内容分享，提高应用程序的使用体验和用户粘性。但同时需要注意安全性和隐私保护，避免\nURL Scheme 被恶意利用。\n\n\nURL Scheme 的使用#\n\nURL Scheme 可以用于在应用程序之间进行跳转和传递数据。下面是 URL Scheme 的一些常见使用场景：\n\n 1. 打开应用程序内特定页面：通过指定 URL Scheme 和相应参数，可以直接打开应用程序内的特定页面，例如打开某个商品的详情页面、用户个人信息页面等。\n\n 2. 启动应用程序并执行特定操作：通过指定 URL Scheme 和相应参数，可以启动应用程序并执行特定操作，例如启动应用程序并执行搜索操作、购买操作等。\n\n 3. 与第三方应用程序进行交互：通过指定 URL Scheme 和相应参数，可以与第三方应用程序进行交互，例如打开某个网页、分享内容等。\n\n需要注意的是，URL Scheme 的使用需要进行相应的安全措施，避免因 URL 参数被恶意篡改而导致安全问题。在应用程序中使用 URL Scheme\n时，需要对 URL 参数进行验证，避免恶意输入或者篡改 URL 参数。例如，可以使用加密算法对 URL 参数进行加密，确保数据安全性。同时，也需要限制特定来源的\nURL Scheme 调用，避免恶意应用程序利用 URL Scheme 进行攻击。\n\n\nURL Scheme 的安全性#\n\nURL Scheme 是一种用于应用程序之间通信的协议，其中包含了用于打开和调用其他应用程序的特定链接。但是，由于 URL Scheme\n是公开的，它们可能会面临一些安全风险。\n\n其中一种常见的安全风险是恶意应用程序可以利用 URL Scheme\n打开其他应用程序并进行恶意操作，比如在用户不知情的情况下访问他们的个人信息或执行一些恶意代码。例如，一个恶意应用程序可能会在用户点击某个看似无害的链接时，利用该\n链接打开其他应用程序，并执行一些危险的操作。\n\n另外，URL Scheme 本身也可能存在一些漏洞和安全问题。例如:\n\n 1. 隐私泄露：通过 URL Scheme\n    打开应用程序可以直接传递参数给应用程序，这些参数可以包含敏感信息。如果不加以限制，这些参数可以被其他应用程序恶意利用，导致隐私泄露问题。\n\n 2. 恶意攻击：由于 URL Scheme 是开放的，任何应用程序都可以使用它来与其他应用程序交互。如果开发人员不加以限制，恶意应用程序可能利用 URL\n    Scheme 对用户进行攻击，例如伪装成其他应用程序来获取用户的敏感信息。\n\n 3. 越权操作：URL Scheme 可以用于直接启动应用程序的某些特定操作，例如发送短信、打电话、发邮件等。如果不加以限制，这些操作可能会被滥用，例如利用\n    URL Scheme 来发送垃圾短信、拨打骚扰电话等。\n\n 4. 为了解决这些安全问题，开发人员需要在实现 URL Scheme 时注意以下几点：\n\n 5. 参数校验：应用程序应该对传入的参数进行有效性校验，避免非法参数的传递。\n\n 6. 权限控制：应用程序应该限制哪些应用程序可以使用自己的 URL\n    Scheme，并且在实现操作时考虑到用户权限的问题，例如发送短信、打电话等操作需要得到用户的明确授权。\n\n 7. 安全认证：在一些敏感操作中，如支付、修改用户信息等操作，应用程序应该对用户进行身份认证，避免恶意攻击。\n\n总之，开发人员需要认真考虑应用程序与其他应用程序的交互方式，避免因 URL Scheme 实现不当导致的安全问题。","routePath":"/posts/javascript/urlScheme","lang":"","toc":[{"text":"URL Scheme 的基本原理","id":"url-scheme-的基本原理","depth":2,"charIndex":1023},{"text":"URL Scheme 的用途","id":"url-scheme-的用途","depth":2,"charIndex":1327},{"text":"打开应用程序","id":"打开应用程序","depth":3,"charIndex":1383},{"text":"执行操作","id":"执行操作","depth":3,"charIndex":1491},{"text":"激活特定页面","id":"激活特定页面","depth":3,"charIndex":1567},{"text":"URL Scheme 的实现方式","id":"url-scheme-的实现方式","depth":2,"charIndex":1646},{"text":"HTML 中使用","id":"html-中使用","depth":3,"charIndex":1714},{"text":"JavaScript 中使用","id":"javascript-中使用","depth":3,"charIndex":1770},{"text":"iOS 中使用","id":"ios-中使用","depth":3,"charIndex":1859},{"text":"Android 中使用","id":"android-中使用","depth":3,"charIndex":1939},{"text":"URL Scheme 的注冊","id":"url-scheme-的注冊","depth":2,"charIndex":2007},{"text":"URL Scheme 的使用","id":"url-scheme-的使用","depth":2,"charIndex":3362},{"text":"URL Scheme 的安全性","id":"url-scheme-的安全性","depth":2,"charIndex":3871}],"domain":"","frontmatter":{"icon":"javascript","description":"深入介绍了 URL Scheme 在前端开发中的作用及实际应用，包括使用场景、实现原理、开发注意事项等，帮助读者更好地理解和使用 URL Scheme。","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>深度解析 URL Scheme 在前端应用中的作用及实际应用","order":3,"star":3,"date":"2024-04-08T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["javascript","URL Scheme"],"tag":["javascript","URL Scheme"],"shortTitle":"深度解析 URL Scheme 在前端应用中的作用及实际应用","head":[["meta",{"name":"keywords","content":"URL Scheme, 前端应用, 应用开发, 实现原理, 使用场景, 注意事项"}]]},"version":""},{"id":430,"title":"JavaScript WebkitSpeechRecognition：使用语音识别技术增强 Web 应用程序","content":"Search","routePath":"/posts/javascript/webkitSpeechRecognition","lang":"","toc":[{"text":"WebkitSpeechRecognition 的基本概念","id":"webkitspeechrecognition-的基本概念","depth":2,"charIndex":-1},{"text":"WebkitSpeechRecognition API 的基本概念如下","id":"webkitspeechrecognition-api-的基本概念如下","depth":3,"charIndex":-1},{"text":"SpeechRecognition 对象：SpeechRecognition 对象是 WebkitSpeechRecognition API 的核心对象，它表示语音识别过程。您可以使用 SpeechRecognition 对象来控制语音识别过程，例如开始识别、停止识别等","id":"speechrecognition-对象speechrecognition-对象是-webkitspeechrecognition-api-的核心对象它表示语音识别过程您可以使用-speechrecognition-对象来控制语音识别过程例如开始识别停止识别等","depth":4,"charIndex":-1},{"text":"语音识别事件：SpeechRecognition 对象会触发多个事件，以便您在语音识别过程中获取信息。例如，onresult 事件会在识别成功后触发，onerror 事件会在识别失败时触发","id":"语音识别事件speechrecognition-对象会触发多个事件以便您在语音识别过程中获取信息例如onresult-事件会在识别成功后触发onerror-事件会在识别失败时触发","depth":4,"charIndex":-1},{"text":"识别结果：语音识别过程的主要输出是识别结果。识别结果是一个包含一个或多个识别的文本字符串的数组。您可以使用识别结果来理解用户说了什么，并相应地更新您的应用程序","id":"识别结果语音识别过程的主要输出是识别结果识别结果是一个包含一个或多个识别的文本字符串的数组您可以使用识别结果来理解用户说了什么并相应地更新您的应用程序","depth":4,"charIndex":-1},{"text":"如何使用 WebkitSpeechRecognition","id":"如何使用-webkitspeechrecognition","depth":2,"charIndex":-1},{"text":"使用 WebkitSpeechRecognition 的示例","id":"使用-webkitspeechrecognition-的示例","depth":2,"charIndex":-1},{"text":"使用语音输入来搜索 Baidu","id":"使用语音输入来搜索-baidu","depth":3,"charIndex":-1},{"text":"Vue 3 代码实现","id":"vue-3-代码实现","depth":3,"charIndex":-1},{"text":"React 代码实现","id":"react-代码实现","depth":3,"charIndex":-1},{"text":"WebkitSpeechRecognition 的局限性","id":"webkitspeechrecognition-的局限性","depth":2,"charIndex":-1},{"text":"WebkitSpeechRecognition 兼容性","id":"webkitspeechrecognition-兼容性","depth":2,"charIndex":-1},{"text":"结论","id":"结论","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"javascript","description":"JavaScript WebkitSpeechRecognition：使用语音识别技术增强Web应用程序","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>JavaScript WebkitSpeechRecognition：使用语音识别技术增强Web应用程序","order":3,"star":3,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["javascript","webkitSpeechRecognition"],"tag":["javascript","webkitSpeechRecognition"],"shortTitle":"JavaScript WebkitSpeechRecognition：使用语音识别技术增强Web应用程序","head":[["meta",{"name":"keywords","content":"JavaScript WebkitSpeechRecognition：使用语音识别技术增强Web应用程序"}]]},"version":""},{"id":431,"title":"如何编写 JavaScript 引擎？","content":"#\n\nJavaScript 引擎是解释和执行 JavaScript 代码的核心组件。\n\n\n词法分析器#\n\n词法分析器是编译器中的一个重要组成部分，其作用是将源程序中的字符流转换为词法单元流，以便后续的语法分析。设计词法分析器的基本步骤如下：\n\n 1. 确定词法单元的类型和模式词法单元是源程序中的最小语法单位，例如标识符、关键字、常量、运算符等。在设计词法分析器时，需要确定每种词法单元的类型和对应的正则\n    表达式模式，以便识别源程序中的词法单元。\n\n例如，对于一个简单的算术表达式语言，可以定义如下的词法单元类型和模式：\n\n * 标识符：以字母或下划线开头，后跟任意个字母、数字或下划线。\n * 数字常量：一个或多个数字组成的字符串。\n * 运算符：加号、减号、乘号、除号等。\n * 左右括号：左括号、右括号。\n\n 2. 编写正则表达式模式确定词法单元类型和模式后，需要编写对应的正则表达式模式，以便识别源程序中的词法单元。正则表达式是一种描述字符串模式的语言，可以用来匹配\n    符合某种模式的字符串。\n\n例如，对于标识符，可以使用正则表达式[a-zA-Z_][a-zA-Z0-9_]*来匹配以字母或下划线开头、后跟任意个字母、数字或下划线的字符串。\n\n 3. 实现词法分析器在实现词法分析器时，可以使用自动机或递归下降分析等算法，对源程序进行扫描和识别。具体实现方式可以参考以下步骤：\n\n * 读入源程序字符流，逐个字符进行扫描。\n * 对每个字符进行分类，判断其属于哪种词法单元。\n * 根据词法单元类型和模式，使用正则表达式进行匹配。\n * 如果匹配成功，则生成对应的词法单元，并将其加入词法单元流中；否则，报告词法错误。\n\n 4. 输出词法单元流在词法分析器完成扫描和识别后，需要将生成的词法单元流输出给后续的语法分析器。词法单元流可以使用链表、数组等数据结构来表示。\n\n例如，对于一个简单的算术表达式语言，源程序\"1+2*(3-4)\"的词法单元流可以表示为：\n\n类型     值\n数字常量   1\n运算符    +\n数字常量   2\n运算符    *\n左括号    (\n数字常量   3\n运算符    -\n数字常量   4\n右括号    )\n\n\n设计词法分析器#\n\n词法分析器是编译器的一个重要组成部分，用于将源代码转换成标记流（Token Stream）。下面是一个简单的词法分析器的设计：\n\n 1. 定义 Token 类，用于表示标记。Token 类应该包含以下属性：\n\n * type：标记类型，例如关键字、标识符、运算符等。\n * value：标记的值，例如标识符的名称、数字的值等。\n * line：标记所在的行号。\n\n 2. 定义词法分析器类，用于将源代码转换成标记流。词法分析器类应该包含以下方法：\n\n * getNextToken()：从源代码中读取下一个标记，并返回一个 Token 对象。\n * tokenize()：将整个源代码转换成标记流。\n\n 3. 在 getNextToken()方法中，可以按照以下步骤进行：\n\n * 跳过空格、制表符、换行符等空白字符。\n * 判断当前字符是否为数字，如果是数字则读取整个数字，并返回一个数字类型的 Token 对象。\n * 判断当前字符是否为字母，如果是字母则读取整个标识符，并判断是否为关键字，如果是则返回一个关键字类型的 Token 对象，否则返回一个标识符类型的\n   Token 对象。\n * 判断当前字符是否为运算符，如果是则返回一个运算符类型的 Token 对象。\n * 如果当前字符不是数字、字母或运算符，则返回一个未知类型的 Token 对象。\n\n 4. 在 tokenize()方法中，可以按照以下步骤进行：\n\n * 读取整个源代码。\n * 循环调用 getNextToken()方法，直到读取完所有的标记。\n * 返回一个包含所有 Token 对象的数组。\n\n\n设计语法分析器#\n\n语法分析器是编译器的另一个重要组成部分，用于将标记流转换成抽象语法树（Abstract Syntax Tree，AST）。下面是一个简单的语法分析器的设计：\n\n 1. 定义 AST 节点类，用于表示抽象语法树的节点。AST 节点类应该包含以下属性：\n\n * type：节点类型，例如表达式、语句、变量声明等。\n * value：节点的值，例如变量名、常量值等。\n * children：子节点列表，用于表示节点的子节点。\n\n 2. 定义语法分析器类，用于将标记流转换成抽象语法树。语法分析器类应该包含以下方法：\n\n * parse()：解析标记流，并返回一个 AST 根节点。\n * 在 parse()方法中，可以按照以下步骤进行：\n\n 3. 读取标记流中的第一个标记，并根据标记的类型创建一个根节点。\n\n * 根据语法规则，递归调用子节点的解析方法，创建子节点，并将子节点添加到根节点的子节点列表中。\n * 如果当前标记不符合语法规则，则抛出语法错误异常。\n * 重复步骤 2 和 3，直到解析完整个标记流。\n\n 4. 在 AST 节点类中，可以定义一些辅助方法，例如：\n\n * isLeaf()：判断当前节点是否为叶子节点。\n * getChildren()：返回当前节点的子节点列表。\n * getType()：返回当前节点的类型。\n * getValue()：返回当前节点的值。以上是一个简单的语法分析器的设计，实际上还需要考虑很多细节，例如处理优先级、左结合性、右结合性等特殊情况。\n\n\n实现 JavaScript 运行时#\n\n实现 JavaScript 运行时需要实现以下几个部分：\n\n 1. 词法分析器：读取 JavaScript 代码并将其转换成标记流（Token Stream）。\n\n 2. 语法分析器：将标记流转换成抽象语法树（Abstract Syntax Tree，AST）。\n\n 3. 执行引擎：遍历抽象语法树，并执行其中的代码。\n\n 4. 内置对象和函数：实现 JavaScript 的内置对象和函数，例如 Object、Array、Function 等。\n    \n    下面是一个简单的 JavaScript 运行时的实现：\n    \n    1. 词法分析器：使用正则表达式匹配 JavaScript 代码中的标记，并返回一个标记流（Token Stream）。\n    \n    2. 语法分析器：使用递归下降算法（Recursive Descent Parsing）将标记流转换成抽象语法树（Abstract Syntax\n       Tree，AST）。\n    \n    3. 执行引擎：遍历抽象语法树，并执行其中的代码。\n    * 对于变量声明语句，创建一个变量并赋初值，将变量存入当前作用域中。\n    * 对于赋值语句，找到变量，并将其值赋为表达式的值。\n    * 对于表达式语句，计算表达式的值并忽略结果。\n    * 对于条件语句（if 语句），根据条件表达式的值判断执行哪个分支。\n    * 对于循环语句（for、while 语句），根据条件表达式的值判断是否执行循环体。\n    * 对于函数声明语句，创建一个函数对象并将其存入当前作用域中。\n    * 对于函数调用表达式，找到函数，并执行函数体。\n    * 对于对象属性访问表达式，找到对象并获取属性值。\n    * 对于数组元素访问表达式，找到数组并获取元素值。\n    4. 内置对象和函数：实现 JavaScript 的内置对象和函数，例如 Object、Array、Function 等。可以使用 JavaScript\n       语言本身来实现这些内置对象和函数。\n\n以上是一个简单的 JavaScript 运行时的实现，实际上还需要考虑很多细节，例如作用域、闭包、类型转换等特殊情况。\n\n\n实现 JavaScript 解释器#\n\nJavaScript 解释器的设计应该包括以下几个部分：\n\n\n词法分析器：将 JavaScript 代码转换为标记流#\n\n词法分析（Lexical Analysis）：将代码分解成单个的词法单元（tokens），例如关键字、标识符、运算符等。这可以通过正则表达式或手写解析器实现\n\n\n语法分析器：将标记流转换为语法树#\n\n语法分析（Parsing）：将词法单元转换成语法树（Abstract Syntax Tree，AST），并检查语法错误。这可以通过手写递归下降解析器、LL 或\nLR 分析器等实现。\n\n\n语义分析器：对语法树进行语义分析#\n\n语义分析（Semantic Analysis）：对 AST 进行语义分析，检查类型、作用域、函数调用等。这可以通过遍历 AST 并应用静态或动态分析算法实现。\n\n\n执行器：执行语法树并输出结果#\n\n将 AST 转换成可执行的机器代码或字节码。这可以通过直接解释、编译成本地代码或编译成中间代码并交给虚拟机执行等方式实现。\n\n点击查看 JavaScript 解释器的实现\n\n\n\n\n实现 JavaScript 编译器#\n\n\n词法编译器（Lexical Analyzer）#\n\n词法编译器（Lexical\nAnalyzer）也被称为词法分析器（Lexer），是编译器中的一个组件，用于将源代码转换为令牌（Token）序列。令牌是编程语言中的基本单元，它们由词素（Le\nxeme）和令牌类型（Token Type）组成。\n\n词法编译器通常由两个主要部分组成：令牌定义和扫描器。令牌定义是一组正则表达式，用于描述编程语言中的各种令牌类型。扫描器则根据这些正则表达式，对源代码进行扫描，并\n将其转换为令牌序列。\n\n点击查看词法编译器的实现\n\n\n\n定义了一组令牌类型，包括标识符、数字、运算符、标点符号和关键字。然后，我们使用正则表达式和数组常量来定义这些令牌类型的规则。\n\ntokenize 函数中，遍历源代码中的每个字符，并根据其类型生成相应的令牌。例如，如果字符是数字，则我们将其解析为数字令牌，并将其添加到令牌序列中。\n\n\n代码生成器：将语法树转换为可执行的机器代码#\n\n代码生成器（Code Generator）是编译器中的一个组件，用于将抽象语法树（AST）转换为目标代码，例如机器代码、字节码或其他编程语言的代码。\n\n代码生成器通常由两个主要部分组成：代码生成规则和代码生成器。代码生成规则是一组规则，用于描述如何将 AST 节点转换为目标代码。代码生成器则根据这些规则，对\nAST 节点进行遍历，并将其转换为目标代码。\n\n点击查看代码生成器的实现\n\n\n\n\n执行器：执行机器代码并输出结果#\n\n执行器（Executor）是编译器中的一个组件，用于执行目标代码，例如机器代码或字节码，并输出结果。执行器通常由两个主要部分组成：解释器和虚拟机。\n\n解释器是一种直接执行目标代码的方法，它将目标代码逐条解释并执行。虚拟机是一种模拟计算机硬件的方法，它将目标代码转换为一组指令，并在虚拟计算机上执行这些指令。\n\n点击查看 JavaScript 编译器的实现\n\n\n\n在这个例子中，我们定义了一个 execute 函数，它接受一个 JavaScript\n源代码字符串作为输入，并将其编译为目标代码，然后使用虚拟机执行目标代码，并输出结果。\n\n在 createVM 函数中，我们定义了一组虚拟机指令，包括\nLOAD（将常量加载到栈中）、ADD（将栈顶两个值相加）、SUB（将栈顶两个值相减）、MUL（将栈顶两个值相乘）、DIV（将栈顶两个值相除）和\nPRINT（打印栈顶的值）。然后，我们使用一个简单的栈来模拟虚拟机的堆栈，并在 run 函数中执行指令序列。\n\n在 execute 函数中，我们首先将源代码编译为目标代码，然后将其解析为指令序列，并使用 createVM 函数创建一个虚拟机。最后，我们调用虚拟机的 run\n函数，执行指令序列，并输出结果。","routePath":"/posts/js-engine","lang":"","toc":[{"text":"词法分析器","id":"词法分析器","depth":2,"charIndex":44},{"text":"设计词法分析器","id":"设计词法分析器","depth":2,"charIndex":933},{"text":"设计语法分析器","id":"设计语法分析器","depth":2,"charIndex":1634},{"text":"实现 JavaScript 运行时","id":"实现-javascript-运行时","depth":2,"charIndex":2293},{"text":"实现 JavaScript 解释器","id":"实现-javascript-解释器","depth":2,"charIndex":3257},{"text":"词法分析器：将 JavaScript 代码转换为标记流","id":"词法分析器将-javascript-代码转换为标记流","depth":3,"charIndex":3308},{"text":"语法分析器：将标记流转换为语法树","id":"语法分析器将标记流转换为语法树","depth":3,"charIndex":3419},{"text":"语义分析器：对语法树进行语义分析","id":"语义分析器对语法树进行语义分析","depth":3,"charIndex":3531},{"text":"执行器：执行语法树并输出结果","id":"执行器执行语法树并输出结果","depth":3,"charIndex":3632},{"text":"实现 JavaScript 编译器","id":"实现-javascript-编译器","depth":2,"charIndex":3739},{"text":"词法编译器（Lexical Analyzer）","id":"词法编译器lexical-analyzer","depth":3,"charIndex":3760},{"text":"代码生成器：将语法树转换为可执行的机器代码","id":"代码生成器将语法树转换为可执行的机器代码","depth":3,"charIndex":4159},{"text":"执行器：执行机器代码并输出结果","id":"执行器执行机器代码并输出结果","depth":3,"charIndex":4379}],"domain":"","frontmatter":{"icon":"question","description":"前端物语|如何编写JavaScript引擎？","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>前端物语|如何编写JavaScript引擎？","order":3,"star":3,"date":"2022-10-07T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["engine","javascript"],"tag":["engine","javascript"],"shortTitle":"前端物语|如何编写JavaScript引擎？","isOriginal":false,"head":[["meta",{"name":"keywords","content":"前端物语|如何编写JavaScript引擎？"}]]},"version":""},{"id":432,"title":"模块化","content":"什么是模块化？\n\n百度百科中的解释: 模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性，分别反映其内部特性。\n\n在编程中\n模块化是将一个复杂的应用程序，按照一定的规则拆分成若干个文件(代码块)，并进行组合。文件内部的数据与实现都是私有的，只是对外暴露一些接口(方法、变量)与其他模块\n进行通信\n\n模块化的好处\n\n * 避免命名空间的冲突\n * 提高代码的复用性\n * 提高维护性\n * 更好的分离，实现按需加载\n\n目前前端主流的模块规范是\n\n * CommonJS\n * ESModule\n * AMD\n * CMD\n * UMD\n\n\nCommonJS#\n\nCommonJS 规范是一种同步加载模块的方式，其主要用于服务端，即 Node 中的\n\n * module.exports 用于规定当前模块对外输出的接口\n * exports 是 module.exports 属性的引用\n * require 用于加载模块文件(读入并执行一个 JavaScript 文件并返回该模块的 exports 对象)\n\n\n\nexports 和 module.exports\n * exports 是 module 对象的一个属性\n * exports 是 module.exports 的一个引用，在默认情况下 module.exports 和 exports 指向同一个空对象\n * 模块导出的是 module.exports\n\nCommonJS 模块的特点\n * 所有代码都运行在模块作用域，不会污染全局作用域\n * 模块可以多次加载，但只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载时就直接读取缓存结果。要想让模块再次运行必须清除缓存\n * 模块加载的顺序按其在代码中出现的顺序\n\n\nESModule#\n\nESModule 是 ES6 在语言标准的层面上实现的模块功能，主要由 export 和 import 构成\n\n * export 命令用于规定模块的对外接口\n * import 命令用于输入其他模块提供的功能\n\nES6 常用知识 —— ESModule\n\nESModule 与 CommonJS 的差异\n * CommonJS 是动态语法可以写在判断里；ESModule 静态语法只能写在顶层\n * CommonJS 模块输出的是一个值的拷贝；ESModule 输出的是值的引用\n   * CommonJS 模块一旦输出一个值模块内部的变化就影响不到这个值\n   * ESModule 模块在 JavaScript 引擎对脚本静态分析时，遇到模块加载命令\n     import，就会生成一个只读引用，等到脚本真正执行时再根据这个只读引用到被加载的那个模块里面去取值(ESModule\n     是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块)\n * CommonJS 模块是运行时加载；ESModule 是编译时输出接口。\n   * CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成\n   * ESModule 不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成\n * CommonJS 模块的 require() 是同步加载模块；ESModule 的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。\n * 顶层的 this 指向不同\n   * CommonJS 模块中的顶层 this 指向模块本身\n   * ESModule 模块中的顶层 this 指向 undefined\n * 模块的循环加载\n   * CommonJS 模块在加载模块后就会执行整个脚本并在内存生成一个对象，当出现某个模块被\"循环加载\"，就只输出已经执行的部分，还未执行的部分不会输出\n   * ESModule 根本不会关心是否发生了\"循环加载\"，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。\n\n\nAMD#\n\nAMD 规范全称是 Asynchronous Module Definition，即异步模块定义，主要用于浏览器。 AMD\n规范完整描述了模块的定义、依赖关系、引用关系以及加载机制。其代表库是 RequireJS\n\n\n相关 api 及使用#\n\n * define(): 定义模块\n * require(): 调用模块\n\n\n\n\nCMD#\n\nCMD 规范全称是 Common Module Definition，即通用模块定义，其代表库是 SeaJS\n\n> CMD 规范是在 AMD 规范的基础上改进的一种规范，其解决了 AMD 规范对依赖模块的执行时机的问题\n\n\n相关 api 及使用#\n\n * define(): 定义模块\n * seajs.use(): 调用模块\n\n\n\nAMD 和 CMD 的区别\n * AMD\n   * 依赖前置: 在定义模块的时需要声明其依赖的模块\n   * 在加载模块完成后就会执行该模块，当所有模块都加载执行完后会进入 require 的回调函数执行主逻辑\n * CMD\n   * 就近依赖: 只有当用到某个具体模块时再去加载\n   * 加载完某个依赖模块后并不执行，当所有依赖模块加载完成后进入主逻辑，遇到 require 语句的时候才执行对应的模块\n\n两者最大的区别是对依赖模块的执行时机处理不同\n\n\nUMD#\n\nUMD 只是一种通用的写法，是为了解决当时存在多种流行而不统一的规范而产生的一种通用规范 UMD 实际是 AMD + CommonJS + 全局变量\n这三种规范的结合\n\n\n\n\n相关文章#\n\n深入 CommonJs 与 ES6 Module","routePath":"/posts/module","lang":"","toc":[{"text":"CommonJS","id":"commonjs","depth":2,"charIndex":282},{"text":"ESModule","id":"esmodule","depth":2,"charIndex":760},{"text":"AMD","id":"amd","depth":2,"charIndex":1681},{"text":"相关 api 及使用","id":"相关-api-及使用","depth":3,"charIndex":1796},{"text":"CMD","id":"cmd","depth":2,"charIndex":1850},{"text":"相关 api 及使用","id":"相关-api-及使用-1","depth":3,"charIndex":1968},{"text":"UMD","id":"umd","depth":2,"charIndex":2253},{"text":"相关文章","id":"相关文章","depth":2,"charIndex":2347}],"domain":"","frontmatter":{"icon":"module","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"es6","tag":"es6","title":"模块化","star":true},"version":""},{"id":433,"title":"react","content":"概念#\n\n 1.  什么是不可变数据 - React 强调的『不可变数据结构』怎么实现?\n 2.  各流派 React 状态管理对比和原理实现\n 3.  在无状态组件每一次函数上下文执行的时候，react 用什么方式记录了 hooks 的状态？\n 4.  多个 react-hooks 用什么来记录每一个 hooks 的顺序的 ？ 换个问法！为什么不能条件语句中，声明 hooks? hooks\n     声明为什么在组件的最顶部？\n 5.  function 函数组件中的 useState，和 class 类组件 setState 有什么区别？\n 6.  react 是怎么捕获到 hooks 的执行上下文，是在函数组件内部的？\n 7.  useEffect,useMemo 中，为什么 useRef 不需要依赖注入，就能访问到最新的改变值？\n 8.  useMemo 是怎么对值做缓存的？如何应用它优化性能？\n 9.  为什么两次传入 useState 的值相同，函数组件不更新?\n 10. ...\n\n\n收藏夹#\n\n * 「react 进阶」年终送给 react 开发者的八条优化建议(篇幅较长，占用 20-30 分钟)\n * Build your own React\n * React 技术揭秘\n * 对 react 相关代码库以及框架的源码进行了一定的分析","routePath":"/posts/react/README","lang":"","toc":[{"text":"概念","id":"概念","depth":2,"charIndex":-1},{"text":"收藏夹","id":"收藏夹","depth":2,"charIndex":454}],"domain":"","frontmatter":{"icon":"react","title":"react","heroText":"h7ml","link":"/intro.html#代码演示","date":"2022-01-27T00:00:00.000Z","author":"h7ml","category":"react","dir":{"order":9},"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml"},"version":""},{"id":434,"title":"concurrent","content":"concurrent 模式#\n\n\nreact diff 原理#\n\n * The Plan for React 18\n * 为数据获取挂起——描述了一种在 React\n   组件中获取数据的新机制。https://reactjs.org/docs/concurrent-mode-suspense.html\n * 并发用户界面模式——展示了一些基于并发模式和挂起模式的用户界面模式。https://reactjs.org/docs/concurrent-mode-pa\n   tterns.html\n * 采用并发模式——说明了如何在项目中尝试并发模式。https://reactjs.org/docs/concurrent-mode-adoption.htm\n   l\n * 并发模式 API 参考——实验版本中可用的新 API\n   文档。https://reactjs.org/docs/concurrent-mode-reference.html","routePath":"/posts/react/concurrent","lang":"","toc":[{"text":"concurrent 模式","id":"concurrent-模式","depth":2,"charIndex":-1},{"text":"react diff 原理","id":"react-diff-原理","depth":3,"charIndex":16}],"domain":"","frontmatter":{"icon":"react","order":5,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"concurrent","category":"react","tag":["react","concurrent"],"star":true,"lastUpdated":false},"version":""},{"id":435,"title":"diff","content":"react diff 原理#\n\n\n概念#\n\n调和函数(源码)是在fiber树构(对比更新)过程中对旧fiber节点与新reactElement进行比较, 判定旧fiber节点是否可以复用的一个比较函数.\n\n调和函数仅是fiber树构造过程中的一个环节, 所以在深入理解这个函数之前, 建议对fiber树构造有一个宏观的理解(可以参考前文 fiber\n树构造(初次创建), fiber 树构造(对比更新), 本节重点探讨其算法的实现细节.\n\n它的主要作用:\n\n 1. 给新增,移动,和删除节点设置fiber.flags(新增, 移动: Placement, 删除: Deletion)\n 2. 如果是需要删除的fiber, 除了自身打上Deletion之外,\n    还要将其添加到父节点的effects链表中(正常副作用队列的处理是在completeWork函数, 但是该节点(被删除)会脱离fiber树,\n    不会再进入completeWork阶段, 所以在beginWork阶段提前加入副作用队列).\n\n\n特性#\n\n算法复杂度低, 从上至下比较整个树形结构, 时间复杂度被缩短到 O(n)\n\n\n基本原理#\n\n 1. 比较对象: fiber对象与ReactElement对象相比较.\n    * 注意: 此处有一个误区, 并不是两棵 fiber 树相比较, 而是旧fiber对象与新ReactElement对象向比较,\n      结果生成新的fiber子节点.\n    * 可以理解为输入ReactElement, 经过reconcileChildren()之后, 输出fiber.\n 2. 比较方案:\n    * 单节点比较\n    * 可迭代节点比较\n\n单节点比较#\n\n单节点的逻辑比较简明, 先直接看源码:\n\n\n\n 1. 如果是新增节点, 直接新建 fiber, 没有多余的逻辑\n 2. 如果是对比更新\n    * 如果key和type都相同(即: ReactElement.key === Fiber.key 且 Fiber.elementType ===\n      ReactElement.type), 则复用\n    * 否则新建\n\n注意: 复用过程是调用useFiber(child, element.props)创建新的fiber对象, 这个新fiber对象.stateNode =\ncurrentFirstChild.stateNode, 即stateNode属性得到了复用, 故 DOM 节点得到了复用.\n\n\n可迭代节点比较(数组类型, [Symbol.iterator]=fn,[@@iterator]=fn)#\n\n可迭代节点比较, 在源码中被分为了 2 个部分:\n\n\n\n其中reconcileChildrenArray函数(针对数组类型)和reconcileChildrenIterator(针对可迭代类型)的核心逻辑几乎一致,\n下文将分析reconcileChildrenArray()函数. 如果是新增节点, 所有的比较逻辑都无法命中, 只有对比更新过程, 才有实际作用,\n所以下文重点分析对比更新的情况.\n\n\n\nreconcileChildrenArray函数源码看似很长, 梳理其主干之后, 其实非常清晰.\n\n通过形参, 首先明确比较对象是currentFirstChild: Fiber | null和newChildren: Array<*>:\n\n * currentFirstChild: 是一个fiber节点, 通过fiber.sibling可以将兄弟节点全部遍历出来.\n   所以可以将currentFirstChild理解为链表头部, 它代表一个序列, 源码中被记为oldFiber.\n * newChildren: 是一个数组, 其中包含了若干个ReactElement对象. 所以newChildren也代表一个序列.\n\n所以reconcileChildrenArray实际就是 2 个序列之间的比较(链表oldFiber和数组newChildren),\n最后返回合理的fiber序列.\n\n上述代码中, 以注释分割线为界限, 整个核心逻辑分为 2 步骤:\n\n 1. 第一次循环: 遍历最长公共序列(key 相同), 公共序列的节点都视为可复用\n    * 如果newChildren序列被遍历完, 那么oldFiber序列中剩余节点都视为删除(打上Deletion标记)\n    * 如果oldFiber序列被遍历完, 那么newChildren序列中剩余节点都视为新增(打上Placement标记)\n 2. 第二次循环: 遍历剩余非公共序列, 优先复用 oldFiber 序列中的节点\n    * 在对比更新阶段(非初次创建fiber, 此时shouldTrackSideEffects被设置为 true). 第二次循环遍历完成之后,\n      oldFiber序列中没有匹配上的节点都视为删除(打上Deletion标记)\n\n假设有如下图所示 2 个初始化序列:\n\n\n\n接下来第一次循环, 会遍历公共序列A,B, 生成的 fiber 节点fiber(A), fiber(B)可以复用.\n\n\n\n最后第二次循环, 会遍历剩余序列E,C,X,Y:\n\n * 生成的 fiber 节点fiber(E), fiber(C)可以复用. 其中fiber(C)节点发生了位移(打上Placement标记).\n * fiber(X), fiber(Y)是新增(打上Placement标记).\n * 同时oldFiber序列中的fiber(D)节点确定被删除(打上Deletion标记).\n\n\n\n整个主干逻辑就介绍完了, 接下来贴上完整源码\n\n> 第一次循环\n\n\n\n> 第二次循环\n\n\n\n\n结果#\n\n无论是单节点还是可迭代节点的比较, 最终的目的都是生成下级子节点. 并在reconcileChildren过程中, 给一些有副作用的节点(新增, 删除,\n移动位置等)打上副作用标记, 等待 commit 阶段(参考 fiber 树渲染的处理.\n\n\n总结#\n\n本节介绍了 React 源码中, fiber构造循环阶段用于生成下级子节点的reconcileChildren函数(函数中的算法被称为调和算法),\n并演示了可迭代节点比较的图解示例. 该算法十分巧妙, 其核心逻辑把newChildren序列分为 2 步遍历, 先遍历公共序列, 再遍历非公共部分,\n同时复用oldFiber序列中的节点.","routePath":"/posts/react/diff","lang":"","toc":[{"text":"react diff 原理","id":"react-diff-原理","depth":2,"charIndex":-1},{"text":"概念","id":"概念","depth":3,"charIndex":16},{"text":"特性","id":"特性","depth":3,"charIndex":456},{"text":"基本原理","id":"基本原理","depth":3,"charIndex":500},{"text":"单节点比较","id":"单节点比较","depth":4,"charIndex":732},{"text":"可迭代节点比较(数组类型, [Symbol.iterator]=fn,[@@iterator]=fn)","id":"可迭代节点比较数组类型-symboliteratorfniteratorfn","depth":3,"charIndex":1070},{"text":"结果","id":"结果","depth":3,"charIndex":2415},{"text":"总结","id":"总结","depth":2,"charIndex":2544}],"domain":"","frontmatter":{"icon":"react","order":4,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"diff","category":"react","tag":["react","diff"],"star":true,"lastUpdated":false},"version":""},{"id":436,"title":"hook-api","content":"useEffect 依赖执行关系#\n\nuseEffect 第二个参数[]如何影响 fn 的执行？换句话说，它的第二个参数是如何影响 fiber 创建 Passive Effect 的？\n\n 1. 不包含第二个参数 useEffect(() => {})，Mount & Update 时，每次 render 时都会创建一个 Passive\n    Effect;\n 2. 包含一个空数组[]作为依赖项 useEffect(() => {}, [])，它会在 mount 时，创建 Passive Effect\n 3. 包含一个依赖项[dep]，它会在 mount 时，dep 依赖项变化时，创建 Passive Effect\n\n\nfn 和 componentDidMount 的执行时机分别是什么？#\n\n过程\n\nrender 阶段到 commit 阶段，传递的时包含不同 fiber 节点的 effect 的链表，commit 阶段时将状态变化（Effect）渲染在视图中\n\n * 渲染视图前，beforeMutation 阶段\n * 渲染视图中，mutation 阶段，Placement 会执行 appendChild，DOM 节点插入到视图中\n * 渲染视图后，layout 阶段，调用 componentDidMount\n\n 1. useEffect 时 commit 完成后异步调用\n 2. componentDidMount 是 commit 阶段完成视图更新（mutation 阶段）后，在 layout 阶段同步调用\n 3. useLayoutEffect 和 componentDidMount 调用时机一致，也是在 layout 阶段同步调用\n\n\n\n\n相关文章#\n\n * React Hooks: 深入剖析 useMemo 和 useEffect","routePath":"/posts/react/hook-api","lang":"","toc":[{"text":"useEffect 依赖执行关系","id":"useeffect-依赖执行关系","depth":2,"charIndex":-1},{"text":"fn 和 componentDidMount 的执行时机分别是什么？","id":"fn-和-componentdidmount-的执行时机分别是什么","depth":2,"charIndex":314},{"text":"相关文章","id":"相关文章","depth":2,"charIndex":735}],"domain":"","frontmatter":{"icon":"react","order":2,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"hook-api","category":"react","tag":["react","hook"],"star":true,"lastUpdated":false},"version":""},{"id":437,"title":"hook","content":"react hook 原理#\n\n * Hook 原理(概览)\n * hook 的实现\n\n讲 hooks 之前提出一个问题：为什么 hooks 不能写在条件语句之中？\n\n我们在初始化 hooks 的时候，fiber 的结构是长什么样的呢？\n\n\n\n当我们执行 updateNum 怎么去更新我们的应用呢？\n\n如上，创建一个 hooks 链表结构，存储在 fiber 的 memoizedState 属性上，next 指针指向下一个 hooks\n\n\n创建更新对象#\n\n\n\n对于 App 来说，点击 p 标签产生的 update 的 action 为 num => num + 1。\n\n如果我们改写下 App 的 onClick：\n\n\n\n那么点击 p 标签会产生三个 update。\n\n\n合并更新#\n\n这些 update 是如何组合在一起呢？\n\n答案是：他们会形成环状单向链表。\n\n\n\n环状链表操作不太容易理解，这里我们详细讲解下。\n\n当产生第一个update（我们叫他u0），此时queue.pending === null。\n\nupdate.next = update;即u0.next = u0，他会和自己首尾相连形成单向环状链表。\n\n然后queue.pending = update;即queue.pending = u0\n\n\n\n当产生第二个update（我们叫他u1），update.next = queue.pending.next;，此时queue.pending.next ===\nu0，即u1.next = u0。\n\nqueue.pending.next = update;，即u0.next = u1。\n\n然后queue.pending = update;即queue.pending = u1\n\n\n\n你可以照着这个例子模拟插入多个update的情况，会发现queue.pending始终指向最后一个插入的update。\n\n这样做的好处是，当我们要遍历update时，queue.pending.next指向第一个插入的update。\n\n\n简单实现#\n\n详情略...\n\n","routePath":"/posts/react/hook","lang":"","toc":[{"text":"react hook 原理","id":"react-hook-原理","depth":2,"charIndex":-1},{"text":"创建更新对象","id":"创建更新对象","depth":3,"charIndex":221},{"text":"合并更新","id":"合并更新","depth":3,"charIndex":339},{"text":"简单实现","id":"简单实现","depth":3,"charIndex":875}],"domain":"","frontmatter":{"icon":"react","order":1,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"hook","category":"react","tag":["react","hook"],"star":true,"lastUpdated":false},"version":""},{"id":438,"title":"immer","content":"react immer 不可变数据#\n\n * 阮一峰 ECMAScript 6 入门\n * 带你重学 ES6 | proxy\n * 带你重学 ES6 | Reflect\n * 实现双向绑定 Proxy 比 defineproperty 优劣如何?\n\n\n为什么强调不可变数据#\n\n\n\n如上，点击后就会发现 obj 引用没变，但是 obj.others.age 修改了，然后也被重新渲染了，这是由于这就是引用类型的副作用导致的。\n\n解决方案\n\n 1. 浅复制：只能复制一层\n 2. 深克隆：我们不仅要考虑到正则、Symbol、Date 等特殊类型,还要考虑到原型链和循环引用的处理，性能消耗大！\n 3. 深克隆的的性能相比于浅克隆大打折扣,但是浅克隆又不能从根本上杜绝引用类型的副作用，使用 immutable：\n    * 即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\n\n\n实现简单的 immutable#\n\nimmer 用法举例： const nextState = produce(state, (draft) => {});\n\n\n\n执行结果：\n\n\n\n\ndefineProperty vs Proxy#\n\n这个没特别的深入，\n\n 1. defineProperty 无法监听数组变化 比如 arr[1] = 2; 如果需要监听\n 2. defineProperty\n    只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。\n 3. Proxy 可以直接监听对象而非属性,Proxy 的劣势就是兼容性问题,而且无法用 polyfill 磨平","routePath":"/posts/react/immer","lang":"","toc":[{"text":"react immer 不可变数据","id":"react-immer-不可变数据","depth":2,"charIndex":-1},{"text":"为什么强调不可变数据","id":"为什么强调不可变数据","depth":3,"charIndex":125},{"text":"实现简单的 immutable","id":"实现简单的-immutable","depth":3,"charIndex":406},{"text":"defineProperty vs Proxy","id":"defineproperty-vs-proxy","depth":3,"charIndex":498}],"domain":"","frontmatter":{"icon":"react","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"immer","category":"react","tag":["react","immer"],"star":true,"lastUpdated":false},"version":""},{"id":439,"title":"react","content":"概念#\n\n 1.  什么是不可变数据 - React 强调的『不可变数据结构』怎么实现?\n 2.  各流派 React 状态管理对比和原理实现\n 3.  在无状态组件每一次函数上下文执行的时候，react 用什么方式记录了 hooks 的状态？\n 4.  多个 react-hooks 用什么来记录每一个 hooks 的顺序的 ？ 换个问法！为什么不能条件语句中，声明 hooks? hooks\n     声明为什么在组件的最顶部？\n 5.  function 函数组件中的 useState，和 class 类组件 setState 有什么区别？\n 6.  react 是怎么捕获到 hooks 的执行上下文，是在函数组件内部的？\n 7.  useEffect,useMemo 中，为什么 useRef 不需要依赖注入，就能访问到最新的改变值？\n 8.  useMemo 是怎么对值做缓存的？如何应用它优化性能？\n 9.  为什么两次传入 useState 的值相同，函数组件不更新?\n 10. ...\n\n\n收藏夹#\n\n * 「react 进阶」年终送给 react 开发者的八条优化建议(篇幅较长，占用 20-30 分钟)\n * Build your own React\n * React 技术揭秘\n * 对 react 相关代码库以及框架的源码进行了一定的分析","routePath":"/posts/react/","lang":"","toc":[{"text":"概念","id":"概念","depth":2,"charIndex":-1},{"text":"收藏夹","id":"收藏夹","depth":2,"charIndex":454}],"domain":"","frontmatter":{"icon":"react","title":"react","heroText":"h7ml","link":"/intro.html#代码演示","date":"2022-01-27T00:00:00.000Z","author":"h7ml","category":"react","dir":{"order":9},"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml"},"version":""},{"id":440,"title":"使用 react-query 让状态管理更加高效优雅","content":"#\n\n\n什么是 react-query#\n\nReact Query 是一个基于 React 的轻量级数据获取和状态管理库，其主要关注点在于客户端如何更好地管理服务器端状态。与传统的状态管理库（如\nRedux 和 MobX）相比，它专注于处理服务器状态，简化了与后端数据交互的逻辑。\n\nReact Query 通过提供 useQuery、useMutation 等\nhooks，使得开发者能够轻松地获取、更新、删除服务器端数据。此外，它还内置了数据缓存、自动更新、重试等功能，进一步优化了客户端与服务器端状态同步的体验。\n\n因此，React Query 的核心价值在于帮助开发者更优雅地管理客户端与服务器端状态的交互，提升前端开发效率。\n\n\n客户端应用状态#\n\n 1. 客户端状态 Client State:多数用于控制客户端的 UI 展示，储存在于客户端。\n\n 2. 服务端状态 Server State:客户端通过异步请求获得的数据，储存在于服务端.\n\n\n服务端状态有以下特点#\n\n 1. 存储在远端\n\n 2. 需要异步 API 来查询和更新\n\n 3. 数据不同步\n\n\nReact Query 还针对下列常见需求给出了自己的解决方案#\n\n1. 缓存#\n\n\n\n2. 将对同一数据的多个请求简化为一个请求#\n\n\n\n3. 在后台更新”过期”数据#\n\n\n\n4. 知道数据何时”过期”#\n\n\n\n5. 尽可能快地反映数据的更新#\n\n\n\n6. 性能优化，如分页和懒加载数据#\n\n\n\n7. 管理内存#\n\n\n\n8. 共享数据#\n\n\n\n\n使用 react-query#\n\n\n1. 首先，需要安装 React Query：#\n\n\n\n安装完成后，在项目的根组件中引入 QueryClient 和 QueryClientProvider：\n\n\n\n\n2. 使用 useQuery 获取数据#\n\nReact Query 提供了一个名为 useQuery 的 hook，可以用于获取远程数据。这是一个简单的示例：\n\n\n\n\n3. 优雅地处理错误和重试#\n\nReact Query 默认会在请求失败时尝试重试 3 次。你还可以自定义重试次数和重试间隔，例如：\n\n\n\n\n4. 缓存和自动更新#\n\nReact Query 默认会缓存数据，减少不必要的请求。当组件卸载后，数据仍然保留在缓存中。当再次使用相同的 key 查询时，React Query\n会直接使用缓存中的数据。同时，React Query 还可以在后台自动更新数据，例如：\n\n\n\n\n5. 使用 useMutation 发送数据#\n\nReact Query 还提供了 useMutation hook，用于处理数据的更改（如添加、修改、删除）。这是一个简单的示例：\n\n\n\n在上面的示例中，useMutation hook 用于处理添加用户的操作。当添加成功时，会显示成功提示；如果添加失败，则显示失败提示。\n\n\n6. 使用 QueryClient 无缝整合#\n\n使用 QueryClient 可以让你更好地控制 React Query 的行为。例如，你可以在添加用户成功后，使用户列表的缓存失效，以便立即获取更新后的数据：\n\n\n\n总结 React Query 是一个强大且灵活的状态管理库，可以让你的项目状态管理变得更加高效优雅。通过使用 React Query 提供的 useQuery\n和 useMutation 等\nhooks，可以轻松地处理服务器状态，同时享受缓存、重试和自动更新等功能。如果你在寻找一个简单易用且功能强大的状态管理库，React Query\n是一个值得尝试的选择。\n\n\nQueryClient#\n\n`QueryClient 是 React Query\n的核心类，它负责管理查询和突变的缓存、配置以及其他内部状态。你可以将其视为一个全局对象，它在整个应用程序中存储并管理所有查询和突变的状态。\n\n创建一个 QueryClient 实例的方法如下：\n\n\n\n在创建 QueryClient 时，你还可以传入配置选项来自定义其行为。例如：\n\n\n\n\nQueryClientProvider#\n\nQueryClientProvider 是一个 React 组件，它的作用是将创建好的 QueryClient 实例传递给应用程序中的其他组件。你可以将它视为\nReact Query 的上下文提供者，它使得 React Query 可以在整个应用程序范围内工作。使用 QueryClientProvider 的方法如下：\n\n\n\n在项目的根组件中引入 QueryClientProvider 并传入 QueryClient 实例，这样你就可以在应用的任何地方使用 React Query\n提供的 hooks，例如 useQuery 和 useMutation 等。\n\nQueryClient 负责管理和配置 React Query 的内部状态，而 QueryClientProvider 则负责将 QueryClient\n实例传递给整个应用程序，使得其他组件可以方便地使用 React Query 的功能。在使用 React Query 时，这两个组件是不可或缺的。\n\n\nuseMutation 里 如何将实时状态传递出去#\n\nuseMutation 提供了一个名为 onMutate 的配置选项，可以在 mutation 开始之前执行。你可以使用此选项捕获 mutation\n的实时状态，并将其传递给外部组件。例如，我们在添加用户的示例中增加一个实时状态传递功能。首先，在 CreateUser 组件中定义一个名为\nonStatusChange 的回调函数，然后将此回调函数作为 prop 传递给子组件：\n\n\n\n然后，在父组件中接收 onStatusChange 回调并处理状态变化：\n\n\n\n现在，当添加用户的 mutation 进行中，父组件会接收到实时状态并显示相应的提示信息。\n\nuseMutation 是 react-query 提供的一个自定义\nhook，用于执行数据修改操作（create/update/delete），并处理相关的状态变化。下面列举出 useMutation 提供的所有方法：\n\n 1. mutate(data, options?): 用于手动触发 mutation 函数执行，并更新相关的状态变量。\n\n● data: 要传递给 mutation 函数的数据。 ● options: 可选对象，包含以下属性： ○ onMutate: 在 mutation\n函数执行之前调用的回调函数。 ○ onSuccess: 在 mutation 函数成功执行后调用的回调函数。 ○ onError: 在 mutation\n函数执行出错后调用的回调函数。 ○ onSettled: 在 mutation 函数执行结束后调用的回调函数。 ○ variables: 要覆盖默认\nmutationKey 的参数对象。 ○ update: 更新缓存的函数，用于手动更新缓存中的数据。 ○ optimisticUpdate: 在\nmutation 函数执行期间进行乐观更新的函数。 ○ throwOnError: 是否在 mutation 函数执行出错时抛出异常。 ○ retry:\n是否自动重试 mutation 函数，或者提供一个重试配置对象。\n\n 2. mutateAsync(data, options?): 与 mutate 方法类似，但使用 async/await 语法来执行 mutation\n    函数，并返回一个 Promise 对象。不会触发 isLoading 和 isError 等状态变量的更新，需要手动处理结果。\n 3. 返回值：一个包含以下属性的对象：\n\n● mutate: 用于触发 mutation 函数执行的方法。 ● mutateAsync: 使用 async/await 语法来执行 mutation\n函数，并返回一个 Promise 对象。不会触发 isLoading 和 isError 等状态变量的更新，需要手动处理结果。 ● reset: 重置\nmutation 函数的状态，清除缓存中的数据并重新加载数据。 ● isLoading: 表示 mutation 函数是否在执行的布尔值。 ● isError:\n表示 mutation 函数执行期间是否出错的布尔值。 ● error: 如果 mutation 函数执行出错，则为错误对象。 ● data: 如果\nmutation 函数执行成功，则为返回的数据。","routePath":"/posts/react/reactQuery","lang":"","toc":[{"text":"什么是 react-query","id":"什么是-react-query","depth":2,"charIndex":3},{"text":"客户端应用状态","id":"客户端应用状态","depth":2,"charIndex":319},{"text":"服务端状态有以下特点","id":"服务端状态有以下特点","depth":2,"charIndex":428},{"text":"React Query 还针对下列常见需求给出了自己的解决方案","id":"react-query-还针对下列常见需求给出了自己的解决方案","depth":3,"charIndex":485},{"text":"1. 缓存","id":"1-缓存","depth":4,"charIndex":519},{"text":"2. 将对同一数据的多个请求简化为一个请求","id":"2-将对同一数据的多个请求简化为一个请求","depth":4,"charIndex":529},{"text":"3. 在后台更新”过期”数据","id":"3-在后台更新过期数据","depth":4,"charIndex":555},{"text":"4. 知道数据何时”过期”","id":"4-知道数据何时过期","depth":4,"charIndex":574},{"text":"5. 尽可能快地反映数据的更新","id":"5-尽可能快地反映数据的更新","depth":4,"charIndex":592},{"text":"6. 性能优化，如分页和懒加载数据","id":"6-性能优化如分页和懒加载数据","depth":4,"charIndex":612},{"text":"7. 管理内存","id":"7-管理内存","depth":4,"charIndex":634},{"text":"8. 共享数据","id":"8-共享数据","depth":4,"charIndex":646},{"text":"使用 react-query","id":"使用-react-query","depth":2,"charIndex":659},{"text":"1. 首先，需要安装 React Query：","id":"1-首先需要安装-react-query","depth":3,"charIndex":677},{"text":"2. 使用 useQuery 获取数据","id":"2-使用-usequery-获取数据","depth":3,"charIndex":761},{"text":"3. 优雅地处理错误和重试","id":"3-优雅地处理错误和重试","depth":3,"charIndex":845},{"text":"4. 缓存和自动更新","id":"4-缓存和自动更新","depth":3,"charIndex":916},{"text":"5. 使用 useMutation 发送数据","id":"5-使用-usemutation-发送数据","depth":3,"charIndex":1053},{"text":"6. 使用 QueryClient 无缝整合","id":"6-使用-queryclient-无缝整合","depth":3,"charIndex":1217},{"text":"QueryClient","id":"queryclient","depth":2,"charIndex":1509},{"text":"QueryClientProvider","id":"queryclientprovider","depth":2,"charIndex":1694},{"text":"useMutation 里 如何将实时状态传递出去","id":"usemutation-里-如何将实时状态传递出去","depth":2,"charIndex":2151}],"domain":"","frontmatter":{"icon":"react","description":"本文介绍了如何使用 React Query 让前端项目的状态管理变得更加高效优雅，详细解析了 React Query 的用法和特性。","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>React Query 状态管理","order":3,"star":3,"date":"2024-04-13T00:00:00.000Z","author":"h7ml","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","category":["react","react query"],"tag":["React","状态管理","React Query"],"shortTitle":"React Query 状态管理","head":[["meta",{"name":"keywords","content":"React, 状态管理, React Query, 前端开发, 缓存, 自动更新, 异步请求"}]]},"version":""},{"id":441,"title":"Redux初体验及高级使用","content":"什么是 Redux#\n\nRedux 是一个用于 JavaScript 应用程序的状态管理库，它帮助我们有效地管理应用程序的状态，并使组件之间的数据传递更加简单和可控。Redux\n使用单一的数据存储（store）来保存整个应用程序的状态，并通过 Reducers 和 Actions 来处理状态的变化。\n\n\nRedux 的核心概念#\n\nRedux 的单一数据流是指整个应用程序中的数据状态（state）存储在一个单一的 JavaScript 对象中，通常称为\"Store\"。这个 Store\n是唯一的，并且整个应用程序共享它。所有的数据改变都通过派发（dispatch）\"Action\"来完成，Action\n是一个包含描述改变的信息的简单对象。然后，这些 Action 会被传递给 Reducer 函数，Reducer 会根据 Action 的类型来更新 Store\n中的数据状态。组件可以订阅（subscribe）Store 的状态变化，以便在状态改变时重新渲染自己。\n\n\nStore：#\n\n整个应用程序只有一个 Store，它是一个包含应用程序状态的 JavaScript 对象。在 Redux 中，我们使用 createStore 函数来创建这个\nStore，并将一个根 Reducer 传递给它。\n\n\nAction：#\n\nAction 是一个普通的 JavaScript 对象，它描述了发生的事件和带有的数据。Action 必须包含一个 type\n字段，用于标识它的类型。其他字段可以用来传递任意数据。\n\n\nDispatch：#\n\n当应用程序中的某个组件需要改变状态时，它会调用 store.dispatch(action)方法来派发一个 Action。\n\n\nReducer：#\n\nReducer 是一个纯函数，它接收当前的状态和一个 Action 作为参数，并根据 Action 的类型来返回一个新的状态。Reducer\n不会直接修改原始状态，而是返回一个全新的状态对象。Redux 应用中可以有多个 Reducer，但最终它们会被合并成一个根 Reducer，并传递给\ncreateStore 函数。\n\n\nState 更新：#\n\n当 Action 被派发时，Redux 会调用根 Reducer 函数，并将当前的状态和 Action 传递给它。Reducer 函数根据 Action\n的类型来更新状态，并返回一个新的状态对象。Redux 会用新的状态对象替换原始状态，从而更新整个应用程序的状态。\n\n\n订阅：#\n\n组件可以通过 store.subscribe(listener)方法来订阅 Store\n的状态变化。一旦状态发生改变，订阅的监听器（listener）就会被调用，组件可以在这里进行重新渲染，从而反映最新的状态。\n\n\nView 渲染：#\n\n组件通过订阅 Store 的状态变化来实时更新自己的数据，并重新渲染视图。\n\n这个单一数据流的过程确保了整个应用程序的数据流动是可预测且一致的。所有的状态都存储在一个中央的 Store 中，由 Reducer\n函数进行管理和更新，而不是分散在各个组件中。这种架构使得应用程序的状态变得易于调试、测试和维护，同时也降低了数据流动的复杂性。\n\n总的来说，Redux 的单一数据流模式提供了一种简单、可预测和可维护的状态管理方案，使得 React 应用程序开发更加高效和优雅。\n\n\n使用#\n\n\n安装#\n\n\n\n\n创建 store#\n\n在 Redux 中，我们通过创建一个 Store 来保存应用程序的状态。一个 Redux 应用只有一个全局唯一的 Store，类似于全局变量存储仓库。\n\n\n\n\n创建 reducer#\n\nReducer 是一个纯函数，用于处理应用程序状态的变化。它接收当前的状态和一个 Action，根据 Action 的类型来更新状态。\n\n\n\n\n创建 action#\n\nAction 是一个普通的 JavaScript 对象，它描述了发生的事件和带有的数据。Action 必须包含一个 type\n字段，用于标识它的类型。其他字段可以用来传递任意数据。\n\n\n\n\n组件中使用#\n\n在组件中，我们可以通过 React 的 useState 来获取 Store 中的状态，并且使用 store.subscribe\n来订阅状态变化，以便在状态发生变化时更新组件。\n\n\n\n\n总结#\n\n我们可以看到 Redux 的基本使用方法。组件通过订阅 Store 的状态变化来实时更新自己的数据，通过 dispatch 一个 action\n来触发状态的更新。\n\n\n高级使用#\n\n在高级使用部分，我们将介绍 Redux 中的 Action Creator 和拆分 Reducer。\n\n\nAction Creator#\n\nAction Creator 是一个函数，用来创建 Action 对象。它封装了创建 Action 的过程，使得代码更加简洁和易于维护。\n\n\n\n\n拆分 Reducer#\n\n当应用变得庞大复杂时，单一的 Reducer 可能会变得过于庞大。为了保持代码的清晰和易于维护，我们可以将 Reducer 进行拆分，分成多个子\nReducer，然后再合并成一个 Root Reducer\n\n\n\n\n使用 Root Reducer#\n\n在根组件中，我们可以使用 combineReducers 函数将所有子 Reducer 合并成一个 Root Reducer，并传递给 createStore\n函数来创建 Store\n\n\n\n\nreact-redux#\n\n当我们使用 React 来开发应用时，结合 Redux 可以更好地管理应用状态。react-redux 是 Redux 官方推荐的用于在 React 应用中集成\nRedux 的官方库。它提供了一些高阶组件和钩子函数，帮助我们简化 Redux 在 React 中的使用。\n\n主要有两个核心组件：Provider 和 connect。\n\n\nProvider#\n\nProvider 组件是一个顶层组件，它接受 Redux 的 store 作为 props，并使得整个应用程序中的所有组件都能够访问到 Redux 的\nstore。通过 Provider 组件，我们无需手动将 store 传递给每个需要使用它的组件，而是让 React 的 Context 机制来帮助我们自动传递\nstore。\n\n\n\n在上面的例子中，我们使用 Provider 将 Redux 的 store 传递给整个应用程序，从而让 App 组件及其子组件都可以访问到 Redux 的\nstore。\n\n\nconnect#\n\nreact-redux 提供了 connect 函数，它允许我们将组件连接到 Redux 的 store，从而可以访问 store 中的状态和派发\naction。\n\n\n\n我们使用 connect 函数将 App 组件连接到 Redux 的 store，通过 mapStateToProps 函数将 store 中的状态映射为组件的\nprops。现在，App 组件可以通过 props 来访问 Redux 的状态，同时还可以通过 dispatch 方法派发 action 来更新状态。\n\n\n使用 connect 函数更新状态#\n\n除了通过 mapStateToProps 函数访问状态外，connect 函数还可以接收第二个参数 mapDispatchToProps，它允许我们将\naction creators 封装成函数，并作为 props 传递给组件。\n\n\n\n在上面的例子中，我们使用 mapDispatchToProps 函数将 inputValueAction.changeInput 封装为\nchangeInputValue 函数，并将它作为 props 传递给 App 组件。现在，App 组件可以通过 changeInputValue 来派发\naction，并更新 Redux 的状态。通过 react-redux 库的提供的 Provider 和 connect 函数，我们可以更加方便地在 React\n应用中集成 Redux，并在组件中访问和更新状态，使得应用开发更加高效和简洁。\n\n\n小结#\n\n在高级使用部分，我们引入了 Action Creator 来封装创建 Action 的过程，使代码更加简洁。同时，我们将 Reducer 进行了拆分，通过\ncombineReducers 函数合并成一个 Root Reducer，从而保持代码的清晰和易于维护。\n\n\n总结#\n\nRedux 是一个强大的状态管理库，可以帮助我们更好地管理 React 应用程序的状态。在初体验中，我们了解了 Redux 的基本使用方法，包括创建\nStore、创建 Reducer 和在组件中调用 Store。在高级使用中，我们学习了 Action Creator 和拆分 Reducer 的技巧，使得\nRedux 在应对大型复杂应用时更加灵活和高效。","routePath":"/posts/react/redux","lang":"","toc":[{"text":"什么是 Redux","id":"什么是-redux","depth":2,"charIndex":-1},{"text":"Redux 的核心概念","id":"redux-的核心概念","depth":2,"charIndex":152},{"text":"Store：","id":"store","depth":3,"charIndex":436},{"text":"Action：","id":"action","depth":3,"charIndex":553},{"text":"Dispatch：","id":"dispatch","depth":3,"charIndex":656},{"text":"Reducer：","id":"reducer","depth":3,"charIndex":732},{"text":"State 更新：","id":"state-更新","depth":3,"charIndex":907},{"text":"订阅：","id":"订阅","depth":3,"charIndex":1055},{"text":"View 渲染：","id":"view-渲染","depth":3,"charIndex":1169},{"text":"使用","id":"使用","depth":2,"charIndex":1418},{"text":"安装","id":"安装","depth":3,"charIndex":1424},{"text":"创建 store","id":"创建-store","depth":3,"charIndex":1432},{"text":"创建 reducer","id":"创建-reducer","depth":3,"charIndex":1523},{"text":"创建 action","id":"创建-action","depth":3,"charIndex":1608},{"text":"组件中使用","id":"组件中使用","depth":3,"charIndex":1715},{"text":"总结","id":"总结","depth":2,"charIndex":1816},{"text":"高级使用","id":"高级使用","depth":2,"charIndex":1905},{"text":"Action Creator","id":"action-creator","depth":3,"charIndex":1965},{"text":"拆分 Reducer","id":"拆分-reducer","depth":3,"charIndex":2055},{"text":"使用 Root Reducer","id":"使用-root-reducer","depth":3,"charIndex":2175},{"text":"react-redux","id":"react-redux","depth":2,"charIndex":2289},{"text":"Provider","id":"provider","depth":3,"charIndex":2471},{"text":"connect","id":"connect","depth":3,"charIndex":2736},{"text":"使用 connect 函数更新状态","id":"使用-connect-函数更新状态","depth":3,"charIndex":2990},{"text":"小结","id":"小结","depth":2,"charIndex":3398},{"text":"总结","id":"总结-1","depth":2,"charIndex":3536}],"domain":"","frontmatter":{"icon":"react","order":1,"date":"2024-08-05T00:00:00.000Z","author":"h7ml","title":"Redux初体验及高级使用","description":"Redux初体验及高级使用","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>nestjs  控制反转（IOC）与依赖注入（DI）","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"Redux初体验及高级使用","category":["Redux","react"],"tag":["Redux","react"],"head":[["meta",{"name":"keywords","content":"Redux初体验及高级使用"}]]},"version":""},{"id":442,"title":"requestIdleCallback","content":"实现 requestIdleCallback#\n\n\n浏览器一帧#\n\n当前大多数的屏幕刷新率都是 60hz，也就是每秒屏幕刷新 60 次，低于 60hz 人眼就会感知卡顿掉帧等情况，同样我们前端浏览器所说的 FPS（frame\nper second）是浏览器每秒刷新的次数，理论上 FPS\n越高人眼觉得界面越流畅，在两次屏幕硬件刷新之间，浏览器正好进行一次刷新（重绘），网页也会很流畅，当然这种是理想模式，\n如果两次硬件刷新之间浏览器重绘多次是没意义的，只会消耗资源，如果浏览器重绘一次的时间是硬件多次刷新的时间，那么人眼将感知卡顿掉帧等，\n所以浏览器对一次重绘的渲染工作需要在 16ms（1000ms/60）之内完成，也就是说每一次重绘小于 16ms 才不会卡顿掉帧。\n\n浏览器的一帧说的就是一次完整的重绘。\n\n一次重绘浏览器需要做哪些事情？\n\n\n\n\n认识 requestIdleCallback#\n\n在执行优先级较低的任务时，可以考虑使用\nwindow.requestIdleCallback()，意为交予任务给浏览器，浏览器有空闲的时候执行而不是立即执行这些任务。\n\n这样这些优先级较低的任务就不阻碍主线程的任务，以达到性能优化的效果。\n\n\n\n\n\n * callback: 一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline\n   的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。其中 IdleDeadline 对象包含：\n   * didTimeout，布尔值，表示任务是否超时，结合 timeRemaining 使用。\n   * timeRemaining()，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。\n * timeout:\n   表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行。如果明确在某段时间内执行\n   回调，可以设置 timeout 值。在浏览器繁忙的时候，requestIdleCallback 超时执行就和 setTimeout 效果一样。\n\n\n浏览器什么时候有空闲时段#\n\n场景一#\n\n当浏览器一帧渲染所用时间小于屏幕刷新率（对于具有 60Hz 的设备，一帧间隔应该小于 16ms）时间，到下一帧渲染渲染开始时出现的空闲时间，如图 idle\nperiod，\n\n\n\n场景二#\n\n当浏览器没有可渲染的任务，主线程一直处于空闲状态，事件队列为空。为了避免在不可预测的任务（例如用户输入的处理）中引起用户可察觉的延迟，这些空闲周期的长度应限制为\n最大值 50ms，也就是 timeRemaining 最大不超过 50（也就是 20fps，这也是 react polyfill\n的原因之一），当空闲时段结束时，可以调度另一个空闲时段，如果它保持空闲，那么空闲时段将更长，后台任务可以在更长时间段内发生。如图:\n\n\n\n\nreact 如何实现 requestIdleCallback#\n\n前面提到 requestIdleCallback 工作只有 20FPS，一般对用户来感觉来说，需要到 60FPS 才是流畅的, 即一帧时间为 16.7\nms，所以这也是 react 团队自己实现 requestIdleCallback 的原因。\n\n实现大致思路是在 requestAnimationFrame 获取一桢的开始时间，触发一个 postMessage，在空闲的时候调用 idleTick\n来完成异步任务。\n\ntabs\n\n::: tab React polyfill\n\n\n\n自己实现一版\n\n调用：\n\n\n\n::::\n\n\n总结#\n\nrequestIdleCallback 需要注意的：\n\n * requestIdleCallback 是屏幕渲染之后执行的。\n * 一些低优先级的任务可使用 requestIdleCallback\n   等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是能够量化，细分的微任务（micro task）比较适合\n   requestIdleCallback。\n * requestIdleCallback 不会和帧对齐，所以涉及到 DOM 的操作和动画最好放在 requestAnimationFrame\n   中执行，requestAnimationFrame 在重新渲染屏幕之前执行。\n * Promise 也不建议在这里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在\n   requestIdleCallback 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。","routePath":"/posts/react/requestIdleCallback","lang":"","toc":[{"text":"实现 requestIdleCallback","id":"实现-requestidlecallback","depth":2,"charIndex":-1},{"text":"浏览器一帧","id":"浏览器一帧","depth":3,"charIndex":25},{"text":"认识 requestIdleCallback","id":"认识-requestidlecallback","depth":3,"charIndex":375},{"text":"浏览器什么时候有空闲时段","id":"浏览器什么时候有空闲时段","depth":3,"charIndex":917},{"text":"react 如何实现 requestIdleCallback","id":"react-如何实现-requestidlecallback","depth":3,"charIndex":1249},{"text":"总结","id":"总结","depth":3,"charIndex":1546}],"domain":"","frontmatter":{"icon":"react","order":4,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"requestIdleCallback","category":"react","tag":["react","requestIdleCallback"],"star":true,"lastUpdated":false},"version":""},{"id":443,"title":"setState","content":"setState 是同步还是异步的？#\n\n\n\n可以发现两个执行的时机不一样，console.log 的结果也不一样。一个是同步，一个则是异步。\n\n\n分析#\n\n我们来看看 react 部分源码\n\n\n\n上述代码可以简单描述这个过程，主要是判断了 executionContext 是否等于 NoContext 来确定当前更新流程是否在 React 事件流中。\n\n所有的事件在触发的时候，都会先调用 batchedEventUpdates$1 这个方法，在这里就会修改 executionContext 的值，React\n就知道此时的 setState 在自己的掌控中。\n\n\n\n\n\n所以，不管是直接调用 flushSyncCallbackQueue ，还是推迟调用，这里本质上都是同步的，只是有个先后顺序的问题。\n\n\n结论#\n\n同步情况\n\n 1. 当前是 Legacy 模式\n 2. 在非合成事件中执行 setState，比如 setTimeout, Promise, MessageChannel 等\n\n异步情况\n\n 1. 如果是合成事件中的回调, executionContext |= EventContext, 所以不会进入, 最终表现出异步\n 2. concurrent 模式下都为异步\n\n\n批处理#\n\n在React 合成事件中执行多次 setState 后，react 会合并进行一次更新，这样就可以提高性能，这就是批处理的概念。\n\n\n\n即使是 async 函数，isBatchedUpdate 为 false，那多次 setState 实际上也会 render 多次。～～\n\n\n给张图#\n\n","routePath":"/posts/react/setState","lang":"","toc":[{"text":"setState 是同步还是异步的？","id":"setstate-是同步还是异步的","depth":2,"charIndex":-1},{"text":"分析","id":"分析","depth":3,"charIndex":73},{"text":"结论","id":"结论","depth":3,"charIndex":355},{"text":"批处理","id":"批处理","depth":3,"charIndex":547},{"text":"给张图","id":"给张图","depth":3,"charIndex":692}],"domain":"","frontmatter":{"icon":"react","order":5,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"setState","category":"react","tag":["react","setState"],"star":true,"lastUpdated":false},"version":""},{"id":444,"title":"synthetic-event","content":"React 合成事件#\n\n\n概览#\n\n从v17.0.0开始, React 不会再将事件处理添加到 document 上, 而是将事件处理添加到渲染 React 树的根 DOM 容器中.\n\n引入官方提供的图片:\n\n\n\n图中清晰的展示了v17.0.0的改动, 无论是在document还是根 DOM 容器上监听事件, 都可以归为事件委托(代理)(mdn).\n\n注意: react的事件体系, 不是全部都通过事件委托来实现的. 有一些特殊情况, 是直接绑定到对应 DOM 元素上的(如:scroll, load),\n它们都通过listenToNonDelegatedEvent函数进行绑定.\n\n上述特殊事件最大的不同是监听的 DOM 元素不同, 除此之外, 其他地方的实现与正常事件大体一致.\n\n本节讨论的是可以被根 DOM 容器代理的正常事件.\n\n\n事件绑定#\n\n在前文 React 应用的启动过程中介绍了React在启动时会创建全局对象, 其中在创建 fiberRoot 对象时, 调用createRootImpl:\n\n\n\nlistenToAllSupportedEvents函数, 实际上完成了事件代理:\n\n\n\n核心逻辑:\n\n 1. 节流优化, 保证全局注册只被调用一次.\n 2. 遍历allNativeEvents, 调用listenToNativeEvent监听冒泡和捕获阶段的事件.\n    * allNativeEvents包括了大量的原生事件名称, 它是在DOMPluginEventSystem.js中被初始化\n\nlistenToNativeEvent:\n\n\n\naddTrappedEventListener:\n\n\n\n从listenToAllSupportedEvents开始, 调用链路比较长,\n最后调用addEventBubbleListener和addEventCaptureListener监听了原生事件.\n\n原生 listener#\n\n在注册原生事件的过程中, 需要重点关注一下监听函数, 即listener函数. 它实现了把原生事件派发到react体系之内, 非常关键.\n\n> 比如点击 DOM 触发原生事件, 原生事件最后会被派发到react内部的onClick函数. listener函数就是这个由外至内的关键环节.\n\nlistener是通过createEventListenerWrapperWithPriority函数产生:\n\n\n\n可以看到, 不同的domEventName调用getEventPriorityForPluginSystem后返回不同的优先级, 最终会有 3 种情况:\n\n 1. DiscreteEvent: 优先级最高, 包括click, keyDown, input等事件, 源码\n    * 对应的listener是dispatchDiscreteEvent\n 2. UserBlockingEvent: 优先级适中, 包括drag, scroll等事件, 源码\n    * 对应的listener是dispatchUserBlockingUpdate\n 3. ContinuousEvent: 优先级最低,包括animation, load等事件, 源码\n    * 对应的listener是dispatchEvent\n\n这 3 种listener实际上都是对dispatchEvent的包装:\n\n\n\n\n事件触发#\n\n当原生事件触发之后, 首先会进入到dispatchEvent这个回调函数. 而dispatchEvent函数是react事件体系中最关键的函数,\n其调用链路较长, 核心步骤如图所示:\n\n重点关注其中 3 个核心环节:\n\n 1. attemptToDispatchEvent\n 2. SimpleEventPlugin.extractEvents\n 3. processDispatchQueue\n\n关联 fiber#\n\nattemptToDispatchEvent把原生事件和fiber树关联起来.\n\n\n\n核心逻辑:\n\n 1. 定位原生 DOM 节点: 调用getEventTarget\n 2. 获取与 DOM 节点对应的 fiber 节点: 调用getClosestInstanceFromNode\n 3. 通过插件系统, 派发事件: 调用 dispatchEventForPluginEventSystem\n\n收集 fiber 上的 listener#\n\ndispatchEvent函数的调用链路中, 通过不同的插件, 处理不同的事件.\n其中最常见的事件都会由SimpleEventPlugin.extractEvents进行处理:\n\n\n\n核心逻辑:\n\n 1. 收集所有listener回调\n    \n    * 这里的是fiber.memoizedProps.onClick/onClickCapture等绑定在fiber节点上的回调函数\n    \n    * 具体逻辑在accumulateSinglePhaseListeners:\n      \n      \n\n 2. 构造合成事件(SyntheticEvent), 添加到派发队列(dispatchQueue)\n\n构造合成事件#\n\nSyntheticEvent, 是react内部创建的一个对象, 是原生事件的跨浏览器包装器,\n拥有和浏览器原生事件相同的接口(stopPropagation,preventDefault), 抹平不同浏览器 api 的差异, 兼容性好.\n\n具体的构造过程并不复杂, 可以直接查看源码.\n\n此处我们需要知道, 在Plugin.extractEvents过程中, 遍历fiber树找到listener之后, 就会创建SyntheticEvent,\n加入到dispatchQueue中, 等待派发.\n\n执行派发#\n\nextractEvents完成之后, 逻辑来到processDispatchQueue, 终于要真正执行派发了.\n\n\n\n在processDispatchQueueItemsInOrder遍历dispatchListeners数组, 执行executeDispatch派发事件,\n在fiber节点上绑定的listener函数被执行.\n\n在processDispatchQueueItemsInOrder函数中, 根据捕获(capture)或冒泡(bubble)的不同, 采取了不同的遍历方式:\n\n 1. capture事件: 从上至下调用fiber树中绑定的回调函数, 所以倒序遍历dispatchListeners.\n 2. bubble事件: 从下至上调用fiber树中绑定的回调函数, 所以顺序遍历dispatchListeners.\n\n\n总结#\n\n从架构上来讲, SyntheticEvent打通了从外部原生事件到内部fiber树的交互渠道, 使得react能够感知到浏览器提供的原生事件,\n进而做出不同的响应, 修改fiber树, 变更视图等.\n\n从实现上讲, 主要分为 3 步:\n\n 1. 监听原生事件: 对齐DOM元素和fiber元素\n 2. 收集listeners: 遍历fiber树, 收集所有监听本事件的listener函数.\n 3. 派发合成事件: 构造合成事件, 遍历listeners进行派发.","routePath":"/posts/react/synthetic-event","lang":"","toc":[{"text":"React 合成事件","id":"react-合成事件","depth":2,"charIndex":-1},{"text":"概览","id":"概览","depth":3,"charIndex":13},{"text":"事件绑定","id":"事件绑定","depth":3,"charIndex":372},{"text":"原生 listener","id":"原生-listener","depth":4,"charIndex":814},{"text":"事件触发","id":"事件触发","depth":3,"charIndex":1429},{"text":"关联 fiber","id":"关联-fiber","depth":4,"charIndex":1635},{"text":"收集 fiber 上的 listener","id":"收集-fiber-上的-listener","depth":4,"charIndex":1843},{"text":"构造合成事件","id":"构造合成事件","depth":4,"charIndex":2174},{"text":"执行派发","id":"执行派发","depth":4,"charIndex":2432},{"text":"总结","id":"总结","depth":3,"charIndex":2811}],"domain":"","frontmatter":{"icon":"react","order":2,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"synthetic-event","category":"react","tag":["react","synthetic-event"],"star":true,"lastUpdated":false},"version":""},{"id":445,"title":"rxjava","content":" * 依赖\n\n * 优势\n\n * 线程调度","routePath":"/posts/rxjava/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"box","order":3,"author":"h7ml","category":"rxjava","tag":"rxjava","title":"rxjava","index":false,"dir":{"order":2},"date":"2019-03-21T00:00:00.000Z"},"version":""},{"id":446,"title":"rxjava","content":" * 依赖\n\n * 优势\n\n * 线程调度","routePath":"/posts/rxjava/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"box","order":3,"author":"h7ml","category":"rxjava","tag":"rxjava","title":"rxjava","index":false,"dir":{"order":2},"date":"2019-03-21T00:00:00.000Z"},"version":""},{"id":447,"title":"依赖","content":"添加依赖#\n\n\n\n\n创建数据源（被观察者/可观察者）#\n\n返回一个可观察对象，该对象发出给定(常量引用)项的信号，然后完成\n\n\njust 方法#\n\n\n\n\n\n\nfromArray 方法#\n\nfromArray 和 Just 几乎是一样的效果，只不过 Just 限制 10 个以内，而 fromArray 并没有限制，查看得知 单个参数 Just\n是自行创建 ObservableJust，而多个参数 Just 最终还是回调了 fromArray，这里不再过多演示\n\n\ncreate 方法#\n\n\n\n\n\n\nrange 方法#\n\n使用范围数据，指定输出数据的范围（1-40 的数值）\n\n\n\n\n\n\ninterval 方法#\n\n指定某一时刻进行数据发送\n\n\n\n\n\n\n创建事件的接收者（观察者|订阅者），onNext 方法中的数据类型必须被观察者指定的泛型#\n\n表示观察者不对被观察者发送的事件作出任何响应（但被观察者还是可以继续发送事件）\n\n\n\n表示观察者只对被观察者发送的 Next 事件作出响应\n\n\n\n表示观察者只对被观察者发送的 Next 事件 & Error 事件作出响应\n\n\n\n表示观察者只对被观察者发送的 Next 事件、Error 事件 & Complete 事件作出响应\n\n\n\n表示观察者只对被观察者发送的 Next 事件、Error 事件 、Complete 事件 & onSubscribe 事件作出响应\n\n\n\n表示观察者对被观察者所有的事件做出响应\n\n\n\n\nObserver 类用法#\n\n\n\n\n\n\n\n\n\n观察者\n\n\n\n\n\n\nConsumer 类用法#\n\n\n\n\n\n\n订阅#\n\n订阅事件，被观察者必须指定了事件的接收者（观察者），整个事件流程才可以被启动\n\n\n\n\n是否被订阅#\n\n\n\n\n取消订阅#\n\n\n\n\n使用步骤#\n\n\n\n\n创建数据源（被观察者/可观察者），泛型必须是 Object 的子类#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n订阅者是观察者的子类，区别在于订阅者可以取消订阅（在程序销毁后）\n\n\n\n * Rxjava 的线程调度\n\n * RxJava 的优势","routePath":"/posts/rxjava/note","lang":"","toc":[{"text":"添加依赖","id":"添加依赖","depth":2,"charIndex":-1},{"text":"创建数据源（被观察者/可观察者）","id":"创建数据源被观察者可观察者","depth":2,"charIndex":9},{"text":"just 方法","id":"just-方法","depth":3,"charIndex":63},{"text":"fromArray 方法","id":"fromarray-方法","depth":3,"charIndex":78},{"text":"create 方法","id":"create-方法","depth":3,"charIndex":232},{"text":"range 方法","id":"range-方法","depth":3,"charIndex":249},{"text":"interval 方法","id":"interval-方法","depth":3,"charIndex":293},{"text":"创建事件的接收者（观察者|订阅者），onNext 方法中的数据类型必须被观察者指定的泛型","id":"创建事件的接收者观察者订阅者onnext-方法中的数据类型必须被观察者指定的泛型","depth":2,"charIndex":326},{"text":"Observer 类用法","id":"observer-类用法","depth":2,"charIndex":633},{"text":"Consumer 类用法","id":"consumer-类用法","depth":2,"charIndex":666},{"text":"订阅","id":"订阅","depth":2,"charIndex":686},{"text":"是否被订阅","id":"是否被订阅","depth":2,"charIndex":734},{"text":"取消订阅","id":"取消订阅","depth":2,"charIndex":745},{"text":"使用步骤","id":"使用步骤","depth":2,"charIndex":755},{"text":"创建数据源（被观察者/可观察者），泛型必须是 Object 的子类","id":"创建数据源被观察者可观察者泛型必须是-object-的子类","depth":2,"charIndex":765}],"domain":"","frontmatter":{"title":"依赖","icon":"java","order":1,"date":"2019-03-21T00:00:00.000Z","author":"h7ml","category":"android","tag":"rxjava"},"version":""},{"id":448,"title":"RxJava的优势","content":"没用 RxJava 之前#\n\n\n\n\n使用 RxJava 之后#\n\n\n\n\nRxJava 优势#\n\n * 实现优雅：链式调用，一点到底\n\n * 逻辑简洁：代码可读性高，解耦\n\n * 使用简单：支持线程调度和各种操作符\n\n * 扩展维护：随着程序逻辑的复杂性提高，它依然能够保持简洁和优雅\n\n * 扩展维护：随着程序逻辑的复杂性提高，它依然能够保持简洁和优雅","routePath":"/posts/rxjava/superiority","lang":"","toc":[{"text":"没用 RxJava 之前","id":"没用-rxjava-之前","depth":3,"charIndex":-1},{"text":"使用 RxJava 之后","id":"使用-rxjava-之后","depth":3,"charIndex":17},{"text":"RxJava 优势","id":"rxjava-优势","depth":3,"charIndex":35}],"domain":"","frontmatter":{"title":"RxJava的优势","icon":"creative","date":"2019-03-27T00:00:00.000Z","author":"h7ml","category":"android","tag":"rxjava"},"version":""},{"id":449,"title":"Rxjava的线程调度","content":"调度器#\n\n用于线程调度\n\n使用案例#\n\n\n\n调度类型#\n\n","routePath":"/posts/rxjava/thread-scheduling","lang":"","toc":[{"text":"调度器","id":"调度器","depth":3,"charIndex":-1},{"text":"使用案例","id":"使用案例","depth":4,"charIndex":13},{"text":"调度类型","id":"调度类型","depth":4,"charIndex":22}],"domain":"","frontmatter":{"title":"Rxjava的线程调度","icon":"creative","date":"2019-03-29T00:00:00.000Z","author":"h7ml","category":"android","tag":"rxjava"},"version":""},{"id":450,"title":"vite","content":"Vite 自动化注册全局组件\n\nvite 别名配置注意事项","routePath":"/posts/vite/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"vue","author":"h7ml","category":"vite","tag":"vite","title":"vite","index":false,"dir":{"order":8},"date":"2021-05-27T00:00:00.000Z"},"version":""},{"id":451,"title":"vite 别名配置注意事项","content":"vite 别名配置注意事项#\n\n 1. Vite config\n\n\n\n\n\n 2. Tsconfig.json\n\n\n\n告诉 TS 解析如何解析某些路径\n\n注意./src/* 后边这个*一定要加","routePath":"/posts/vite/alias","lang":"","toc":[{"text":"vite 别名配置注意事项","id":"vite-别名配置注意事项","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-05-30T00:00:00.000Z","author":"h7ml","title":"vite 别名配置注意事项","category":"vite","tag":"vite","star":true},"version":""},{"id":452,"title":"vue2与vue3全局组件注册","content":"dgiot-dashboard 最佳实践\n\n\nvue2#\n\n\n\n\n获取组件配置#\n\n\n\n\n全局注册组件#\n\n\n\n\nVite 注册全局组件的方式#\n\n\nimport.meta.glob()#\n\n\nimport.meta.globEager()#\n\n\n\n\n在 main.js 文件中 import 并 use#\n\n\n\n因为在 Vite 中不能使用 webpack 的 require.context()方式来读取文,所以之前使用 webpack 注册全局组件的方式就不能使用了。","routePath":"/posts/vite/automatic-registration-global-components","lang":"","toc":[{"text":"vue2","id":"vue2","depth":2,"charIndex":22},{"text":"获取组件配置","id":"获取组件配置","depth":3,"charIndex":32},{"text":"全局注册组件","id":"全局注册组件","depth":3,"charIndex":44},{"text":"Vite 注册全局组件的方式","id":"vite-注册全局组件的方式","depth":2,"charIndex":56},{"text":"import.meta.glob()","id":"importmetaglob","depth":3,"charIndex":74},{"text":"import.meta.globEager()","id":"importmetaglobeager","depth":3,"charIndex":96},{"text":"在 main.js 文件中 import 并 use","id":"在-mainjs-文件中-import-并-use","depth":3,"charIndex":125}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-05-27T00:00:00.000Z","author":"h7ml","title":"vue2与vue3全局组件注册","category":"vite","tag":"vite","star":true},"version":""},{"id":453,"title":"vite","content":"Vite 自动化注册全局组件\n\nvite 别名配置注意事项","routePath":"/posts/vite/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"vue","author":"h7ml","category":"vite","tag":"vite","title":"vite","index":false,"dir":{"order":8},"date":"2021-05-27T00:00:00.000Z"},"version":""},{"id":454,"title":"Object.defineproperty 核心代码 自定义实现","content":"#\n\n","routePath":"/posts/vue/Object-defineproperty","lang":"","toc":[],"domain":"","frontmatter":{"icon":"vue","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","category":"vue","tag":"vue","star":true},"version":""},{"id":455,"title":"Proxy 核心代码 自定义实现","content":"#\n\n","routePath":"/posts/vue/Proxy","lang":"","toc":[],"domain":"","frontmatter":{"icon":"vue","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","category":"vue","tag":"vue","star":true},"version":""},{"id":456,"title":"vue","content":"vue 源码分析#\n\n\n核心#\n\nVue 响应式的核心是利用\nObject.defineProperty()这个方法进行数据劫持和观察者模式进行数据响应式的。Object.defineProperty()这个方法会直接在一\n个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。具体用法如下：\n\n它有三个参数，第一个是 object，它代表要定义属性的对象。；第二个是 prop，它代表目标对象的属性值；第三个参数是\ndescriptor，它代表要定义或修改的属性描述符。\n\n响应式用法：\n\n\n\n\n观察者模式#\n\n什么是观察者模式？它分为注册环节跟发布环节。\n\n比如我去买芝士蛋糕，但是店家还没有做出来。这时候我又不想在店外面傻傻等，我就需要隔一段时间来回来问问蛋糕做好没，对于我来说是很麻烦的事情，说不定我就懒得买了。\n\n店家肯定想要做生意，不想流失我这个吃货客户。于是，在蛋糕没有做好的这段时间，有客户来，他们就让客户把自己的电话留下，这就是观察者模式中的注册环节。然后蛋糕做好之\n后，一次性通知所有记录了的客户，这就是观察者的发布环节。\n\n一个简单的观察者模式类：\n\n\n\n\n初始化#\n\nvue 在初始化执行 initState 的时候，会对props、methods、data、computed 和 wathcer 等属性做初始化操作。\n\n\n\n在初始化 data 的时候，一共做了两件事，一件是利用 proxy 将数据代理到整个 vue 实例上，另一件就是将 data 中的所有对象属性 reactive\n化，变成响应式对象，为对象添加 getter 和 setter。\n\n\n\n上面的这段代码，它将对象的所有属性进行遍历执行 defineReactive()方法进行响应式化\n\n\n\n在执行这个方法的过程中，会 new 一个 dep 实例，记得注意，后面会用到\n\n\n\n上述代码中的 Dep 类就是一个观察者类，每个对象属性都一个 dep 实例对象，在执行 get 的时候进行触发 depend 方法，触发 sit 的时候执行\nnotify 方法。\n\n\nmount 阶段#\n\n在 vue 实例挂载阶段，会创建一个 Watcher 类的实例对象，这个 Watcher 实际上是连接 Vue 组件与 Dep（也就是视图更新环节）的桥梁。\n\n\n\n在 rende()方法将模板渲染成虚拟 Vnode 的过程中会访问 data，从而触发属性的 getter，然后每个对象属性又有一个 dep\n实例对象（上面提到的），然后再 getter 的逻辑中又会调用该 dep 的 depend 方法，将 watcher 实例 add 到 sub（存在 Dep\n类中的存储 watcher 的数组）里面。在 depend 方法里面，Dep.target 就是 watcher 本身，在 Wacher\n类中的构造函数会执行（上面代码有）。以上过程就叫依赖收集。\n\n\n派发更新#\n\n在对象属性的数据改变之后，会触发 sitter，从而执行 sitter 函数的逻辑，从而调用 dep 实例的 notify 方法，从而进行遍历调用 sub\n中所有 watcher 的 upadte 方法进行视图更新。\n\n\n总结#\n\n**第一步：**组件初始化的时候，先给每一个 Data 属性都注册 getter，setter，也就是 reactive 化。然后再 new 一个自己的\nWatcher 对象，此时 watcher 会立即调用组件的 render 函数去生成虚拟 DOM。在调用 render 的时候，就会需要用到 data\n的属性值，此时会触发 getter 函数，将当前的 Watcher 函数注册进 sub 里。\n\n**第二步：**当 data 属性发生改变之后，会触发 sitter，遍历 sub 里所有的 watcher 对象，通知它们去重新渲染组件。\n\n注意：vue 对数组响应式是通过变异方法完成的，而且如果要对响应式对象添加新的属性，必须要用$set 方法才能完成\n\n参考文章：\n\nvue 技术揭秘\n\n最简化 VUE 的响应式原理","routePath":"/posts/vue/README","lang":"","toc":[{"text":"vue 源码分析","id":"vue-源码分析","depth":2,"charIndex":-1},{"text":"**核心**","id":"核心","depth":3,"charIndex":-1},{"text":"**观察者模式**","id":"观察者模式","depth":3,"charIndex":-1},{"text":"**初始化**","id":"初始化","depth":3,"charIndex":-1},{"text":"**mount 阶段**","id":"mount-阶段","depth":3,"charIndex":-1},{"text":"**派发更新**","id":"派发更新","depth":3,"charIndex":-1},{"text":"**总结**","id":"总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"icon":"vue","date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"vue","category":"vue","tag":"vue","star":true,"index":true,"dir":{"order":6}},"version":""},{"id":457,"title":"Computed 和 Watch","content":"Computed 和 Watch#\n\nComputed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会\n让模板难以维护，可以将复杂的逻辑放入计算属性中处理。\n\nWatch没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进\n行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用unWatch手动注销哦。\n\n * 功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数\n * 使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用ret\n   urn\n * 性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调\n * 场景上\n   * computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；\n   * watch：当一条数据影响多条数据的时候，例子：搜索框\n\n\nWatch#\n\n侦听属性的初始化也是发生在 Vue 的实例初始化阶段的 initState 函数中，在 computed 初始化之后，执行了：\n\n\n\n这里的逻辑也很简单，首先对 hanlder 的类型做判断，拿到它最终的回调函数，最后调用 vm.$watch(keyOrFn, handler,\noptions) 函数，$watch 是 Vue 原型上的方法，它是在执行 stateMixin 的时候定义的：\n\n\n\n虽然watch内部是使用this.$watch，但是我们也是可以手动调用this.$watch来创建监听属性的，所以第二个参数cb会出现是对象的情况。接下来设置\n一个标记位options.user为true，表明这是一个user-watcher。\n\n再给watch设置了immediate属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是immediate的实现原理。最后的返回值是一个方法，\n执行后可以取消对该监听属性的监听。接下来我们看看user-watcher是如何定义的：\n\n\n\n当是user-watcher时，Watcher内部是以上方式实例化的，通常情况下我们是使用字符串的形式创建监听属性，所以首先来看下parsePath方法是干什么\n的：\n\n\n\nparsePath方法最终返回一个闭包方法，此时Watcher类中的this.getter就是一个函数了，再执行this.get()方法时会将this.vm传入\n到闭包内，补全Watcher其他的逻辑：\n\n\n总结#\n\n * 计算属性 VS 侦听属性\n * 搞懂 computed 和 watch 原理，减少使用场景思考时间\n * 浅谈 Vue 中 computed 实现原理","routePath":"/posts/vue/computed_and_watch","lang":"","toc":[{"text":"Computed 和 Watch","id":"computed-和-watch","depth":2,"charIndex":-1},{"text":"Watch","id":"watch","depth":3,"charIndex":588},{"text":"总结","id":"总结","depth":3,"charIndex":1240}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"Computed 和 Watch","category":"vue","tag":["vue","Computed","Watch"],"star":true,"lastUpdated":false},"version":""},{"id":458,"title":"diff","content":"Diff 算法#\n\nDiff算法的核心就是针对具有相同父节点的同层新旧子节点进行比较，而不是使用逐层搜索递归遍历的方式。时间复杂度为O(n)。\n\n如何理解？\n\n说白点，就是当新旧VNode树在同一层具有相同的VNode节点时，才会继续对其子节点进行比较。一旦旧VNode树同层中的节点在新VNode树中不存在或者是多余的\n，都会在新的真实DOM中进行添加或者删除。\n\n下面就拿一副图进行解释。\n\n\n\n从上面的示例图可以看到，Diff算法中只会对同一层的元素进行比较，并且必须拥有相同节点元素，才会对其子节点进行比较，其他多余的同层节点都会一律做删除或添加操作。\n\n接下来，我们就从源码角度来看看这过程到底是如何发生的。🤔\n\n\ndiff 流程图#\n\n当数据发生改变时，set 方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的 DOM 打补丁，更新相应的视图。\n\n\n\n\n从源码角度进行探究#\n\n我们依然是从_update方法入手，看看到底是如何操作的。\n\n\n\n每一次更新模板时，都会先将渲染好的新VNode树保存到实例的_vnode属性上，这样做的目的是为了下一次更新时，能获取到旧VNode树进行比较。\n\n针对是否拥有旧的VNode树，使用__patch__方法执行相应逻辑，也即执行了patch过程。\n\n\n\n可以看到，只有在浏览器的环境下才能进行patch过程，而实现patch的，就是createPatchFunction方法，我们接着看下去。\n\n\n\n好啦，对于patch比较过程，你也应该有了一个大概了解。现在就来简单总结一下上述代码。\n\n * 当旧VNode树不存在时，直接根据新VNode树创建相应的真实DOM。\n * 当旧VNode树存在时，则会调用sameVnode方法比较当前新旧节点是否相同。\n   * 当新旧节点是相同时，会调用patchVnode方法比较新旧节点（过程就是继续比较其子节点，递归下去～）。\n   * 当新旧节点是不同时，则会先按照新VNode节点创建新的真实DOM节点，再根据旧VNode节点将相应的真实DOM节点进行删除。\n\n是不是很简单 🤔...那么问题来了，不是说patch过程是使用Diff算法进行比较的吗？怎么还看不到，甭急，下面我会讲到哈。\n\n在上面的总结中，我们是可以看到两个方法，分别是sameVnode方法和patchVnode方法。接下来我们就来探讨一下这两个方法。\n\n\nsameVnode#\n\n判断两个节点间是否相同\n\n\n\n比较两个新旧节点间是很简单的，主要是按照下面几个属性进行判断。\n\n * VNode节点唯一标识key。\n * 是否同为注释isComment。\n * 数据属性是否为空isDef。\n * 是否为相同的input类型sameInputType。\n\n\npatchVnode#\n\n好啦，接着就到我们的主角patchVnode方法了，这个才是Diff相关方法，我们先来看看源码是如何实现的。🤔\n\n\n\npatchVnode方法做的事情不多，最主要就是按照一下场景做了处理;\n\ndiff过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode的子节点：\n\n * 首先进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；\n * 在vnode没有文本节点的情况下，进入子节点的 diff；\n * 当 oldCh 和 ch 都存在且不相同的情况下，调用 updateChildren 对子节点进行 diff；\n * 若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；\n * 若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；\n * 若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。\n\n接下来才是最重点呀。。😅 在上面中留下了updateChildren方法，那么这个方法又是干啥？\n\n不瞒你说，updateChildren方法在根据场景Diff后，将oldVNode树作出相应的改动。在没有看源码之前，我会先阐述一下。\n\nDiff算法过程中，在将oldVNode树改动时，优先考虑相同位置的相同节点，再考虑需要移动的相同节点，最后才考虑创建或删除节点。\n\n\nupdateChildren#\n\n有了上面的简单理解，我们就来继续探究啦 😄。\n\n\n\n\n具体的 diff 分析#\n\n我们可以假设有旧的 Vnode 数组和新的 Vnode 数组这两个数组,而且有四个变量充当指针分别指到两个数组的头尾.\n\n重复下面的对比过程，直到两个数组中任一数组的头指针超过尾指针，循环结束 :\n\n * 头头对比: 对比两个数组的头部，如果找到，把新节点 patch 到旧节点，头指针后移\n * 尾尾对比: 对比两个数组的尾部，如果找到，把新节点 patch 到旧节点，尾指针前移\n * 旧尾新头对比: 交叉对比，旧尾新头，如果找到，把新节点 patch 到旧节点，旧尾指针前移，新头指针后移\n * 旧头新尾对比: 交叉对比，旧头新尾，如果找到，把新节点 patch 到旧节点，新尾指针前移，旧头指针后移\n * 利用 key 对比: 用新指针对应节点的 key 去旧数组寻找对应的节点,这里分三种情况,当没有对应的 key，那么创建新的节点,如果有 key\n   并且是相同的节点，把新节点 patch 到旧节点,如果有 key 但是不是相同的节点，则创建新节点\n\n我们假设有新旧两个数组:\n\n * 旧数组: [1, 2, 3, 4, 5]\n * 新数组: [1, 4, 6, 1000, 100, 5]\n\n\n\n首先我们进行头头对比,新旧数组的头部都是1,因此将双方的头部指针后移.\n\n\n\n我们继续头头对比,但是2 !== 4导致对比失败,我进入尾尾对比,5 === 5,那么尾部指针则可前移.\n\n\n\n现在进入新的循环,头头对比2 !== 4,尾尾对比4 !== 100,此时进入交叉对比,先进行旧尾新头对比,即4 === 4,旧尾前移且新头后移.\n\n\n\n接着再进入一个轮新的循环,头头对比2 !== 6,尾尾对比3 !== 100,交叉对比2 != 100 3 !=\n6,四种对比方式全部不符合,如果这个时候需要通过key去对比,然后将新头指针后移\n\n\n\n继续重复上述对比的循环方式直至任一数组的头指针超过尾指针，循环结束.\n\n\n\n在上述循环结束后,两个数组中可能存在未遍历完的情况: 循环结束后，\n\n * 先对比旧数组的头尾指针，如果旧数组遍历完了（可能新数组没遍历完，有漏添加的问题），添加新数组中漏掉的节点\n * 再对比新数组的头尾指针，如果新数组遍历完了（可能旧数组没遍历完，有漏删除的问题），删除旧数组中漏掉的节点\n\n\n参考#\n\n * Vue 核心之虚拟 DOM\n * 解析 vue2.0 的 diff 算法\n * 详解 vue 的 diff 算法\n * 面试官: 你对虚拟 DOM 原理的理解?\n * 【 Vue 源码分析 】如何在更新 Patch 中进行 Diff.md","routePath":"/posts/vue/diff","lang":"","toc":[{"text":"Diff 算法","id":"diff-算法","depth":2,"charIndex":-1},{"text":"diff 流程图","id":"diff-流程图","depth":3,"charIndex":313},{"text":"从源码角度进行探究","id":"从源码角度进行探究","depth":3,"charIndex":406},{"text":"sameVnode","id":"samevnode","depth":3,"charIndex":1038},{"text":"patchVnode","id":"patchvnode","depth":3,"charIndex":1188},{"text":"updateChildren","id":"updatechildren","depth":3,"charIndex":1866},{"text":"具体的 diff 分析","id":"具体的-diff-分析","depth":3,"charIndex":1911},{"text":"参考","id":"参考","depth":3,"charIndex":2892}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"diff","category":"vue","tag":["vue","diff"],"star":true,"lastUpdated":false},"version":""},{"id":459,"title":"vue","content":"vue 源码分析#\n\n\n核心#\n\nVue 响应式的核心是利用\nObject.defineProperty()这个方法进行数据劫持和观察者模式进行数据响应式的。Object.defineProperty()这个方法会直接在一\n个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。具体用法如下：\n\n它有三个参数，第一个是 object，它代表要定义属性的对象。；第二个是 prop，它代表目标对象的属性值；第三个参数是\ndescriptor，它代表要定义或修改的属性描述符。\n\n响应式用法：\n\n\n\n\n观察者模式#\n\n什么是观察者模式？它分为注册环节跟发布环节。\n\n比如我去买芝士蛋糕，但是店家还没有做出来。这时候我又不想在店外面傻傻等，我就需要隔一段时间来回来问问蛋糕做好没，对于我来说是很麻烦的事情，说不定我就懒得买了。\n\n店家肯定想要做生意，不想流失我这个吃货客户。于是，在蛋糕没有做好的这段时间，有客户来，他们就让客户把自己的电话留下，这就是观察者模式中的注册环节。然后蛋糕做好之\n后，一次性通知所有记录了的客户，这就是观察者的发布环节。\n\n一个简单的观察者模式类：\n\n\n\n\n初始化#\n\nvue 在初始化执行 initState 的时候，会对props、methods、data、computed 和 wathcer 等属性做初始化操作。\n\n\n\n在初始化 data 的时候，一共做了两件事，一件是利用 proxy 将数据代理到整个 vue 实例上，另一件就是将 data 中的所有对象属性 reactive\n化，变成响应式对象，为对象添加 getter 和 setter。\n\n\n\n上面的这段代码，它将对象的所有属性进行遍历执行 defineReactive()方法进行响应式化\n\n\n\n在执行这个方法的过程中，会 new 一个 dep 实例，记得注意，后面会用到\n\n\n\n上述代码中的 Dep 类就是一个观察者类，每个对象属性都一个 dep 实例对象，在执行 get 的时候进行触发 depend 方法，触发 sit 的时候执行\nnotify 方法。\n\n\nmount 阶段#\n\n在 vue 实例挂载阶段，会创建一个 Watcher 类的实例对象，这个 Watcher 实际上是连接 Vue 组件与 Dep（也就是视图更新环节）的桥梁。\n\n\n\n在 rende()方法将模板渲染成虚拟 Vnode 的过程中会访问 data，从而触发属性的 getter，然后每个对象属性又有一个 dep\n实例对象（上面提到的），然后再 getter 的逻辑中又会调用该 dep 的 depend 方法，将 watcher 实例 add 到 sub（存在 Dep\n类中的存储 watcher 的数组）里面。在 depend 方法里面，Dep.target 就是 watcher 本身，在 Wacher\n类中的构造函数会执行（上面代码有）。以上过程就叫依赖收集。\n\n\n派发更新#\n\n在对象属性的数据改变之后，会触发 sitter，从而执行 sitter 函数的逻辑，从而调用 dep 实例的 notify 方法，从而进行遍历调用 sub\n中所有 watcher 的 upadte 方法进行视图更新。\n\n\n总结#\n\n**第一步：**组件初始化的时候，先给每一个 Data 属性都注册 getter，setter，也就是 reactive 化。然后再 new 一个自己的\nWatcher 对象，此时 watcher 会立即调用组件的 render 函数去生成虚拟 DOM。在调用 render 的时候，就会需要用到 data\n的属性值，此时会触发 getter 函数，将当前的 Watcher 函数注册进 sub 里。\n\n**第二步：**当 data 属性发生改变之后，会触发 sitter，遍历 sub 里所有的 watcher 对象，通知它们去重新渲染组件。\n\n注意：vue 对数组响应式是通过变异方法完成的，而且如果要对响应式对象添加新的属性，必须要用$set 方法才能完成\n\n参考文章：\n\nvue 技术揭秘\n\n最简化 VUE 的响应式原理","routePath":"/posts/vue/","lang":"","toc":[{"text":"vue 源码分析","id":"vue-源码分析","depth":2,"charIndex":-1},{"text":"**核心**","id":"核心","depth":3,"charIndex":-1},{"text":"**观察者模式**","id":"观察者模式","depth":3,"charIndex":-1},{"text":"**初始化**","id":"初始化","depth":3,"charIndex":-1},{"text":"**mount 阶段**","id":"mount-阶段","depth":3,"charIndex":-1},{"text":"**派发更新**","id":"派发更新","depth":3,"charIndex":-1},{"text":"**总结**","id":"总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"icon":"vue","date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"vue","category":"vue","tag":"vue","star":true,"index":true,"dir":{"order":6}},"version":""},{"id":460,"title":"keep-alive","content":"keep-alive#\n\nkeep-alive是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。\n\nactivated和deactivated两个生命周期, 将会在树内的所有嵌套组件中触发, 用来得知当前组件是否处于活跃状态。\n\n * include - 字符串或正则表达式。只有名称匹配的组件会被缓存。\n * exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。\n * max - 数字。最多可以缓存多少组件实例。\n\n实现原理：\n\n * keep-alive\n * 聊聊 keep-alive 组件的使用及其实现原理\n\n\n组件中 data 为什么是一个函数#\n\n为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？\n\n因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中\ndata 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue\n的实例，是不会被复用的，因此不存在引用对象的问题。\n\n\n父子组件钩子函数执行顺序#\n\nVue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：\n\n * 加载渲染过程\n\n父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子\nbeforeMount -> 子 mounted -> 父 mounted\n\n * 子组件更新过程\n\n父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated\n\n * 父组件更新过程\n\n父 beforeUpdate -> 父 updated\n\n * 销毁过程\n\n父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed\n\n\n父组件监听子组件的生命周期#\n\n比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：\n\n\n\n以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：\n\n\n\n当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。","routePath":"/posts/vue/keep-alive","lang":"","toc":[{"text":"keep-alive","id":"keep-alive","depth":2,"charIndex":-1},{"text":"组件中 data 为什么是一个函数","id":"组件中-data-为什么是一个函数","depth":2,"charIndex":287},{"text":"父子组件钩子函数执行顺序","id":"父子组件钩子函数执行顺序","depth":2,"charIndex":552},{"text":"父组件监听子组件的生命周期","id":"父组件监听子组件的生命周期","depth":2,"charIndex":926}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"keep-alive","category":"vue","tag":["vue","keep-alive"],"star":true,"lastUpdated":false},"version":""},{"id":461,"title":"vue生命周期","content":"#\n\nVue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载 Dom、渲染 → 更新 → 渲染、销毁等一系列过程，我们称这是 Vue\n的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。\n\n每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM\n等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。\n\n\n\n在我们实际项目开发过程中，会非常频繁地和 Vue 组件的生命周期打交道，接下来我们就从源码的角度来看一下这些生命周期的钩子函数是如何被执行的。\n\n源码中最终执行生命周期的函数都是调用 callHook 方法\n\n\n\ncallHook函数的逻辑很简单，根据传入的字符串 hook，去拿到 vm.$options[hook] 对应的回调函数数组，然后遍历执行，执行的时候把 vm\n作为函数执行的上下文。\n\n\nbeforeCreate & created#\n\nbeforeCreate 和 created函数都是在实例化 Vue 的阶段，在_init方法中执行的, 也就是初始化实例的时候\n\n\n\nbeforeCreate 和 created 的钩子调用是在 initState 的前后，initState 的作用是初始化\nprops、data、methods、watch、computed 等属性，之后我们会详细分析。那么显然 beforeCreate 的钩子函数中就不能获取到\nprops、data 中定义的值，也不能调用 methods 中定义的函数。\n\n\nbeforeMount & mounted#\n\n顾名思义，beforeMount 钩子函数发生在 mount，也就是 DOM 挂载之前，它的调用时机是在 mountComponent 函数中\n\n\n\n在执行 vm._render() 函数渲染VNode之前，执行了 beforeMount 钩子函数，在执行完 vm._update() 把 VNode\npatch到真实 DOM 后，执行 mounted钩子。注意，这里对 mounted钩子函数执行有一个判断逻辑，vm.$vnode 如果为\nnull，则表明这不是一次组件的初始化过程，而是我们通过外部new Vue初始化过程。那么对于组件，它的 mounted时机在哪儿呢？组件的 VNode\npatch 到 DOM 后，会执行 invokeInsertHook 函数，把 insertedVnodeQueue里保存的钩子函数依次执行一遍\n\n\n\n该函数会执行 insert 这个钩子函数，对于组件而言，insert 钩子函数的定义在 src/core/vdom/create-component.js 中的\ncomponentVNodeHooks 中：\n\n\n\n可以看到，每个子组件都是在这个钩子函数中执行 mounted 钩子函数，并且我们之前分析过，insertedVnodeQueue\n的添加顺序是先子后父，所以对于同步渲染的子组件而言，mounted 钩子函数的执行顺序也是先子后父。\n\n\nbeforeUpdate & updated#\n\n顾名思义，beforeUpdate 和 updated 的钩子函数执行时机都应该是在数据更新的时候，到目前为止，还没有分析 Vue 的数据双向绑定、更新相关。\nbeforeUpdate 的执行时机是在渲染 Watcher 的 before 函数中：\n\n\n\n注意这里有个判断，也就是在组件已经 mounted 之后，才会去调用这个钩子函数。 update 的执行时机是在 flushSchedulerQueue\n函数调用的时候，它的定义在 src/core/observer/scheduler.js 中：\n\n\n\nflushSchedulerQueue updatedQueue 是更新了的 wathcer 数组，那么在 callUpdatedHooks\n函数中，它对这些数组做遍历，只有满足当前 watcher 为 vm.\\_watcher 以及组件已经 mounted 这两个条件，才会执行 updated\n钩子函数。在组件 mount 的过程中，会实例化一个渲染的 Watcher 去监听 vm 上的数据变化重新渲染，这段逻辑发生在 mountComponent\n函数执行的时候：\n\n\n\n那么在实例化 Watcher 的过程中，在它的构造函数里会判断 isRenderWatcher，接着把当前 watcher 的实例赋值给\nvm.\\_watcher，定义在 src/core/observer/watcher.js 中：\n\n\n\n同时，还把当前 wathcer 实例 push 到 vm.\\_watchers 中，vm.\\_watcher 是专门用来监听 vm\n上数据变化然后重新渲染的，所以它是一个渲染相关的 watcher，因此在 callUpdatedHooks 函数中，只有 vm.\\_watcher\n的回调执行完毕后，才会执行 updated 钩子函数。\n\n\nbeforeDestroy & destroyed#\n\n顾名思义，beforeDestroy 和 destroyed 钩子函数的执行时机在组件销毁的阶段，组件的销毁过程之后会详细介绍，最终会调用 $destroy\n方法，它的定义在 src/core/instance/lifecycle.js中：\n\n\n\nbeforeDestroy 钩子函数的执行时机是在 $destroy 函数执行最开始的地方，接着执行了一系列的销毁动作，包括从 parent 的\n$children 中删掉自身，删除 watcher，当前渲染的 VNode 执行销毁钩子函数等，执行完毕后再调用 destroy 钩子函数。在\n$destroy 的执行过程中，它又会执行 vm.**patch**(vm.\\_vnode, null) 触发它子组件的销毁钩子函数，这样一层层的递归调用，所以\ndestroy 钩子函数执行顺序是先子后父，和 mounted 过程一样。\n\n\nactivated & deactivated#\n\nactivated 和 deactivated钩子函数是专门为keep-alive 组件定制的钩子.\n\n\n总结#\n\nVue 生命周期中各个钩子函数的执行时机以及顺序，在 created 钩子函数中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在\ndestroy 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。","routePath":"/posts/vue/life-cycle","lang":"","toc":[{"text":"beforeCreate & created","id":"beforecreate--created","depth":2,"charIndex":441},{"text":"beforeMount & mounted","id":"beforemount--mounted","depth":2,"charIndex":717},{"text":"beforeUpdate & updated","id":"beforeupdate--updated","depth":2,"charIndex":1340},{"text":"beforeDestroy & destroyed","id":"beforedestroy--destroyed","depth":2,"charIndex":2152},{"text":"activated & deactivated","id":"activated--deactivated","depth":2,"charIndex":2571},{"text":"总结","id":"总结","depth":2,"charIndex":2650}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"vue生命周期","category":"vue","tag":"vue","star":true,"lastUpdated":false},"version":""},{"id":462,"title":"nextTick","content":"nextTick#\n\n在做项目的时候，我们经常会用到nextTick，简单的理解就是它就是一个setTimeout函数，将函数放到异步后去处理；将它替换成setTimeout好像也能\n跑起来，但它仅仅这么简单吗？那为什么我们不直接用setTimeout呢？让我们深入剖析一下。\n\n\n先看一个例子#\n\n\n\n打印出来的结果是begin，我们在点击事件里明明将message赋值为end，而获取真实 DOM 节点的 innerHTML\n却没有得到预期中的begin，为什么？\n\n同样的情况也发生在给子组件传参上；我们给子组件传参数后，在子组件中调用函数查看参数。\n\n\n再看一个例子#\n\n\n\n虽然页面上展示了子组件的 name，但是打印出来却是空值：\n\n\n异步更新#\n\n我们发现上述两个问题的发生，不管子组件还是父组件，都是在给 data\n中赋值后立马去查看数据导致的。由于查看数据这个动作是同步操作的，而且都是在赋值之后；因此我们猜测一下，给数据赋值操作是一个异步操作，并没有马上执行，Vue\n官网对数据操作是这么描述的：\n\n> 可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue\n> 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要\n> 的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue\n> 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用\n> setTimeout(fn, 0) 代替。\n\n也就是说我们在设置this.msg = 'some thing'的时候，Vue 并没有马上去更新 DOM\n数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿出来处理。\n\n这样做主要是为了提升性能，因为如果在主线程中更新 DOM，循环 100 次就要更新 100 次 DOM；但是如果等事件循环完成之后更新 DOM，只需要更新 1\n次。\n\n为了在数据更新操作之后操作 DOM，我们可以在数据变化之后立即使用Vue.nextTick(callback)；这样回调函数会在 DOM\n更新完成后被调用，就可以拿到最新的 DOM 元素了。\n\n\n\n\n事件轮询#\n\nVue.js 在修改数据的时候，不会立马修改数据，而是要等同一事件轮询的数据都更新完之后，再统一进行视图更新。 知乎上的例子：\n\n\n\n\n\n\nnextTick 源码分析#\n\n了解了nextTick的用法和原理之后，我们就来看一下 Vue 是怎么来实现这波“操作”的。\n\nVue 把nextTick的源码单独抽到一个文件中，/src/core/util/next-tick.js，删掉注释也就大概六七十行的样子，让我们逐段来分析。\n\n\n\n其中Promise和setTimeout很好理解，是一个异步任务，会在同步任务以及更新 DOM 的异步任务之后回调具体函数。\n\n下面着重介绍一下MutationObserver\n\nMutationObserver是 HTML5 中的新 API，是个用来监视 DOM 变动的接口。他能监听一个 DOM\n对象上发生的子节点删除、属性修改、文本内容修改等等。\n\n调用过程很简单，但是有点不太寻常：你需要先给他绑回调：\n\n\n\n通过给MutationObserver的构造函数传入一个回调，能得到一个MutationObserver实例，这个回调就会在MutationObserver实例\n监听到变动时触发。\n\n这个时候你只是给 MutationObserver 实例绑定好了回调，他具体监听哪个 DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的\nobserver 方法就可以完成这一步:\n\n\n\n\n\n在nextTick中MutationObserver的作用就如上图所示。在监听到 DOM 更新后，调用回调函数。\n\n其实使用MutationObserver的原因就是nextTick想要一个异步\nAPI，用来在当前的同步代码执行完毕后，执行我想执行的异步回调，包括Promise和setTimeout都是基于这个原因。\n\n\n实现一个简易的 nextTick#\n\n\n\n可以看到，在简易版的 nextTick 中，通过 nextTick 接收回调函数，通过 setTimeout 来异步执行回调函数。通过这种方式，可以实现在下一个\ntick 中执行回调函数，即在 UI 重新渲染后执行回调函数。\n\n\n总结#\n\n到这里，整体 nextTick 的代码都分析完毕了，总结一下它的流程就是：\n\n 1. 把回调函数放入 callbacks 等待执行\n 2. 将执行函数放到微任务或者宏任务中\n 3. 事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调\n\n * Vue 中$nextTick 源码解析\n * Vue.js 异步更新及 nextTick\n * Vue 源码解析之 nextTick\n * 简单理解 Vue 中的 nextTick","routePath":"/posts/vue/nextTick","lang":"","toc":[{"text":"nextTick","id":"nexttick","depth":2,"charIndex":-1},{"text":"先看一个例子","id":"先看一个例子","depth":3,"charIndex":140},{"text":"再看一个例子","id":"再看一个例子","depth":3,"charIndex":280},{"text":"异步更新","id":"异步更新","depth":3,"charIndex":323},{"text":"事件轮询","id":"事件轮询","depth":3,"charIndex":1071},{"text":"nextTick 源码分析","id":"nexttick-源码分析","depth":3,"charIndex":1148},{"text":"实现一个简易的 nextTick","id":"实现一个简易的-nexttick","depth":3,"charIndex":1858},{"text":"总结","id":"总结","depth":3,"charIndex":1994}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"nextTick","category":"vue","tag":["vue","nextTick"],"star":true,"lastUpdated":false},"version":""},{"id":463,"title":"props","content":"props#\n\n这一次，通过源码阅读，主要探索的方面包括如何初始化 Props、以及如何进行更新。\n\n\n初始化#\n\n\n\n初始化 Props 的关键点就在于 loop 函数，让我们接着该函数做了什么事情。\n\n\n\n理解上应该不会有太大的问题，loop 函数中主要做了以下几件事：\n\n * defineReactive\n\n相信对这个函数应该都不会陌生，其实就是对 Vue 实例上的_props对象中每一个属性都配置成响应式的，这样一来，当父组件中传递进来的 Props\n变化时，则会通知相应的子组件中更新函数进行更新；\n\n * 对相应的子组件配置 Props 属性的 Setter 警告函数\n\n用过 Vue 的童鞋们应该都会遇到直接更改一个 Props 中的属性时，会抛出一个警告。而这个警告就是在 Vue 遍历 _props\n对象中的值时，都会默认配置一个警告 Setter 函数；\n\n * proxy\n\n在遍历的过程中，一旦发现有新的属性时，都会将新属性重新挂载到 Vue 实例的 _props 中。这里有一个很重要的知识点，当我们直接访问一个 Props\n中的属性时，即上面栗子中this.name，其实是直接访问了 Vue 实例的 _props 对象中值而已。\n\n至此，我们也知道 Vue 源码是如何实现初始化 Props 的了，那么，究竟是父组件是如何通知更新 Props 的呢？我们接着看下去。\n\n\n更新#\n\n由于父组件在更新的过程中，会通知子组件也进行更新，这时候就会调取一个方法updateChildComponent，而这个方法里就会对 Props\n进行更新。我们就来看看是如何处理的：\n\n\n\n一开始看到这里代码时，我是懵逼状态的，因为很容易绕不出来 😂。。在这里面会有几个问题，分别是：\n\n * validateProp 作用究竟是什么？\n\n相信用过 Props 的同学都清楚，在传递给子组件时，子组件中是有权限决定传递的值类型的，大大提高传递的规范，举个例子：\n\n\n\n代码很好理解，就是规定 name 属性的类型以及是否必传。而方法validateProp作用就是校验父组件传递给子组件的值是否按要求传递，若正确传递则直接赋值给\n_props 对象上相应的属性。\n\n * 校验通过后，直接赋值给 _props 对象上相应的属性的用意何在？\n\n上面提到过，_props 对象上的每一个属性都会使用 proxy 方法进行响应式挂载。那么当我直接赋值到 _props 对象上相应的属性时，就会触发到其\nSetter 函数进行相应的依赖更新。因此，当父组件更新一个传递到子组件的属性时，首先会触发其 Setter\n函数通知父组件进行更新，然后通过渲染函数传递到子组件后，更新子组件中的 Props。这时候，由于此时的 Props\n对象中的属性收集到了子组件的依赖，更改后会通知相应的依赖进行更新。\n\n * toggleObserving 究竟是干嘛用的？\n\n首先它是一个递归遍历方法，Props 在通知子组件依赖更新时，必须搞清楚的一点，就是是整个值的变化来进行通知。如何理解？\n\n简单滴说，对于属性值为基本数据类型的，当值改变时，是可以直接通知子组件进行更新的，而对于复杂数据类型来说，在更新时，会递归遍历其对象内部的属性来通知相应的依赖进\n行更新。\n\n那么当调用方法toggleObserving为 false\n时，对于基础数据类型来说，当其值变化时则直接通知子组件更新，而对于其复杂数据类型来说，则不会递归下去，而只会监听整个复杂数据类型替换时，才会去通知子组件进行更新\n。因此在 Props 中所有属性通知完后，又会重新调用方法 toggleObserving 为 true\n来打开递归开关。（真的不得不服尤大大啊，这么好的优化思路都能想出来，牛人 👍）\n\n至此，你大概也知道整个更新流程了，但是我当时还是存在疑惑的，既然基础数据类型值更改或复杂数据类型整个值更改，可以直接通知到子组件进行更新，那么是否会有一种情况就\n是，复杂数据类型中属性更改时，又是如何通知子组件更新的呢？？🤔\n\n首先，我们一开始已经忽略一个方法，那就是 defineReactive$$1，这个方法真的用的秒，可以看看上面的代码，在初始化 Props 时候，会对\nProps\n每一项的属性进行使用该方法进行响应式的处理，包括了复杂数据类型的中属性，此时该属性不但收集了父组件依赖，还收集了子组件的依赖，这样一来，当复杂数据类型中属性变化\n时，会先通知父组件更新，再通知子组件进行更新。（这时候我真的不得不服到五体投地。。。）\n\n\n总结#\n\n * 当 Props 中属性为基础数据类型值更改或复杂数据类型替换时，会通过 Setter 函数通知父组件进行更新，然后通过渲染函数，传递到子组件中更新其\n   Props 中对象相应的值，这时候就会触发到相应值的 Setter 来通知子组件进行更新；\n * 当 Props 中属性为复杂数据类型的属性更改时，由于使用 defineReactive$$1\n   方法收集到了父组件依赖以及子组件的依赖，这时候会先通知父组件进行更新，再通知子组件进行更新；\n\n参考:\n\n * Vue.js 技术揭秘 props\n * 【 Vue 源码分析 】运行机制之 Props","routePath":"/posts/vue/props","lang":"","toc":[{"text":"props","id":"props","depth":2,"charIndex":-1},{"text":"初始化","id":"初始化","depth":3,"charIndex":51},{"text":"更新","id":"更新","depth":3,"charIndex":602},{"text":"总结","id":"总结","depth":3,"charIndex":1912}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"props","category":"vue","tag":["vue","props"],"star":true,"lastUpdated":false},"version":""},{"id":464,"title":"proxy-observe 核心代码 自定义实现","content":"#\n\n","routePath":"/posts/vue/proxy-observe","lang":"","toc":[],"domain":"","frontmatter":{"icon":"vue","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","category":"vue","tag":"vue","star":true},"version":""},{"id":465,"title":"set","content":"$set() 实时更新#\n\n\n对象添加属性#\n\n对于使用 Object.defineProperty 实现响应式的对象，当我们去给这个对象添加一个新的属性的时候，是不能够触发它的 setter 的，比如：\n\n\n\n但是添加新属性的场景我们在平时开发中会经常遇到，那么 Vue 为了解决这个问题，定义了一个全局 API Vue.set 方法\n\n\n\nset 方法接收 3 个参数，\n\n * target 可能是数组或者是普通对象\n * key 代表的是数组的下标或者是对象的键值\n * val 代表添加的值\n\n首先判断如果 target 是数组且 key 是一个合法的下标，则之前通过 splice 去添加进数组然后返回，这里的 splice 其实已经不仅仅是原生数组的\nsplice 了，稍后我会详细介绍数组的逻辑。\n\n接着又判断 key 已经存在于 target 中，则直接赋值返回，因为这样的变化是可以观测到了。\n\n接着再获取到 target.__ob__ 并赋值给 ob，之前分析过它是在 Observer 的构造函数执行的时候初始化的，表示 Observer\n的一个实例，如果它不存在，则说明 target 不是一个响应式的对象，则直接赋值并返回。\n\n最后通过 defineReactive(ob.value, key, val) 把新添加的属性变成响应式对象，然后再通过 ob.dep.notify()\n手动的触发依赖通知，还记得我们在给对象添加 getter 的时候有这么一段逻辑：\n\n\n\n在 getter 过程中判断了 childOb，并调用了 childOb.dep.depend() 收集了依赖，这就是为什么执行 Vue.set 的时候通过\nob.dep.notify() 能够通知到 watcher，从而让添加新的属性到对象也可以检测到变化。这里如果 value 是个数组，那么就通过\ndependArray 把数组每个元素也去做依赖收集。\n\n\n数组#\n\n接着说一下数组的情况，Vue 也是不能检测到以下变动的数组：\n\n1.当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n\n2.当你修改数组的长度时，例如：vm.items.length = newLength\n\n对于第一种情况，可以使用：Vue.set(example1.items, indexOfItem, newValue)；而对于第二种情况，可以使用\nvm.items.splice(newLength)。\n\n我们刚才也分析到，对于 Vue.set 的实现，当 target 是数组的时候，也是通过 target.splice(key, 1, val)\n来添加的，那么这里的 splice 到底有什么黑魔法，能让添加的对象变成响应式的呢。\n\n其实之前我们也分析过，在通过 observe 方法去观察对象的时候会实例化 Observer，在它的构造函数中是专门对数组做了处理。\n\n\n\n这里我们只需要关注 value 是 Array 的情况，首先获取 augment，这里的 hasProto 实际上就是判断对象中是否存在\n__proto__，如果存在则 augment 指向 protoAugment， 否则指向 copyAugment，来看一下这两个函数的定义：\n\n\n\nprotoAugment 方法是直接把 target.__proto__ 原型直接修改为 src，而 copyAugment 方法是遍历 keys，通过\ndef，也就是 Object.defineProperty 去定义它自身的属性值。对于大部分现代浏览器都会走到 protoAugment，那么它实际上就把\nvalue 的原型指向了 arrayMethods\n\n\n\n可以看到，arrayMethods 首先继承了 Array，然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。\n\n重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice\n方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 ob.dep.notify() 手动触发依赖通知，这就很好地解释了之前的示例中调用\nvm.items.splice(newLength) 方法可以检测到变化。","routePath":"/posts/vue/set","lang":"","toc":[{"text":"$set() 实时更新","id":"set-实时更新","depth":2,"charIndex":-1},{"text":"对象添加属性","id":"对象添加属性","depth":3,"charIndex":14},{"text":"数组","id":"数组","depth":3,"charIndex":830}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"set","category":"vue","tag":["vue"],"star":true,"lastUpdated":false},"version":""},{"id":466,"title":"vue核心概念","content":"在父组件中监听子组件的生命周期钩子#\n\n\n\n相关源码\n\n\n在 methods 中使用 debounce / throttle#\n\n\n\n官网例子\n\n\n1、组件化#\n\n\n组件化基础#\n\n * MVVM 模型\n   \n   * 模型-视图-视图模型。\n   * 模型（Model）指的是后端传递的数据。视图(View)指的是所看到的页面。视图模型(ViewModel)是 mvvm 模式的核心，它是连接 view\n     和 model\n     的桥梁。它有两个方向：一是将模型（Model）转化成视图(View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图(Vie\n     w)转化成模型(Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。\n\n * MVC\n   \n   * 模型-视图-控制器。\n   * M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。 C 即 Controller 指的是页面业务逻辑。使用 MVC 的目的就是将 M 和\n     V 的代码分离。 MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。 MVC 和 MVVM\n     的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离\n     Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说\n     MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。\n\n\n数据驱动视图#\n\n * 传统组件，只是静态渲染，更新还要依赖操作 DOM\n * 数据驱动视图 - Vue MVVM\n * 数据驱动视图 - React setState\n\n\n2、响应式#\n\n * 核心 api Object.defineproperty\n   * vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的，\n     也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；\n   * Object.defineproperty 核心代码 自定义实现\n * 监听对象（深度），监听数组\n * Object.defineproperty 的缺点（vue3 用 Proxy）\n   * 深度监听，需要递归到底，一次性计算量大\n   * 无法监听新增属性/删除属性（Vue.set Vue.delete）\n   * Proxy 核心代码 自定义实现\n   * proxy-observe 核心代码 自定义实现\n\nObject.defineproperty.html\n\n\n3、vdom 和 diff#\n\n * 应用背景\n   * vdom 是实现 vue 和 react 的重要基石\n   * diff 算法是 vdom 中最核心、最关键的部分\n   * vdom 是一个热门话题，也是面试中的热门问题\n   * DOM 操作非常耗费性能\n   * 以前用 jQuery，可以自行控制 DOM 操作的时机，手动调整\n   * Vue 和 React 是数据驱动视图，如何有效控制 DOM 操作\n * 解决方案 - vdom\n   * 有了一定复杂度，想减少计算次数比较难\n   * 能不能吧计算，更多的转移为 JS 计算？因为 JS 执行速度很快\n   * vdom - 用 JS 模拟 DOM 结构，计算出最小的变更，操作 DOM\n * vnode 结构\n * snabbdom 使用：vnode h patch\n\n\ndiff 算法#\n\n * diff 算法是 vdom 中最核心、最关键的部分\n * diff 算法能在日常使用 vue React 中体现出来（如 key）\n * diff 算法是前端热门话题\n\ndiff 算法概述#\n\n * diff 即对比，是一个广泛的概念，如 linux diff 命令、git diff 等\n * 两个 js 对象也可以做 diff，如https://gethub.com/cujojs/jiff\n\n\n4、模版编译#\n\n * with 语法\n * 模版编译为 render 函数\n * 执行 render 函数生成 vdom\n\n\n5、渲染过程#\n\n * 初次渲染过程\n * 更新过程\n * 异步渲染\n\n\n6、前端路由#\n\n * hash\n * h5 history\n * 两者对比\n\n\n7、vue 面试真题演练#\n\n\n1、v-show 和 v-if 的区别#\n\n * v-show 通过 css display 控制显示和隐藏\n * v-if 组件真正的渲染和销毁， 而不是显示和隐藏\n * 频繁切换显示状态用 v-show， 否则用 v-if\n\n\n为何在 v-for 中使用 key#\n\n * 必须用 key， 且不能是 index 和 random\n * diff 算法中通过 tag 和 key 来判断， 是否是 sameNode\n * 减少渲染次数，提升渲染性能\n\n\n描述 Vue 组件生命周期（父子组件）#\n\n * 单组件生命周期\n * 父子组件生命周期关系\n\n\nVue 组件如何通讯（常见）#\n\n * 父子组件 props 和 this.$emit\n * 自定义事件 event.$no event.$off event.emit\n * vuex\n\n\n描述组件渲染和更新的过程#\n\n * 响应式（监听属性变化）\n * 模版渲染\n * vdom\n\n\n双向数据绑定 v-model 的实现原理#\n\n * input 元素的 value = this.name\n * 绑定 input 事件 this.name = $event.target.value\n * data 更新触发 re-render\n\n\n对于 MVVM 的理解#\n\n * Model、viewModel、view\n\n\ncomputed 有何特点#\n\n * 缓存，不变不会重新计算\n * 提高性能\n\n\n为何组件 data 必须是一个函数？#\n\n * data 必须是一个函数（为了不同的实例不冲突）\n * vue 是一个 class\n\n\najax 请求应该放在哪个生命周期#\n\n * mounted\n * js 是单线程的， ajax 异步获取数据\n * 放在 mounted 之前没有什么用，只会让逻辑变得更混乱\n\n\n如何将组件所有 props 传递给子组件？#\n\n * $props\n * \n * 细节知识点，优先级不高\n\n\n如何自己实现 v-model#\n\n\n\n\n多个组件有相同的逻辑，如何抽离？#\n\n * mixin\n * 以及 mixin 的一些缺点\n\n\n为何要使用异步组件？#\n\n * 加载大组件\n * 路由异步加载\n\n\n何时使用 keep-alive？#\n\n * 缓存组件，不需要重复渲染\n * 如多个静态 tab 页的切换\n * 优化性能\n\n\n何时需要使用 beforeDestory#\n\n * 解绑自定义事件 event.$off\n * 清除定时器\n * 解绑自定义的 DOM 事件，如 window scroll 等\n\n\n什么是作用域插槽#\n\n\n\n\nvuex 中 action 和 mutation 有何区别#\n\n * action 中处理异步，mutation 不可以\n * mutaion 做原子操作\n * action 可以整合多个 mutation\n\n\nvue-router 常用的路由模式#\n\n * hash 默认\n * H5 history（需要服务支持）\n * 两者比较\n\n\n如何配置 vue-router 异步加载#\n\n * path 和 component\n * component: ()=> import('..///')\n\n\n请用 vnode 描述一个 DOM 结构#\n\n\n\n\n\n\n监听 data 变化的核心 API 是什么#\n\n * Object.defineProperty\n * 以及深度监听、监听数组\n * 有何缺点\n\n\nVue 如何监听数组变化#\n\n * Object.defineProperty 不能监听数组变化\n * 重新定义原型，重写 push pop 等方法，实现监听\n * proxy 可以原生支持监听数组变化\n\n\n请描述响应式原理#\n\n * 监听 data 变化\n * 组件渲染和更新的流程\n\n\ndiff 算法的时间复杂度#\n\n * O(n)\n * 在 O(n^3)基础上做了一些调整\n\n\n简述 diff 算法过程#\n\n * patch(elem, vnode)和 path(vnode, newVode)\n * pathVnode 和 addVnodes 和 removeVnodes\n * updataChildren（key 的重要性）\n\n\nvue 为何是异步渲染， $nextTick 何用#\n\n * 异步渲染（以合并 data 修改），以提高渲染性能\n * $nextTick 在 DOM 更新完后，触发回调\n\n\nVue 常见性能优化方式#\n\n * 合理使用 v-show 和 v-if\n * 合理使用 computed\n * v-for 时加 key， 以及避免和 v-if 同时使用\n * （v-for 优先级高， 每次 v-for 会重新计算一遍 v-if）\n * 自定义事件、DOM 事件及时销毁\n * 合理使用异步组件\n * 合理使用 keep-alive\n * data 层级不要太深\n * 使用 vue-loader 在开发环境做模版编译（预编译）\n * webpack 层面的优化\n * 前端通用的性能优化，如图片懒加载\n * 使用 SSR\n\n\nhash 和 history 路由实现原理#\n\nlocation.hash 的值实际就是 URL 中#后面的东西。\n\nhistory 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和\nhistory.replaceState()。","routePath":"/posts/vue/theory","lang":"","toc":[{"text":"在父组件中监听子组件的生命周期钩子","id":"在父组件中监听子组件的生命周期钩子","depth":2,"charIndex":-1},{"text":"在 methods 中使用 debounce / throttle","id":"在-methods-中使用-debounce--throttle","depth":2,"charIndex":28},{"text":"1、组件化","id":"1组件化","depth":2,"charIndex":73},{"text":"组件化基础","id":"组件化基础","depth":3,"charIndex":82},{"text":"数据驱动视图","id":"数据驱动视图","depth":3,"charIndex":761},{"text":"2、响应式","id":"2响应式","depth":2,"charIndex":848},{"text":"3、vdom 和 diff","id":"3vdom-和-diff","depth":2,"charIndex":1221},{"text":"diff 算法","id":"diff-算法","depth":3,"charIndex":1595},{"text":"diff 算法概述","id":"diff-算法概述","depth":4,"charIndex":1693},{"text":"4、模版编译","id":"4模版编译","depth":2,"charIndex":1808},{"text":"5、渲染过程","id":"5渲染过程","depth":2,"charIndex":1872},{"text":"6、前端路由","id":"6前端路由","depth":2,"charIndex":1909},{"text":"7、vue 面试真题演练","id":"7vue-面试真题演练","depth":2,"charIndex":1950},{"text":"1、v-show 和 v-if 的区别","id":"1v-show-和-v-if-的区别","depth":3,"charIndex":1966},{"text":"为何在 v-for 中使用 key","id":"为何在-v-for-中使用-key","depth":3,"charIndex":2082},{"text":"描述 Vue 组件生命周期（父子组件）","id":"描述-vue-组件生命周期父子组件","depth":3,"charIndex":2195},{"text":"Vue 组件如何通讯（常见）","id":"vue-组件如何通讯常见","depth":3,"charIndex":2244},{"text":"描述组件渲染和更新的过程","id":"描述组件渲染和更新的过程","depth":3,"charIndex":2339},{"text":"双向数据绑定 v-model 的实现原理","id":"双向数据绑定-v-model-的实现原理","depth":3,"charIndex":2387},{"text":"对于 MVVM 的理解","id":"对于-mvvm-的理解","depth":3,"charIndex":2513},{"text":"computed 有何特点","id":"computed-有何特点","depth":3,"charIndex":2553},{"text":"为何组件 data 必须是一个函数？","id":"为何组件-data-必须是一个函数","depth":3,"charIndex":2594},{"text":"ajax 请求应该放在哪个生命周期","id":"ajax-请求应该放在哪个生命周期","depth":3,"charIndex":2662},{"text":"如何将组件所有 props 传递给子组件？","id":"如何将组件所有-props-传递给子组件","depth":3,"charIndex":2753},{"text":"如何自己实现 v-model","id":"如何自己实现-v-model","depth":3,"charIndex":2808},{"text":"多个组件有相同的逻辑，如何抽离？","id":"多个组件有相同的逻辑如何抽离","depth":3,"charIndex":2828},{"text":"为何要使用异步组件？","id":"为何要使用异步组件","depth":3,"charIndex":2876},{"text":"何时使用 keep-alive？","id":"何时使用-keep-alive","depth":3,"charIndex":2910},{"text":"何时需要使用 beforeDestory","id":"何时需要使用-beforedestory","depth":3,"charIndex":2973},{"text":"什么是作用域插槽","id":"什么是作用域插槽","depth":3,"charIndex":3064},{"text":"vuex 中 action 和 mutation 有何区别","id":"vuex-中-action-和-mutation-有何区别","depth":3,"charIndex":3078},{"text":"vue-router 常用的路由模式","id":"vue-router-常用的路由模式","depth":3,"charIndex":3184},{"text":"如何配置 vue-router 异步加载","id":"如何配置-vue-router-异步加载","depth":3,"charIndex":3248},{"text":"请用 vnode 描述一个 DOM 结构","id":"请用-vnode-描述一个-dom-结构","depth":3,"charIndex":3328},{"text":"监听 data 变化的核心 API 是什么","id":"监听-data-变化的核心-api-是什么","depth":3,"charIndex":3356},{"text":"Vue 如何监听数组变化","id":"vue-如何监听数组变化","depth":3,"charIndex":3430},{"text":"请描述响应式原理","id":"请描述响应式原理","depth":3,"charIndex":3534},{"text":"diff 算法的时间复杂度","id":"diff-算法的时间复杂度","depth":3,"charIndex":3575},{"text":"简述 diff 算法过程","id":"简述-diff-算法过程","depth":3,"charIndex":3622},{"text":"vue 为何是异步渲染， $nextTick 何用","id":"vue-为何是异步渲染-nexttick-何用","depth":3,"charIndex":3751},{"text":"Vue 常见性能优化方式","id":"vue-常见性能优化方式","depth":3,"charIndex":3839},{"text":"hash 和 history 路由实现原理","id":"hash-和-history-路由实现原理","depth":2,"charIndex":4113}],"domain":"","frontmatter":{"icon":"vue","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"vue核心概念","category":"vue","tag":"vue","star":true},"version":""},{"id":467,"title":"Virtual DOM","content":"Virtual DOM#\n\n要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom\n树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？\n\ndiff算法能够帮助我们。\n\n我们先根据真实 DOM 生成一颗virtual DOM，当virtual\nDOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM\n上，然后使oldVnode的值为Vnode。\n\ndiff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的 DOM打补丁。\n\n\nvirtual DOM 和真实 DOM 的区别#\n\nvirtual DOM是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的：\n\n\n\n对应的 virtual DOM（伪代码）：\n\n\n\n（温馨提示：VNode和oldVNode都是对象，一定要记住）\n\n * 用 JavaScript 对象模拟 DOM\n\n * 把此虚拟 DOM 转成真实 DOM 并插入页面中\n\n * 如果有事件发生修改了虚拟 DOM\n\n * 比较两棵虚拟 DOM 树的差异，得到差异对象\n\n * 把差异对象应用到真正的 DOM 树上\n\n\nVNode#\n\n对于 VNode，相信大家一点都不陌生，用于表示虚拟节点，是实现Virtual DOM的一种方式。那么它究竟是怎样的呢？我们就去 Vue 源码里探讨一下。\n\n\n\n这里千万不要因为 VNode 的这么属性而被吓到，或者咬紧牙去摸清楚每个属性的意义，其实，我们主要了解其几个核心的关键属性就差不多了，例如：\n\n * tag 属性即这个vnode的标签属性\n * data 属性包含了最后渲染成真实 dom 节点后，节点上的class，attribute，style以及绑定的事件\n * children 属性是vnode的子节点\n * text 属性是文本属性\n * elm 属性为这个vnode对应的真实 dom 节点\n * key 属性是vnode的标记，在diff过程中可以提高diff的效率\n\nVirtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。","routePath":"/posts/vue/virtual-dom","lang":"","toc":[{"text":"Virtual DOM","id":"virtual-dom","depth":2,"charIndex":-1},{"text":"virtual DOM 和真实 DOM 的区别","id":"virtual-dom-和真实-dom-的区别","depth":3,"charIndex":314},{"text":"VNode","id":"vnode","depth":3,"charIndex":583}],"domain":"","frontmatter":{"icon":"vue","order":3,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"Virtual DOM","category":"vue","tag":["vue","Virtual DOM"],"star":true,"lastUpdated":false},"version":""},{"id":468,"title":"vueuse实用方法","content":"浏览器#\n\n\n使用屏幕断点#\n\n\n\n\n复制文字#\n\n\n\n\n事件监听#\n\n\n\n\n取色器#\n\n\n\n\n网站图标#\n\n\n\n\n全屏元素#\n\n\n\n\n异步加载图片#\n\n\n\n\n加载 script 标签#\n\n\n\n\n加载 css 字符串#\n\n * 输入\n\n\n\n * 输出\n\n\n\n\n网站标题#\n\n\n\n\nurl 查询参数#\n\n * history\n\n\n\n * hash\n\n\n\n\n系统通知#\n\n\n\n\n传感器#\n\n\n键盘事件#\n\n\n\n\n长按#\n\n\n\n * 使用指令\n\n\n\n\n设备列表#\n\n\n\n\n屏幕共享#\n\n\n\n\n鼠标悬停#\n\n\n\n * 指令\n\n\n\n\n焦点#\n\n\n\n\n地理位置#\n\n\n\n\n跟踪用户空闲#\n\n\n\n\n无限滚动#\n\n\n\n * 指令\n\n\n\n\n鼠标位置#\n\n\n\n\n网络状态#\n\n\n\n\n网络在线#\n\n\n\n\n页面离开#\n\n\n\n\n文本选中#\n\n","routePath":"/posts/vue/vssue","lang":"","toc":[{"text":"浏览器","id":"浏览器","depth":2,"charIndex":-1},{"text":"使用屏幕断点","id":"使用屏幕断点","depth":3,"charIndex":6},{"text":"复制文字","id":"复制文字","depth":3,"charIndex":18},{"text":"事件监听","id":"事件监听","depth":3,"charIndex":28},{"text":"取色器","id":"取色器","depth":3,"charIndex":38},{"text":"网站图标","id":"网站图标","depth":3,"charIndex":47},{"text":"全屏元素","id":"全屏元素","depth":3,"charIndex":57},{"text":"异步加载图片","id":"异步加载图片","depth":3,"charIndex":67},{"text":"加载 script 标签","id":"加载-script-标签","depth":3,"charIndex":79},{"text":"加载 css 字符串","id":"加载-css-字符串","depth":3,"charIndex":97},{"text":"网站标题","id":"网站标题","depth":3,"charIndex":129},{"text":"url 查询参数","id":"url-查询参数","depth":3,"charIndex":139},{"text":"系统通知","id":"系统通知","depth":3,"charIndex":176},{"text":"传感器","id":"传感器","depth":2,"charIndex":186},{"text":"键盘事件","id":"键盘事件","depth":3,"charIndex":193},{"text":"长按","id":"长按","depth":3,"charIndex":203},{"text":"设备列表","id":"设备列表","depth":3,"charIndex":222},{"text":"屏幕共享","id":"屏幕共享","depth":3,"charIndex":232},{"text":"鼠标悬停","id":"鼠标悬停","depth":3,"charIndex":242},{"text":"焦点","id":"焦点","depth":3,"charIndex":261},{"text":"地理位置","id":"地理位置","depth":3,"charIndex":269},{"text":"跟踪用户空闲","id":"跟踪用户空闲","depth":3,"charIndex":279},{"text":"无限滚动","id":"无限滚动","depth":3,"charIndex":291},{"text":"鼠标位置","id":"鼠标位置","depth":3,"charIndex":310},{"text":"网络状态","id":"网络状态","depth":3,"charIndex":320},{"text":"网络在线","id":"网络在线","depth":3,"charIndex":330},{"text":"页面离开","id":"页面离开","depth":3,"charIndex":340},{"text":"文本选中","id":"文本选中","depth":3,"charIndex":350}],"domain":"","frontmatter":{"icon":"direction","order":1,"date":"2023-03-20T00:00:00.000Z","author":"h7ml","category":"vue","tag":"vue","star":true,"title":"vueuse实用方法","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"vueuse实用方法","isOriginal":false,"head":[["meta",{"name":"keywords","content":"vueuse实用方法"}]]},"version":""},{"id":469,"title":"new Vue 发生了什么","content":"#\n\n写在前面：本文基于vue2.6进行源码分析\n\n\n初始化 vue#\n\n我们在实例化一个 vue 实例，也即 new Vue() 时，实际上是执行 src/core/instance/index.js 中定义的 Function\n函数。\n\n\n\n通过查看 Vue 的 function，我们知道 Vue 只能通过 new 关键字初始化，然后调用 this._init 方法，该方法在\nsrc/core/instance/init.js 中定义。\n\n\n\nVue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。\n\n\nVue 实例挂载#\n\nVue 中是通过 $mount 实例方法去挂载 dom 的，下面我们通过分析 compiler 版本的 mount 实现，相关源码在目录\nsrc/platforms/web/entry-runtime-with-compiler.js 文件中定义：。\n\n\n\n我们发现最终还是调用用原先原型上的 $mount 方法挂载 ，原先原型上的 $mount 方法在\nsrc/platforms/web/runtime/index.js 中定义 。\n\n\n\n我们发现$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js\n文件中\n\n\n\n从上面的代码可以看到，mountComponent核心就是先实例化一个渲染Watcher，在它的回调函数中会调用\nupdateComponent方法，在此方法中调用 vm._render方法先生成虚拟 Node，最终调用 vm._update更新 DOM。\n\n\n创建虚拟 Node#\n\nVue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟Node。它的定义在 src/core/instance/render.js\n文件中：\n\n\n\nvm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node\n\nVue.js 利用 _createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中：\n\n\n\n_createElement 方法有 5 个参数，context表示 VNode 的上下文环境，它是\nComponent类型；tag表示标签，它可以是一个字符串，也可以是一个 Component；data表示 VNode 的数据，它是一个\nVNodeData类型，可以在 flow/vnode.js 中找到它的定义；children表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的\nVNode 数组；\n\n\n更新视图#\n\n完成视图的更新工作事实上就是调用了vm._update方法，这个方法接收的第一个参数是刚生成的Vnode，调用的vm._update方法定义在\nsrc/core/instance/lifecycle.js 中。\n\n\n\n\n总结#\n\n下图更直观地看到从初始化 Vue 到最终渲染的整个过程。\n\n","routePath":"/posts/vue/what_happened_to_new_Vue","lang":"","toc":[{"text":"初始化 vue","id":"初始化-vue","depth":2,"charIndex":26},{"text":"Vue 实例挂载","id":"vue-实例挂载","depth":2,"charIndex":307},{"text":"创建虚拟 Node","id":"创建虚拟-node","depth":2,"charIndex":756},{"text":"更新视图","id":"更新视图","depth":2,"charIndex":1207},{"text":"总结","id":"总结","depth":2,"charIndex":1324}],"domain":"","frontmatter":{"icon":"vue","order":4,"date":"2021-07-12T00:00:00.000Z","author":"h7ml","title":"new Vue 发生了什么","category":"vue","tag":"vue","star":true,"lastUpdated":false},"version":""},{"id":470,"title":"PostgreSQL的语法知识和常见查询操作","content":"PostgreSQL 的语法知识和常见查询操作\n\n\n1. 数据定义语句（DDL）#\n\n\n1.1. 登录数据库#\n\n\n\n\n1.2. 创建数据库#\n\n\n\n\n1.3. 查看所有数据库#\n\n\n\n\n1.4. 连接数据库#\n\n\n\n\n1.5. 查看所有数据表#\n\n\n\n\n1.6. 删除数据库#\n\n\n\n\n2. 表操作#\n\n\n2.1. 创建表#\n\n\n\n\n2.2. 查看表结构#\n\n\n\n\n2.3. 删除表#\n\n\n\n\n2.4. 修改表名#\n\n\n\n2.5. 修改表的所有者#\n\n\n\n2.6. 修改表的注释#\n\n\n\n\n2.7. 修改列名#\n\n\n\n2.8. 修改列的数据类型#\n\n\n\n2.9. 修改列的默认值#\n\n\n\n2.10. 修改列的注释#\n\n\n\n\n2.11. 删除列#\n\n\n\n\n2.12. 添加列#\n\n\n\n2.13. 添加主键#\n\n\n\n2.14. 添加外键#\n\n\n\n2.15. 添加唯一约束#\n\n\n\n\n2.16. 添加检查约束#\n\n\n\n\n2.17. 删除主键#\n\n\n\n\n2.18. 删除外键#\n\n\n\n\n2.19. 删除唯一约束#\n\n\n\n\n2.20. 删除检查约束#\n\n\n\n\n2.21 查询列#\n\n\n\n\n3. 查询操作#\n\n\n3.1. 查询所有数据#\n\n\n\n\n3.2. 查询指定列#\n\n\n\n3.3. 查询指定列并去重#\n\n\n\n3.4. 查询指定列并排序#\n\n\n\n3.5. 查询指定列并限制返回行数#\n\n\n\n3.6. 查询指定列并限制返回行数并跳过指定行数#\n\n\n\n3.7. 查询指定列并限制返回行数并跳过指定行数并排序#\n\n\n\n3.8. 查询指定列并限制返回行数并跳过指定行数并排序并去重#\n\n\n\n\n3.9. 聚合函数#\n\n\n\n> 常见的聚合函数有：AVG、COUNT、SUM、MIN、MAX。\n\n3.10. 聚合函数并分组#\n\n\n\n3.11. 聚合函数并分组并排序#\n\n\n\n3.12. 聚合函数并分组并排序并限制返回行数并跳过指定行数#\n\n\n\n3.13. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重#\n\n\n\n3.14. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重并过滤#\n\n\n\n\n3.13 条件查询#\n\n\n\n> 常见的条件操作符有：=、<、>、<=、>=、<>等。\n\n3.14. 条件查询并分组#\n\n\n\n3.15. 条件查询并分组并排序#\n\n\n\n3.16. 条件查询并分组并排序并限制返回行数并跳过指定行数#\n\n\n\n> ASC 表示升序，DESC 表示降序。\n\n3.17. 条件查询并分组并排序并限制返回行数并跳过指定行数并去重#\n\n\n\n\n3.18. 连接查询#\n\n\n\n> 常见的连接类型有：INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN。\n\n\n3.19. 连接查询并分组#\n\n\n\n3.20. 连接查询并分组并排序#\n\n\n\n3.21. 连接查询并分组并排序并限制返回行数并跳过指定行数#\n\n\n\n\n3.22. 子查询#\n\n\n\n\n3.23. 分组查询#\n\n\n\n> 常见的聚合函数有：AVG、COUNT、SUM、MIN、MAX。\n\n3.24. 分组查询并排序#\n\n\n\n3.25. 分组查询并排序并限制返回行数并跳过指定行数#\n\n\n\n3.26. 分组查询并排序并限制返回行数并跳过指定行数并去重#\n\n\n\n\n3.27 嵌套查询#\n\n\n\n\n3.28 更新操作#\n\n\n\n\n3.29 删除操作#\n\n\n\n\nPostgreSQL 特有功能#\n\n\n4.1. JSON 数据类型#\n\nPostgreSQL 支持存储和查询 JSON 数据类型。\n\n\n\n\n4.2 全文搜索#\n\nPostgreSQL 提供全文搜索功能，可以在文本数据中进行高效的关键词搜索。\n\n\n\n\n4.3. 空间数据类型#\n\nPostgreSQL 支持空间数据类型和空间索引，用于存储和查询地理位置信息。\n\n\n\n\n参考文档#\n\n * PostgreSQL Documentation\n * PostgreSQL Tutorial\n * PostgreSQL Exercises\n * 菜鸟教程","routePath":"/up/PostgreSQL/PostgreSQL","lang":"","toc":[{"text":"1. 数据定义语句（DDL）","id":"1-数据定义语句ddl","depth":2,"charIndex":25},{"text":"1.1. 登录数据库","id":"11-登录数据库","depth":3,"charIndex":43},{"text":"1.2. 创建数据库","id":"12-创建数据库","depth":3,"charIndex":59},{"text":"1.3. 查看所有数据库","id":"13-查看所有数据库","depth":3,"charIndex":75},{"text":"1.4. 连接数据库","id":"14-连接数据库","depth":3,"charIndex":93},{"text":"1.5. 查看所有数据表","id":"15-查看所有数据表","depth":3,"charIndex":109},{"text":"1.6. 删除数据库","id":"16-删除数据库","depth":3,"charIndex":127},{"text":"2. 表操作","id":"2-表操作","depth":2,"charIndex":143},{"text":"2.1. 创建表","id":"21-创建表","depth":3,"charIndex":153},{"text":"2.2. 查看表结构","id":"22-查看表结构","depth":3,"charIndex":167},{"text":"2.3. 删除表","id":"23-删除表","depth":3,"charIndex":183},{"text":"2.4. 修改表名","id":"24-修改表名","depth":3,"charIndex":197},{"text":"2.5. 修改表的所有者","id":"25-修改表的所有者","depth":4,"charIndex":211},{"text":"2.6. 修改表的注释","id":"26-修改表的注释","depth":4,"charIndex":228},{"text":"2.7. 修改列名","id":"27-修改列名","depth":3,"charIndex":245},{"text":"2.8. 修改列的数据类型","id":"28-修改列的数据类型","depth":4,"charIndex":259},{"text":"2.9. 修改列的默认值","id":"29-修改列的默认值","depth":4,"charIndex":277},{"text":"2.10. 修改列的注释","id":"210-修改列的注释","depth":4,"charIndex":294},{"text":"2.11. 删除列","id":"211-删除列","depth":3,"charIndex":312},{"text":"2.12. 添加列","id":"212-添加列","depth":3,"charIndex":327},{"text":"2.13. 添加主键","id":"213-添加主键","depth":4,"charIndex":341},{"text":"2.14. 添加外键","id":"214-添加外键","depth":4,"charIndex":356},{"text":"2.15. 添加唯一约束","id":"215-添加唯一约束","depth":4,"charIndex":371},{"text":"2.16. 添加检查约束","id":"216-添加检查约束","depth":3,"charIndex":389},{"text":"2.17. 删除主键","id":"217-删除主键","depth":3,"charIndex":407},{"text":"2.18. 删除外键","id":"218-删除外键","depth":3,"charIndex":423},{"text":"2.19. 删除唯一约束","id":"219-删除唯一约束","depth":3,"charIndex":439},{"text":"2.20. 删除检查约束","id":"220-删除检查约束","depth":3,"charIndex":457},{"text":"2.21 查询列","id":"221-查询列","depth":3,"charIndex":475},{"text":"3. 查询操作","id":"3-查询操作","depth":2,"charIndex":489},{"text":"3.1. 查询所有数据","id":"31-查询所有数据","depth":3,"charIndex":500},{"text":"3.2. 查询指定列","id":"32-查询指定列","depth":3,"charIndex":517},{"text":"3.3. 查询指定列并去重","id":"33-查询指定列并去重","depth":4,"charIndex":532},{"text":"3.4. 查询指定列并排序","id":"34-查询指定列并排序","depth":4,"charIndex":550},{"text":"3.5. 查询指定列并限制返回行数","id":"35-查询指定列并限制返回行数","depth":4,"charIndex":568},{"text":"3.6. 查询指定列并限制返回行数并跳过指定行数","id":"36-查询指定列并限制返回行数并跳过指定行数","depth":4,"charIndex":590},{"text":"3.7. 查询指定列并限制返回行数并跳过指定行数并排序","id":"37-查询指定列并限制返回行数并跳过指定行数并排序","depth":4,"charIndex":619},{"text":"3.8. 查询指定列并限制返回行数并跳过指定行数并排序并去重","id":"38-查询指定列并限制返回行数并跳过指定行数并排序并去重","depth":4,"charIndex":651},{"text":"3.9. 聚合函数","id":"39-聚合函数","depth":3,"charIndex":687},{"text":"3.10. 聚合函数并分组","id":"310-聚合函数并分组","depth":4,"charIndex":736},{"text":"3.11. 聚合函数并分组并排序","id":"311-聚合函数并分组并排序","depth":4,"charIndex":754},{"text":"3.12. 聚合函数并分组并排序并限制返回行数并跳过指定行数","id":"312-聚合函数并分组并排序并限制返回行数并跳过指定行数","depth":4,"charIndex":775},{"text":"3.13. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重","id":"313-聚合函数并分组并排序并限制返回行数并跳过指定行数并去重","depth":4,"charIndex":810},{"text":"3.14. 聚合函数并分组并排序并限制返回行数并跳过指定行数并去重并过滤","id":"314-聚合函数并分组并排序并限制返回行数并跳过指定行数并去重并过滤","depth":4,"charIndex":848},{"text":"3.13 条件查询","id":"313-条件查询","depth":3,"charIndex":890},{"text":"3.14. 条件查询并分组","id":"314-条件查询并分组","depth":4,"charIndex":934},{"text":"3.15. 条件查询并分组并排序","id":"315-条件查询并分组并排序","depth":4,"charIndex":952},{"text":"3.16. 条件查询并分组并排序并限制返回行数并跳过指定行数","id":"316-条件查询并分组并排序并限制返回行数并跳过指定行数","depth":4,"charIndex":973},{"text":"3.17. 条件查询并分组并排序并限制返回行数并跳过指定行数并去重","id":"317-条件查询并分组并排序并限制返回行数并跳过指定行数并去重","depth":4,"charIndex":1031},{"text":"3.18. 连接查询","id":"318-连接查询","depth":3,"charIndex":1070},{"text":"3.19. 连接查询并分组","id":"319-连接查询并分组","depth":3,"charIndex":1141},{"text":"3.20. 连接查询并分组并排序","id":"320-连接查询并分组并排序","depth":4,"charIndex":1159},{"text":"3.21. 连接查询并分组并排序并限制返回行数并跳过指定行数","id":"321-连接查询并分组并排序并限制返回行数并跳过指定行数","depth":4,"charIndex":1180},{"text":"3.22. 子查询","id":"322-子查询","depth":3,"charIndex":1216},{"text":"3.23. 分组查询","id":"323-分组查询","depth":3,"charIndex":1231},{"text":"3.24. 分组查询并排序","id":"324-分组查询并排序","depth":4,"charIndex":1281},{"text":"3.25. 分组查询并排序并限制返回行数并跳过指定行数","id":"325-分组查询并排序并限制返回行数并跳过指定行数","depth":4,"charIndex":1299},{"text":"3.26. 分组查询并排序并限制返回行数并跳过指定行数并去重","id":"326-分组查询并排序并限制返回行数并跳过指定行数并去重","depth":4,"charIndex":1331},{"text":"3.27 嵌套查询","id":"327-嵌套查询","depth":3,"charIndex":1367},{"text":"3.28 更新操作","id":"328-更新操作","depth":3,"charIndex":1382},{"text":"3.29 删除操作","id":"329-删除操作","depth":3,"charIndex":1397},{"text":"PostgreSQL 特有功能","id":"postgresql-特有功能","depth":2,"charIndex":1412},{"text":"4.1. JSON 数据类型","id":"41-json-数据类型","depth":3,"charIndex":1431},{"text":"4.2 全文搜索","id":"42-全文搜索","depth":3,"charIndex":1482},{"text":"4.3. 空间数据类型","id":"43-空间数据类型","depth":3,"charIndex":1537},{"text":"参考文档","id":"参考文档","depth":2,"charIndex":1595}],"domain":"","frontmatter":{"icon":"PostgreSQL","order":1,"date":"2024-07-11T00:00:00.000Z","author":"h7ml","title":"PostgreSQL的语法知识和常见查询操作","description":"PostgreSQL的语法知识和常见查询操作","footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>PostgreSQL的语法知识和常见查询操作","star":1,"image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"PostgreSQL的语法知识和常见查询操作","category":["PostgreSQL","eventsource"],"tag":["PostgreSQL","eventsource"],"head":[["meta",{"name":"keywords","content":"PostgreSQL的语法知识和常见查询操作"}]]},"version":""},{"id":471,"title":"PostgreSQL","content":" * PostgreSQL","routePath":"/up/PostgreSQL/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"workingDirectory","title":"PostgreSQL","heroText":"h7ml","date":"2020-01-01T00:00:00.000Z","author":"h7ml","index":true,"category":"PostgreSQL","show":false,"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml","tag":"PostgreSQL","description":"PostgreSQL的语法知识和常见查询操作","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"PostgreSQL的语法知识和常见查询操作"},"version":""},{"id":472,"title":"PostgreSQL","content":" * PostgreSQL","routePath":"/up/PostgreSQL/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"workingDirectory","title":"PostgreSQL","heroText":"h7ml","date":"2020-01-01T00:00:00.000Z","author":"h7ml","index":true,"category":"PostgreSQL","show":false,"footer":"<a href='https://beian.mit.gov.cn/' target='blank'>浙ICP备2021037683号-2</a>MIT Licensed | Copyright © 2022-present h7ml","tag":"PostgreSQL","description":"PostgreSQL的语法知识和常见查询操作","image":"https://www.h7ml.cn/logo.png","banner":"https://www.h7ml.cn/logo.png","shortTitle":"PostgreSQL的语法知识和常见查询操作"},"version":""},{"id":473,"title":"python","content":" * Xpath\n\n * Scrapy\n\n * selenium\n\n * urllib","routePath":"/up/Python/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"python","author":"h7ml","category":"python","tag":"python","title":"python","index":false,"dir":{"order":10},"date":"2022-04-18T00:00:00.000Z"},"version":""},{"id":474,"title":"XPath","content":"XPath 语法#\n\n--------------------------------------------------------------------------------\n\nXPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。\n\n--------------------------------------------------------------------------------\n\n菜鸟教程 open in new window\n\n\nXML 实例文档#\n\n我们将在下面的例子中使用这个 XML 文档。\n\n\n实例#\n\n\n\n\n选取节点#\n\nXPath 使用路径表达式在 XML 文档中选取节点。节点是通过沿着路径或者 step 来选取的。 下面列出了最有用的路径表达式：\n\n表达式        描述\nnodename   选取此节点的所有子节点。\n/          从根节点选取（取子节点）。\n//         从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）。\n.          选取当前节点。\n..         选取当前节点的父节点。\n@          选取属性。\n\n在下面的表格中，我们已列出了一些路径表达式以及表达式的结果：\n\n路径表达式             结果\nbookstore         选取 bookstore 元素的所有子节点。\n/bookstore        选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！\nbookstore/book    选取属于 bookstore 的子元素的所有 book 元素。\n//book            选取所有 book 子元素，而不管它们在文档中的位置。\nbookstore//book   选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。\n//@lang           选取名为 lang 的所有属性。\n\n\n谓语（Predicates）#\n\n谓语用来查找某个特定的节点或者包含某个指定的值的节点。\n\n谓语被嵌在方括号中。\n\n在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：\n\n路径表达式                                 结果\n/bookstore/book[1]                    选取属于 bookstore 子元素的第一个 book 元素。\n/bookstore/book[last()]               选取属于 bookstore 子元素的最后一个 book 元素。\n/bookstore/book[last()-1]             选取属于 bookstore 子元素的倒数第二个 book 元素。\n/bookstore/book[position()<3]         选取最前面的两个属于 bookstore 元素的子元素的 book 元素。\n//title[@lang]                        选取所有拥有名为 lang 的属性的 title 元素。\n//title[@lang='eng']                  选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。\n/bookstore/book[price>35.00]          选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。\n/bookstore/book[price>35.00]//title   选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于\n                                      35.00。\n\n\n选取未知节点#\n\nXPath 通配符可用来选取未知的 XML 元素。\n\n通配符      描述\n*        匹配任何元素节点。\n@*       匹配任何属性节点。\nnode()   匹配任何类型的节点。\n\n在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：\n\n路径表达式          结果\n/bookstore/*   选取 bookstore 元素的所有子元素。\n//*            选取文档中的所有元素。\n//title[@*]    选取所有带有属性的 title 元素。\n\n\n选取若干路径#\n\n通过在路径表达式中使用\"|\"运算符，您可以选取若干个路径。\n\n在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果：\n\n| 路径表达式 | 结果 | | ----------------------- | -------------- |\n--------------------------------------------------------------------------------\n--- | | //book/title | //book/price | 选取 book 元素的所有 title 和 price 元素。 | |\n//title | //price | 选取文档中的所有 title 和 price 元素。 | | /bookstore/book/title |\n//price | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 |\n\n\nXPath 轴（Axes）#\n\n轴可定义相对于当前节点的节点集。\n\n轴名称                  结果\nancestor             选取当前节点的所有先辈（父、祖父等）。\nancestor-or-self     选取当前节点的所有先辈（父、祖父等）以及当前节点本身。\nattribute            选取当前节点的所有属性。\nchild                选取当前节点的所有子元素。\ndescendant           选取当前节点的所有后代元素（子、孙等）。\ndescendant-or-self   选取当前节点的所有后代元素（子、孙等）以及当前节点本身。\nfollowing            选取文档中当前节点的结束标签之后的所有节点。\nfollowing-sibling    选取当前节点之后的所有兄弟节点\nnamespace            选取当前节点的所有命名空间节点。\nparent               选取当前节点的父节点。\npreceding            选取文档中当前节点的开始标签之前的所有节点。\npreceding-sibling    选取当前节点之前的所有同级节点。\nself                 选取当前节点。","routePath":"/up/Python/Xpath","lang":"","toc":[{"text":"XPath 语法","id":"xpath-语法","depth":2,"charIndex":-1},{"text":"XML 实例文档","id":"xml-实例文档","depth":2,"charIndex":268},{"text":"实例","id":"实例","depth":2,"charIndex":304},{"text":"选取节点","id":"选取节点","depth":2,"charIndex":312},{"text":"谓语（Predicates）","id":"谓语predicates","depth":2,"charIndex":933},{"text":"选取未知节点","id":"选取未知节点","depth":2,"charIndex":1735},{"text":"选取若干路径","id":"选取若干路径","depth":2,"charIndex":1996},{"text":"XPath 轴（Axes）","id":"xpath-轴axes","depth":2,"charIndex":2432}],"domain":"","frontmatter":{"icon":"python","order":1,"date":"2022-05-20T00:00:00.000Z","author":"h7ml","category":"python","tag":"python","title":"XPath"},"version":""},{"id":475,"title":"python","content":" * Xpath\n\n * Scrapy\n\n * selenium\n\n * urllib","routePath":"/up/Python/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"python","author":"h7ml","category":"python","tag":"python","title":"python","index":false,"dir":{"order":10},"date":"2022-04-18T00:00:00.000Z"},"version":""},{"id":476,"title":"Scrapy","content":"Scrapy#\n\n\n安装#\n\n\nWindows 安装方式#\n\n升级 pip 版本：\n\n\n\n通过 pip 安装 Scrapy 框架:\n\n\nUbuntu 安装方式#\n\n安装非 Python 的依赖:\n\n\n\n通过 pip 安装 Scrapy 框架：\n\n\nMac OS 安装方式#\n\npip 版本必须转 22+，升级 pip 版本\n\n\n\n使用清华源下载\n\n\n\n> 注意：在 mac 中使用 scrapy 指令必须在前面加上 python3 -m\n\n\n新建项目#\n\n在开始爬取之前，必须创建一个新的 Scrapy 项目。进入自定义的项目目录中，运行下列命令：\n\n\n\n其中， mySpider 为项目名称，可以看到将会创建一个 mySpider 文件夹，目录结构大致如下：\n\n下面来简单介绍一下各个主要文件的作用：\n\n\n\n这些文件分别是:\n\n * scrapy.cfg: 项目的配置文件。\n * mySpider/: 项目的 Python 模块，将会从这里引用代码。\n * mySpider/items.py: 项目的目标文件。\n * mySpider/pipelines.py: 项目的管道文件。\n * mySpider/settings.py: 项目的设置文件。\n * mySpider/spiders/: 存储爬虫代码目录。\n\n\n创建爬虫文件#\n\n1、cd 进入 spiders 文件夹中\n\n\n\n2、创建爬虫文件\n\n\n\n3、test.py\n\n\n\n\n运行爬虫代码#\n\n> 注意：有的网站会有 robots 协议，这是一个君子协议，scrapy 默认是启动遵守的，如果想要爬取需要关闭\n\n在settings.py文件中\n\n\n\n\n语法#\n\n\nresponse 对象#\n\n解析数据返回的对象\n\n * response.body ：响应返回页面已二进制格式的内容\n\n * response.text ：响应返回页面已字符串格式的内容\n\n * response.url ：响应返回页面 url\n\n * response.status ：响应返回 ajax 请求状态码\n\n * response.xpath()：（常用） 使用 xpath 路径查询特定元素，返回一个selector列表对象\n\n * response.css()：使用css_selector查询元素，返回一个selector列表对象\n   \n   * 获取内容 ：response.css('#su::text').extract_first()\n   * 获取属性 ：response.css('#su::attr(“value”)').extract_first()\n\n\nselector 对象#\n\n> 通过xpath方法调用返回的是seletor列表\n\nextract()#\n\n * 提取selector对象的值\n * 如果提取不到值，那么会报错\n * 使用 xpath 请求到的对象是一个selector对象，需要进一步使用extract()方法拆 包，转换为unicode字符串\n\nextract_first()#\n\n * 提取seletor列表中的第一个值\n * 如果提取不到值，会返回一个空值\n * 返回第一个解析到的值，如果列表为空，此种方法也不会报错，会返回一个空值 xpath() css()\n\n> 注意：每一个selector对象可以再次的去使用xpath或者css方法\n\n\n使用管道封装#\n\n1、items.py 在项目目标文件中定义\n\n\n\n2、爬虫住文件\n\n\n\n3、在settings.py中开启管道\n\n\n\n4、pipelines.py 管道文件\n\n\n\n5、items 目标文件\n\n\n\n\nScrapy CrawlSpideropen in new window#\n\n\n创建爬虫文件#\n\n\n\nScrapy CrawlSpider，继承自Spider, 爬取网站常用的爬虫，其定义了一些规则(rule)方便追踪或者是过滤link。 也许该 spider\n并不完全适合您的特定网站或项目，但其对很多情况都是适用的。 因此您可以以此为基础，修改其中的方法，当然您也可以实现自己的spider。\n\n\nclass scrapy.contrib.spiders.CrawlSpider#\n\nCrawlSpider继承自Spider, 爬取网站常用的爬虫，其定义了一些规则(rule)方便追踪或者是过滤 link。 也许该 spider\n并不完全适合您的特定网站或项目，但其对很多情况都是适用的。 因此您可以以此为基础，修改其中的方法，当然您也可以实现自己的spider。\n\n除了从Spider继承过来的(您必须提供的)属性外，其提供了一个新的属性:\n\n * rules\n\n一个包含一个(或多个) Rule 对象的集合(list)。 每个 Rule 对爬取网站的动作定义了特定表现。 Rule对象在下边会介绍。 如果多个 rule\n匹配了相同的链接，则根据他们在本属性中被定义的顺序，第一个会被使用。\n\n该 spider 也提供了一个可复写(overrideable)的方法:\n\n * parse_start_url(response)\n\n当start_url的请求返回时，该方法被调用。 该方法分析最初的返回值并必须返回一个 Item 对象或者 一个 Request 对象或者\n一个可迭代的包含二者对象。\n\n\n爬取规则#\n\n\n\nlink_extractor 是一个 Link Extractor 对象。 其定义了如何从爬取到的页面提取链接。\n\ncallback 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。\n从link_extractor中每获取到链接时将会调用该函数。该回调函数接受一个 response 作为其第一个参数， 并返回一个包含 Item 以及(或)\nRequest 对象(或者这两者的子类)的列表(list)。\n\n> 当编写爬虫规则时，请避免使用 parse 作为回调函数。 由于 CrawlSpider 使用 parse 方法来实现其逻辑，如果 您覆盖了 parse\n> 方法，crawl spider 将会运行失败。\n\n * cb_kwargs: 包含传递给回调函数的参数(keyword argument)的字典。\n * follow: 是一个布尔(boolean)值，指定了根据该规则从 response 提取的链接是否需要跟进。 如果 callback 为 None，\n   follow 默认设置为 True ，否则默认为 False 。\n * process_links: 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。 从 link_extractor\n   中获取到链接列表时将会调用该函数。该方法主要用来过滤。\n * process_request: 是一个 callable 或 string(该 spider 中同名的函数将会被调用)。 该规则提取到每个\n   request 时都会调用该函数。该函数必须返回一个 request 或者 None。 (用来过滤 request)\n\n\nCrawlSpider 示例#\n\n\n\nCrawlSpider将从yiibai.com的首页开始爬取，获取yiibai.com/cplusplus以及item的链接并，对后者调用 parse_item\n方法。 当 item 获得返回response时，将使用XPath处理 HTML 并生成一些数据填入 Item 中。\n\n\n日志信息和日志等级#\n\n日志级别：\n\n 1. CRIRICAL：严重错误\n 2. ERROR：一般错误\n 3. WARNING：警告\n 4. INFO：一级信息\n 5. DEBUG：调试信息\n\n默认日志等级是 DEBUG，只有出现 DEBUG 才会出现。\n\nsettings.py 文件设置：\n\n * LOG_FILE：将屏幕显示的信息全部记录到文件中，屏幕不在显示，注意文件名一定是.log\n * LOG_LEVEL: 设置日志的等级，就显示哪些，不显示哪些\n\n\nPOST 请求#\n\n","routePath":"/up/Python/scrapy","lang":"","toc":[{"text":"Scrapy","id":"scrapy","depth":2,"charIndex":-1},{"text":"安装","id":"安装","depth":2,"charIndex":9},{"text":"Windows 安装方式","id":"windows-安装方式","depth":3,"charIndex":15},{"text":"Ubuntu 安装方式","id":"ubuntu-安装方式","depth":3,"charIndex":67},{"text":"Mac OS 安装方式","id":"mac-os-安装方式","depth":3,"charIndex":123},{"text":"新建项目","id":"新建项目","depth":2,"charIndex":220},{"text":"创建爬虫文件","id":"创建爬虫文件","depth":3,"charIndex":561},{"text":"运行爬虫代码","id":"运行爬虫代码","depth":3,"charIndex":620},{"text":"语法","id":"语法","depth":2,"charIndex":708},{"text":"response 对象","id":"response-对象","depth":3,"charIndex":714},{"text":"selector 对象","id":"selector-对象","depth":3,"charIndex":1111},{"text":"extract()","id":"extract","depth":4,"charIndex":1153},{"text":"extract_first()","id":"extract_first","depth":4,"charIndex":1269},{"text":"使用管道封装","id":"使用管道封装","depth":2,"charIndex":1422},{"text":"Scrapy CrawlSpideropen in new window","id":"scrapy-crawlspideropen-in-new-window","depth":2,"charIndex":1530},{"text":"创建爬虫文件","id":"创建爬虫文件-1","depth":3,"charIndex":1570},{"text":"class scrapy.contrib.spiders.CrawlSpider","id":"class-scrapycontribspiderscrawlspider","depth":3,"charIndex":1731},{"text":"爬取规则","id":"爬取规则","depth":3,"charIndex":2234},{"text":"CrawlSpider 示例","id":"crawlspider-示例","depth":3,"charIndex":2984},{"text":"日志信息和日志等级","id":"日志信息和日志等级","depth":2,"charIndex":3145},{"text":"POST 请求","id":"post-请求","depth":2,"charIndex":3378}],"domain":"","frontmatter":{"icon":"python","order":2,"date":"2022-05-20T00:00:00.000Z","author":"h7ml","category":"python","tag":"python","title":"Scrapy"},"version":""},{"id":477,"title":"selenium","content":"selenium#\n\n\nscrapy + selenium 抓取动态页面#\n\n腾讯云博客 open in new window\n\n\n安装 selenium#\n\n\n下载 selenium 调试工具#\n\nChrome下载地址 open in new window，版本与 Chrome 最近即可\n\n\n使用#\n\n1、在 middlewares.py 文件中修改返回的 response 对象\n\n找到 Scrapy[这里是你的项目名字]sDownloaderMiddleware 类，修改process_request方法\n\n\n\n3、在settings.py文件中打开SPIDER_MIDDLEWARES 、DOWNLOADER_MIDDLEWARES 和DOWNLOAD_DELAY配置\n\n","routePath":"/up/Python/selenium","lang":"","toc":[{"text":"selenium","id":"selenium","depth":2,"charIndex":-1},{"text":"scrapy + selenium 抓取动态页面","id":"scrapy--selenium-抓取动态页面","depth":2,"charIndex":11},{"text":"安装 selenium","id":"安装-selenium","depth":3,"charIndex":65},{"text":"下载 selenium 调试工具","id":"下载-selenium-调试工具","depth":3,"charIndex":80},{"text":"使用","id":"使用","depth":3,"charIndex":147}],"domain":"","frontmatter":{"icon":"python","order":3,"date":"2022-05-20T00:00:00.000Z","author":"h7ml","category":"python","tag":"python","title":"selenium"},"version":""},{"id":478,"title":"urllib","content":"Urllib#\n\nurllib 包 包含以下几个模块：\n\n * urllib.request - 打开和读取 URL。\n * urllib.error - 包含 urllib.request 抛出的异常。\n * urllib.parse - 解析 URL。\n * urllib.robotparser - 解析 robots.txt 文件。\n\n\n\n\nurllib.request#\n\nurllib.request 定义了一些打开 URL 的函数和类，包含授权验证、重定向、浏览器 cookies 等。\n\nurllib.request 可以模拟浏览器的一个请求发起过程。\n\n我们可以使用 urllib.request 的 urlopen 方法来打开一个 URL，语法格式如下：\n\n\n\n * url：url 地址。\n * data：发送到服务器的其他数据对象，默认为 None。\n * timeout：设置访问超时时间。\n * cafile 和 capath：cafile 为 CA 证书， capath 为 CA 证书的路径，使用 HTTPS 需要用到。\n * cadefault：已经被弃用。\n * context：ssl.SSLContext 类型，用来指定 SSL 设置。\n\n\n\n\n模拟头部信息#\n\n我们抓取网页一般需要对 headers（网页头信息）进行模拟，这时候需要使用到 urllib.request.Request 类：\n\n\n\n * url：url 地址。\n * data：发送到服务器的其他数据对象，默认为 None。\n * headers：HTTP 请求的头部信息，字典格式。\n * origin_req_host：请求的主机地址，IP 或域名。\n * unverifiable：很少用整个参数，用于设置网页是否需要验证，默认是 False。。\n * method：请求方法， 如 GET、POST、DELETE、PUT 等。\n\n\n\n请求对象的定制\n\nUA 介绍:User Agent 中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统\n\n及版本、CPU 类型、浏览器及版本。浏览器内核、浏览器渲染引擎、浏览器语言、浏览器插件等\n\n\nurllib.parse#\n\nurllib.parse 用于解析 URL，格式如下：\n\n\n\nurlstring 为 字符串的 url 地址，scheme 为协议类型，\n\nallow_fragments 参数为 false，则无法识别片段标识符。相反，它们被解析为路径，参数或查询组件的一部分，并 fragment\n在返回值中设置为空字符串。\n\n以上实例输出结果为：\n\n完整内容如下：\n\n属性         索引   值              值（如果不存在）\nscheme     0    URL 协议         scheme 参数\nnetloc     1    网络位置部分         空字符串\npath       2    分层路径           空字符串\nparams     3    最后路径元素的参数      空字符串\nquery      4    查询组件           空字符串\nfragment   5    片段识别           空字符串\nusername        用户名            None\npassword        密码             None\nhostname        主机名（小写）        None\nport            端口号为整数（如果存在）   None\n\n\n.quote()方法#\n\n将中文字符转换成 Unicode 编码格式\n\n\n\n\n.urlencode()方法#\n\n可以将字典转化成 query 穿惨格式\n\n\n\n\nurllib.error#\n\nurllib.error 模块为 urllib.request 所引发的异常定义了异常类，基础异常类是 URLError。\n\nurllib.error 包含了两个方法，URLError 和 HTTPError。\n\nURLError 是 OSError 的一个子类，用于处理程序在遇到问题时会引发此异常（或其派生的异常），包含的属性 reason 为引发异常的原因。\n\nHTTPError 是 URLError 的一个子类，用于处理特殊 HTTP 错误例如作为认证请求的时候，包含的属性 code 为 HTTP 的状态码，\nreason 为引发异常的原因，headers 为导致 HTTPError 的特定 HTTP 请求的 HTTP 响应头。\n\n对不存在的网页抓取并处理异常:\n\n\n\n\nencode()方法#\n\n描述\n\nencode() 方法以 encoding 指定的编码格式编码字符串。errors 参数可以指定不同的错误处理方案。\n\n语法\n\nencode()方法语法：\n\n\n\n参数\n\n * encoding -- 要使用的编码，如\"UTF-8\"。\n * errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个 UnicodeError。 其他可能得值有 'ignore',\n   'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过\n   codecs.register_error() 注册的任何值。\n\n返回值\n\n该方法返回编码后的字符串。\n\n\ndecode()方法#\n\n描述\n\ndecode() 方法以 encoding 指定的编码格式解码字符串。默认编码为字符串编码。\n\n语法\n\ndecode()方法语法：\n\n\n\n参数\n\n * encoding -- 要使用的编码，如\"UTF-8\"。\n * errors -- 设置不同错误的处理方案。默认为 'strict',意为编码错误引起一个 UnicodeError。 其他可能得值有 'ignore',\n   'replace', 'xmlcharrefreplace', 'backslashreplace' 以及通过\n   codecs.register_error() 注册的任何值。\n\n返回值\n\n该方法返回解码后的字符串。\n\n\npost 请求案例百度翻译#\n\n * Post 请求的参数必须编码，先通过urlencode转换为二进制形式，在通过encode转换为utf-8\n * 响应回来的数据是 json 需要进行反序列（loads）\n\n\n\n\nCookie 反爬#\n\n有的加密接口会携带 cookie 或者其他令牌，这个不是固定的每个接口安全方式不一样，所有需要去分析，一般 cookie 是最常见的，在 headers 中添加\n\n\n\n\nhandler 代理#\n\n","routePath":"/up/Python/urllib","lang":"","toc":[{"text":"Urllib","id":"urllib","depth":2,"charIndex":-1},{"text":"urllib.request","id":"urllibrequest","depth":2,"charIndex":174},{"text":"模拟头部信息","id":"模拟头部信息","depth":3,"charIndex":542},{"text":"urllib.parse","id":"urllibparse","depth":2,"charIndex":944},{"text":".quote()方法","id":"quote方法","depth":3,"charIndex":1544},{"text":".urlencode()方法","id":"urlencode方法","depth":3,"charIndex":1583},{"text":"urllib.error","id":"urlliberror","depth":2,"charIndex":1624},{"text":"encode()方法","id":"encode方法","depth":2,"charIndex":1982},{"text":"decode()方法","id":"decode方法","depth":2,"charIndex":2313},{"text":"post 请求案例百度翻译","id":"post-请求案例百度翻译","depth":2,"charIndex":2632},{"text":"Cookie 反爬","id":"cookie-反爬","depth":2,"charIndex":2741},{"text":"handler 代理","id":"handler-代理","depth":2,"charIndex":2838}],"domain":"","frontmatter":{"icon":"python","order":4,"date":"2022-05-20T00:00:00.000Z","author":"h7ml","category":"python","tag":"python","title":"urllib"},"version":""},{"id":479,"title":"docker","content":" * docker\n\n * dockerfile","routePath":"/up/docker/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"box","date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"docker","title":"docker","index":false,"dir":{"order":2}},"version":""},{"id":480,"title":"docker","content":"#\n\n\n概念#\n\n\nDocker 的核心四大组成对象#\n\n> 镜像 ( Image )、容器 ( Container )、网络 ( Network )、数据卷 ( Volume )\n\n镜像#\n\n所谓镜像，可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。\n\n每次对镜像内容的修改，Docker\n都会将这些修改铸造成一个镜像层，而一个镜像其实就是由其下层所有的镜像层所组成的。当然，每一个镜像层单独拿出来，与它之下的镜像层都可以组成一个镜像。\n\n另外，由于这种结构，Docker 的镜像实质上是无法被修改的，因为所有对镜像的修改只会产生新的镜像，而不是更新原有的镜像。\n\n类似git，增量记录文件变更。\n\n镜像命名#\n\n准确的来说，镜像的命名我们可以分成三个部分：username、repository 和 tag。\n\nusername： 主要用于识别上传镜像的不同用户，与 GitHub 中的用户空间类似。对于 username 来说，在上面我们展示的 docker\nimages 结果中，有的镜像有 username 这个部分，而有的镜像是没有的。没有 username 这个部分的镜像，表示镜像是由 Docker\n官方所维护和提供的，所以就不单独标记用户了。 repository：主要用于识别进行的内容，形成对镜像的表意描述。Docker 中镜像的 repository\n部分通常采用的是软件名，可以任意取名，用软件名，只是为了更易示意。 tag：主要用户表示镜像的版本，方便区分进行内容的不同细节。\n\n容器#\n\n容器就是用来隔离虚拟环境的基础设施，而在 Docker 里，它也被引申为隔离出来的虚拟环境。通过 PID\n进程隔离，容器中的主进程就是容器本身，杀掉容器中的主进程，相当于杀掉了容器。\n\n如果把镜像理解为编程中的类，那么容器就可以理解为类的实例。镜像内存放的是不可变化的东西，当以它们为基础的容器启动后，容器内也就成为了一个“活”的空间。\n\n用更官方的定义，Docker 的容器应该有三项内容组成：\n\n * 一个 Docker 镜像\n * 一个程序运行环境\n * 一个指令集合\n\n容器生命周期#\n\nCreated、Running、Paused、Stopped、Deleted\n\n * Created：容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。\n * Running：容器正在运行，也就是容器中的应用正在运行。\n * Paused：容器已暂停，表示容器中的所有程序都处于暂停 ( 不是停止 ) 状态。\n * Stopped：容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。\n * Deleted：容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。\n\n写时复制机制#\n\nDocker 的写时复制与编程中的相类似，也就是在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS\n将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。\n\n也就是说，容器在创建和启动的过程中，不需要进行任何的文件系统复制操作，也不需要为容器单独开辟大量的硬盘空间，与其他虚拟化方式对这个过程的操作进行对比，Docke\nr 启动的速度可见一斑。\n\n容器互联#\n\n由于 Docker\n提倡容器与应用共生的轻量级容器理念，所以容器中通常只包含一种应用程序，但我们知道，如今纷繁的系统服务，没有几个是可以通过单一的应用程序支撑的。拿最简单的 Web\n应用为例，也至少需要业务应用、数据库应用、缓存应用等组成。也就是说，在 Docker 里我们需要通过多个容器来组成这样的系统。\n\n镜像 vs 容器#\n\n镜像像是记录容器运行环境的模板，是只读的，docker\n依照这个模板启动一个容器，容器启动运行时是按需从镜像模板里拿取依赖（写时复制）肯定是先有模板才能依照模板启动容器！没有镜像，容器就是无源之水。镜像像类，容器像类\n的实例。或者说，镜像是程序是死的，容器是运行的进程，是活的。\n\n网络#\n\n网络通讯是目前最常用的一种程序间的数据交换方式，所有的应用都可以通过网络在不同的硬件平台或操作系统平台上进行数据交互。\n\ndocker 容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。\n\n在 Docker 网络中，有三个比较核心的概念，也就是：沙盒 ( Sandbox )、网络 ( Network )、端点 ( Endpoint )。\n\n * 沙盒提供了容器的虚拟网络栈，也就是之前所提到的端口套接字、IP 路由表、防火墙等的内容。其实现隔离了容器网络与宿主机网络，形成了完全独立的容器网络环境。\n * 网络可以理解为 Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。Docker\n   的这种虚拟网络也是于宿主机网络存在隔离关系的，其目的主要是形成容器间的安全通讯环境。\n * 端点是位于容器或网络隔离墙之上的洞，其主要目的是形成一个可以控制的突破封闭的网络环境的出入口。当容器的端点与网络的端点形成配对后，就如同在这两者之间搭建了\n   桥梁，便能够进行数据传输了。\n\n数据卷#\n\n在 Docker 中，通过这几种方式进行数据共享或持久化的文件或目录，我们都称为数据卷 ( Volume )。\n\n在以往的虚拟机中，我们通常直接采用虚拟机的文件系统作为应用数据等文件的存储位置。然而这种方式其实并非完全安全的，当虚拟机或者容器出现问题导致文件系统无法使用时，\n虽然我们可以很快的通过镜像重置文件系统使得应用快速恢复运行，但是之前存放的数据也就消失了。\n\n为了保证数据的独立性，我们通常会单独挂载一个文件系统来存放数据。这种操作在虚拟机中是繁琐的，因为我们不但要搞定挂载在不同宿主机中实现的方法，还要考虑挂载文件系统\n兼容性，虚拟操作系统配置等问题。值得庆幸的是，这些在 Docker 里都已经为我们轻松的实现了，我们只需要简单的一两个命令或参数，就能完成文件系统目录的挂载。\n\n基于底层存储实现，Docker 提供了三种适用于不同场景的文件系统挂载方式：Bind Mount、Volume 和 Tmpfs Mount。\n\n * Bind Mount\n   能够直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，通过指定容器外的路径和容器内的路径，就可以形成挂载映射关系，在容器内外对文件的读写，都是相互\n   可见的。\n\n * Volume 也是从宿主操作系统中挂载目录到容器内，只不过这个挂载的目录由 Docker\n   进行管理，我们只需要指定容器内的目录，不需要关心具体挂载到了宿主操作系统中的哪里。\n\n * Tmpfs Mount 支持挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。\n\n其他#\n\nDocker 是依赖于 Linux 而存在的，其实 Docker Desktop 的实现逻辑很简单：既然 Windows 和 macOS 中没有 Docker\n能够利用的 Linux 环境，那么我们生造一个 Linux 环境就行啦！Docker for Windows 和 Docker for Mac 正是这么实现的。\n\n\n常用命令#\n\n * docker version\n\n\n\n * docker info\n   \n   在 docker info 这条命令的结果中，我们可以看到正在运行的 Docker Engine 实例中运行的容器数量，存储的引擎等等信息。\n\n * docker images\n   \n   在 docker images 命令的结果中，我们可以看到镜像的 ID ( IMAGE ID)、构建时间 ( CREATED )、占用空间 ( SIZE\n   ) 等数据。\n\n\n镜像相关#\n\n * docker pull：拉取镜像\n\n * docker search：搜索镜像\n\n * docker images：列出本地镜像\n\n * docker inspect：查看关于某个镜像相当完备的信息\n\n * docker rmi：删除镜像\n\n * docker commit ：提交容器的更改，例如docker commit -m \"Configured\" webapp，打包生成新镜像。Docker\n   执行将容器内沙盒文件系统记录成镜像层的时候，会先暂停容器的运行，以保证容器内的文件系统处于一个相对稳定的状态，确保数据的一致性\n\n\n\n * docker tag：重命名镜像名\n\n镜像迁移#\n\n\n\n\n容器相关#\n\n * docker create ：根据所给出的镜像创建容器，例如：docker create --name nginx nginx:1.12\n * docker start <容器名>：启动容器\n * docker run：创建(create)并且启动(start)容器，例如：docker run --name nginx -d\n   nginx:1.12，-d表示在启动后将程序与控制台分离，使其进入“后台”运行。创建时通过--link可让一个容器连接到另外一个容器。可以通过--expo\n   se来暴露容器端口。\n\n\n\n * docker ps：列出的容器是处于运行中的容器，-a参数，列出所有容器。结果中还可以看到容器暴露给其他容器访问的端口\n * docker stop ：停止容器\n * docker rm\n   ：删除容器，容器中应用程序所产生的一些文件数据，是非常重要的，如果这些数据随着容器的删除而丢失，其损失是非常巨大的。对于这类由应用程序所产生的数据，并且需\n   要保证它们不会随着容器的删除而消失的，我们可以使用 Docker\n   中的数据卷来单独存放。由于数据卷是独立于容器存在的，所以其能保证数据不会随着容器的删除而丢失\n * docker exec ：让容器运行我们所给出的命令，例如：docker exec nginx more /etc/hostname\n * docker exec -it nginx bash，用 bash 来进入 nginx 容器，其中 -i ( --interactive )\n   表示保持我们的输入流，只有使用它才能保证控制台程序能够正确识别我们的命令。而 -t ( --tty ) 表示启用一个伪终端，形成我们与 bash\n   的交互，如果没有它，我们无法看到 bash 内部的执行结果\n\n\n网络相关#\n\n * docker network create：自己定义虚拟子网，例如：docker network create -d bridge\n   individual，通过 -d 选项我们可以为新的网络指定驱动的类型，其值可以是刚才我们所提及的\n   bridge、host、overlay、maclan、none，也可以是其他网络驱动插件所定义的类型。这里我们使用的是 Bridge Driver (\n   当我们不指定网络驱动时，Docker 也会默认采用 Bridge Driver 作为网络驱动 )- docker network ls：查看 Docker\n   中已经存在的网络\n * docker run --network：在我们创建容器时，可以通过 --network 来指定容器所加入的网络\n * docker run\n   --publish：映射端口，把容器的端口映射到宿主操作系统的端口上，从外部访问宿主操作系统的端口时，数据请求就会自动发送给与之关联的容器端口，例如：do\n   cker run -d --name nginx -p 80:80 -p 443:443 nginx:1.12。-p :: 其中 ip\n   是宿主操作系统的监听 ip，可以用来控制监听的网卡，默认为 0.0.0.0，也就是监听所有网卡。host-port 和 container-port\n   分别表示映射到宿主操作系统的端口和容器的端口，这两者是可以不一样的，我们可以将容器的 80 端口映射到宿主操作系统的 8080 端口，传入 -p\n   8080:80 即可\n\n\n存储相关#\n\n * docker run --volume：将宿主操作系统中的目录挂载到容器，例如：docker run -d --name nginx -v\n   /webapp/html:/usr/share/nginx/html nginx:1.12 (参数传递不同，即可实现使用数据卷挂载，参考下一条命令)\n   \n   1. 使用 -v 或 --volume 来挂载宿主操作系统目录的形式是 -v : 或 --volume :，其中 host-path 和\n      container-path 分别代表宿主操作系统中的目录和容器中的目录。这里需要注意的是，为了避免混淆，Docker\n      这里强制定义目录时必须使用绝对路径，不能使用相对路径。\n   \n   2. 我们能够指定目录进行挂载，也能够指定具体的文件来挂载，具体选择何种形式来挂载，大家可以根据具体的情况来选择。可以添加:ro实现只读挂载。\n   \n   3. 当我们需要从宿主操作系统共享配置的时候 和 当我们需要借助 Docker\n      进行开发的时候(每次对代码的修改都可以直接在容器外部进行)，该挂载方式有实际应用场景。\n\n * docker run --volume：例如：docker run -d --name webapp -v /webapp/storage\n   webapp:latest，\n   \n   * 数据卷的本质其实依然是宿主操作系统上的一个目录，只不过这个目录存放在 Docker 内部，接受 Docker\n     的管理。在使用数据卷进行挂载时，我们不需要知道数据具体存储在了宿主操作系统的何处，只需要给定容器中的哪个目录会被挂载即可。\n\n * -v :：数据卷命名，例如：docker run -d --name webapp -v appdata:/webapp/storage\n   webapp:latest，命名为appdata\n   \n   * 数据卷的命名在 Docker 中是唯一的\n\n * docker volume create ：创建数据卷\n\n * docker volume ls：列出数据卷\n\n * docker volume rm ：删除数据卷，在删除容器时，可以使用docker rm -v 来删除容器的同时删除关联的数据卷\n\n如果我们没有随容器删除这些数据卷，Docker\n在创建新的容器时也不会启用它们，即使它们与新创建容器所定义的数据卷有完全一致的特征。也就是说，此时它们已经变成了孤魂野鬼，纯粹的占用着硬盘空间而又不受管理。\n\n * docker volume prune：删除那些没有被容器引用的数据卷\n\n数据卷容器#\n\n创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建：docker create --name appdata -v\n/webapp/storage ubuntu，使用ubuntu镜像来创建名为appdata的数据卷容器\n\n数据卷容器就可以算是容器间的文件系统桥梁，可以像加入网络一样引用数据卷容器，只需要在创建新容器时使用专门的 --volumes-from 选项即可，sudo\ndocker run -d --name webapp --volumes-from appdata webapp:latest\n\n数据卷备份和迁移#\n\n由于数据卷本身就是宿主操作系统中的一个目录，我们只需要在 Docker\n资源目录里找到它就可以很轻松的打包、迁移、恢复了。虽然这么做相对其他虚拟化方案来说已经很简单了，但在 Docker 里还不是最优雅的解决方式。\n\n利用数据卷容器，我们还能够更方便的对数据卷中的数据进行迁移。\n\n数据备份、迁移、恢复的过程可以理解为对数据进行打包，移动到其他位置，在需要的地方解压的过程。在数据打包之前，我们先建立一个用来存放打包文件的目录，这里我们使用\n/backup 作为例子。\n\n要备份数据，我们先建立一个临时的容器，将用于备份的目录和要备份的数据卷都挂载到这个容器上。\n\n在备份命令中，除了挂载的配置外，我们再注意几个选项。通过 --rm\n选项，我们可以让容器在停止后自动删除，而不需要我们再使用容器删除命令来删除它，这对于我们使用一些临时容器很有帮助。在容器所基于的镜像之后，我们还看到了一串命令，\n也就是 tar cvf /backup/backup.tar\n/webapp/storage，其实如果我们在镜像定义之后接上命令，可以直接替换掉镜像所定义的主程序启动命令，而去执行这一条命令。在很多场合下，我们还能通过这个\n方法干很多不同的事情。\n\n在备份后，我们就可以在 /backup 下找到数据卷的备份文件，也就是 backup.tar 了。\n\n如果要恢复数据卷中的数据，我们也可以借助临时容器完成。\n\n\n\n\n笔记#\n\n\n修改国内镜像源#\n\n在Docker Desktop的 docker engine 中配置增加registry-mirrors\n\n\n\n\n通过 Dockerfile 创建镜像#\n\nDockerfile 是 Docker 中用于定义镜像自动化构建流程的配置文件，在 Dockerfile 中，包含了构建镜像过程中需要执行的命令和其他操作。通过\nDockerfile 我们可以更加清晰、明确的给定 Docker\n镜像的制作过程，而由于其仅是简单、小体积的文件，在网络等其他介质中传递的速度极快，能够更快的帮助我们实现容器迁移和集群部署。\n\n\n编写#\n\n相对于之前我们介绍的提交容器修改，再进行镜像迁移的方式相比，使用 Dockerfile 进行这项工作有很多优势，我总结了几项尤为突出的。\n\n * Dockerfile 的体积远小于镜像包，更容易进行快速迁移和部署。\n * 环境构建流程记录了 Dockerfile 中，能够直观的看到镜像构建的顺序和逻辑。\n * 使用 Dockerfile 来构建镜像能够更轻松的实现自动部署等自动化流程。\n * 在修改环境搭建细节时，修改 Dockerfile 文件要比从新提交镜像来的轻松、简单。\n\nDockerfile 的结构#\n\n总体上来说，我们可以将 Dockerfile 理解为一个由上往下执行指令的脚本文件。当我们调用构建命令让 Docker 通过我们给出的 Dockerfile\n构建镜像时，Docker 会逐一按顺序解析 Dockerfile 中的指令，并根据它们不同的含义执行不同的操作。\n\n如果进行细分，我们可以将 Dockerfile 的指令简单分为五大类。\n\n * 基础指令：用于定义新镜像的基础和性质。\n * 控制指令：是指导镜像构建的核心部分，用于描述镜像在构建过程中需要执行的命令。\n * 引入指令：用于将外部文件直接引入到构建镜像内部。\n * 执行指令：能够为基于镜像所创建的容器，指定在启动时需要执行的脚本或命令。\n * 配置指令：对镜像以及基于镜像所创建的容器，可以通过配置指令对其网络、用户等内容进行配置。\n\n这五类命令并非都会出现在一个 Dockerfile 里，但却对基于这个 Dockerfile 所构建镜像形成不同的影响。\n\n常见 Dockerfile 指令#\n\n * FROM\n\n通常来说，我们不会从零开始搭建一个镜像，而是会选择一个已经存在的镜像作为我们新镜像的基础，这种方式能够大幅减少我们的时间。\n\n在 Dockerfile 里，我们可以通过 FROM 指令指定一个基础镜像，接下来所有的指令都是基于这个镜像所展开的。在镜像构建的过程中，Docker\n也会先获取到这个给出的基础镜像，再从这个镜像上进行构建操作。\n\nFROM 指令支持三种形式，不管是哪种形式，其核心逻辑就是指出能够被 Docker 识别的那个镜像，好让 Docker 从那个镜像之上开始构建工作。\n\n\n\n既然选择一个基础镜像是构建新镜像的根本，那么 Dockerfile 中的第一条指令必须是 FROM 指令，因为没有了基础镜像，一切构建过程都无法开展。\n\n当然，一个 Dockerfile 要以 FROM 指令作为开始并不意味着 FROM 只能是 Dockerfile 中的第一条指令。在 Dockerfile\n中可以多次出现 FROM 指令，当 FROM\n第二次或者之后出现时，表示在此刻构建时，要将当前指出镜像的内容合并到此刻构建镜像的内容里。这对于我们直接合并两个镜像的功能很有帮助。\n\n * RUN\n\n镜像的构建虽然是按照指令执行的，但指令只是引导，最终大部分内容还是控制台中对程序发出的命令，而 RUN 指令就是用于向控制台发送命令的指令。\n\n在 RUN 指令之后，我们直接拼接上需要执行的命令，在构建时，Docker 就会执行这些命令，并将它们对文件系统的修改记录下来，形成镜像的变化。\n\n\n\n * ENTRYPOINT 和 CMD\n\n基于镜像启动的容器，在容器启动时会根据镜像所定义的一条命令来启动容器中进程号为 1 的进程。而这个命令的定义，就是通过 Dockerfile 中的\nENTRYPOINT 和 CMD 实现的。\n\n\n\nENTRYPOINT 指令和 CMD 指令的用法近似，都是给出需要执行的命令，并且它们都可以为空，或者说是不在 Dockerfile 里指出。\n\n当 ENTRYPOINT 与 CMD 同时给出时，CMD 中的内容会作为 ENTRYPOINT 定义命令的参数，最终执行容器启动的还是 ENTRYPOINT\n中给出的命令。\n\n * EXPOSE\n\n由于我们构建镜像时更了解镜像中应用程序的逻辑，也更加清楚它需要接收和处理来自哪些端口的请求，所以在镜像中定义端口暴露显然是更合理的做法。\n\n通过 EXPOSE 指令就可以为镜像指定要暴露的端口。\n\n\n\n当我们通过 EXPOSE 指令配置了镜像的端口暴露定义，那么基于这个镜像所创建的容器，在被其他容器通过 --link\n选项连接时，就能够直接允许来自其他容器对这些端口的访问了。\n\n * VOLUME\n\n在一些程序里，我们需要持久化一些数据，比如数据库中存储数据的文件夹就需要单独处理。在之前的小节里，我们提到可以通过数据卷来处理这些问题。\n\n但使用数据卷需要我们在创建容器时通过 -v 选项来定义，而有时候由于镜像的使用者对镜像了解程度不高，会漏掉数据卷的创建，从而引起不必要的麻烦。\n\n还是那句话，制作镜像的人是最清楚镜像中程序工作的各项流程的，所以它来定义数据卷也是最合适的。所以在 Dockerfile 里，提供了 VOLUME\n指令来定义基于此镜像的容器所自动建立的数据卷。\n\n\n\n在 VOLUME 指令中定义的目录，在基于新镜像创建容器时，会自动建立为数据卷，不需要我们再单独使用 -v 选项来配置了。\n\n * COPY 和 ADD\n\n在制作新的镜像的时候，我们可能需要将一些软件配置、程序代码、执行脚本等直接导入到镜像内的文件系统里，使用 COPY 或 ADD\n指令能够帮助我们直接从宿主机的文件系统里拷贝内容到镜像里的文件系统中。\n\n\n\nCOPY 与 ADD 指令的定义方式完全一样，需要注意的仅是当我们的目录中存在空格时，可以使用后两种格式避免空格产生歧义。\n\n对比 COPY 与 ADD，两者的区别主要在于 ADD 能够支持使用网络端的 URL 地址作为 src 源，并且在源文件被识别为压缩包时，自动进行解压，而\nCOPY 没有这两个能力。\n\n虽然看上去 COPY 能力稍弱，但对于那些不希望源文件被解压或没有网络请求的场景，COPY 指令是个不错的选择。\n\n\n构建镜像#\n\n\n\n * -t 选项，用它来指定新生成镜像的名称\n\n\n常见技巧#\n\n构建中使用变量#\n\n在 Dockerfile 里，我们可以用 ARG 指令来建立一个参数变量，我们可以在构建时通过构建指令传入这个参数变量，并且在 Dockerfile 里使用它。\n\n例如，我们希望通过参数变量控制 Dockerfile 中某个程序的版本，在构建时安装我们指定版本的软件，我们可以通过 ARG\n定义的参数作为占位符，替换版本定义的部分。\n\n\n\n在这个例子里，我们将 Tomcat 的版本号通过 ARG 指令定义为参数变量，在调用下载 Tomcat\n包时，使用变量替换掉下载地址中的版本号。通过这样的定义，就可以让我们在不对 Dockerfile 进行大幅修改的前提下，轻松实现对 Tomcat\n版本的切换并重新构建镜像了。\n\n如果我们需要通过这个 Dockerfile 文件构建 Tomcat 镜像，我们可以在构建时通过 docker build 的 --build-arg\n选项来设置参数变量。\n\n\n\n环境变量#\n\n环境变量也是用来定义参数的东西，与 ARG 指令相类似，环境变量的定义是通过 ENV 这个指令来完成的。\n\n\n\n环境变量的使用方法与参数变量一样，也都是能够直接替换指令参数中的内容。\n\n与参数变量只能影响构建过程不同，环境变量不仅能够影响构建，还能够影响基于此镜像创建的容器。环境变量设置的实质，其实就是定义操作系统环境变量，所以在运行的容器里，\n一样拥有这些变量，而容器中运行的程序也能够得到这些变量的值。\n\n另一个不同点是，环境变量的值不是在构建指令中传入的，而是在 Dockerfile 中编写的，所以如果我们要修改环境变量的值，我们需要到 Dockerfile\n修改。不过即使这样，只要我们将 ENV 定义放在 Dockerfile 前部容易查找的地方，其依然可以很快的帮助我们切换镜像环境中的一些内容。\n\n由于环境变量在容器运行时依然有效，所以运行容器时我们还可以对其进行覆盖，在创建容器时使用 -e 或是 --env\n选项，可以对环境变量的值进行修改或定义新的环境变量。\n\n\n\n事实上，这种用法在我们开发中是非常常见的。也正是因为这种允许运行时配置的方法存在，环境变量和定义它的 ENV\n指令，是我们更常使用的指令，我们会优先选择它们来实现对变量的操作。\n\n另外需要说明一点，通过 ENV 指令和 ARG 指令所定义的参数，在使用时都是采用 $ + NAME\n这种形式来占位的，所以它们之间的定义就存在冲突的可能性。对于这种场景，大家只需要记住，ENV 指令所定义的变量，永远会覆盖 ARG\n所定义的变量，即使它们定时的顺序是相反的。\n\n合并命令#\n\n在上一节我们展示的完整的官方 Redis 镜像的 Dockerfile 中，我们会发现 RUN 等指令里会聚合下大量的代码。\n\n事实上，下面两种写法对于搭建的环境来说是没有太大区别的。\n\n\n\n构建缓存#\n\nDocker 在镜像构建的过程中，还支持一种缓存策略来提高镜像的构建速度。\n\n由于镜像是多个指令所创建的镜像层组合而得，那么如果我们判断新编译的镜像层与已经存在的镜像层未发生变化，那么我们完全可以直接利用之前构建的结果，而不需要再执行这条\n构建指令，这就是镜像构建缓存的原理。\n\n那么 Docker 是如何判断镜像层与之前的镜像间不存在变化的呢？这主要参考两个维度，第一是所基于的镜像层是否一样，第二是用于生成镜像层的指令的内容是否一样。\n\n基于这个原则，我们在条件允许的前提下，更建议将不容易发生变化的搭建过程放到 Dockerfile\n的前部，充分利用构建缓存提高镜像构建的速度。另外，指令的合并也不宜过度，而是将易变和不易变的过程拆分，分别放到不同的指令里。\n\n在另外一些时候，我们可能不希望 Docker 在构建镜像时使用构建缓存，这时我们可以通过 --no-cache 选项来禁用它。\n\n\n\n搭配 ENTRYPOINT 和 CMD#\n\n上一节我们谈到了 ENTRYPOINT 和 CMD 这两个命令，也解释了这两个命令的目的，即都是用来指定基于此镜像所创建容器里主进程的启动命令的。\n\n两个指令的区别在于，ENTRYPOINT 指令的优先级高于 CMD 指令。当 ENTRYPOINT 和 CMD 同时在镜像中被指定时，CMD 里的内容会作为\nENTRYPOINT 的参数，两者拼接之后，才是最终执行的命令。\n\n有的读者会存在疑问，既然两者都是用来定义容器启动命令的，为什么还要分成两个，合并为一个指令岂不是更方便吗？\n\n这其实在于 ENTRYPOINT 和 CMD 设计的目的是不同的。ENTRYPOINT 指令主要用于对容器进行一些初始化，而 CMD\n指令则用于真正定义容器中主程序的启动命令。\n\n另外，我们之前谈到创建容器时可以改写容器主程序的启动命令，而这个覆盖只会覆盖 CMD 中定义的内容，而不会影响 ENTRYPOINT 中的内容。\n\n我们依然以之前的 Redis 镜像为例，这是 Redis 镜像中对 ENTRYPOINT 和 CMD 的定义。\n\n\n\n可以很清晰的看到，CMD 指令定义的正是启动 Redis 的服务程序，而 ENTRYPOINT 使用的是一个外部引入的脚本文件。\n\n事实上，使用脚本文件来作为 ENTRYPOINT 的内容是常见的做法，因为对容器运行初始化的命令相对较多，全部直接放置在 ENTRYPOINT 后会特别复杂。\n\n我们来看看 Redis 中的 ENTRYPOINT 脚本，可以看到其中会根据脚本参数进行一些处理，而脚本的参数，其实就是 CMD 中定义的内容。\n\n\n\n这里我们要关注脚本最后的一条命令，也就是 exec \"$@\"。在很多镜像的 ENTRYPOINT\n脚本里，我们都会看到这条命令，其作用其实很简单，就是运行一个程序，而运行命令就是 ENTRYPOINT 脚本的参数。反过来，由于 ENTRYPOINT\n脚本的参数就是 CMD 指令中的内容，所以实际执行的就是 CMD 里的命令。\n\n所以说，虽然 Docker 对容器启动命令的结合机制为 CMD 作为 ENTRYPOINT 的参数，合并后执行 ENTRYPOINT\n中的定义，但实际在我们使用中，我们还会在 ENTRYPOINT 的脚本里代理到 CMD 命令上。\n\n使用 Alpine 镜像#\n\n如果大家多接触几个镜像，就会发现带有 Alpine 的版本是许多镜像中都常见的标签。带有 Alpine\n标签的镜像到底是什么样的存在呢？它与相同软件不同标签的镜像又有什么样的区别呢？\n\n镜像标签中的 Alpine 其实指的是这个镜像内的文件系统内容，是基于 Alpine Linux 这个操作系统的。Alpine Linux\n是一个相当精简的操作系统，而基于它的 Docker 镜像可以仅有数 MB 的尺寸。如果软件基于这样的系统镜像之上构建而得，可以想象新的镜像也是十分小巧的。\n\n\nDocker Compose 容器编排#\n\n由于 Docker\n采用轻量级容器的设计，每个容器一般只运行一个软件，而目前绝大多数应用系统都绝不是一个软件所能组成的。虽然我们之前提到了容器间互相连接、交换数据的各种方法，通过这\n些方法足以搭建起完整的用于应用系统运行的容器群，但是这显然还不够，这个容器群的搭建需要执行太多命令，更重要的是需要考虑太多应用和容器间的依赖关系处理，是一波令人\n头大的操作。在这一节中，我们就来介绍如何解决这些问题。\n\n\n容器管理问题#\n\n拿任何一个相对完整的应用系统来说，都不可能是由一个程序独立支撑的，而对于使用 Docker\n来部署的分布式计算服务更是这样。随着时代的发展和技术演进，我们越来越推崇将大型服务拆分成较小的微服务，分别部署到独立的机器或容器中。也就是说，我们的应用系统往往\n由数十个甚至上百个应用程序或微服务组成。即使是一个小的微服务模块，通常都需要多个应用协作完成工作。\n\n我们编写一个小型的微服务模块，虽然我们编写代码主要针对的是其中的应用部分，但如果我们要完整的进行开发、测试，与应用相关的周边软件必然是必不可少的。\n\n虽然 Docker Engine\n帮助我们完成了对应用运行环境的封装，我们可以不需要记录复杂的应用环境搭建过程，通过简单的配置便可以将应用运行起来了，但这只是针对单个容器或单个应用程序来说的。如\n果延伸到由多个应用组成的应用系统，那情况就稍显复杂了。\n\n就拿最简单的例子来说吧，如果我们要为我们的应用容器准备一个 MySQL 容器和一个 Redis 容器，那么在每次启动时，我们先要将 MySQL 容器和\nRedis 容器启动起来，再将应用容器运行起来。这其中还不要忘了在创建应用容器时将容器网络连接到 MySQL 容器和 Redis\n容器上，以便应用连接上它们并进行数据交换。\n\n这还不够，如果我们还对容器进行了各种配置，我们最好还得将容器创建和配置的命令保存下来，以便下次可以直接使用。\n\n如果我们要想让这套体系像 docker run 和 docker rm\n那样自如的进行无痕切换，那就更加麻烦了，我们可能需要编写一些脚本才能不至于被绕到命令的毛线球里。\n\n说了这么多，其实核心还是缺少一个对容器组合进行管理的东西。\n\n针对这种情况，我们就不得不引出在我们开发中最常使用的多容器定义和运行软件，也就是 Docker Compose 了。\n\n如果说 Dockerfile 是将容器内运行环境的搭建固化下来，那么 Docker Compose 我们就可以理解为将多个容器运行的方式和配置固化下来。\n\n在 Docker Compose 里，我们通过一个配置文件，将所有与应用系统相关的软件及它们对应的容器进行配置，之后使用 Docker Compose\n提供的命令进行启动，就能让 Docker Compose 将刚才我们所提到的那些复杂问题解决掉。\n\n\n编写 Docker Compose 配置#\n\n配置文件是 Docker Compose 的核心部分，我们正是通过它去定义组成应用服务容器群的各项配置，而编写配置文件，则是使用 Docker Compose\n过程中最核心的一个步骤。\n\nDocker Compose 的配置文件是一个基于 YAML 格式的文件。关于 YAML 的语法大家可以在网上找到，这里不再细说，总的来说，YAML\n是一种清晰、简单的标记语言，你甚至都可以在看过几个例子后摸索出它的语法。\n\n与 Dockerfile 采用 Dockerfile 这个名字作为镜像构建定义的默认文件名一样，Docker Compose\n的配置文件也有一个缺省的文件名，也就是 docker-compose.yml，如非必要，我建议大家直接使用这个文件名来做 Docker Compose\n项目的定义。\n\n\n\nDocker Compose 配置文件里可以包含许多内容，从每个容器的各个细节控制，到网络、数据卷等的定义。\n\n这里我们看几个主要的细节。首先是 version 这个配置，这代表我们定义的 docker-compose.yml 文件内容所采用的版本，目前 Docker\nCompose 的配置文件已经迭代至了第三版，其所支持的功能也越来越丰富，所以我们建议使用最新的版本来定义。\n\n接下来我们来看 services 这块，这是整个 docker-compose.yml 的核心部分，其定义了容器的各项细节。\n\n在 Docker Compose 里不直接体现容器这个概念，这是把 service 作为配置的最小单元。虽然我们看上去每个 service\n里的配置内容就像是在配置容器，但其实 service 代表的是一个应用集群的配置。每个 service\n定义的内容，可以通过特定的配置进行水平扩充，将同样的容器复制数份形成一个容器集群。而 Docker Compose\n能够对这个集群做到黑盒效果，让其他的应用和容器无法感知它们的具体结构。\n\n\n启动和停止#\n\n * 启动：docker-compose up -d，-d 代表后台执行\n\n需要注意的是，docker-compose 命令默认会识别当前控制台所在目录内的 docker-compose.yml\n文件，而会以这个目录的名字作为组装的应用项目的名称。如果我们需要改变它们，可以通过选项 -f 来修改识别的 Docker Compose 配置文件，通过 -p\n选项来定义项目名(一堆容器构成一个项目，即一个服务)。\n\n\n\n * 停止所有的容器，并将它们删除，同时消除网络等配置内容，也就是几乎将这个 Docker Compose 项目的所有影响从 Docker 中清除。\n\n\n\n如果条件允许，我更建议大家像容器使用一样对待 Docker Compose 项目，做到随用随启，随停随删。也就是使用的时候通过 docker-compose\nup 进行，而短时间内不再需要时，通过 docker-compose down 清理它。\n\n借助 Docker 容器的秒级启动和停止特性，我们在使用 docker-compose up 和 docker-compose down\n时可以非常快的完成操作。这就意味着，我们可以在不到半分钟的时间内停止一套环境，切换到另外一套环境，这对于经常进行多个项目开发的朋友来说，绝对是福音。\n\n通过 Docker 让我们能够在开发过程中搭建一套不受干扰的独立环境，让开发过程能够基于稳定的环境下进行。而 Docker Compose\n则让我们更近一步，同时让我们处理好多套开发环境，并进行快速切换。\n\n\n容器命令#\n\n除了启动和停止命令外，Docker Compose\n还为我们提供了很多直接操作服务的命令。之前我们说了，服务可以看成是一组相同容器的集合，所以操作服务就有点像操作容器一样。\n\n这些命令看上去都和 Docker Engine 中对单个容器进行操作的命令类似，我们来看几个常见的。\n\n在 Docker Engine 中，如果我们想要查看容器中主进程的输出内容，可以使用 docker logs 命令。而由于在 Docker Compose\n下运行的服务，其命名都是由 Docker Compose 自动完成的，如果我们直接使用 docker logs\n就需要先找到容器的名字，这显然有些麻烦了。我们可以直接使用 docker-compose logs 命令来完成这项工作。\n\n\n\n在 docker-compose logs 衔接的是 Docker Compose 中所定义的服务的名称。\n\n同理，在 Docker Compose 还有几个类似的命令可以单独控制某个或某些服务。\n\n通过 docker-compose create，docker-compose start 和 docker-compose stop 我们可以实现与\ndocker create，docker start 和 docker stop 相似的效果，只不过操作的对象由 Docker Engine 中的容器变为了\nDocker Compose 中的服务。\n\n\n\n\n常用的 Docker Compose 配置项#\n\n配置示例#\n\n\n\n指定镜像#\n\n容器最基础的就是镜像了，所以每个服务必须指定镜像。在 Docker Compose 里，我们可以通过两种方式为服务指定所采用的镜像。一种是通过 image\n这个配置，这个相对简单，给出能在镜像仓库中找到镜像的名称即可。\n\n另外一种指定镜像的方式就是直接采用 Dockerfile 来构建镜像，通过 build 这个配置我们能够定义构建的环境目录，这与 docker build\n中的环境目录是同一个含义。如果我们通过这种方式指定镜像，那么 Docker Compose 先会帮助我们执行镜像的构建，之后再通过这个镜像启动容器。\n\n\n\n在配置文件里，我们还能用 Map 的形式来定义 build，在这种格式下，我们能够指定更多的镜像构建参数，例如 Dockerfile 的文件名，构建参数等等。\n\n当然，对于一些可以不通过重新构建镜像的方式便能修改的内容，我们还是不建议重新构建镜像，而是使用原有的镜像做简单的修改。\n\n例如上面的配置里，我们希望修改 Redis 的启动命令，加入配置文件以便对 Redis 服务进行配置，那么我们可以直接通过 command 配置来修改。而在\nMySQL 的定义，我们通过 environment 配置为 MySQL 设置了初始密码。\n\n这些对镜像的使用方法我们在之前都已经谈到过了，只不过我们之前用的是 Docker Engine 的命令以及其选项来控制的，而在 Docker Compose\n里，我们直接通过配置文件来定义它们。\n\n由于 Docker Compose 的配置已经固化下来，所以我们不需要担心忘记之前执行了哪些命令来启动容器，当每次需要开启或关闭环境时，只需要\ndocker-compose up -d 和 docker-compose down 命令，就能轻松完成操作。\n\n依赖声明 (depends_on)#\n\n> 容器启动顺序\n\n虽然我们在 Docker Compose 的配置文件里定义服务，在书写上有由上至下的先后关系，但实际在容器启动中，由于各种因素的存在，其顺序还是无法保障的。\n\n所以，如果我们的服务间有非常强的依赖关系，我们就必须告知 Docker Compose 容器的先后启动顺序。只有当被依赖的容器完全启动后，Docker\nCompose 才会创建和启动这个容器。\n\n定义依赖的方式很简单，在上面的例子里我们已经看到了，也就是 depends_on 这个配置项，我们只需要通过它列出这个服务所有依赖的其他服务即可。在\nDocker Compose 为我们启动项目的时候，会检查所有依赖，形成正确的启动顺序并按这个顺序来依次启动容器。\n\n文件挂载#\n\n在 Docker Compose 里定义文件挂载的方式与 Docker Engine 里也并没有太多的区别，使用 volumes 配置可以像 docker\nCLI 里的 -v 选项一样来指定外部挂载和数据卷挂载。\n\n在上面的例子里，我们看到了定义几种常用挂载的方式。我们能够直接挂载宿主机文件系统中的目录，也可以通过数据卷的形式挂载内容。\n\n在使用外部文件挂载的时候，我们可以直接指定相对目录进行挂载，这里的相对目录是指相对于 docker-compose.yml 文件的目录。\n\n由于有相对目录这样的机制，我们可以将 docker-compose.yml\n和所有相关的挂载文件放置到同一个文件夹下，形成一个完整的项目文件夹。这样既可以很好的整理项目文件，也利于完整的进行项目迁移。\n\n虽然 Docker 提倡将代码或编译好的程序通过构建镜像的方式打包到镜像里，随整个 CI\n流部署到服务器中，但对于开发者来说，每次修改程序进行简单测试都要重新构建镜像简直是浪费生命的操作。所以在开发时，我们推荐直接将代码挂载到容器里，而不是通过镜像构\n建的方式打包成镜像。\n\n同时，在开发过程中，对于程序的配置等内容，我们也建议直接使用文件挂载的形式挂载到容器里，避免经常修改所带来的麻烦。\n\n使用数据卷#\n\n如果我们要在项目中使用数据卷来存放特殊的数据，我们也可以让 Docker Compose 自动完成对数据卷的创建，而不需要我们单独进行操作。\n\n在上面的例子里，独立于 services 的 volumes 配置就是用来声明数据卷的。定义数据卷最简单的方式仅需要提供数据卷的名称，对于我们在 Docker\nEngine 中创建数据卷时能够使用的其他定义，也能够放入 Docker Compose 的数据卷定义中。\n\n如果我们想把属于 Docker Compose 项目以外的数据卷引入进来直接使用，我们可以将数据卷定义为外部引入，通过 external\n这个配置就能完成这个定义。\n\n\n\n在加入 external 定义后，Docker Compose 在创建项目时不会直接创建数据卷，而是优先从 Docker Engine\n中已有的数据卷里寻找并直接采用。\n\n配置网络#\n\n网络也是容器间互相访问的桥梁，所以网络的配置对于多个容器组成的应用系统来说也是非常重要的。在 Docker Compose\n里，我们可以为整个应用系统设置一个或多个网络。\n\n要使用网络，我们必须先声明网络。声明网络的配置同样独立于 services 存在，是位于根配置下的 networks 配置。在上面的例子里，我们已经看到了声明\nfrontend 和 backend 这两个网络最简单的方式。\n\n除了简单的声明网络名称，让 Docker Compose 自动按默认形式完成网络配置外，我们还可以显式的指定网络的参数。\n\n\n\n在这里，我们为网络定义了网络驱动的类型，并指定了子网的网段。\n\n使用网络别名#\n\n直接使用容器名或服务名来作为连接其他服务的网络地址，因为缺乏灵活性，常常还不能满足我们的需要。这时候我们可以为服务单独设置网络别名，在其他容器里，我们将这个别名\n作为网络地址进行访问。\n\n网络别名的定义方式很简单，这里需要将之前简单的网络 List 定义结构修改成 Map 结构，以便在网络中加入更多的定义。\n\n\n\n在我们进行这样的配置后，我们便可以使用这里我们所设置的网络别名对其他容器进行访问了。\n\n端口映射#\n\n在 Docker Compose 的每个服务配置里，我们还看到了 ports 这个配置项，它是用来定义端口映射的。\n\n我们可以利用它进行宿主机与容器端口的映射，这个配置与 docker CLI 中 -p 选项的使用方法是近似的。\n\n需要注意的是，由于 YAML 格式对 xx:yy 这种格式的解析有特殊性，在设置小于 60\n的值时，会被当成时间而不是字符串来处理，所以我们最好使用引号将端口映射的定义包裹起来，避免歧义。\n\n\n编写 Docker Compose 项目 (实践一)#\n\n\n编写 Docker Compose 项目#\n\n在这一小节里，我们以一个由 MySQL、Redis、PHP-FPM 和 Nginx 组成的小型 PHP 网站为例，介绍通过 Docker\n搭建运行这套程序运行环境的方法。\n\n既然我们说到这个小型网站是由 MySQL、Redis、PHP-FPM 和 Nginx 四款软件所组成的，那么自然在 Docker\n里，我们要准备四个容器分别来运行它们。而为了更好地管理这四个容器所组成的环境，我们这里还会使用到 Docker Compose。\n\n与搭建一个软件开发项目类似，我们提倡将 Docker Compose 项目的组成内容聚集到一个文件目录中，这样更利于我们进行管理和迁移。\n\n简单说明一下这个结构中主要目录和文件的功能和作用。在这个结构里，我们可以将根目录下的几个目录分为四类：\n\n * 第一类是 Docker 定义目录，也就是 compose 这个目录。在这个目录里，包含了 docker-compose.yml 这个用于定义 Docker\n   Compose 项目的配置文件。此外，还包含了我们用于构建自定义镜像的内容。\n * 第二类是程序文件目录，在这个项目里是 mysql、nginx、phpfpm、redis 这四个目录。这些目录分别对应着 Docker Compose\n   中定义的服务，在其中主要存放对应程序的配置，产生的数据或日志等内容。\n * 第三类是代码目录，在这个项目中就是存放 Web 程序的 website 目录。我们将代码统一放在这个目录中，方便在容器中挂载。\n * 第四类是工具命令目录，这里指 bin 这个目录。我们在这里存放一些自己编写的命令脚本，我们通过这些脚本可以更简洁地操作整个项目。\n\n\ndocker-compose.yml#\n\n\n\n使用合适的镜像是提高工作效率的途径之一，这里讲解一下我们在这个项目中选择镜像的原由。\n\n在这个项目里，我们直接采用了 MySQL、Redis 和 Nginx 三个官方镜像，而对于 PHP-FPM 的镜像，我们需要增加一些功能，所以我们通过\nDockerfile 构建的方式来生成。\n\n对于 MySQL 来说，我们需要为它们设置密码，所以原则上我们是需要对它们进行改造并生成新的镜像来使用的。而由于 MySQL\n镜像可以通过我们之前在镜像使用方法一节所提到的环境变量配置的方式，来直接指定 MySQL\n的密码及其他一些关键性内容，所以我们就无须单独构建镜像，可以直接采用官方镜像并配合使用环境变量来达到目的。\n\n对于 Redis 来说，出于安全考虑，我们一样需要设置密码。Redis 设置密码的方法是通过配置文件来完成的，所以我们需要修改 Redis 的配置文件并挂载到\nRedis 容器中。这个过程也相对简单，不过需要注意的是，在官方提供的 Redis 镜像里，默认的启动命令是\nredis-server，其并没有指定加载配置文件。所以在我们定义 Redis 容器时，要使用 command\n配置修改容器的启动命令，使其读取我们挂载到容器的配置文件。\n\n\n自定义镜像 (Dockerfile)#\n\n相比较于 MySQL、Redis 这样可以通过简单配置即可直接使用的镜像不同，PHP\n的镜像中缺乏了一些我们程序中必要的元素，而这些部分我们推荐使用自定义镜像的方式将它们加入其中。\n\n在这个例子里，因为需要让 PHP 连接到 MySQL 数据库中，所以我们要为镜像中的 PHP 程序安装和开启 pdo_mysql 这个扩展。\n\n了解如何安装扩展，这就要考验我们之前在 Docker Hub 镜像使用一节中学到的知识了。我们通过阅读 PHP 镜像的介绍页面，可以找到 PHP\n镜像中已经为我们准备好了扩展的安装和启用命令，这让我们可以很轻松地在镜像中加入扩展。\n\n\n\n由于 Docker 官方所提供的镜像比较精简，所以在这个 Dockerfile 里，我们还执行了 cron 的安装命令，来确保我们可以使用定时任务。\n\n大家注意到，这里除了我们进行功能安装外，还将一个脚本拷入了镜像中，并将其作为 ENTRYPOINT 启动入口。这个文件的作用主要是为了启动 cron\n服务，以便我们在容器中可以正常使用它。\n\n\n\n在 docker-entrypoint.sh 里，除了启动 cron 服务的命令外，我们在脚本的最后看到的是 exec \"$@\" 这行命令。$@ 是 shell\n脚本获取参数的符号，这里获得的是所有传入脚本的参数，而 exec 是执行命令，直接执行这些参数。\n\n如果直接看这条命令大家会有些疑惑，参数怎么拿来执行，这不是有问题么？\n\n请大家回顾一下，我们之前提到的，如果在镜像里同时定义了 ENTRYPOINT 和 CMD 两个指令，CMD 指令的内容会以参数的形式传递给 ENTRYPOINT\n指令。所以，这里脚本最终执行的，是 CMD 中所定义的命令。\n\n\n目录挂载#\n\n在这个例子里，我们会把项目中的一些目录或文件挂载到容器里，这样的挂载主要有三种目的：\n\n * 将程序的配置通过挂载的方式覆盖容器中对应的文件，这让我们可以直接在容器外修改程序的配置，并通过直接重启容器就能应用这些配置；\n\n * 把目录挂载到容器中应用数据的输出目录，就可以让容器中的程序直接将数据输出到容器外，对于 MySQL、Redis\n   中的数据，程序的日志等内容，我们可以使用这种方法来持久保存它们；\n\n * 把代码或者编译后的程序挂载到容器中，让它们在容器中可以直接运行，这就避免了我们在开发中反复构建镜像带来的麻烦，节省出大量宝贵的开发时间。\n\n上述的几种方法，对于线上部署来说都是不适用的，但在我们的开发过程中，却可以为我们免去大量不必要的工作，因此建议在开发中使用这些挂载结构。\n\n\n编写辅助脚本#\n\n我们知道，虽然 Docker Compose 简化了许多操作流程，但我们还是需要使用 docker-compose\n命令来管理项目。对于这个例子来说，我们要启动它就必须使用这样的 docker-compose 命令来管理项目。对于这个例子来说，我们要启动它就必须使用这样的：\n\n\n\n而执行的目录必须是 docker-compose.yml 文件所在的目录，这样才能正确地读取 Docker Compose 项目的配置内容。\n\n我编写了一个 compose 脚本，用来简化 docker-compose 的操作命令。\n\n\n\n在这个脚本里，我把一些共性的东西包含进去，这样我们就不必每次传入这些参数或选项了。同时，这个脚本还能自适应调用的目录，准确找到\ndocker-compose.yml 文件，更方便我们直接调用。\n\n通过这个脚本来操作项目，我们的命令就可以简化为：\n\n\n\n\ndocker 常用命令#\n\n\n一、docker 启动#\n\nUbuntu#\n\n\n\nCentOS#\n\n\n\n\n二、关闭 docker#\n\nUbuntu#\n\n\n\nCentOS#\n\n\n\n\n三、重启 docker#\n\nUbuntu#\n\n\n\nCentOS#\n\n\n\n\n四、卸载 docker#\n\nUbuntu#\n\n\n\nCentOS#\n\n\n\n\n五、镜像加速#\n\nDocker 官方和国内很多云服务商都提供了国内加速器服务，例如：\n\n> 科大镜像：https://docker.mirrors.ustc.edu.cn/\n> \n> 网易：https://hub-mirror.c.163.com/\n> \n> 阿里云： ID>.mirror.aliyuncs.com\n> \n> 七牛云加速器：https://reg-mirror.qiniu.com\n> \n> Ubuntu14.04、Debian7Wheezy\n\n对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：\n\n> DOCKER_OPTS=\"--registry-mirror=https://registry.docker-cn.com\"\n\n重新启动服务:\n\n\n\nUbuntu16.04+、Debian8+、CentOS7#\n\n对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n\n{\"registry-mirrors\":[\"https://reg-mirror.qiniu.com/\"]}\n\n之后重新启动服务：\n\n\n\n\n六、镜像使用#\n\n列出镜像列表#\n\n\n\n获取一个新的镜像#\n\n\n\n查找镜像#\n\n\n\n删除镜像`#\n\n\n\n\n七、容器使用#\n\n1、获取镜像#\n\n\n\n2、启动容器#\n\n\n\n> -i: 交互式操作。\n> \n> -t: 终端。\n> \n> -d: 后台运行\n> \n> --name nginx-test：容器名称。\n> \n> nginx: nginx 镜像\n> \n> /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。(要退出终端，直接输入 exit)\n\n3、提交容器副本为镜像#\n\n\n\n> -m: 提交的描述信息\n> \n> -a: 指定镜像作者\n> \n> h7ml：容器 ID\n> \n> lqs/nginx-test:v1: 指定要创建的目标镜像名\n\n4、查看所有的容器#\n\n\n\n5、停止一个容器#\n\n\n\n6、启动已停止运行的容器#\n\n\n\n7、进入容器#\n\ndocker attach # 退出容器会停止\n\ndocker exec # 推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。\n\n\n\n8、导出容器\n\n\n\n9、导入容器快照#\n\n可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 nginx.tar 导入到镜像 test/nginx:v1:\n\n\n\n10、删除容器#\n\n\n\n\n八、容器的端口映射#\n\n1、查看容器端口的映射情况#\n\n\n\n2、容器启动时可以指定通信协议，比如 tcp、udp#\n\n\n\n\n\n3、容器启动绑定多 IP 和端口（跟多个-p）#\n\n\n\n4、通过宿主机的 iptables 进行 nat 转发，将宿主机的端口映射到容器的内部端口上#\n\n这种方式适用于容器启动时没有指定端口映射的情况！\n\n首先获得容器的 ip 地址\n\n\n\n将容器的 80 端口映射到 docker 主机的 8080 端口\n\n\n\n5、提交一个运行中的容器为镜像，运行镜像并添加端口#\n\n\n\n","routePath":"/up/docker/docker","lang":"","toc":[{"text":"概念","id":"概念","depth":2,"charIndex":3},{"text":"Docker 的核心四大组成对象","id":"docker-的核心四大组成对象","depth":3,"charIndex":9},{"text":"镜像","id":"镜像","depth":4,"charIndex":91},{"text":"容器","id":"容器","depth":4,"charIndex":665},{"text":"网络","id":"网络","depth":4,"charIndex":1743},{"text":"数据卷","id":"数据卷","depth":4,"charIndex":2204},{"text":"其他","id":"其他","depth":4,"charIndex":2908},{"text":"常用命令","id":"常用命令","depth":2,"charIndex":3076},{"text":"镜像相关","id":"镜像相关","depth":3,"charIndex":3311},{"text":"镜像迁移","id":"镜像迁移","depth":4,"charIndex":3614},{"text":"容器相关","id":"容器相关","depth":3,"charIndex":3624},{"text":"网络相关","id":"网络相关","depth":3,"charIndex":4415},{"text":"存储相关","id":"存储相关","depth":3,"charIndex":5112},{"text":"数据卷容器","id":"数据卷容器","depth":4,"charIndex":6249},{"text":"数据卷备份和迁移","id":"数据卷备份和迁移","depth":4,"charIndex":6534},{"text":"笔记","id":"笔记","depth":2,"charIndex":7151},{"text":"修改国内镜像源","id":"修改国内镜像源","depth":3,"charIndex":7157},{"text":"通过 Dockerfile 创建镜像","id":"通过-dockerfile-创建镜像","depth":2,"charIndex":7224},{"text":"编写","id":"编写","depth":3,"charIndex":7424},{"text":"Dockerfile 的结构","id":"dockerfile-的结构","depth":4,"charIndex":7672},{"text":"常见 Dockerfile 指令","id":"常见-dockerfile-指令","depth":4,"charIndex":8107},{"text":"构建镜像","id":"构建镜像","depth":3,"charIndex":9920},{"text":"常见技巧","id":"常见技巧","depth":3,"charIndex":9954},{"text":"构建中使用变量","id":"构建中使用变量","depth":4,"charIndex":9961},{"text":"环境变量","id":"环境变量","depth":4,"charIndex":10371},{"text":"合并命令","id":"合并命令","depth":4,"charIndex":11053},{"text":"构建缓存","id":"构建缓存","depth":4,"charIndex":11156},{"text":"搭配 ENTRYPOINT 和 CMD","id":"搭配-entrypoint-和-cmd","depth":4,"charIndex":11564},{"text":"使用 Alpine 镜像","id":"使用-alpine-镜像","depth":4,"charIndex":12557},{"text":"Docker Compose 容器编排","id":"docker-compose-容器编排","depth":2,"charIndex":12815},{"text":"容器管理问题","id":"容器管理问题","depth":3,"charIndex":13039},{"text":"编写 Docker Compose 配置","id":"编写-docker-compose-配置","depth":3,"charIndex":14030},{"text":"启动和停止","id":"启动和停止","depth":3,"charIndex":14882},{"text":"容器命令","id":"容器命令","depth":3,"charIndex":15552},{"text":"常用的 Docker Compose 配置项","id":"常用的-docker-compose-配置项","depth":3,"charIndex":16177},{"text":"配置示例","id":"配置示例","depth":4,"charIndex":16202},{"text":"指定镜像","id":"指定镜像","depth":4,"charIndex":16211},{"text":"依赖声明 (depends_on)","id":"依赖声明-depends_on","depth":4,"charIndex":16981},{"text":"文件挂载","id":"文件挂载","depth":4,"charIndex":17323},{"text":"配置网络","id":"配置网络","depth":4,"charIndex":18257},{"text":"编写 Docker Compose 项目 (实践一)","id":"编写-docker-compose-项目-实践一","depth":2,"charIndex":18991},{"text":"编写 Docker Compose 项目","id":"编写-docker-compose-项目","depth":3,"charIndex":19021},{"text":"docker-compose.yml","id":"docker-composeyml","depth":3,"charIndex":19761},{"text":"自定义镜像 (Dockerfile)","id":"自定义镜像-dockerfile","depth":3,"charIndex":20312},{"text":"目录挂载","id":"目录挂载","depth":3,"charIndex":21071},{"text":"编写辅助脚本","id":"编写辅助脚本","depth":3,"charIndex":21429},{"text":"docker 常用命令","id":"docker-常用命令","depth":2,"charIndex":21826},{"text":"一、docker 启动","id":"一docker-启动","depth":3,"charIndex":21841},{"text":"Ubuntu","id":"ubuntu","depth":4,"charIndex":21855},{"text":"CentOS","id":"centos","depth":4,"charIndex":21866},{"text":"二、关闭 docker","id":"二关闭-docker","depth":3,"charIndex":21878},{"text":"Ubuntu","id":"ubuntu-1","depth":4,"charIndex":21892},{"text":"CentOS","id":"centos-1","depth":4,"charIndex":21903},{"text":"三、重启 docker","id":"三重启-docker","depth":3,"charIndex":21915},{"text":"Ubuntu","id":"ubuntu-2","depth":4,"charIndex":21929},{"text":"CentOS","id":"centos-2","depth":4,"charIndex":21940},{"text":"四、卸载 docker","id":"四卸载-docker","depth":3,"charIndex":21952},{"text":"Ubuntu","id":"ubuntu-3","depth":4,"charIndex":21966},{"text":"CentOS","id":"centos-3","depth":4,"charIndex":21977},{"text":"五、镜像加速","id":"五镜像加速","depth":3,"charIndex":21989},{"text":"Ubuntu16.04+、Debian8+、CentOS7","id":"ubuntu1604debian8centos7","depth":4,"charIndex":22371},{"text":"六、镜像使用","id":"六镜像使用","depth":3,"charIndex":22542},{"text":"列出镜像列表","id":"列出镜像列表","depth":4,"charIndex":22551},{"text":"获取一个新的镜像","id":"获取一个新的镜像","depth":4,"charIndex":22562},{"text":"查找镜像","id":"查找镜像","depth":4,"charIndex":22575},{"text":"删除镜像`","id":"删除镜像","depth":4,"charIndex":22584},{"text":"七、容器使用","id":"七容器使用","depth":3,"charIndex":22595},{"text":"1、获取镜像","id":"1获取镜像","depth":4,"charIndex":22604},{"text":"2、启动容器","id":"2启动容器","depth":4,"charIndex":22615},{"text":"3、提交容器副本为镜像","id":"3提交容器副本为镜像","depth":4,"charIndex":22795},{"text":"4、查看所有的容器","id":"4查看所有的容器","depth":4,"charIndex":22894},{"text":"5、停止一个容器","id":"5停止一个容器","depth":4,"charIndex":22908},{"text":"6、启动已停止运行的容器","id":"6启动已停止运行的容器","depth":4,"charIndex":22921},{"text":"7、进入容器","id":"7进入容器","depth":4,"charIndex":22938},{"text":"9、导入容器快照","id":"9导入容器快照","depth":4,"charIndex":23042},{"text":"10、删除容器","id":"10删除容器","depth":4,"charIndex":23131},{"text":"八、容器的端口映射","id":"八容器的端口映射","depth":3,"charIndex":23144},{"text":"1、查看容器端口的映射情况","id":"1查看容器端口的映射情况","depth":4,"charIndex":23156},{"text":"2、容器启动时可以指定通信协议，比如 tcp、udp","id":"2容器启动时可以指定通信协议比如-tcpudp","depth":4,"charIndex":23174},{"text":"3、容器启动绑定多 IP 和端口（跟多个-p）","id":"3容器启动绑定多-ip-和端口跟多个-p","depth":4,"charIndex":23207},{"text":"4、通过宿主机的 iptables 进行 nat 转发，将宿主机的端口映射到容器的内部端口上","id":"4通过宿主机的-iptables-进行-nat-转发将宿主机的端口映射到容器的内部端口上","depth":4,"charIndex":23235},{"text":"5、提交一个运行中的容器为镜像，运行镜像并添加端口","id":"5提交一个运行中的容器为镜像运行镜像并添加端口","depth":4,"charIndex":23363}],"domain":"","frontmatter":{"icon":"community","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"docker","tag":"docker"},"version":""},{"id":481,"title":"dockerFile","content":"DockerFile#\n\n官网 open in new window，Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。\n\n\n\n构建三步骤\n\n * 编写 Dockerfile 文件\n * docker build 命令构建镜像\n * docker run 依镜像运行容器实例\n\n\nDockerFile 构建过程解析#\n\n\nDockerfile 内容基础知识#\n\n 1. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数\n 2. 指令按照从上到下，顺序执行\n 3. #表示注释\n 4. 每条指令都会创建一个新的镜像层并对镜像进行提交\n\n\nDocker 执行 Dockerfile 的大致流程#\n\n * （1）docker从基础镜像运行一个容器\n * （2）执行一条指令并对容器作出修改\n * （3）执行类似docker commit的操作提交一个新的镜像层\n * （4）docker再基于刚提交的镜像运行一个新容器\n * （5）执行dockerfile中的下一条指令直到所有指令都执行完成\n\n\n小总结#\n\n从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，\n\n * Dockerfile是软件的原材料\n * Docker镜像是软件的交付品\n * Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例\n\nDockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当 Docker 体系的基石。\n\n\n\n1、Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、\n环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace\n的权限控制)等等;\n\n2、Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个 Docker 镜像，当运行\nDocker镜像时会真正开始提供服务;\n\n3、Docker容器，容器是直接提供服务的。\n\n\nDockerFile 常用保留字指令#\n\n\nFROM#\n\n基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from\n\n\nMAINTAINER#\n\n镜像维护者的姓名和邮箱地址\n\n\nRUM#\n\n容器构建时需要运行的命令\n\n * shell 格式\n\n\n\n * exec 格式\n\n\n\n\nEXPOSE#\n\n当前容器对外暴露出的端口\n\n\nWORKDIR#\n\n指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点\n\n\nUSER#\n\n指定该镜像以什么样的用户去执行，如果都不指定，默认是 root\n\n\nENV#\n\n用来在构建镜像过程中设置环境变量\n\n\nADD#\n\n将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包\n\n\nCOPY#\n\n类似 ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置\n\n\n\n\nVOLUME#\n\n容器数据卷，用于数据保存和持久化工作\n\n\nCMD#\n\n指定容器启动后的要干的事情\n\nCMD指令的格式和RUN相以，也是两种格式：\n\n * shell 格式：CND<命令>\n * exec 格式：CND[\"可执行文件\"，\"参数1\"，\"参数2\"..]\n * 参数列表格式：CMD[\"参数1\"，\"参数2\"..]。在指定了ENTRYPOINT指令后，用 CND 指定具体的参数。\n\nWARNING\n\nDockerfile 中可以有多个 CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换\n\n参考官网Tomcat的dockerfile演示讲解\n\n\n\n我们演示自己的覆盖操作\n\n\n\n它和前面 RUN 命令的区别\n\n * CMD 是在 docker run 时运行\n * RUN 是在 docker build 时运行\n\n\nENTRYPOINT#\n\n也是用来指定一个容器启动时要运行的命令\n\n类似于 CMD 指令，但是ENTRYPOINT不会被docker run后面的命令覆盖， 而且这些命令行参数会被当作参数送给 ENTRYPOINT\n指令指定的程序\n\n命令格式和案例说明：\n\n\n\nENTRYPOINT可以和 CMD 一起用，一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参。\n\n当指定了ENTRYPOINT后，CMD 的含义就发生了变化，不再是直接运行其命令而是将 CMD 的内容作为参数传递给ENTRYPOINT指令，他两个组合会变成\n\n\n\n**案例如下：**假设已通过 Dockerfile 构建了 nginx:test 镜像：\n\n\n\n是否传参        按照 DOCKERFILE 编写执行               传参运行\nDocker 命令   docker run nginx:test            docker run nginx:test -c /etc/nginx/new.conf\n衍生出的实际命令    nginx -c /etc/nginx/nginx.conf   nginx -c /etc/nginx/new.conf\n\nTIP\n\n优点：在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。\n\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\n\n\n小总结#\n\n\n\n\n案例#\n\n自定义镜像 mycentosjava8\n\n * Centos7 镜像具备 vim+ifconfig+jdk8\n\n * JDK 的下载镜像地址\n\nhttps://www.oracle.com/java/technologies/downloads/#java8\n\n\n\nhttps://mirrors.yangxingzhen.com/jdk/\n\n准备编写 Dockerfile 文件\n\n\n\n\n\n大写字母 D、构建\n\n\n\n> 注意，上面 TAG 后面有个空格，有个点，代表当前目录\n\n运行\n\n\n\n\n\n\n虚悬镜像#\n\n是什么：仓库名、标签都是的镜像，俗称 dangling image，Dockerfile 写一个。\n\n\n\n\n\n查看\n\n\n\n\n\n删除\n\n虚悬镜像已经失去存在价值，可以删除\n\n\n\n\n总结#\n\n","routePath":"/up/docker/dockerfile","lang":"","toc":[{"text":"DockerFile","id":"dockerfile","depth":2,"charIndex":-1},{"text":"DockerFile 构建过程解析","id":"dockerfile-构建过程解析","depth":2,"charIndex":169},{"text":"Dockerfile 内容基础知识","id":"dockerfile-内容基础知识","depth":3,"charIndex":190},{"text":"Docker 执行 Dockerfile 的大致流程","id":"docker-执行-dockerfile-的大致流程","depth":3,"charIndex":300},{"text":"小总结","id":"小总结","depth":3,"charIndex":478},{"text":"DockerFile 常用保留字指令","id":"dockerfile-常用保留字指令","depth":2,"charIndex":980},{"text":"FROM","id":"from","depth":3,"charIndex":1002},{"text":"MAINTAINER","id":"maintainer","depth":3,"charIndex":1058},{"text":"RUM","id":"rum","depth":3,"charIndex":1087},{"text":"EXPOSE","id":"expose","depth":3,"charIndex":1137},{"text":"WORKDIR","id":"workdir","depth":3,"charIndex":1161},{"text":"USER","id":"user","depth":3,"charIndex":1202},{"text":"ENV","id":"env","depth":3,"charIndex":1243},{"text":"ADD","id":"add","depth":3,"charIndex":1268},{"text":"COPY","id":"copy","depth":3,"charIndex":1314},{"text":"VOLUME","id":"volume","depth":3,"charIndex":1391},{"text":"CMD","id":"cmd","depth":3,"charIndex":1421},{"text":"ENTRYPOINT","id":"entrypoint","depth":3,"charIndex":1772},{"text":"小总结","id":"小总结-1","depth":3,"charIndex":2416},{"text":"案例","id":"案例","depth":2,"charIndex":2425},{"text":"虚悬镜像","id":"虚悬镜像","depth":2,"charIndex":2679},{"text":"总结","id":"总结","depth":2,"charIndex":2775}],"domain":"","frontmatter":{"icon":"community","order":2,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"docker","tag":"docker","title":"dockerFile"},"version":""},{"id":482,"title":"docker","content":" * docker\n\n * dockerfile","routePath":"/up/docker/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"box","date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"docker","title":"docker","index":false,"dir":{"order":2}},"version":""},{"id":483,"title":"概览","content":"#","routePath":"/up/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"sidebar_label":"概览","sidebar_position":1},"version":""},{"id":484,"title":"Linux 基础操作","content":"无界面安装#\n\nWARNING\n\n这里不展示虚拟机安装镜像的过程\n\nB 站视频 open in new window\n\n\ninstallation界面#\n\n镜像安装完成后会出现这个界面\n\n\n\n按 r 刷新之后会有三个感叹号\n\n\n\n分别是：5 磁盘设置、8 密码设置、9 创建用户\n\n\n按 5 进行磁盘设置#\n\n之后依次按 c、c、c，之后的界面是这样\n\n\n\n\n按 8 进行秘密设置#\n\n\n\n这里会进行两次密码输入，\n\n 1. 第一次设置\n 2. 第二次确认输入\n 3. 最后输入 yes\n 4. 回到installation界面按 b 保存\n\n\n安装完成#\n\n\n\n在此界面按回车键（Enter）完成安装\n\n\n登录#\n\n\n\n输入用户名：root\n\n输入密码：xxxxx\n\n\n目录结构#\n\n\n/bin#\n\n是Binary的缩写，这个目录存放着最经常常用的命令\n\n\n/sbin#\n\ns 就是Super User的意思，这里存放的是系统管理员使用的系统管理程序\n\n\n/home#\n\n存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户买的账号命名的\n\n\n/root#\n\n该目录系统管理员，也城作为超级权限者的用户主目录\n\n\n/lib#\n\n系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的 DLL 文件。几乎所有的应用程序都需要用这些共享库\n\n\n/lost+found#\n\n这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n\n\n/etc#\n\n所有的系统管理所需要的配置文件和子目录。\n\n\n/usr#\n\n这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\n\n\n/boot#\n\n这里存放的是启动Liux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。\n\n\n/proc#\n\n这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n\n\n/srv#\n\nservice缩写，该目录存放一些服务启动之后需要提取的数据。\n\n\n/sys#\n\n这是iux2.6内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统sysfs\n\n\n/tmp#\n\n这个目录是用来存放一些临时文件的\n\n\n/dev#\n\n类似于windows的设备管理器，把所有的硬件用文件的形式存储。\n\n\n/media(CentOS6)#\n\nlinux系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\nCentOS7迁移到/run/media\n\n\n/mnt#\n\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了\n\n\n/opt#\n\n这是给主机额外安装软件所摆放的目录。比如你安装一个ysq数据库则就可以放到这个目录下。默认是空的。\n\n\n/var#\n\n这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n\nvim 软键盘#\n\nvim 用过一些插件可以实现和 IDE 一样的功能\n\nVim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\nLinux 中，必须会使用 Vim（查看内容，编辑内容，保存内容）\n\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。\n\nvim 则可以说是程序开发者的一项很好用的工具。\n\n可以理解 vim 是 vi 的升级版\n\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件\n\n\n\n\n三种使用模式#\n\n基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line\nmode）。这三种模式的作用分别是：\n\n\n命令模式：#\n\n用户刚刚启动 vi/vim，便进入了命令模式。\n\n\n\n\n\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。\n\n以下是常用的几个命令：\n\n * i 切换到输入模式，以输入字符。\n * x 删除当前光标所在处的字符。\n * : 切换到底线命令模式，以在最底一行输入命令。如果是便捷模式，需要退出便捷模式ESC\n\n若想要编辑文本： 启动Vim，进入了命令模式，按下 i，切换到输入模式。\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n\n输入模式#\n\n在命令模式下按下 i 就进入了输入模式。\n\n\n\n在输入模式中，可以使用以下按键：\n\n * 字符按键以及 Shift 组合，输入字符\n * ENTER，回车键，换行\n * BACK SPACE，退格键，删除光标前一个字符\n * DEL，删除键，删除光标后一个字符\n * 方向键，在文本中移动光标\n * HOME/END，移动光标到行首/行尾\n * Page Up/Page Down，上/下翻页\n * Insert，切换光标为输入/替换模式，光标将变成竖线/下划线\n * ESC，退出输入模式，切换到命令模式\n\n\n底线命令模式#\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n\n\n\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\n\nw 保存文件\n\n\n\n按 ESC 键可随时退出底线命令模式。\n\n\n\n\n\n\n完整的演示#\n\n> 说明新建或者编辑文件，按 i 进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线命令模式：wq 保存退出！\n\n\nVim 按键说明#\n\n\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等#\n\n移动光标的方法                        \nh 或 向左箭头键(←)                   光标向左移动一个字符\nj 或 向下箭头键(↓)                   光标向下移动一个字符\nk 或 向上箭头键(↑)                   光标向上移动一个字符\nl 或 向右箭头键(→)                   光标向右移动一个字符\n[Ctrl] + [f]                   屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n[Ctrl] + [b]                   屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n[Ctrl] + [d]                   屏幕『向下』移动半页\n[Ctrl] + [u]                   屏幕『向上』移动半页\n+                              光标移动到非空格符的下一行\n-                              光标移动到非空格符的上一行\nn                              **那个 n 表示『数字』，例如 20 。按下数字后再按空格键，\n光标会向右移动这一行的 n 个字符。 数字 加 空格**   \n0 或功能键[Home]                   这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键[End]                    移动到这一行的最后面字符处(常用)\nH                              光标移动到这个屏幕的最上方那一行的第一个字符\nM                              光标移动到这个屏幕的中央那一行的第一个字符\nL                              光标移动到这个屏幕的最下方那一行的第一个字符\nG                              移动到这个档案的最后一行(常用)\nnG                             n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                             移动到这个档案的第一行，相当于 1G 啊！(常用)\nn                              n 为数字。光标向下移动 n 行(常用)\n\n搜索替换                                       \n/word                                      向光标之下寻找一个名称为 word 的字符串。\n例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)   \n?word                                      向光标之上寻找一个字符串名称为 word 的字符串。\nn                                          这个 n 是英文按键。代表重复前一个搜寻的动作。\n\n举例来说：如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后， 会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行\n?vbird 的 | | N | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻\nvbird 。 |\n\n删除、 复制与粘贴                                  \nx, X                                       在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)，\nX 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)   \nnx                                         n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\ndd                                         删除游标所在的那一整行(常用)\ndw                                         删除游标所在的一个词\nndd                                        n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)\nd1G                                        删除光标所在到第一行的所有数据\ndG                                         删除光标所在到最后一行的所有数据\nd$                                         删除游标所在处，到该行的最后一个字符\nd0                                         那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\nyy                                         复制游标所在的那一行(常用)\nyw                                         复制游标所在的一个词\nnyy                                        n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\ny1G                                        复制游标所在行到第一行的所有数据\nyG                                         复制游标所在行到最后一行的所有数据\ny0                                         复制光标所在的那个字符到该行行首的所有数据\ny$                                         复制光标所在的那个字符到该行行尾的所有数据\np, P                                       p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！\n\n举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。\n但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) | | J | 将光标所在行与下一行的数据结合成同一行 | | c |\n重复删除多个数据，例如向下删除 10 行，[ 10cj ] | | u | 复原前一个动作。(常用) | | [Ctrl]+r | 重做上一个动作。(常用) |\n| crystalift+6（^） | 移动到行头 | | `crystalift+4 （ | $）` 移动到行尾 | | n+shift+g | n\n为数字。移动到页头 | | crystalift+g | 移动到页尾 | | n+shift+g | n 为数字。移动到目标行 |\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明#\n\n进入输入或取代的编辑模式   \ni, I           进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I\n               为『在目前所在行的第一个非空格符处开始输入』。(常用)\na, A           进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A\n               为『从光标所在行的最后一个字符处开始输入』。(常用)\no, O           进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O\n               为在目前光标所在处的上一行输入新的一行！(常用)\nr, R           进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下\n               ESC 为止；(常用)\n[Esc]          退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明#\n\n指令行的储存、离开等指令          \n:w                    将编辑的数据写入硬盘档案中(常用)\n:w!                   若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n:q                    离开 vi (常用)\n:q!                   若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n:wq                   储存后离开，若为 :wq! 则为强制储存后离开 (常用)\nZZ                    这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！\n:w [filename]         将编辑的数据储存成另一个档案（类似另存新档）\n:r [filename]         在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n:n1,n2 w [filename]   将 n1 到 n2 的内容储存成 filename 这个档案。\n:! command            暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看\n                      /home 底下以 ls 输出的档案信息！\n:set nu 设置行号，代码中      显示行号，设定之后，会在每一行的前缀显示该行的行号\n:set nonu             与 set nu 相反，为取消行号！\n\n> 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n查看网络 IP 和 网关#\n\n\n查看虚拟网络编辑器#\n\n\n\n\n修改虚拟网卡 Ip#\n\n\n\n\n查看网关#\n\n\n\n\n查看 windows 环境的中 VMnet8 网络配置#\n\n\n\n\n配置网络 ip 地址#\n\n\nifconfig 配置网络接口#\n\nifconfig :network interfaces configuring 网络接口配置\n\n1、基本语法\n\n * ifconfig （功能描述：显示所有网络接口的配置信息）\n\n2、案例实操\n\n * 查看当前网络 ip\n\n\n\n\nping 测试主机之间网络连通性#\n\n1、基本语法\n\n * ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）\n\n2、案例实操\n\n * 测试当前服务器是否可以连接百度\n\n\n\n\n修改 IP 地址#\n\n1、查看 IP 配置文件\n\n\n\n\n\n以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。\n\n\n\n修改后\n\n\n\n编辑完后，按键盘 esc ，然后输入 :wq 回车即可。\n\n2、执行 service network restart 重启网络\n\n\n\n\n修改 IP 地址后可能会遇到的问题#\n\n 1. 物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机,一般都是因为物理机的防火墙问题,把防火墙关闭就行\n 2. 虚拟机能 Ping 通物理机,但是虚拟机 Ping 不通外网,一般都是因为DNS 的设置有问题\n 3. 虚拟机 Ping www.baidu.com 显示域名未知等信息,一般查看GATEWAY 和DNS 设置是否正确\n 4. 如果以上全部设置完还是不行，需要关闭 NetworkManager 服务\n    1. systemctl stop NetworkManager 关闭\n    2. systemctl disable NetworkManager 禁用\n 5. 如果检查发现 systemctl status network 有问题 需要检查ifcfg-ens33\n\n\n下面是 red hat/CentOs7 关闭防火墙的命令#\n\n1:查看防火状态\n\n * systemctl status firewalld\n * service iptables status\n\n2:暂时关闭防火墙\n\n * systemctl stop firewalld\n * service iptables stop\n\n3:永久关闭防火墙\n\n * systemctl disable firewalld\n * chkconfig iptables off\n\n4:重启防火墙\n\n * systemctl enable firewalld\n * service iptables restart\n\n5:永久关闭后重启\n\n//暂时还没有试过\n\n * chkconfig iptables on\n\n\n配置主机名#\n\n\n修改主机名称#\n\n1、基本语法\n\nhostname （功能描述：查看当前服务器的主机名称）\n\nHostnamectl（查看详细信息）使用hostnamectl set-hostname [自定义名称] 可强制更改不需要重启\n\n2、案例实操\n\n 1. 查看当前服务器主机名称\n\n\n\n 2. 如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/hostname 文件\n\n\n\n修改完成后重启生效。\n\n\n修改 hosts 映射文件#\n\n修改 linux 的主机映射文件（hosts 文件） 后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置，比较简单方便。 不用刻意记\nip 地址。\n\n 1. 打开/etc/hosts\n\n\n\n添加如下内容\n\n\n\n 2. 重启设备，重启后，查看主机名，已经修改成功\n\n修改 windows 的主机映射文件（hosts 文件）\n\n 1. 进入 C:\\Windows\\System32\\drivers\\etc 路径\n 2. 打开 hosts 文件并添加如下内容\n\n\n\n\n远程登录#\n\nWindows: Xshell, SSH Secure crystalell, SecureCRT,FinalShell\n\nMacOS :iTerm2，Royal TSX\n\n\nCentOS Node#\n\n官网 open in new window\n\n\n第一步 在 CentOS 找好安装位置#\n\nx86 架构\n\n\n\n让你一步到位的命令\n\n\n\nurl 拆解\n\nhttps://npm.taobao.org/mirrors/node/v16.17.0 node 版本号\n\nnode-v16.17.0-linux-x64.tar.gz 对应架构的文件名\n\n\n第二步 解压压缩文件#\n\n执行一下命令\n\n\n\n进入到 node-v16.17.0-linux-x64.tar.gz，执行一下命令安装 Node.js 的依赖组件\n\n\n\n重命名 node-v12.16.1-linux-x64.tar.gz 文件夹为 Node.js\n\n\n\n\n第三步 部署 bin 文件并建立软连接（类似于 Windows 中配置环境变量）#\n\n进入到/usr/local/temp/Node.js/bin 你会看到\n\n\n\nln 指令用于创建关联\n\n依次执行以下命令\n\n\n\n最后在终端输入 node -v\n\n\n\n出现这个就完成\n\n\n安装 yarn#\n\n\n配置yarnopen in new window官方 yum 存储库#\n\n\n\n\n安装#\n\n\n验证#\n\n\n\n\nCentos7 Mysql 安装#\n\n\n1、下载#\n\nhttps://downloads.mysql.com/archives/community/\n\n\n\n上传到 Linux\n\n或一键下载\n\n\n\n\n2、解压#\n\n将文件移动到一个目录中\n\n\n\n解包文件\n\n\n\n\n\n\n3、安装#\n\n--nodeps --force 为强制安装\n\n\n\n\n\n\n\n\n\n\n\n\n\n必须安装以上顺序安装\n\n\n4、问题#\n\n安装完成后不出意外的话输入初始化命令就成功了\n\n\n\n如果出现以下报错\n\n\n\n那可能是缺少 openssl10\n\n在 Linux 中安装 openssl10，进行OpenSSLopen in new window升级（用 yum 升不上去，用 rpm 包简单有效）\n\n阿里云下载链接\n\n\n\n下载后进行安装\n\n\n\n最终安装过程图\n\n\n\n\n5、启动#\n\n\n初始化 Nysql#\n\n\n\n\n添加权限#\n\n\n\n\n启动服务#\n\n\n查看初始密码#\n\n\n\n\n\n\n登入 Mysql#\n\n\n问题#\n\n这里我在登录的时候是遇到了两个问题\n\n报错 1\n\n\n\n没有libncurses.so.5，可能有libncurses.so不同版本的文件，使用命令全局查找\n\n\n\n\n\n之后将/usr/lib64下找到的libncurses.so 版本和libncurses.so.5进行链接\n\n\n\n报错 2\n\n\n\n与上同理，全局查找libtinfo将文件与 libtinfo.so.5 进行链接\n\n最终登录效果\n\n\n\n\n修改密码#\n\n\n\n\n查看数据库#\n\n\n\n\n6、navicat 远程链接#\n\n点击新建链接使用 SSH\n\n\n\n\n链接失败 1130#\n\n1130 - Host ‘xxx.xxx.xxx.xxx’ is not allowed to connect to this MySQL server\n\na.问题分析#\n\n某某 ip 不被允许连接这个 MySQL 服务，排除服务器防火墙没开放 3306 端口的情况\n\nb.解决办法#\n\n连接远端服务器，登录进去到 MySQL，查看名为 mysql 的数据库中的一个名字叫 user 的表，一般来讲如果出现 1130 代码问题，大概率是 MySQL\n登录用户的 host 权限是 localhost 或其他，把登录用户对应的 host 改成%即可，%意为任意 ip 地址\n\nc.解决步骤#\n\n\n\n2.接着说可能会出现的其他问题：失败 2059\n\n\n链接失败 2059#\n\n2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded:\nxxxxxxxxxx\n\n\n\na.问题分析#\n\n这个问题存在于 MySQL8.0 及以后的版本，MySQL8.0 对密码的加密方式进行了修改，由原来的 mysql_native_password 方式，改成了\ncaching_sha2_password 方式，导致了支持 mysql_native_password 方式的Navicatopen in new\nwindow无法成功连接 MySQL8.0\n\nb.问题解决#\n\n修改 MySQL 数据库的密码加密方式，并使用加密方式修改覆盖原来的密码，保证相同密码加密后的一致，密码改成 Navicat 支持的\nmysql_native_password 方式\n\nc.解决步骤#\n\n\n\n\n7、Node 链接 Mysql8 的一些问题#\n\nnode.js连接 mysql 出现错误： ER_NOT_SUPPORTED_AUTH_MODE: Client does not support\nauthentication protocol requested by server; consider upgrading MySQL client\n\n目前是因为版本问题\n\n\n解决办法#\n\n1、找到 MYSQL 的安装路径下的 bin 目录，这里是：C:\\Program Files\\MySQL\\MySQL Server\n8.0\\bin，然后在命令行工具进入，如下图\n\n\n\n2、登录 mysql 数据库。即继续在命令行工具输入：mysql -u root -p。然后输入自己数据库的密码，进入数据库\n\n\n\n3、接着输入\n\n\n\n上面’123456’是我的数据库密码，将其改为自己的即可。\n\n这里root'@'localhost' 对应的是 mysql数据库的user表的键和值，我这里的root的host是%，所以为root'@'%'\n\n\n\n4、最后在输入下面这个命令，然后回车。\n\n第三步第四步的截图：\n\n\n\n然后就可以连上数据库了。","routePath":"/up/linux/README","lang":"","toc":[{"text":"无界面安装","id":"无界面安装","depth":3,"charIndex":-1},{"text":"`installation`界面","id":"installation界面","depth":3,"charIndex":-1},{"text":"按 5 进行磁盘设置","id":"按-5-进行磁盘设置","depth":3,"charIndex":141},{"text":"按 8 进行秘密设置","id":"按-8-进行秘密设置","depth":3,"charIndex":179},{"text":"安装完成","id":"安装完成","depth":3,"charIndex":272},{"text":"登录","id":"登录","depth":3,"charIndex":303},{"text":"目录结构","id":"目录结构","depth":2,"charIndex":335},{"text":"/bin","id":"bin","depth":3,"charIndex":343},{"text":"/sbin","id":"sbin","depth":3,"charIndex":379},{"text":"/home","id":"home","depth":3,"charIndex":428},{"text":"/root","id":"root","depth":3,"charIndex":487},{"text":"/lib","id":"lib","depth":3,"charIndex":522},{"text":"/lost+found","id":"lostfound","depth":3,"charIndex":592},{"text":"/etc","id":"etc","depth":3,"charIndex":641},{"text":"/usr","id":"usr","depth":3,"charIndex":671},{"text":"/boot","id":"boot","depth":3,"charIndex":742},{"text":"/proc","id":"proc","depth":3,"charIndex":801},{"text":"/srv","id":"srv","depth":3,"charIndex":857},{"text":"/sys","id":"sys","depth":3,"charIndex":898},{"text":"/tmp","id":"tmp","depth":3,"charIndex":957},{"text":"/dev","id":"dev","depth":3,"charIndex":983},{"text":"/media(CentOS6)","id":"mediacentos6","depth":3,"charIndex":1025},{"text":"/mnt","id":"mnt","depth":3,"charIndex":1123},{"text":"/opt","id":"opt","depth":3,"charIndex":1195},{"text":"/var","id":"var","depth":3,"charIndex":1254},{"text":"vim 软键盘","id":"vim-软键盘","depth":2,"charIndex":1314},{"text":"三种使用模式","id":"三种使用模式","depth":2,"charIndex":1603},{"text":"**命令模式：**","id":"命令模式","depth":3,"charIndex":-1},{"text":"输入模式","id":"输入模式","depth":3,"charIndex":1984},{"text":"底线命令模式","id":"底线命令模式","depth":3,"charIndex":2247},{"text":"完整的演示","id":"完整的演示","depth":3,"charIndex":2389},{"text":"**Vim 按键说明**","id":"vim-按键说明","depth":2,"charIndex":-1},{"text":"**第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等**","id":"第一部分一般模式可用的光标移动复制粘贴搜索替换等","depth":3,"charIndex":-1},{"text":"**第二部分：一般模式切换到编辑模式的可用的按钮说明**","id":"第二部分一般模式切换到编辑模式的可用的按钮说明","depth":3,"charIndex":-1},{"text":"**第三部分：一般模式切换到指令行模式的可用的按钮说明**","id":"第三部分一般模式切换到指令行模式的可用的按钮说明","depth":3,"charIndex":-1},{"text":"查看网络 IP 和 网关","id":"查看网络-ip-和-网关","depth":2,"charIndex":6984},{"text":"查看虚拟网络编辑器","id":"查看虚拟网络编辑器","depth":3,"charIndex":7000},{"text":"修改虚拟网卡 Ip","id":"修改虚拟网卡-ip","depth":3,"charIndex":7015},{"text":"查看网关","id":"查看网关","depth":3,"charIndex":7030},{"text":"查看 windows 环境的中 VMnet8 网络配置","id":"查看-windows-环境的中-vmnet8-网络配置","depth":3,"charIndex":7040},{"text":"配置网络 ip 地址","id":"配置网络-ip-地址","depth":2,"charIndex":7073},{"text":"ifconfig 配置网络接口","id":"ifconfig-配置网络接口","depth":3,"charIndex":7087},{"text":"ping 测试主机之间网络连通性","id":"ping-测试主机之间网络连通性","depth":3,"charIndex":7221},{"text":"修改 IP 地址","id":"修改-ip-地址","depth":3,"charIndex":7318},{"text":"修改 IP 地址后可能会遇到的问题","id":"修改-ip-地址后可能会遇到的问题","depth":3,"charIndex":7458},{"text":"下面是 red hat/CentOs7 关闭防火墙的命令","id":"下面是-red-hatcentos7-关闭防火墙的命令","depth":3,"charIndex":7834},{"text":"配置主机名","id":"配置主机名","depth":2,"charIndex":8184},{"text":"修改主机名称","id":"修改主机名称","depth":3,"charIndex":8193},{"text":"修改 hosts 映射文件","id":"修改-hosts-映射文件","depth":3,"charIndex":8395},{"text":"远程登录","id":"远程登录","depth":2,"charIndex":8655},{"text":"CentOS Node","id":"centos-node","depth":2,"charIndex":8750},{"text":"**第一步 在 CentOS 找好安装位置**","id":"第一步-在-centos-找好安装位置","depth":2,"charIndex":-1},{"text":"第二步 解压压缩文件","id":"第二步-解压压缩文件","depth":2,"charIndex":8938},{"text":"第三步 部署 bin 文件并建立软连接（类似于 Windows 中配置环境变量）","id":"第三步-部署-bin-文件并建立软连接类似于-windows-中配置环境变量","depth":2,"charIndex":9074},{"text":"安装 yarn","id":"安装-yarn","depth":2,"charIndex":9210},{"text":"配置yarnopen in new window官方 yum 存储库","id":"配置yarnopen-in-new-window官方-yum-存储库","depth":3,"charIndex":9221},{"text":"安装","id":"安装","depth":3,"charIndex":9261},{"text":"验证","id":"验证","depth":3,"charIndex":9267},{"text":"Centos7 Mysql 安装","id":"centos7-mysql-安装","depth":2,"charIndex":9275},{"text":"1、下载","id":"1下载","depth":2,"charIndex":9295},{"text":"2、解压","id":"2解压","depth":2,"charIndex":9374},{"text":"3、安装","id":"3安装","depth":2,"charIndex":9407},{"text":"4、问题","id":"4问题","depth":2,"charIndex":9463},{"text":"5、启动","id":"5启动","depth":2,"charIndex":9637},{"text":"初始化 Nysql","id":"初始化-nysql","depth":3,"charIndex":9645},{"text":"添加权限","id":"添加权限","depth":3,"charIndex":9660},{"text":"启动服务","id":"启动服务","depth":3,"charIndex":9670},{"text":"查看初始密码","id":"查看初始密码","depth":3,"charIndex":9678},{"text":"登入 Mysql","id":"登入-mysql","depth":3,"charIndex":9692},{"text":"问题","id":"问题","depth":3,"charIndex":9704},{"text":"修改密码","id":"修改密码","depth":3,"charIndex":9910},{"text":"查看数据库","id":"查看数据库","depth":3,"charIndex":9920},{"text":"6、navicat 远程链接","id":"6navicat-远程链接","depth":2,"charIndex":9931},{"text":"链接失败 1130","id":"链接失败-1130","depth":3,"charIndex":9965},{"text":"a.问题分析","id":"a问题分析","depth":4,"charIndex":10055},{"text":"b.解决办法","id":"b解决办法","depth":4,"charIndex":10112},{"text":"c.解决步骤","id":"c解决步骤","depth":4,"charIndex":10264},{"text":"链接失败 2059","id":"链接失败-2059","depth":3,"charIndex":-1},{"text":"a.问题分析","id":"a问题分析-1","depth":4,"charIndex":10398},{"text":"b.问题解决","id":"b问题解决","depth":4,"charIndex":10586},{"text":"c.解决步骤","id":"c解决步骤-1","depth":4,"charIndex":10688},{"text":"7、Node 链接 Mysql8 的一些问题","id":"7node-链接-mysql8-的一些问题","depth":2,"charIndex":10700},{"text":"解决办法","id":"解决办法","depth":3,"charIndex":10889}],"domain":"","frontmatter":{"icon":"linux","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"Linux 基础操作","category":"linux","tag":"linux"},"version":""},{"id":485,"title":"Linux 常用命令","content":"#\n\n\npwd 显示当前工作目录的绝对路径#\n\npwd:print working directory 打印工作目录\n\n基本语法\n\npwd （功能描述：显示当前工作目录的绝对路径）\n\n案例实操\n\n * 显示当前工作目录的绝对路径\n\n\n\n\nls 列出目录的内容#\n\nls:list 列出目录内容\n\n基本语法\n\nls [选项] [目录或是文件]\n\n选项说明\n\n选项   功能\n-a   全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)\n-l   长数据串列出，包含文件的属性与权限等等数据(常用)等价于“ll”\n\n显示说明\n\n每行列出的信息依次是：文件类型与权限 链接数 文件属主 文件属组文件大小用 byte 来表示 建立或最近修改的时间 名字\n\n案例实操\n\n * 查看当前目录的所有内容信息\n\n\n\n\ncd 切换目录#\n\n基本语法\n\ncd [参数]\n\n参数说明\n\n参数          功能\ncd 绝对路径     切换路径\ncd 相对路径     切换路径\ncd ~或者 cd   回到自己的家目录\ncd -        回到上一次所在目录\ncd ..       回到当前目录的上一级目录\ncd -P       跳转到实际物理路径，而非快捷方式路径\n\n案例实操\n\n * 使用绝对路径切换到 root 目录\n\n\n\n * 使用相对路径切换到“公共的”目录\n\n\n\n * 表示回到自己的家目录，亦即是 /root 这个目录\n\n\n\n * cd- 回到上一次所在目录\n\n * 表示回到当前目录的上一级目录，亦即是 “/root/公共的”的上一级目录的意思\n\n\n\n\nmkdir 创建一个新的目录#\n\nmkdir:Make directory 建立目录\n\n基本语法\n\n * mkdir [选项] 要创建的目录\n\n选项说明\n\n选项   功能\n-p   创建多层目录\n\n案例实操\n\n * 创建一个目录\n\n\n\n * 创建一个多级目录\n\n\n\n\nrmdir 删除一个空的目录#\n\nrmdir:Remove directory 移除目录\n\n基本语法\n\n * rmdir 要删除的空目录\n\n案例实操\n\n * 删除一个空的文件夹\n\n\n\n\ntouch 创建空文件#\n\n基本语法\n\n * touch 文件名称\n\n案例实操\n\n\n\n\ncp 复制文件或目录#\n\n基本语法\n\n * cp [选项] source dest （功能描述：复制source文件到dest）\n\n选项说明\n\n选项   功能\n-r   递归复制整个文件夹\n\n参数说明\n\n参数       功能\nsource   源文件\ndest     目标文件\n\n经验技巧\n\n强制覆盖不提示的方法：\\cp\n\n案例实操\n\n * 复制文件\n\n\n\n * 递归复制整个文件夹\n\n\n\n\nrm 删除文件或目录#\n\n基本语法\n\n * rm [选项] deleteFile （功能描述：递归删除目录中所有内容）\n\n选项说明\n\n选项   功能\n-r   递归删除目录中所有内容\n-f   强制执行删除操作，而不提示用于进行确认\n-v   显示指令的详细执行过程\n\n案例实操\n\n * 删除目录中的内容\n\n\n\n * 递归删除目录中所有内容\n\n\n\n\nmv 移动文件与目录或重命名#\n\n基本语法\n\n * mv oldNameFile newNameFile （功能描述：重命名） - mv /temp/movefile /targetFolder\n   （功能描述：移动文件）\n\n案例实操\n\n * 重命名\n\n\n\n * 移动文件\n\n\n\n\ncat 查看文件内容#\n\n查看文件内容，从第一行开始显示。\n\n基本语法\n\n * cat [选项] 要查看的文件\n\n选项说明\n\n选项   功能描述\n-n   显示所有行的行号，包括空行。\n\n经验技巧\n\n * 一般查看比较小的文件，一屏幕能显示全的。\n\n案例实操\n\n * 查看文件内容并显示行号\n\n\n\n\nmore 文件内容分屏查看器#\n\nmore 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键，详见操作说明。\n\n基本语法\n\n * more 要查看的文件\n\n操作说明\n\n操作            功能说明\n空白键 (space)   代表向下翻一页\nEnter         代表向下翻『一行』\nq             代表立刻离开 more ，不再显示该文件内容。Ctrl+F 向下滚动一屏\nCtrl+F        向下滚动一屏\nCtrl+B        返回上一屏\n=             输出当前行的行号\n:f            输出文件名和当前行的行号\n\n案例实操\n\n * 采用 more 查看文件\n\n\n\n\nless 分屏显示文件内容#\n\nless 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less\n指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。\n\n基本语法\n\n * less 要查看的文件\n\n操作说明\n\n操作           功能说明\n空白键          向下翻动一页\n[pagedown]   向下翻动一页\n[pageup]     向上翻动一页\n/字串          向下搜寻『字串』的功能 n：向下查找 N：向上查找\n?字串          向上搜寻『字串』的功能 n：向上查找 N：向下查找\nq            离开 less 这个程序\n\n经验技巧\n\n * 用SecureCRT时[pagedown]和[pageup]可能会出现无法识别的问题\n\n案例实操\n\n * 采用 less 查看文件\n\n\n\n\necho 输出内容到控制台#\n\n基本语法\n\n * echo [选项] [输出内容]\n\n选项说明\n\n * -e： 支持反斜线控制的字符转换\n\n控制字符   作用\n\\\\     输出\\本身\n\\n     换行符\n\\t     制表符，也就是 Tab 键\n\n案例实操\n\n\n\n\nhead 显示文件头部内容#\n\nhead 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。\n\n基本语法\n\n * head 文件 （功能描述：查看文件头 10 行内容）\n * head -n 5 文件 （功能描述：查看文件头 5 行内容，5 可以是任意行数）\n\n选项说明\n\n选项       功能\n-n<行数>   指定显示头部内容的行数\n\n案例实操\n\n * 查看文件的头 2 行\n\n\n\n\ntail 输出文件尾部内容#\n\ntail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。\n\n基本语法\n\n * tail 文件 （功能描述：查看文件尾部 10 行内容）\n * tail -n 5 文件 （功能描述：查看文件尾部 5 行内容，5 可以是任意行数）\n * tail -f 文件 （功能描述：实时追踪该文档的所有更新）\n\n选项说明\n\n选项       功能\n-n<行数>   输出文件尾部 n 行内容\n-f       显示文件最新追加的内容，监视文件变化\n\n案例实操\n\n * 查看文件尾 1 行内容\n\n\n\n * 实时追踪该档的所有更新\n\n\n\n\n> 输出重定向和 >> 追加#\n\n基本语法\n\n * ls-l >文件 (功能描述:列表的内容写入文件 a.txt 中(覆盖写))\n * ls-al >>文件 (功能描述:列表的内容追加到文件 aa.txt 的末尾)\n * cat 文件 1 > 文件 2 (功能描述:将文件 1 的内容覆盖到文件 2)\n * echo “内容” >> 文件\n\n案例实操\n\n * 将 ls 查看信息写入到文件中\n\n\n\n * 将 ls 查看信息追加到文件中\n\n\n\n * 采用 echo 将 hello 单词追加到文件中\n\n\n\n\nln 软链接#\n\n软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放\n\n了链接其他文件的路径。\n\n基本语法\n\n * ln -s [原文件或目录] [软链接名] (功能描述:给原文件创建一个软链接)\n\n经验技巧\n\n * 删除软链接: rm -rf 软链接名，而不是 rm -rf 软链接名/\n\n * 如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉\n\n * 查询:通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。\n\n案例实操\n\n * 创建软连接\n\n\n\n * 删除软连接(注意不要写最后的/)\n\n\n\n * 进入软连接实际物理路径\n\n\n\n\nhistory 查看已经执行过历史命令#\n\n基本语法\n\n * history (功能描述:查看已经执行过历史命令)\n\n案例实操\n\n * 查看已经执行过的历史命令\n\n\n\n\n文件目录类（频繁）#\n\n\npwd 显示当前工作目录的绝对路径#\n\npwd:print working directory 打印工作目录\n\n基本语法\n\npwd （功能描述：显示当前工作目录的绝对路径）\n\n案例实操\n\n * 显示当前工作目录的绝对路径\n\n\n\n\nls 列出目录的内容#\n\nls:list 列出目录内容\n\n基本语法\n\nls [选项] [目录或是文件]\n\n选项说明\n\n选项   功能\n-a   全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)\n-l   长数据串列出，包含文件的属性与权限等等数据(常用)等价于“ll”\n\n显示说明\n\n每行列出的信息依次是：文件类型与权限 链接数 文件属主 文件属组文件大小用 byte 来表示 建立或最近修改的时间 名字\n\n案例实操\n\n * 查看当前目录的所有内容信息\n\n\n\n\ncd 切换目录#\n\n基本语法\n\ncd [参数]\n\n参数说明\n\n参数          功能\ncd 绝对路径     切换路径\ncd 相对路径     切换路径\ncd ~或者 cd   回到自己的家目录\ncd -        回到上一次所在目录\ncd ..       回到当前目录的上一级目录\ncd -P       跳转到实际物理路径，而非快捷方式路径\n\n案例实操\n\n * 使用绝对路径切换到 root 目录\n\n\n\n * 使用相对路径切换到“公共的”目录\n\n\n\n * 表示回到自己的家目录，亦即是 /root 这个目录\n\n\n\n * cd- 回到上一次所在目录\n\n * 表示回到当前目录的上一级目录，亦即是 “/root/公共的”的上一级目录的意思\n\n\n\n\nmkdir 创建一个新的目录#\n\nmkdir:Make directory 建立目录\n\n基本语法\n\n * mkdir [选项] 要创建的目录\n\n选项说明\n\n选项   功能\n-p   创建多层目录\n\n案例实操\n\n * 创建一个目录\n\n\n\n * 创建一个多级目录\n\n\n\n\nrmdir 删除一个空的目录#\n\nrmdir:Remove directory 移除目录\n\n基本语法\n\n * rmdir 要删除的空目录\n\n案例实操\n\n * 删除一个空的文件夹\n\n\n\n\ntouch 创建空文件#\n\n基本语法\n\n * touch 文件名称\n\n案例实操\n\n\n\n\ncp 复制文件或目录#\n\n基本语法\n\n * cp [选项] source dest （功能描述：复制source文件到dest）\n\n选项说明\n\n选项   功能\n-r   递归复制整个文件夹\n\n参数说明\n\n参数       功能\nsource   源文件\ndest     目标文件\n\n经验技巧\n\n强制覆盖不提示的方法：\\cp\n\n案例实操\n\n * 复制文件\n\n\n\n * 递归复制整个文件夹\n\n\n\n\nrm 删除文件或目录#\n\n基本语法\n\n * rm [选项] deleteFile （功能描述：递归删除目录中所有内容）\n\n选项说明\n\n选项   功能\n-r   递归删除目录中所有内容\n-f   强制执行删除操作，而不提示用于进行确认\n-v   显示指令的详细执行过程\n\n案例实操\n\n * 删除目录中的内容\n\n\n\n * 递归删除目录中所有内容\n\n\n\n\nmv 移动文件与目录或重命名#\n\n基本语法\n\n * mv oldNameFile newNameFile （功能描述：重命名） - mv /temp/movefile /targetFolder\n   （功能描述：移动文件）\n\n案例实操\n\n * 重命名\n\n\n\n * 移动文件\n\n\n\n\ncat 查看文件内容#\n\n查看文件内容，从第一行开始显示。\n\n基本语法\n\n * cat [选项] 要查看的文件\n\n选项说明\n\n选项   功能描述\n-n   显示所有行的行号，包括空行。\n\n经验技巧\n\n * 一般查看比较小的文件，一屏幕能显示全的。\n\n案例实操\n\n * 查看文件内容并显示行号\n\n\n\n\nmore 文件内容分屏查看器#\n\nmore 指令是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 指令中内置了若干快捷键，详见操作说明。\n\n基本语法\n\n * more 要查看的文件\n\n操作说明\n\n操作            功能说明\n空白键 (space)   代表向下翻一页\nEnter         代表向下翻『一行』\nq             代表立刻离开 more ，不再显示该文件内容。Ctrl+F 向下滚动一屏\nCtrl+F        向下滚动一屏\nCtrl+B        返回上一屏\n=             输出当前行的行号\n:f            输出文件名和当前行的行号\n\n案例实操\n\n * 采用 more 查看文件\n\n\n\n\nless 分屏显示文件内容#\n\nless 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less\n指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。\n\n基本语法\n\n * less 要查看的文件\n\n操作说明\n\n操作           功能说明\n空白键          向下翻动一页\n[pagedown]   向下翻动一页\n[pageup]     向上翻动一页\n/字串          向下搜寻『字串』的功能 n：向下查找 N：向上查找\n?字串          向上搜寻『字串』的功能 n：向上查找 N：向下查找\nq            离开 less 这个程序\n\n经验技巧\n\n * 用SecureCRT时[pagedown]和[pageup]可能会出现无法识别的问题\n\n案例实操\n\n * 采用 less 查看文件\n\n\n\n\necho 输出内容到控制台#\n\n基本语法\n\n * echo [选项] [输出内容]\n\n选项说明\n\n * -e： 支持反斜线控制的字符转换\n\n控制字符   作用\n\\\\     输出\\本身\n\\n     换行符\n\\t     制表符，也就是 Tab 键\n\n案例实操\n\n\n\n\nhead 显示文件头部内容#\n\nhead 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容。\n\n基本语法\n\n * head 文件 （功能描述：查看文件头 10 行内容）\n * head -n 5 文件 （功能描述：查看文件头 5 行内容，5 可以是任意行数）\n\n选项说明\n\n选项       功能\n-n<行数>   指定显示头部内容的行数\n\n案例实操\n\n * 查看文件的头 2 行\n\n\n\n\ntail 输出文件尾部内容#\n\ntail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。\n\n基本语法\n\n * tail 文件 （功能描述：查看文件尾部 10 行内容）\n * tail -n 5 文件 （功能描述：查看文件尾部 5 行内容，5 可以是任意行数）\n * tail -f 文件 （功能描述：实时追踪该文档的所有更新）\n\n选项说明\n\n选项       功能\n-n<行数>   输出文件尾部 n 行内容\n-f       显示文件最新追加的内容，监视文件变化\n\n案例实操\n\n * 查看文件尾 1 行内容\n\n\n\n * 实时追踪该档的所有更新\n\n\n\n\n> 输出重定向和 >> 追加#\n\n基本语法\n\n * ls-l >文件 (功能描述:列表的内容写入文件 a.txt 中(覆盖写))\n * ls-al >>文件 (功能描述:列表的内容追加到文件 aa.txt 的末尾)\n * cat 文件 1 > 文件 2 (功能描述:将文件 1 的内容覆盖到文件 2)\n * echo “内容” >> 文件\n\n案例实操\n\n * 将 ls 查看信息写入到文件中\n\n\n\n * 将 ls 查看信息追加到文件中\n\n\n\n * 采用 echo 将 hello 单词追加到文件中\n\n\n\n\nln 软链接#\n\n软链接也称为符号链接，类似于 windows 里的快捷方式，有自己的数据块，主要存放\n\n了链接其他文件的路径。\n\n基本语法\n\n * ln -s [原文件或目录] [软链接名] (功能描述:给原文件创建一个软链接)\n\n经验技巧\n\n * 删除软链接: rm -rf 软链接名，而不是 rm -rf 软链接名/\n\n * 如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉\n\n * 查询:通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。\n\n案例实操\n\n * 创建软连接\n\n\n\n * 删除软连接(注意不要写最后的/)\n\n\n\n * 进入软连接实际物理路径\n\n\n\n\nhistory 查看已经执行过历史命令#\n\n基本语法\n\n * history (功能描述:查看已经执行过历史命令)\n\n案例实操\n\n * 查看已经执行过的历史命令\n\n\n\n\n时间日期类#\n\n\ndate 显示当前时间#\n\n基本语法\n\n\n\n * date (功能描述:显示当前时间)\n * date +%Y (功能描述:显示当前年份)\n * date +%m (功能描述:显示当前月份)\n * date +%d (功能描述:显示当前是哪一天)\n * date \"+%Y-%m-%d %H:%M:%S\" (功能描述:显示年月日时分秒)\n\n选项说明\n\n选项          功能\n-d<时间字符串>   显示指定“时间字符串”表示时间，而非当前时间\n-s<日期时间>    设置系统日期时间\n\n参数说明\n\n参数          功能\n<+日期时间格式>   指定显示时使用的日期时间格式\n\n案例实操\n\n * 显示当前时间信息\n\n\n\n * 显示当前时间年月日\n\n\n\n * 显示当前时间年月日时分秒\n\n\n\n\ndate 显示非当前时间#\n\n基本语法\n\n * date -d '1 days ago'(功能描述:显示前一天时间)\n * date -d '-1 days ago'(功能描述:显示明天时间)\n\n案例实操\n\n * 显示前一天\n\n\n\n * 显示明天时间\n\n\n\n\ndate 设置系统时间#\n\n基本语法\n\n * date -s 字符串时间\n\n案例实操\n\n * 设置系统当前时间\n\n\n\n\ncal 查看日历#\n\n基本语法\n\n * cal [选项] (功能描述:不加选项，显示本月日历)\n\n选项说明\n\n选项      功能\n具体某一年   显示这一年\n\n案例实操\n\n * 查看当前月的日历\n\n * 查看 2017 年的日历\n\n\n\n\n用户管理命令#\n\n\nuseradd 添加新用户#\n\n基本语法\n\n * useradd 用户名 (功能描述:添加新用户)\n * useradd -g 组名 用户名 (功能描述:添加新用户到某个组)\n\n选项说明\n\n选项           功能\n-c comment   指定一段注释性描述。\n-d           目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。\n-g           用户组 指定用户所属的用户组。\n-G           用户组，用户组 指定用户所属的附加组。\n-m           自动创建这个用户的主目录 /home/qinjiang\n-s           Shell 文件 指定用户的登录 Shell。\n-u           用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。\n\n案例实操\n\n * 添加一个用户\n\n\n\n\npasswd 设置用户密码#\n\n基本语法\n\n * passwd 用户名 (功能描述:设置用户密码)\n\n案例实操\n\n * 设置用户的密码\n\n\n\n\n查看用户是否存在#\n\n基本语法\n\n * id 用户名\n\n案例实操\n\n * 看用户是否存在\n\n\n\n\ncat /etc/passwd 查看创建了哪些用户#\n\n * 案例实操\n\n\n\n\n\n\nsu 切换用户#\n\nsu: swith user 切换用户\n\n基本语法\n\n * su用户名称 (功能描述:切换用户，只能获得用户的执行权限，不能获得环境变量)\n * su - 用户名称 (功能描述:切换到用户并获得该用户的环境变量及执行权限)\n\n案例实操\n\n * 切换用户\n\n\n\nroot 超级用户\n\n\n\n普通用户\n\n\n\n\nuserdel 删除用户#\n\n基本语法\n\n * userdel 用户名 (功能描述:删除用户但保存用户主目录)\n * userdel -r 用户名 2) (功能描述:用户和用户主目录，都删除\n\n选项说明\n\n选项           功能\n-r           删除用户的同时，删除与用户相关的所有文件。\n-c comment   指定一段注释性描述。\n-d           目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。\n-g           用户组 指定用户所属的用户组。\n-G           用户组，用户组 指定用户所属的附加组。\n-m           自动创建这个用户的主目录 /home/qinjiang\n-s           Shell 文件 指定用户的登录 Shell。\n-u           用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。\n\n案例实操\n\n * 删除用户但保存用户主目录\n\n\n\n * 删除用户和用户主目录，都删除\n\n\n\n\nwho 查看登录用户信息#\n\n基本语法\n\n * whoami (功能描述:显示自身用户名称)\n * who am i (功能描述:显示登录用户的用户名以及登陆时间)\n\n案例实操\n\n * 显示自身用户名称\n\n\n\n * 显示登录用户的用户名\n\n\n\n\nsudo 设置普通用户具有 root 权限#\n\n * 添加 atguigu 用户，并对其设置密码。\n\n\n\n * 修改配置文件\n\n\n\n修改 /etc/sudoers 文件，找到下面一行(91 行)，在 root 下面添加一行，如下所示:\n\n\n\n或者配置成采用 sudo 命令时，不需要输入密码\n\n\n\n修改完毕，现在可以用 atguigu 帐号登录，然后用命令 sudo ，即可获得 root 权限进行 操作。\n\n案例实操\n\n * 用普通用户在/opt 目录下创建一个文件夹\n\n\n\n\nusermod 修改用户#\n\n基本语法\n\n * usermod -g 用户组 用户名\n\n选项说明\n\n选项   功能\n-g   修改用户的初始登录组，给定的组必须存在。默认组 id 是 1。\n\n案例实操\n\n * 将用户加入到用户组\n\n\n\n\n锁定账号#\n\nroot 冻结这个账号，一旦冻结，这个人就登录不上系统了\n\n可使用的选项：\n\n * -l 锁定口令，即禁用账号。\n * -u 口令解锁。\n * -d 使账号无口令。\n * -f 强迫用户下次登录时修改口令。\n\n\n\n此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。\n\npasswd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录\n\n\n用户组管理#\n\n每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，\n\n如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。\n\n用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 /etc/group文件的更新。\n\n\ngroupadd 新增组#\n\n基本语法\n\n * groupadd 组名\n\n选项说明\n\n选项   功能\n-m   自动创建者用户的主目录 /home/xiaohe\n-g   给用户分配组！\n\n案例实操\n\n * 添加一个xitianqujing组\n\n\n\n\ngroupdel 删除组#\n\n基本语法\n\n * groupdel 组名\n\n案例实操\n\n * 删除xitianqujing组\n\n\n\n\ngroupmod 修改组#\n\n基本语法\n\n * groupmod -n 新组名 老组名\n\n选项说明\n\n选项        功能\n-n<新组名>   指定工作组的新组名\n-g        GID 为用户组指定新的组标识号\n-o        与-g选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。\n\n案例实操\n\n * 修改atguigu组名称为atguigu1\n\n\n\n\n查看创建了哪些组#\n\ncat /etc/group\n\n基本操作\n\n\n\n\n文件权限#\n\n\n文件属性#\n\nLinux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。\n为了保护系统的安全性，Linux系统对不同的用户访问同一文件(包括目录文件)的权限做 了不同的规定。在Linux中我们可以使用ll或者 ls\n-l命令来显示一个文件的属性以及文件所属 的用户和组。\n\n从左到右的 10 个字符表示\n\n\n\n如果没有权限，就会出现减号[ - ]而已。从左至右用 0-9 这些数字来表示:\n\n * 0 首位表示类型\n   * 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等\n   * - 代表文件\n   * d 代表目录\n   * l 链接文档(link file)\n * 第 1-3 位确定属主(该文件的所有者)拥有该文件的权限。---User\n * 第 4-6 位确定属组(所有者的同组用户)拥有该文件的权限，---Group\n * 第 7-9 位确定其他用户拥有该文件的权限 ---Other\n\nrwx 作用文件和目录的不同解释\n\n * 作用到文件:\n   \n   * [ r ]代表可读(read): 可以读取，查看\n   * [ w ]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件\n   * [ x ]代表可执行(execute):可以被系统执行\n\n * 作用到目录:\n   \n   * [ r ]代表可读(read): 可以读取，ls 查看目录内容\n   * [ w ]代表可写(write): 可以修改，目录内创建+删除+重命名目录\n   * [ x ]代表可执行(execute):可以进入该目录\n\n案例实操\n\n\n\n\n\n * 如果查看到是文件:链接数指的是硬链接个数。\n * 如果查看的是文件夹:链接数指的是子文件夹个数。\n\n\nchmod 改变权限#\n\n基本语法\n\n\n\n * 第一种方式变更权限\n\n\n\n * 第二种方式变更权限\n\n\n\n经验技巧\n\n * u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)\n * r=4 w=2 x=1 rwx=4+2+1=7\n\n这里的 421 其实就是二进制的转换，每个选项上有值则为 1，‘-’则为 0。\n\n例如：rwx = 0111 = 7、 r-x = 0101 = 5 、r-x = 0101 = 5 ，所以得 755\n\n\n\n案例实操\n\n * 修改文件使其所属主用户具有执行权限\n\n\n\n * 修改文件使其所属组用户具有执行权限\n\n\n\n * 修改文件所属主用户执行权限,并使其他用户具有执行权限\n\n\n\n * 采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。\n\n\n\n * 修改整个文件夹里面的所有文件的所有者、所属组、其他用户都具有可读可写可 执行权限。\n\n\n\n\nchown 改变所有者#\n\n基本语法\n\n * chown [选项] [最终用户] [文件或目录] （功能描述:改变文件或者目录的所有者）\n\n选项说明\n\n选项   功能\n-R   递归操作\n\n案例实操\n\n * 修改文件所有者\n\n\n\n * 递归改变文件所有者和所有组\n\n\n\n\nchgrp 改变所属组#\n\n基本语法\n\n * chgrp [最终用户组] [文件或目录]（功能描述:改变文件或者目录的所属组）\n\n案例实操\n\n * 修改文件的所属组\n\n\n\n\n压缩解压缩（频繁）#\n\n\ngzip/gunzip 压缩#\n\n基本语法\n\n * gzip 文件 (功能描述:压缩文件，只能将文件压缩为*.gz 文件)\n * gunzip 文件.gz (功能描述:解压缩文件命令)\n\n经验技巧\n\n * 只能压缩文件不能压缩目录\n * 不保留原来的文件\n * 同时多个文件会产生多个压缩包\n\n案例实操\n\n * gzip压缩\n\n\n\n * gunzip 解压缩文件\n\n\n\n\nzip/unzip 压缩#\n\n基本语法\n\n * zip [选项] XXX.zip 将要压缩的内容（功能描述:压缩文件和目录的命令）\n * unzip [选项] XXX.zip （功能描述:解压缩文件）\n\n选项说明\n\nZIP 选项   功能\n-r       压缩目录\n\nUNZIP 选项   功能\n-d<目录>     指定解压后文件的存放目录\n\n经验技巧\n\n * zip 压缩命令在windows/linux都通用，可以压缩目录且保留源文件。\n\n案例实操\n\n * 压缩 houge.txt 和bailongma.txt，压缩后的名称为mypackage.zip\n\n\n\n * 解压 mypackage.zip\n\n\n\n * 解压mypackage.zip到指定目录-d\n\n\n\n\ntar 打包#\n\n基本语法\n\n * tar [选项] XXX.tar.gz 将要打包进去的内容 （功能描述:打包目录，压缩后的文件格式.tar.gz)\n\n选项说明\n\n选项   功能\n-c   产生.tar 打包文件\n-v   显示详细信息\n-f   指定压缩后的文件名 -z 打包同时压缩\n-x   解包.tar 文件\n-C   解压到指定目录\n\n案例实操\n\n * 压缩多个文件\n\n\n\n * 压缩目录\n\n\n\n * 解压到当前目录\n\n\n\n * 解压到指定目录\n\n\n\n\n磁盘查看与分区#\n\n\ndu 查看文件和目录占用的磁盘空间#\n\ndu: disk usage磁盘占用情况\n\n基本语法\n\n * du 目录/文件 （功能描述：显示目录下每个子目录的磁盘使用情况）\n\n选项说明\n\n选项              功能\n-h              以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n-a              不仅查看子目录大小，还要包括文件\n-c              显示所有的文件和子目录大小后，显示总和\n-s              只显示总和\n--max-depth=n   指定统计子目录的深度为第 n\n\n案例实操\n\n * 查看当前用户主目录占用的磁盘空间大小\n\n\n\n\ndf 查看磁盘空间使用情况#\n\ndf: disk free 空余磁盘\n\n基本语法\n\ndf 选项 （功能描述：列出文件系统的整体磁盘使用量，检查文件系统的磁盘空间占 用情况)\n\n选项说明\n\n选项   功能\n-h   以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n\n\nlsblk 查看设备挂载情况#\n\n基本语法\n\nlsblk （功能描述：查看设备挂载情况）\n\n选项说明\n\n选项   功能\n-f   查看详细的设备挂载情况，显示文件系统信息\n\n\nmount/umount 挂载/卸载#\n\n对于 Linux 用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根 目录、一个独立且唯一的文件结构。\n\nLinux 中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理\n方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来， 要载入的那个分区将使它的存储空间在这个目录下获得。\n\n挂载前准备（必须要有光盘或者已经连接镜像文件）\n\n\n\n\n\n基本语法\n\n * mount [-t vfstype] [-o options] device dir （功能描述：挂载设备）\n * umount 设备文件名或挂载点 （功能描述：卸载设备）\n\n参数说明\n\n参数          功能\n-t vfstyp   指定文件系统的类型，通常不必指定。mount 会自动选择正确的类 型。\n\n常用类型有： 光盘或光盘镜像：iso9660 DOS fat16 文件系统：msdos Windows 9x fat32 文件系统：vfat Windows\nNT ntfs 文件系统：ntfs Mount Windows 文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs | | -o\noptions | 主要用来描述设备或档案的挂接方式。 常用的参数有： loop：用来把一个文件当成硬盘分区挂接上系统 ro：采用只读方式挂接设备\nrw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 | | device | 要挂接(mount)的设备 | | dir |\n设备在系统上的挂接点(mount point) |\n\n案例实操\n\n * 挂载光盘镜像文件\n\n\n\n * 卸载光盘镜像文件\n\n\n\n设置开机自动挂载\n\n\n\n添加红框中的内容，保存退出\n\n\n\n\nfdisk 分区#\n\n基本语法\n\n * fdisk -l （功能描述：查看磁盘分区详情）\n * fdisk 硬盘设备名 （功能描述：对新增硬盘进行分区操作）\n\n选项说明\n\n选项   功能\n-l   显示所有硬盘的分区列表\n\n经验技巧\n\n * 该命令必须在 root 用户下才能使用\n\n功能说明\n\n * Linux 分区\n   \n   * Device：分区序列\n   * Boot：引导\n   * Start：从 X 磁柱开始\n   * End：到 Y 磁柱结束\n   * Blocks：容量\n   * Id：分区类型 ID\n   * System：分区类型\n\n * 分区操作按键说明\n   \n   * m：显示命令列表\n   * p：显示当前磁盘分区\n   * n：新增分区\n   * w：写入分区信息并退出\n   * q：不保存分区信息直接退出\n\n案例实操\n\n * 查看系统分区情况\n\n\n\n\n进程管理（频繁）#\n\n进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地 址空间，并占用一定的系统资源。\n\n\nps 查看当前系统进程状态#\n\nps:process status 进程\n\n基本语法\n\n * ps aux | grep xxx （功能描述：查看系统中所有进程）\n * ps -ef | grep xxx （功能描述：可以查看子父进程之间的关系）\n\n选项说明\n\n选项   功能\na    列出带有终端的所有用户的进程\nx    列出当前用户的所有进程\nu    面向用户友好的显示风格\n-e   列出所有进程\n-u   列出某个用户关联的所有进程\n-f   显示完整格式的进程列表\n\n功能说明\n\n * ps aux 显示信息说明\n   * USER：该进程是由哪个用户产生的\n   * PID：进程的 ID 号\n   * %CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；\n   * %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；\n   * VSZ：该进程占用虚拟内存的大小，单位 KB；\n   * RSS：该进程占用实际物理内存的大小，单位 KB；\n   * TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端，\n   * tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。\n   * STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示\n   * START：该进程的启动时间\n   * TIME：该进程占用 CPU 的运算时间，注意不是系统时间\n   * COMMAND：产生此进程的命令名\n * ps -ef 显示信息说明\n   * UID：用户 ID\n   * PID：进程 ID\n   * PPID：父进程 ID\n   * C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O\n     密集型运算，执行优先级会提高\n   * STIME：进程启动的时间\n   * TTY：完整的终端名称\n   * TIME：CPU 时间\n   * CMD：启动进程所用的命令和参数\n\n经验技巧\n\n * 如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux\n * 如果想查看进程的父进程 ID 可以使用 e\n\n案例实操\n\n\n\n\n\n\n\n\n\n\nkill 终止进程#\n\n基本语法\n\n * kill [选项] 进程号 （功能描述：通过进程号杀死进程）\n * killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这 在系统因负载过大而变得很慢时很有用)\n\n选项说明\n\n选项   功能\n-9   表示强迫进程立即停止\n\n案例实操\n\n * 杀死浏览器进程\n\n\n\n * 通过进程名称杀死进程\n\n\n\n\npstree 查看进程树#\n\n基本语法\n\n * pstree [选项]\n\n选项说明\n\n选项   功能\n-p   显示进程的 PID\n-u   显示进程的所属用户\n\n案例实操\n\n * 显示进程 pid\n\n\n\n * 显示进程所属用户\n\n\n\n\ntop 实时监控系统进程状态#\n\n基本命令\n\n * top [选项]\n\n选项说明\n\n选项   功能\n-d   秒数 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当中可以执行的命令：\ni    使 top 不显示任何闲置或者僵死进程。\n-p   通过指定监控进程 ID 来仅仅监控某个进程的状态。\n\n操作说明\n\n操作   功能\nP    以 CPU 使用率排序，默认就是此项\nM    以内存的使用率排序\nN    以 PID 排序\nq    退出 top\n\n查询结果字段解释\n\n * 第一行信息为任务队列信息\n\n内容                               说明\n12:26:46                         系统当前时间\nup 1 day, 13:32                  系统的运行时间，本机已经运行 1 天 13 小时 32 分钟\n2 users                          当前登录了两个用户\nload average: 0.00, 0.00, 0.00   系统在之前 1 分钟，5 分钟，15 分钟的平均负载。一般认为小于 1 时，负载较小。如果大于 1，系统已经超出负荷。\n\n * 第二行为进程信息\n\n内容                说明\nTasks: 95 total   系统中的进程总数\n1 running         正在运行的进程数\n94 sleeping       睡眠的进程\n0 stopped         正在停止的进程\n0 zombie          僵尸进程。如果不是 0，需要手工检查僵尸进\n\n * 第三行为 CPU 信息\n\n内容                      说明\nCpu(s): 0.1%us          用户模式占用的 CPU 百分比\n0.1%sy                  系统模式占用的 CPU 百分比\n0.0%ni                  改变过优先级的用户进程占用的 CPU 百分比\n99.7%id                 空闲 CPU 的 CPU 百分比\n0.1%wa                  等待输入/输出的进程的占用 CPU 百分比\n0.0%hi                  硬中断请求服务占用的 CPU 百分比\n0.1%si                  软中断请求服务占用的 CPU 百分\n0.0%st st（Steal time）   虚拟时间百分比。就是当有虚拟机时，虚拟 CPU 等待实际 CPU 的时间百分\n\n * 第四行为物理内存信息\n\n内容                   说明\nMem: 625344k total   物理内存的总量，单位 KB\n571504k used         已经使用的物理内存数量\n53840k free          空闲的物理内存数量，我们使用的是虚拟机，总共只分配了 628MB 内存，所以只有 53MB 的空闲内存了\n65800k buffers       作为缓冲的内存数量\n\n * 第五行为交换分区（swap）信息\n\n内容                    说明\nSwap: 524280k total   交换分区（虚拟内存）的总大小\n0k used               已经使用的交互分区的大小\n524280k free          空闲交换分区的大小\n409280k cached        作为缓存的交互分区的大小\n\n案例实操\n\n\n\n执行上述命令后，可以按 P、M、N 对查询出的进程结果进行排\n\n\nnetstat 显示网络状态和端口占用信息#\n\n基本语法\n\n * netstat -anp | grep 进程号 （功能描述：查看该进程网络)\n * netstat –nlp | grep 端口号 （功能描述：查看网络端口号占用情况)\n\n选项说明\n\n选项   功能\n-a   显示所有正在监听（listen）和未监听的套接字（socket）\n-n   拒绝显示别名，能显示数字的全部转化成数字\n-l   仅列出在监听的服务状态\n-p   表示显示哪个进程在调用\n\n案例实操\n\n * 通过进程号查看 sshd 进程的网络信息\n\n\n\n * 查看某端口号是否被占用\n\n\n\n\ncrontab 系统定时任务#\n\n\ncrontab 服务管理#\n\n * crontab 服务管理\n\n\n\n\ncrontab 定时任务设置#\n\n基本语法\n\n * crontab [选项\n\n选项说明\n\n选项   功能\n-e   编辑 crontab 定时任务\n-l   查询 crontab 任务\n-r   删除当前用户所有的 crontab 任务\n\n参数说明\n\n\n\n * 进入 crontab 编辑界面。会打开 vim 编辑你的工作。例如：*****执行的任务\n\n项目       含义           范围\n第一个“*”   一小时当中的第几分钟   0-59\n第二个“*”   一天当中的第几小时    0-23\n第三个“*”   一个月当中的第几天    1-31\n第四个“*”   一年当中的第几月     1-12\n第五个“*”   一周当中的星期几     0-7（ 0 和 7 都 代 表 星 期日）\n\n * 特殊符号\n\n特殊符                                        号 含义\n*                                          代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。\n，                                          代表不连续的时间。比如“0 8,12,16 * * * 命令”，\n就代表在每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令   \n-                                          代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨 5 点 0 分执行命令\n*/n                                        代表每隔多久执行一次。比如“_/10 _ * * * 命令”，代表每隔 10 分钟就执行一遍命令\n\n * 特定时间执行命令\n\n时间                含义\n45 22 * * * 命令    每天 22 点 45 分执行命令\n0 17 * * 1 命令     每周 1 的 17 点 0 分执行命令\n0 5 1,15 * * 命令   每月 1 号和 15 号的凌晨 5 点 0 分执行命令\n40 4 * * 1-5 命令   每周一到周五的凌晨 4 点 40 分执行命令\n*/10 4 * * * 命令   每天的凌晨 4 点，每隔 10 分钟执行一次命令\n0 0 1,15 * 1 命令   每月 1 号和 15 号，每周 1 的 0 点 0\n                  分都会执行命令。注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱。\n\n案例实操\n\n * 每隔 1 分钟，向/root/bailongma.txt 文件中添加一个 11 的数字\n\n\n\n\n软件包管理（频繁）#\n\n\nRPM 包管理#\n\nRPM（RedHat Package Manager），RedHat软件包管理工具，类似windows里面的setup.exe\n是Linux这系列操作系统里面的打包安装工具，它虽然是RedHat的标志，但理念是通用的。 RPM包的名称格式\nApache-1.3.23-11.i386.rpm\n\n * “apache” 软件名称\n * “1.3.23-11”软件的版本号，主版本和此版本\n * “i386”是软件所运行的硬件平台，Intel 32 位处理器的统称\n * “rpm”文件扩展名，代表 RPM 包\n\n\n查询命令（rpm -qa）#\n\n基本语法\n\n * rpm -qa （功能描述：查询所安装的所有 rpm 软件包）\n\n经验技巧\n\n * 由于软件包比较多，一般都会采取过滤。rpm -qa | grep rpm软件包\n\n案例实操\n\n * 查询firefox软件安装情况\n\n\n\n\n卸载命令（rpm -e）#\n\n基本语法\n\n * rpm -e RPM 软件\n * rpm -e --nodeps 软件\n\n选项说明\n\n选项         功能\n-e         卸载软件包\n--nodeps   卸载软件时，不检查依赖。这样的话，那些使用该软件包的软件在此之后可能就不能正常工作了。\n\n案例实操\n\n * 卸载firefox软件\n\n\n\n\n安装命令（rpm -ivh）#\n\n基本语法\n\nrpm -ivh RPM 包全名\n\n选项说明\n\n选项         功能\n-i         install，安装\n-v         --verbose，显示详细信息\n-h         --hash，进度条\n--nodeps   安装前不检查依赖\n\n案例实操\n\n * 安装firefox软件\n\n\n\n\nYUM 仓库配置#\n\nYUM（全称为 Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 CentOS 中的 Shell\n前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包 并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次\n次下载、安装。\n\n\n\n\n常用命令#\n\n基本语法\n\n * yum [选项] [参数]\n\n选项说明\n\n选项   功能\n-y   对所有提问都回答“yes\"\n\n参数说明\n\n参数             功能\ninstall        安装 rpm 软件包\nupdate         更新 rpm 软件包\ncheck-update   检查是否有可用的更新 rpm 软件包\nremove         删除指定的 rpm 软件包\nlist           显示软件包信息\nclean          清理 yum 过期的缓存\ndeplist        显示 yum 软件包的所有依赖关系\n\n案例实操\n\n * 采用 yum 方式安装 firefox\n\n\n\n\n修改网络 YUM 源#\n\n默认的系统 YUM 源，需要连接国外 apache 网站，网速比较慢，可以修改关联的网络 YUM 源为国内镜像的网站，比如网易 163,aliyun 等\n\n * 安装 wget, wget 用来从指定的 URL 下载文件\n\n\n\n * 在/etc/yum.repos.d/目录下，备份默认的 repos 文件\n\n\n\n * 下载网易 163 或者是 aliyun 的 repos 文件,任选其一\n\n\n\n\n\n * 使用下载好的 repos 文件替换默认的 repos 文件。例如:用 CentOS7-Base-163.repo 替换 CentOS-Base.rep\n\n\n\n * 清理旧缓存数据，缓存新数据\n\n\n\n * 测试\n\n","routePath":"/up/linux/command","lang":"","toc":[{"text":"pwd 显示当前工作目录的绝对路径","id":"pwd-显示当前工作目录的绝对路径","depth":2,"charIndex":3},{"text":"ls 列出目录的内容","id":"ls-列出目录的内容","depth":2,"charIndex":118},{"text":"cd 切换目录","id":"cd-切换目录","depth":2,"charIndex":358},{"text":"mkdir 创建一个新的目录","id":"mkdir-创建一个新的目录","depth":2,"charIndex":688},{"text":"rmdir 删除一个空的目录","id":"rmdir-删除一个空的目录","depth":2,"charIndex":822},{"text":"touch 创建空文件","id":"touch-创建空文件","depth":2,"charIndex":915},{"text":"cp 复制文件或目录","id":"cp-复制文件或目录","depth":2,"charIndex":959},{"text":"rm 删除文件或目录","id":"rm-删除文件或目录","depth":2,"charIndex":1157},{"text":"mv 移动文件与目录或重命名","id":"mv-移动文件与目录或重命名","depth":2,"charIndex":1332},{"text":"cat 查看文件内容","id":"cat-查看文件内容","depth":2,"charIndex":1474},{"text":"more 文件内容分屏查看器","id":"more-文件内容分屏查看器","depth":2,"charIndex":1624},{"text":"less 分屏显示文件内容","id":"less-分屏显示文件内容","depth":2,"charIndex":1975},{"text":"echo 输出内容到控制台","id":"echo-输出内容到控制台","depth":2,"charIndex":2405},{"text":"head 显示文件头部内容","id":"head-显示文件头部内容","depth":2,"charIndex":2540},{"text":"tail 输出文件尾部内容","id":"tail-输出文件尾部内容","depth":2,"charIndex":2751},{"text":"**>** 输出重定向和 **>>** 追加","id":"-输出重定向和--追加","depth":2,"charIndex":-1},{"text":"**ln** 软链接","id":"ln-软链接","depth":2,"charIndex":-1},{"text":"**history** 查看已经执行过历史命令","id":"history-查看已经执行过历史命令","depth":2,"charIndex":-1},{"text":"文件目录类（频繁）","id":"文件目录类频繁","depth":2,"charIndex":3691},{"text":"pwd 显示当前工作目录的绝对路径","id":"pwd-显示当前工作目录的绝对路径-1","depth":2,"charIndex":3704},{"text":"ls 列出目录的内容","id":"ls-列出目录的内容-1","depth":2,"charIndex":3819},{"text":"cd 切换目录","id":"cd-切换目录-1","depth":2,"charIndex":4059},{"text":"mkdir 创建一个新的目录","id":"mkdir-创建一个新的目录-1","depth":2,"charIndex":4389},{"text":"rmdir 删除一个空的目录","id":"rmdir-删除一个空的目录-1","depth":2,"charIndex":4523},{"text":"touch 创建空文件","id":"touch-创建空文件-1","depth":2,"charIndex":4616},{"text":"cp 复制文件或目录","id":"cp-复制文件或目录-1","depth":2,"charIndex":4660},{"text":"rm 删除文件或目录","id":"rm-删除文件或目录-1","depth":2,"charIndex":4858},{"text":"mv 移动文件与目录或重命名","id":"mv-移动文件与目录或重命名-1","depth":2,"charIndex":5033},{"text":"cat 查看文件内容","id":"cat-查看文件内容-1","depth":2,"charIndex":5175},{"text":"more 文件内容分屏查看器","id":"more-文件内容分屏查看器-1","depth":2,"charIndex":5325},{"text":"less 分屏显示文件内容","id":"less-分屏显示文件内容-1","depth":2,"charIndex":5676},{"text":"echo 输出内容到控制台","id":"echo-输出内容到控制台-1","depth":2,"charIndex":6106},{"text":"head 显示文件头部内容","id":"head-显示文件头部内容-1","depth":2,"charIndex":6241},{"text":"tail 输出文件尾部内容","id":"tail-输出文件尾部内容-1","depth":2,"charIndex":6452},{"text":"**>** 输出重定向和 **>>** 追加","id":"-输出重定向和--追加-1","depth":2,"charIndex":-1},{"text":"**ln** 软链接","id":"ln-软链接-1","depth":2,"charIndex":-1},{"text":"**history** 查看已经执行过历史命令","id":"history-查看已经执行过历史命令-1","depth":2,"charIndex":-1},{"text":"时间日期类","id":"时间日期类","depth":2,"charIndex":7392},{"text":"**date** 显示当前时间","id":"date-显示当前时间","depth":2,"charIndex":-1},{"text":"**date** 显示非当前时间","id":"date-显示非当前时间","depth":2,"charIndex":-1},{"text":"**date** 设置系统时间","id":"date-设置系统时间","depth":2,"charIndex":-1},{"text":"**cal** 查看日历","id":"cal-查看日历","depth":2,"charIndex":-1},{"text":"用户管理命令","id":"用户管理命令","depth":2,"charIndex":8065},{"text":"useradd 添加新用户","id":"useradd-添加新用户","depth":2,"charIndex":8075},{"text":"**passwd** 设置用户密码","id":"passwd-设置用户密码","depth":2,"charIndex":-1},{"text":"查看用户是否存在","id":"查看用户是否存在","depth":2,"charIndex":8550},{"text":"cat /etc/passwd 查看创建了哪些用户","id":"cat-etcpasswd-查看创建了哪些用户","depth":2,"charIndex":8599},{"text":"su 切换用户","id":"su-切换用户","depth":2,"charIndex":8641},{"text":"**userdel** 删除用户","id":"userdel-删除用户","depth":2,"charIndex":-1},{"text":"**who** 查看登录用户信息","id":"who-查看登录用户信息","depth":2,"charIndex":-1},{"text":"**sudo** 设置普通用户具有 **root** 权限","id":"sudo-设置普通用户具有-root-权限","depth":2,"charIndex":-1},{"text":"**usermod** 修改用户","id":"usermod-修改用户","depth":2,"charIndex":-1},{"text":"锁定账号","id":"锁定账号","depth":2,"charIndex":9758},{"text":"用户组管理","id":"用户组管理","depth":2,"charIndex":9972},{"text":"**groupadd** 新增组","id":"groupadd-新增组","depth":2,"charIndex":-1},{"text":"groupdel 删除组","id":"groupdel-删除组","depth":2,"charIndex":10262},{"text":"groupmod 修改组","id":"groupmod-修改组","depth":2,"charIndex":10328},{"text":"查看创建了哪些组","id":"查看创建了哪些组","depth":2,"charIndex":10525},{"text":"文件权限","id":"文件权限","depth":2,"charIndex":10561},{"text":"文件属性","id":"文件属性","depth":2,"charIndex":10569},{"text":"**chmod** 改变权限","id":"chmod-改变权限","depth":2,"charIndex":-1},{"text":"**chown** 改变所有者","id":"chown-改变所有者","depth":2,"charIndex":-1},{"text":"chgrp 改变所属组","id":"chgrp-改变所属组","depth":2,"charIndex":11896},{"text":"压缩解压缩（频繁）","id":"压缩解压缩频繁","depth":2,"charIndex":11983},{"text":"**gzip/gunzip** 压缩","id":"gzipgunzip-压缩","depth":2,"charIndex":-1},{"text":"**zip/unzip** 压缩","id":"zipunzip-压缩","depth":2,"charIndex":-1},{"text":"**tar** 打包","id":"tar-打包","depth":2,"charIndex":-1},{"text":"磁盘查看与分区","id":"磁盘查看与分区","depth":2,"charIndex":12753},{"text":"du 查看文件和目录占用的磁盘空间","id":"du-查看文件和目录占用的磁盘空间","depth":2,"charIndex":12764},{"text":"df 查看磁盘空间使用情况","id":"df-查看磁盘空间使用情况","depth":2,"charIndex":13087},{"text":"lsblk 查看设备挂载情况","id":"lsblk-查看设备挂载情况","depth":2,"charIndex":13237},{"text":"mount/umount 挂载/卸载","id":"mountumount-挂载卸载","depth":2,"charIndex":13325},{"text":"fdisk 分区","id":"fdisk-分区","depth":2,"charIndex":14110},{"text":"进程管理（频繁）","id":"进程管理频繁","depth":2,"charIndex":14508},{"text":"ps 查看当前系统进程状态","id":"ps-查看当前系统进程状态","depth":2,"charIndex":14575},{"text":"kill 终止进程","id":"kill-终止进程","depth":2,"charIndex":15573},{"text":"pstree 查看进程树","id":"pstree-查看进程树","depth":2,"charIndex":15756},{"text":"top 实时监控系统进程状态","id":"top-实时监控系统进程状态","depth":2,"charIndex":15875},{"text":"netstat 显示网络状态和端口占用信息","id":"netstat-显示网络状态和端口占用信息","depth":2,"charIndex":17447},{"text":"crontab 系统定时任务","id":"crontab-系统定时任务","depth":2,"charIndex":17731},{"text":"crontab 服务管理","id":"crontab-服务管理","depth":2,"charIndex":17749},{"text":"crontab 定时任务设置","id":"crontab-定时任务设置","depth":2,"charIndex":17784},{"text":"软件包管理（频繁）","id":"软件包管理频繁","depth":2,"charIndex":18990},{"text":"RPM 包管理","id":"rpm-包管理","depth":2,"charIndex":19003},{"text":"查询命令（rpm -qa）","id":"查询命令rpm--qa","depth":3,"charIndex":19269},{"text":"卸载命令（rpm -e）","id":"卸载命令rpm--e","depth":3,"charIndex":19406},{"text":"安装命令（rpm -ivh）","id":"安装命令rpm--ivh","depth":3,"charIndex":19585},{"text":"YUM 仓库配置","id":"yum-仓库配置","depth":2,"charIndex":19764},{"text":"常用命令","id":"常用命令","depth":3,"charIndex":19944},{"text":"修改网络 YUM 源","id":"修改网络-yum-源","depth":3,"charIndex":20266}],"domain":"","frontmatter":{"icon":"linux","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"Linux 常用命令","category":"linux","tag":"linux"},"version":""},{"id":486,"title":"Linux 基础操作","content":"无界面安装#\n\nWARNING\n\n这里不展示虚拟机安装镜像的过程\n\nB 站视频 open in new window\n\n\ninstallation界面#\n\n镜像安装完成后会出现这个界面\n\n\n\n按 r 刷新之后会有三个感叹号\n\n\n\n分别是：5 磁盘设置、8 密码设置、9 创建用户\n\n\n按 5 进行磁盘设置#\n\n之后依次按 c、c、c，之后的界面是这样\n\n\n\n\n按 8 进行秘密设置#\n\n\n\n这里会进行两次密码输入，\n\n 1. 第一次设置\n 2. 第二次确认输入\n 3. 最后输入 yes\n 4. 回到installation界面按 b 保存\n\n\n安装完成#\n\n\n\n在此界面按回车键（Enter）完成安装\n\n\n登录#\n\n\n\n输入用户名：root\n\n输入密码：xxxxx\n\n\n目录结构#\n\n\n/bin#\n\n是Binary的缩写，这个目录存放着最经常常用的命令\n\n\n/sbin#\n\ns 就是Super User的意思，这里存放的是系统管理员使用的系统管理程序\n\n\n/home#\n\n存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录是以用户买的账号命名的\n\n\n/root#\n\n该目录系统管理员，也城作为超级权限者的用户主目录\n\n\n/lib#\n\n系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的 DLL 文件。几乎所有的应用程序都需要用这些共享库\n\n\n/lost+found#\n\n这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n\n\n/etc#\n\n所有的系统管理所需要的配置文件和子目录。\n\n\n/usr#\n\n这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。\n\n\n/boot#\n\n这里存放的是启动Liux时使用的一些核心文件，包括一些连接文件以及镜像文件，自己的安装别放这里。\n\n\n/proc#\n\n这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。\n\n\n/srv#\n\nservice缩写，该目录存放一些服务启动之后需要提取的数据。\n\n\n/sys#\n\n这是iux2.6内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统sysfs\n\n\n/tmp#\n\n这个目录是用来存放一些临时文件的\n\n\n/dev#\n\n类似于windows的设备管理器，把所有的硬件用文件的形式存储。\n\n\n/media(CentOS6)#\n\nlinux系统会自动识别一些设备，例如 U 盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。\n\nCentOS7迁移到/run/media\n\n\n/mnt#\n\n系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了\n\n\n/opt#\n\n这是给主机额外安装软件所摆放的目录。比如你安装一个ysq数据库则就可以放到这个目录下。默认是空的。\n\n\n/var#\n\n这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n\nvim 软键盘#\n\nvim 用过一些插件可以实现和 IDE 一样的功能\n\nVim 是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\nLinux 中，必须会使用 Vim（查看内容，编辑内容，保存内容）\n\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。\n\nvim 则可以说是程序开发者的一项很好用的工具。\n\n可以理解 vim 是 vi 的升级版\n\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件\n\n\n\n\n三种使用模式#\n\n基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line\nmode）。这三种模式的作用分别是：\n\n\n命令模式：#\n\n用户刚刚启动 vi/vim，便进入了命令模式。\n\n\n\n\n\n此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符。比如我们此时按下 i，并不会输入一个字符，i 被当作了一个命令。\n\n以下是常用的几个命令：\n\n * i 切换到输入模式，以输入字符。\n * x 删除当前光标所在处的字符。\n * : 切换到底线命令模式，以在最底一行输入命令。如果是便捷模式，需要退出便捷模式ESC\n\n若想要编辑文本： 启动Vim，进入了命令模式，按下 i，切换到输入模式。\n\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n\n\n输入模式#\n\n在命令模式下按下 i 就进入了输入模式。\n\n\n\n在输入模式中，可以使用以下按键：\n\n * 字符按键以及 Shift 组合，输入字符\n * ENTER，回车键，换行\n * BACK SPACE，退格键，删除光标前一个字符\n * DEL，删除键，删除光标后一个字符\n * 方向键，在文本中移动光标\n * HOME/END，移动光标到行首/行尾\n * Page Up/Page Down，上/下翻页\n * Insert，切换光标为输入/替换模式，光标将变成竖线/下划线\n * ESC，退出输入模式，切换到命令模式\n\n\n底线命令模式#\n\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n\n\n\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\n\nw 保存文件\n\n\n\n按 ESC 键可随时退出底线命令模式。\n\n\n\n\n\n\n完整的演示#\n\n> 说明新建或者编辑文件，按 i 进入编辑模式，编写内容，编写完成后退出编辑模式，esc，退出之后进入底线命令模式：wq 保存退出！\n\n\nVim 按键说明#\n\n\n第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等#\n\n移动光标的方法                        \nh 或 向左箭头键(←)                   光标向左移动一个字符\nj 或 向下箭头键(↓)                   光标向下移动一个字符\nk 或 向上箭头键(↑)                   光标向上移动一个字符\nl 或 向右箭头键(→)                   光标向右移动一个字符\n[Ctrl] + [f]                   屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n[Ctrl] + [b]                   屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n[Ctrl] + [d]                   屏幕『向下』移动半页\n[Ctrl] + [u]                   屏幕『向上』移动半页\n+                              光标移动到非空格符的下一行\n-                              光标移动到非空格符的上一行\nn                              **那个 n 表示『数字』，例如 20 。按下数字后再按空格键，\n光标会向右移动这一行的 n 个字符。 数字 加 空格**   \n0 或功能键[Home]                   这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键[End]                    移动到这一行的最后面字符处(常用)\nH                              光标移动到这个屏幕的最上方那一行的第一个字符\nM                              光标移动到这个屏幕的中央那一行的第一个字符\nL                              光标移动到这个屏幕的最下方那一行的第一个字符\nG                              移动到这个档案的最后一行(常用)\nnG                             n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                             移动到这个档案的第一行，相当于 1G 啊！(常用)\nn                              n 为数字。光标向下移动 n 行(常用)\n\n搜索替换                                       \n/word                                      向光标之下寻找一个名称为 word 的字符串。\n例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)   \n?word                                      向光标之上寻找一个字符串名称为 word 的字符串。\nn                                          这个 n 是英文按键。代表重复前一个搜寻的动作。\n\n举例来说：如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后， 会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行\n?vbird 的 | | N | 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻\nvbird 。 |\n\n删除、 复制与粘贴                                  \nx, X                                       在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)，\nX 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)   \nnx                                         n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\ndd                                         删除游标所在的那一整行(常用)\ndw                                         删除游标所在的一个词\nndd                                        n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)\nd1G                                        删除光标所在到第一行的所有数据\ndG                                         删除光标所在到最后一行的所有数据\nd$                                         删除游标所在处，到该行的最后一个字符\nd0                                         那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\nyy                                         复制游标所在的那一行(常用)\nyw                                         复制游标所在的一个词\nnyy                                        n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\ny1G                                        复制游标所在行到第一行的所有数据\nyG                                         复制游标所在行到最后一行的所有数据\ny0                                         复制光标所在的那个字符到该行行首的所有数据\ny$                                         复制光标所在的那个字符到该行行尾的所有数据\np, P                                       p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！\n\n举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。\n但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用) | | J | 将光标所在行与下一行的数据结合成同一行 | | c |\n重复删除多个数据，例如向下删除 10 行，[ 10cj ] | | u | 复原前一个动作。(常用) | | [Ctrl]+r | 重做上一个动作。(常用) |\n| crystalift+6（^） | 移动到行头 | | `crystalift+4 （ | $）` 移动到行尾 | | n+shift+g | n\n为数字。移动到页头 | | crystalift+g | 移动到页尾 | | n+shift+g | n 为数字。移动到目标行 |\n\n\n第二部分：一般模式切换到编辑模式的可用的按钮说明#\n\n进入输入或取代的编辑模式   \ni, I           进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I\n               为『在目前所在行的第一个非空格符处开始输入』。(常用)\na, A           进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A\n               为『从光标所在行的最后一个字符处开始输入』。(常用)\no, O           进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O\n               为在目前光标所在处的上一行输入新的一行！(常用)\nr, R           进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R 会一直取代光标所在的文字，直到按下\n               ESC 为止；(常用)\n[Esc]          退出编辑模式，回到一般模式中(常用)\n\n\n第三部分：一般模式切换到指令行模式的可用的按钮说明#\n\n指令行的储存、离开等指令          \n:w                    将编辑的数据写入硬盘档案中(常用)\n:w!                   若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n:q                    离开 vi (常用)\n:q!                   若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n:wq                   储存后离开，若为 :wq! 则为强制储存后离开 (常用)\nZZ                    这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！\n:w [filename]         将编辑的数据储存成另一个档案（类似另存新档）\n:r [filename]         在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n:n1,n2 w [filename]   将 n1 到 n2 的内容储存成 filename 这个档案。\n:! command            暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看\n                      /home 底下以 ls 输出的档案信息！\n:set nu 设置行号，代码中      显示行号，设定之后，会在每一行的前缀显示该行的行号\n:set nonu             与 set nu 相反，为取消行号！\n\n> 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n查看网络 IP 和 网关#\n\n\n查看虚拟网络编辑器#\n\n\n\n\n修改虚拟网卡 Ip#\n\n\n\n\n查看网关#\n\n\n\n\n查看 windows 环境的中 VMnet8 网络配置#\n\n\n\n\n配置网络 ip 地址#\n\n\nifconfig 配置网络接口#\n\nifconfig :network interfaces configuring 网络接口配置\n\n1、基本语法\n\n * ifconfig （功能描述：显示所有网络接口的配置信息）\n\n2、案例实操\n\n * 查看当前网络 ip\n\n\n\n\nping 测试主机之间网络连通性#\n\n1、基本语法\n\n * ping 目的主机 （功能描述：测试当前服务器是否可以连接目的主机）\n\n2、案例实操\n\n * 测试当前服务器是否可以连接百度\n\n\n\n\n修改 IP 地址#\n\n1、查看 IP 配置文件\n\n\n\n\n\n以下标红的项必须修改，有值的按照下面的值修改，没有该项的要增加。\n\n\n\n修改后\n\n\n\n编辑完后，按键盘 esc ，然后输入 :wq 回车即可。\n\n2、执行 service network restart 重启网络\n\n\n\n\n修改 IP 地址后可能会遇到的问题#\n\n 1. 物理机能 ping 通虚拟机，但是虚拟机 ping 不通物理机,一般都是因为物理机的防火墙问题,把防火墙关闭就行\n 2. 虚拟机能 Ping 通物理机,但是虚拟机 Ping 不通外网,一般都是因为DNS 的设置有问题\n 3. 虚拟机 Ping www.baidu.com 显示域名未知等信息,一般查看GATEWAY 和DNS 设置是否正确\n 4. 如果以上全部设置完还是不行，需要关闭 NetworkManager 服务\n    1. systemctl stop NetworkManager 关闭\n    2. systemctl disable NetworkManager 禁用\n 5. 如果检查发现 systemctl status network 有问题 需要检查ifcfg-ens33\n\n\n下面是 red hat/CentOs7 关闭防火墙的命令#\n\n1:查看防火状态\n\n * systemctl status firewalld\n * service iptables status\n\n2:暂时关闭防火墙\n\n * systemctl stop firewalld\n * service iptables stop\n\n3:永久关闭防火墙\n\n * systemctl disable firewalld\n * chkconfig iptables off\n\n4:重启防火墙\n\n * systemctl enable firewalld\n * service iptables restart\n\n5:永久关闭后重启\n\n//暂时还没有试过\n\n * chkconfig iptables on\n\n\n配置主机名#\n\n\n修改主机名称#\n\n1、基本语法\n\nhostname （功能描述：查看当前服务器的主机名称）\n\nHostnamectl（查看详细信息）使用hostnamectl set-hostname [自定义名称] 可强制更改不需要重启\n\n2、案例实操\n\n 1. 查看当前服务器主机名称\n\n\n\n 2. 如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/hostname 文件\n\n\n\n修改完成后重启生效。\n\n\n修改 hosts 映射文件#\n\n修改 linux 的主机映射文件（hosts 文件） 后续在 hadoop 阶段，虚拟机会比较多，配置时通常会采用主机名的方式配置，比较简单方便。 不用刻意记\nip 地址。\n\n 1. 打开/etc/hosts\n\n\n\n添加如下内容\n\n\n\n 2. 重启设备，重启后，查看主机名，已经修改成功\n\n修改 windows 的主机映射文件（hosts 文件）\n\n 1. 进入 C:\\Windows\\System32\\drivers\\etc 路径\n 2. 打开 hosts 文件并添加如下内容\n\n\n\n\n远程登录#\n\nWindows: Xshell, SSH Secure crystalell, SecureCRT,FinalShell\n\nMacOS :iTerm2，Royal TSX\n\n\nCentOS Node#\n\n官网 open in new window\n\n\n第一步 在 CentOS 找好安装位置#\n\nx86 架构\n\n\n\n让你一步到位的命令\n\n\n\nurl 拆解\n\nhttps://npm.taobao.org/mirrors/node/v16.17.0 node 版本号\n\nnode-v16.17.0-linux-x64.tar.gz 对应架构的文件名\n\n\n第二步 解压压缩文件#\n\n执行一下命令\n\n\n\n进入到 node-v16.17.0-linux-x64.tar.gz，执行一下命令安装 Node.js 的依赖组件\n\n\n\n重命名 node-v12.16.1-linux-x64.tar.gz 文件夹为 Node.js\n\n\n\n\n第三步 部署 bin 文件并建立软连接（类似于 Windows 中配置环境变量）#\n\n进入到/usr/local/temp/Node.js/bin 你会看到\n\n\n\nln 指令用于创建关联\n\n依次执行以下命令\n\n\n\n最后在终端输入 node -v\n\n\n\n出现这个就完成\n\n\n安装 yarn#\n\n\n配置yarnopen in new window官方 yum 存储库#\n\n\n\n\n安装#\n\n\n验证#\n\n\n\n\nCentos7 Mysql 安装#\n\n\n1、下载#\n\nhttps://downloads.mysql.com/archives/community/\n\n\n\n上传到 Linux\n\n或一键下载\n\n\n\n\n2、解压#\n\n将文件移动到一个目录中\n\n\n\n解包文件\n\n\n\n\n\n\n3、安装#\n\n--nodeps --force 为强制安装\n\n\n\n\n\n\n\n\n\n\n\n\n\n必须安装以上顺序安装\n\n\n4、问题#\n\n安装完成后不出意外的话输入初始化命令就成功了\n\n\n\n如果出现以下报错\n\n\n\n那可能是缺少 openssl10\n\n在 Linux 中安装 openssl10，进行OpenSSLopen in new window升级（用 yum 升不上去，用 rpm 包简单有效）\n\n阿里云下载链接\n\n\n\n下载后进行安装\n\n\n\n最终安装过程图\n\n\n\n\n5、启动#\n\n\n初始化 Nysql#\n\n\n\n\n添加权限#\n\n\n\n\n启动服务#\n\n\n查看初始密码#\n\n\n\n\n\n\n登入 Mysql#\n\n\n问题#\n\n这里我在登录的时候是遇到了两个问题\n\n报错 1\n\n\n\n没有libncurses.so.5，可能有libncurses.so不同版本的文件，使用命令全局查找\n\n\n\n\n\n之后将/usr/lib64下找到的libncurses.so 版本和libncurses.so.5进行链接\n\n\n\n报错 2\n\n\n\n与上同理，全局查找libtinfo将文件与 libtinfo.so.5 进行链接\n\n最终登录效果\n\n\n\n\n修改密码#\n\n\n\n\n查看数据库#\n\n\n\n\n6、navicat 远程链接#\n\n点击新建链接使用 SSH\n\n\n\n\n链接失败 1130#\n\n1130 - Host ‘xxx.xxx.xxx.xxx’ is not allowed to connect to this MySQL server\n\na.问题分析#\n\n某某 ip 不被允许连接这个 MySQL 服务，排除服务器防火墙没开放 3306 端口的情况\n\nb.解决办法#\n\n连接远端服务器，登录进去到 MySQL，查看名为 mysql 的数据库中的一个名字叫 user 的表，一般来讲如果出现 1130 代码问题，大概率是 MySQL\n登录用户的 host 权限是 localhost 或其他，把登录用户对应的 host 改成%即可，%意为任意 ip 地址\n\nc.解决步骤#\n\n\n\n2.接着说可能会出现的其他问题：失败 2059\n\n\n链接失败 2059#\n\n2059 - Authentication plugin ‘caching_sha2_password’ cannot be loaded:\nxxxxxxxxxx\n\n\n\na.问题分析#\n\n这个问题存在于 MySQL8.0 及以后的版本，MySQL8.0 对密码的加密方式进行了修改，由原来的 mysql_native_password 方式，改成了\ncaching_sha2_password 方式，导致了支持 mysql_native_password 方式的Navicatopen in new\nwindow无法成功连接 MySQL8.0\n\nb.问题解决#\n\n修改 MySQL 数据库的密码加密方式，并使用加密方式修改覆盖原来的密码，保证相同密码加密后的一致，密码改成 Navicat 支持的\nmysql_native_password 方式\n\nc.解决步骤#\n\n\n\n\n7、Node 链接 Mysql8 的一些问题#\n\nnode.js连接 mysql 出现错误： ER_NOT_SUPPORTED_AUTH_MODE: Client does not support\nauthentication protocol requested by server; consider upgrading MySQL client\n\n目前是因为版本问题\n\n\n解决办法#\n\n1、找到 MYSQL 的安装路径下的 bin 目录，这里是：C:\\Program Files\\MySQL\\MySQL Server\n8.0\\bin，然后在命令行工具进入，如下图\n\n\n\n2、登录 mysql 数据库。即继续在命令行工具输入：mysql -u root -p。然后输入自己数据库的密码，进入数据库\n\n\n\n3、接着输入\n\n\n\n上面’123456’是我的数据库密码，将其改为自己的即可。\n\n这里root'@'localhost' 对应的是 mysql数据库的user表的键和值，我这里的root的host是%，所以为root'@'%'\n\n\n\n4、最后在输入下面这个命令，然后回车。\n\n第三步第四步的截图：\n\n\n\n然后就可以连上数据库了。","routePath":"/up/linux/","lang":"","toc":[{"text":"无界面安装","id":"无界面安装","depth":3,"charIndex":-1},{"text":"`installation`界面","id":"installation界面","depth":3,"charIndex":-1},{"text":"按 5 进行磁盘设置","id":"按-5-进行磁盘设置","depth":3,"charIndex":141},{"text":"按 8 进行秘密设置","id":"按-8-进行秘密设置","depth":3,"charIndex":179},{"text":"安装完成","id":"安装完成","depth":3,"charIndex":272},{"text":"登录","id":"登录","depth":3,"charIndex":303},{"text":"目录结构","id":"目录结构","depth":2,"charIndex":335},{"text":"/bin","id":"bin","depth":3,"charIndex":343},{"text":"/sbin","id":"sbin","depth":3,"charIndex":379},{"text":"/home","id":"home","depth":3,"charIndex":428},{"text":"/root","id":"root","depth":3,"charIndex":487},{"text":"/lib","id":"lib","depth":3,"charIndex":522},{"text":"/lost+found","id":"lostfound","depth":3,"charIndex":592},{"text":"/etc","id":"etc","depth":3,"charIndex":641},{"text":"/usr","id":"usr","depth":3,"charIndex":671},{"text":"/boot","id":"boot","depth":3,"charIndex":742},{"text":"/proc","id":"proc","depth":3,"charIndex":801},{"text":"/srv","id":"srv","depth":3,"charIndex":857},{"text":"/sys","id":"sys","depth":3,"charIndex":898},{"text":"/tmp","id":"tmp","depth":3,"charIndex":957},{"text":"/dev","id":"dev","depth":3,"charIndex":983},{"text":"/media(CentOS6)","id":"mediacentos6","depth":3,"charIndex":1025},{"text":"/mnt","id":"mnt","depth":3,"charIndex":1123},{"text":"/opt","id":"opt","depth":3,"charIndex":1195},{"text":"/var","id":"var","depth":3,"charIndex":1254},{"text":"vim 软键盘","id":"vim-软键盘","depth":2,"charIndex":1314},{"text":"三种使用模式","id":"三种使用模式","depth":2,"charIndex":1603},{"text":"**命令模式：**","id":"命令模式","depth":3,"charIndex":-1},{"text":"输入模式","id":"输入模式","depth":3,"charIndex":1984},{"text":"底线命令模式","id":"底线命令模式","depth":3,"charIndex":2247},{"text":"完整的演示","id":"完整的演示","depth":3,"charIndex":2389},{"text":"**Vim 按键说明**","id":"vim-按键说明","depth":2,"charIndex":-1},{"text":"**第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等**","id":"第一部分一般模式可用的光标移动复制粘贴搜索替换等","depth":3,"charIndex":-1},{"text":"**第二部分：一般模式切换到编辑模式的可用的按钮说明**","id":"第二部分一般模式切换到编辑模式的可用的按钮说明","depth":3,"charIndex":-1},{"text":"**第三部分：一般模式切换到指令行模式的可用的按钮说明**","id":"第三部分一般模式切换到指令行模式的可用的按钮说明","depth":3,"charIndex":-1},{"text":"查看网络 IP 和 网关","id":"查看网络-ip-和-网关","depth":2,"charIndex":6984},{"text":"查看虚拟网络编辑器","id":"查看虚拟网络编辑器","depth":3,"charIndex":7000},{"text":"修改虚拟网卡 Ip","id":"修改虚拟网卡-ip","depth":3,"charIndex":7015},{"text":"查看网关","id":"查看网关","depth":3,"charIndex":7030},{"text":"查看 windows 环境的中 VMnet8 网络配置","id":"查看-windows-环境的中-vmnet8-网络配置","depth":3,"charIndex":7040},{"text":"配置网络 ip 地址","id":"配置网络-ip-地址","depth":2,"charIndex":7073},{"text":"ifconfig 配置网络接口","id":"ifconfig-配置网络接口","depth":3,"charIndex":7087},{"text":"ping 测试主机之间网络连通性","id":"ping-测试主机之间网络连通性","depth":3,"charIndex":7221},{"text":"修改 IP 地址","id":"修改-ip-地址","depth":3,"charIndex":7318},{"text":"修改 IP 地址后可能会遇到的问题","id":"修改-ip-地址后可能会遇到的问题","depth":3,"charIndex":7458},{"text":"下面是 red hat/CentOs7 关闭防火墙的命令","id":"下面是-red-hatcentos7-关闭防火墙的命令","depth":3,"charIndex":7834},{"text":"配置主机名","id":"配置主机名","depth":2,"charIndex":8184},{"text":"修改主机名称","id":"修改主机名称","depth":3,"charIndex":8193},{"text":"修改 hosts 映射文件","id":"修改-hosts-映射文件","depth":3,"charIndex":8395},{"text":"远程登录","id":"远程登录","depth":2,"charIndex":8655},{"text":"CentOS Node","id":"centos-node","depth":2,"charIndex":8750},{"text":"**第一步 在 CentOS 找好安装位置**","id":"第一步-在-centos-找好安装位置","depth":2,"charIndex":-1},{"text":"第二步 解压压缩文件","id":"第二步-解压压缩文件","depth":2,"charIndex":8938},{"text":"第三步 部署 bin 文件并建立软连接（类似于 Windows 中配置环境变量）","id":"第三步-部署-bin-文件并建立软连接类似于-windows-中配置环境变量","depth":2,"charIndex":9074},{"text":"安装 yarn","id":"安装-yarn","depth":2,"charIndex":9210},{"text":"配置yarnopen in new window官方 yum 存储库","id":"配置yarnopen-in-new-window官方-yum-存储库","depth":3,"charIndex":9221},{"text":"安装","id":"安装","depth":3,"charIndex":9261},{"text":"验证","id":"验证","depth":3,"charIndex":9267},{"text":"Centos7 Mysql 安装","id":"centos7-mysql-安装","depth":2,"charIndex":9275},{"text":"1、下载","id":"1下载","depth":2,"charIndex":9295},{"text":"2、解压","id":"2解压","depth":2,"charIndex":9374},{"text":"3、安装","id":"3安装","depth":2,"charIndex":9407},{"text":"4、问题","id":"4问题","depth":2,"charIndex":9463},{"text":"5、启动","id":"5启动","depth":2,"charIndex":9637},{"text":"初始化 Nysql","id":"初始化-nysql","depth":3,"charIndex":9645},{"text":"添加权限","id":"添加权限","depth":3,"charIndex":9660},{"text":"启动服务","id":"启动服务","depth":3,"charIndex":9670},{"text":"查看初始密码","id":"查看初始密码","depth":3,"charIndex":9678},{"text":"登入 Mysql","id":"登入-mysql","depth":3,"charIndex":9692},{"text":"问题","id":"问题","depth":3,"charIndex":9704},{"text":"修改密码","id":"修改密码","depth":3,"charIndex":9910},{"text":"查看数据库","id":"查看数据库","depth":3,"charIndex":9920},{"text":"6、navicat 远程链接","id":"6navicat-远程链接","depth":2,"charIndex":9931},{"text":"链接失败 1130","id":"链接失败-1130","depth":3,"charIndex":9965},{"text":"a.问题分析","id":"a问题分析","depth":4,"charIndex":10055},{"text":"b.解决办法","id":"b解决办法","depth":4,"charIndex":10112},{"text":"c.解决步骤","id":"c解决步骤","depth":4,"charIndex":10264},{"text":"链接失败 2059","id":"链接失败-2059","depth":3,"charIndex":-1},{"text":"a.问题分析","id":"a问题分析-1","depth":4,"charIndex":10398},{"text":"b.问题解决","id":"b问题解决","depth":4,"charIndex":10586},{"text":"c.解决步骤","id":"c解决步骤-1","depth":4,"charIndex":10688},{"text":"7、Node 链接 Mysql8 的一些问题","id":"7node-链接-mysql8-的一些问题","depth":2,"charIndex":10700},{"text":"解决办法","id":"解决办法","depth":3,"charIndex":10889}],"domain":"","frontmatter":{"icon":"linux","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"Linux 基础操作","category":"linux","tag":"linux"},"version":""},{"id":487,"title":"NAS","content":"NAS 主要用于 Docker 服务、影视管理和文件存储备用这三方面。群晖 NAS 在使用前，注意以下几点：\n\n * 选择「控制面板」>「文件服务」>「SMB」>「高级设置」，将最小 SMB 协议 设为 SMB1，避免部分应用发现了 NAS 但无法打开共享文件。\n * 选择「控制面板」>「任务计划」>「新增」>「计划的任务」>「用户定义的脚本」，给 NAS 建立定时任务脚本。\n * SSD 缓存对家用的 NAS 性能提升不大，没必要加。\n * DS/Transmission 套件：用于 PT 下载 (禁用 DHT，半小时停止做种)。\n * Synology Drive Server 套件：电脑文件备份。\n * Hyper Backup：本地多硬盘备份，防止一个硬盘丢失后重要文件损坏，比如 docker 容器的本地配置文件夹。\n * 群晖系统分布在所有硬盘，拔出一个不影响使用。但应用会有影响？\n\n\nNAS Docker#\n\nNAS Docker 建议指定本地端口，否则重启容器会让端口发生改变，重启不会不影响 docker 配置。升级容器镜像，不影响内部数据库。群晖的「Docker\n导出」只会导出安装镜像和配置，但不包括容器内部使用的数据库，用处不大。\n\nDocker 容器安装：\n\n推荐用 docker-compose.yml 安装 Docker，镜像会自动同步到 NAS 的容器列表中。docker-compose 使用参考 TTRSS\ndocker-composeopen in new window。\n\n 1. 选择「控制面板」>「终端机和 SNMP」，启动 SSH 功能。\n 2. putty 连接群晖 SSH，进入 docker-compose.yml 所在路径，比如 cd /volume3/storage。\n 3. 通过终端在同目录下运行 sudo docker-compose up -d 后等待部署完成。\n 4. 关闭 SSH 功能。\n\n注意：root 用户需在命令前添加 sudo，否则会提示 Permission denied。\n\n\nDocker 容器#\n\n\n常用#\n\n * qbittorrentopen in new window：需修改所有默认端口，否则容易报错。PT 下载关闭 BitTorrent - DHT\n   和其他隐私选项，半小时停止做种，将下载文件添加 Everyone 权限，其他设置参考 群晖使用 qbittorrentopen in new\n   window。\n * PhotoPrismopen in new window：基于 ai\n   私有化部署的个人相册。如果部署时出错，则尝试删除数据库文件夹下的内容。地点标记功能非常强大，类似本地版 Google Photos。\n * qiandaoopen in new window：自动签到开源框架，需搭配浏览器扩展 get-cookiesopen in new window\n   使用，可导出配置。\n * watchtoweropen in new window：监控并更新 Docker 容器。\n   * 监控指定名称的镜像：docker run -d --name watchtower -v\n     /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup\n     --run-once nginx redis。本案例只更新名为「nginx」和「redis」的容器，其他容器将被忽略。\n   * 指定容器的 compose 命令中添加 lable\n     com.centurylinklabs.watchtower.enable=false，可禁止该容器的监控和更新。\n\n\n资讯#\n\n * RSSHub：无需保存数据，pubData 为 GMT 时区，普通用户无法更改，Docker Timezone 设置也不会有改变。\n * Huginn：定期备份抓取脚本，数据库保存在本地。\n * Tiny Tiny RSS：定期备份订阅源和设置，自动更新，可配置全文插件 mercury-parser-apiopen in new window。\n * Check 酱 open in new window：监测网页内容变化，并发送异动到微信。亦支持 http status、json 和 rss\n   监测。配合自架云端，关电脑后也能运行。同类工具有 changedetection.ioopen in new window。\n\n\n娱乐#\n\n * AListopen in new window：开源的网盘管理工具，还支持对象存储，本地存储，FTP 等等。\n * LANraragiopen in new window：免费开源的漫画管理器，支持\n   zip/rar/targz/lzma/7z/xz/cbz/cbr/pdf 多种格式，可从网页和 第三方客户端 open in new window 浏览。\n * Tachiyomiopen in new window：开源的漫画阅读应用，通过安装扩展插件，可以方便地订阅并聚合漫画源。使用前，需进入\n   Extensions，点右上角的 Enabled Languages 按钮，设置为中文源，然后会在页面底部发现中文漫画源。安装源后，进入 Souces\n   中点击进入对应源。\n * readeropen in new window：阅读 3\n   的服务器版，摆脱客户端，网页版即可查看。自定义替换进入文章页面左侧的「设置」-「过滤规则管理」。\n * Tale Bookopen in new window：基于 Calibre 的简单的个人图书管理系统，支持在线阅读，但阅读体验不强且 Bug\n   较多，个人更喜欢直接用 PC 端查看。\n * Bilibili_Danmujiopen in new window：B\n   站直播礼物答谢、定时广告、关注感谢，自动回复工具，房管工具，自动打卡，Bilibili 直播弹幕姬 (使用 websocket 协议)，java 版 B\n   站弹幕姬。部署 Docker 时需更新 jdr release 文件。\n\n\n自动化#\n\n * n8nopen in new window：开源 IFTTT 工具，偏重于云服务。\n * Monicaopen in new window：Monica\n   允许人们记录所有关于朋友和家人的重要事情。喜欢和他们一起的活动。你最后一次打电话给某人的时候，你们谈了些什么。它会帮助你记住他们孩子的名字和年龄。它还能提\n   醒你打电话给一个很久没联系的人。Monica 的容器设置查看 Monica Dockeropen in new window。\n * supermanito/Helloworldopen in new window：京东签到等脚本，功能很强大，没怎么研究。\n * ubuntu-desktop-lxde-vncopen in new window：能在 Docker 上运行的 Ubuntu\n   桌面版，适合挂载要长期运行的程序。测试 OBS 时，对内存要求不高，但 CPU 直冲 100%，fps 只有 7。\n\n\n待了解#\n\n * 兰空图床 open in new window：图床已经部署在七牛云，用 Picgo 上传，没感觉有必要用它。\n * AutoBangumiopen in new window：自动追番器，用以替代自我审查的 Bilibili。\n * nas-toolsopen in new window：号称能自动整理文件，但测试识别中很容易出错，暂不考虑。\n * Emby、Plex：流媒体方案，暂不考虑。\n * Clash：代理服务器。\n\n\n影视整理#\n\n下载文件后，用 tinyMediaManager 重命名并下载 NFO 和影视封面，最后放置于分类文件夹。\n\ntinyMediaManageropen in new window v4 免费版足够个人使用，v3 作偶尔补充使用，搜索首选语言改为「大陆简体」更精准。[1]\n\n\n\n\nNAS 硬盘#\n\n插入新硬盘，新建储存空间，使用 Btrfs 或 Basic 格式。SHR 是群晖的智能 RAID 格式，不适用于硬盘容量不同的情况。\n\n硬盘     容量    到期时间（5 年）\n硬盘 1   10T   2025-06-18\n硬盘 2   4T    2023-01-24\n硬盘 3   14T   2027-02-11\n硬盘 4   8T    2026-01-06\n冷备份    2T    2014-10\n\n换下的机械硬盘做冷备份，存储照片等长期数据。\n\n硬盘临期后，用大容量硬盘替换。选择「存储池」>「更改 RAID 类型」，无损转换 basic 到 Raid1。不过，不同容量硬盘组\nRAID，只能以最小磁盘容量计使用空间。\n\n更换硬盘后，注意将数据连同文件夹用 file station 复制过去 (按住 Shift 选中所有你要的文件点右键\n移动到...)，关机卸载旧盘。如果该硬盘涉及套件位置，注意检查设置。[2]\n\n共享文件迁移：选择「控制面板」>「共享文件夹」，把你的共享文件夹位置修改到新储存空间。[3]\n\n--------------------------------------------------------------------------------\n\n 1. 群晖 NAS 使用 Emby+tMM 打造全平台观影畅爽体验（附下载地址）open in new window ↩︎\n\n 2. 如何把群晖 NAS 上的套件搬到另外个硬盘上 open in new window ↩︎\n\n 3. 群晖 NAS 跨存储空间移动共享文件夹 (NAS 新增磁盘)open in new window ↩︎","routePath":"/up/linux/nas","lang":"","toc":[{"text":"NAS Docker","id":"nas-docker","depth":2,"charIndex":403},{"text":"Docker 容器","id":"docker-容器","depth":2,"charIndex":884},{"text":"常用","id":"常用","depth":3,"charIndex":897},{"text":"资讯","id":"资讯","depth":3,"charIndex":1599},{"text":"娱乐","id":"娱乐","depth":3,"charIndex":1924},{"text":"自动化","id":"自动化","depth":3,"charIndex":2621},{"text":"待了解","id":"待了解","depth":3,"charIndex":3050},{"text":"影视整理","id":"影视整理","depth":2,"charIndex":3276},{"text":"NAS 硬盘","id":"nas-硬盘","depth":2,"charIndex":3423}],"domain":"","frontmatter":{"icon":"process","order":4,"date":"2023-01-19T00:00:00.000Z","author":"h7ml","title":"NAS","category":"linux","tag":"linux","star":true,"lastUpdated":false},"version":""},{"id":488,"title":"Linux-Shell编程","content":"Shell#\n\n\nShell 概述#\n\n\n\n * Linux 提供的 Shell 解析器有\n\n\n\n * bash 和 sh 的关系\n\n\n\n * Centos 默认的解析器是 bash\n\n\n\n\nShell 入门#\n\n脚本格式\n\n\n第一个 Shell#\n\n脚本：helloworld.s\n\n创建一个 Shell 脚本，输出 helloworld\n\n\n\n在 helloworld.sh 中输入如下内容\n\n\n\n脚本的常用执行方式\n\n第一种#\n\n采用 bash 或 sh+脚本的相对路径或绝对路径（不用赋予脚本+x 权限） sh+脚本的相对路径\n\n\n\nsh+脚本的绝对路径\n\n\n\nbash+脚本的相对路径\n\n\n\nbash+脚本的绝对路径\n\n\n\n第二种#\n\n采用输入脚本的绝对路径或相对路径执行脚本**（必须具有可执行权限+x)**\n\n首先要赋予 helloworld.sh 脚本的+x 权限\n\n执行脚本\n\n相对路径\n\n\n\n绝对路径\n\n\n\nWARNING\n\n注意：第一种执行方法，本质是 bash 解析器帮你执行脚本，所以脚本本身不需要执行 权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。\n\n第三种#\n\n在脚本的路径前加上“.”或者 sourc\n\n有以下脚本\n\n\n\n分别使用 sh，bash，./ 和 . 的方式来执行，结果如下：\n\n\n\n原因：\n\n * 前两种方式都是在当前 shell 中打开一个子 shell 来执行脚本内容，当脚本内容结束，则子 shell 关闭，回到父 shell 中。\n * 第三种，也就是使用在脚本路径前加“.”或者 source 的方式，**可以使脚本内容在当前shell 里执行，而无需打开子\n   shell！**这也是为什么我们每次要修改完/etc/profile 文件以后，需要 source 一下的原因。\n * 开子 shell 与不开子 shell 的区别就在于，环境变量的继承关系，如在子 shell 中设置的当前变量，父 shell 是不可见的\n\n\n变量#\n\n\n系统预定义变量#\n\n常用系统变量 $HOME、$PWD、$SHELL、$USER...\n\n * 查看系统变量的值\n\n\n\n * 显示当前 Shell 中所有变量：set\n\n\n\n\n自定义变量#\n\n基本语法\n\n * 定义变量：变量名=变量值，注意，=号前后不能有空格\n * 撤销变量：unset 变量名\n * 声明静态变量：readonly 变量，注意：不能 unset\n\n变量定义规则\n\n * 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。\n * 等号两侧不能有空格\n * 在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算。\n * 变量的值如果有空格，需要使用双引号或单引号括起来\n\n案例实操\n\n * 定义变量 A\n\n\n\n * 给变量 A 重新赋值\n\n\n\n * 撤销变量 A\n\n\n\n * 声明静态的变量 B=2，不能 unset\n\n\n\n * 在 bash 中，变量默认类型都是字符串类型，无法直接进行数值运算\n\n\n\n * 变量的值如果有空格，需要使用双引号或单引号括起来\n\n\n\n * 可把变量提升为全局环境变量，可供其他 Shell 程序使用，export 变量名\n\n\n\n\n\n发现并没有打印输出变量 B 的值。\n\n\n\nTIP\n\n在子 Shell 中声明或者改变全局的变量都不会影响父 Shell 中的变量\n\n\n字符串#\n\n字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。\n\n\n单引号#\n\n单引号字符串的限制：\n\n * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；\n * 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n\n\n双引号#\n\n\n\n双引号的优点：\n\n * 双引号里可以有变量\n * 双引号里可以出现转义字符\n\n\n数组#\n\nbash支持一维数组**（不支持多维数组），并且没有限定数组的大小**。\n\n类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。\n\n\n定义数组#\n\n在 Shell 中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为：\n\n例如：\n\n\n\n或者\n\n\n\n还可以单独定义数组的各个分量：\n\n\n\n可以不使用连续的下标，而且下标的范围没有限制。\n\n\n读取数组#\n\n读取数组元素值的一般格式是：\n\n例如：\n\n使用 @ 符号可以获取数组中的所有元素，例如：\n\n\n获取数组的长度#\n\n获取数组长度的方法与获取字符串长度的方法相同，例如：\n\n\n\n\n特殊变量#\n\n\n$n#\n\n功能描述：n 为数字，$0 代表该脚本名称，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}\n\n\n\n\n$#\n\n功能描述：获取所有输入参数个数，常用于循环，判断参数的个数是否正确以及加强脚本的健壮性\n\n\n\n\n$*、$@#\n\n * $* 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体\n * $@ 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待\n\n\n\n\n$？#\n\n$？最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一 个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明\n上一个命令执行不正确了。\n\n判断 helloworld.sh 脚本是否正确执\n\n\n\n\n运算符#\n\n运算符有两种写法\n\n * ((表达式))\n * [ 表达式 ] 注意 [] 里面左右要有空格\n\n\n算术运算符#\n\n下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n\n运算符   说明                          举例\n+     加法                          expr $a + $b 结果为 30。\n-     减法                          expr $a - $b 结果为 -10。\n*     乘法                          expr $a \\* $b 结果为 200。\n/     除法                          expr $b / $a 结果为 2。\n%     取余                          expr $b % $a 结果为 0。\n=     赋值                          a=$b 把变量 b 的值赋给 a。\n==    相等。用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。\n!=    不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b ] 返回 true。\n\n> **注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。\n\n\n\n\n\nTIP\n\n * 乘号(*)前边必须加反斜杠()才能实现乘法运算；\n * if...then...fi 是条件语句，后续将会讲解。\n * 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 \"*\" 不需要转义符号 \"\" 。\n\n\n关系运算符#\n\n关系运算符只支持数字，不支持字符串，除非字符串的值是数字。\n\n下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：\n\n运算符   说明                              举例\n-eq   检测两个数是否相等，相等返回 true。            [ $a -eq $b ] 返回 false。\n-ne   检测两个数是否不相等，不相等返回 true。          [ $a -ne $b ] 返回 true。\n-gt   检测左边的数是否大于右边的，如果是，则返回 true。     [ $a -gt $b ] 返回 false。\n-lt   检测左边的数是否小于右边的，如果是，则返回 true。     [ $a -lt $b ] 返回 true。\n-ge   检测左边的数是否大于等于右边的，如果是，则返回 true。   [ $a -ge $b ] 返回 false。\n-le   检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b ] 返回 true。\n\n\n\n\n\nTIP\n\n这里我们使用 ((表达式)) 来做判断的话。在 ((表达式)) 中就可以写 <,>,<=,>=,=这些数学的运算符号\n\n\n逻辑运算符#\n\n以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:\n\n| 运算符 | 说明 | 举例 | | ------ | ---------- |\n------------------------------------------- | --------- | -------------- | --- |\n------------------------ | | && | 逻辑的 AND | [[$a -lt 100 && $b -gt 100]] 返回\nfalse | | | | | 逻辑的 OR | [[$a -lt 100 | | $b -gt 100]] 返回 true |\n\n\n\n\n字符串运算符#\n\n下表列出了常用的字符串运算符，假定变量 a 为 \"abc\"，变量 b 为 \"efg\"：\n\n运算符   说明                            举例\n=     检测两个字符串是否相等，相等返回 true。        [ $a = $b ] 返回 false。\n!=    检测两个字符串是否不相等，不相等返回 true。      [ $a != $b ] 返回 true。\n-z    检测字符串长度是否为 0，为 0 返回 true。     [ -z $a ] 返回 false。\n-n    检测字符串长度是否不为 0，不为 0 返回 true。   [ -n \"$a\" ] 返回 true。\n$     检测字符串是否不为空，不为空返回 true。        [ $a ] 返回 true。\n\n\n\n\n\n\n文件测试运算符#\n\n文件测试运算符用于检测 Unix 文件的各种属性。\n\n属性检测描述如下：\n\n操作符       说明                                         举例\n-b file   检测文件是否是块设备文件，如果是，则返回 true。                 [ -b $file ] 返回 false。\n-c file   检测文件是否是字符设备文件，如果是，则返回 true。                [ -c $file ] 返回 false。\n-d file   检测文件是否是目录，如果是，则返回 true。                    [ -d $file ] 返回 false。\n-f file   检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。   [ -f $file ] 返回 true。\n-g file   检测文件是否设置了 SGID 位，如果是，则返回 true。             [ -g $file ] 返回 false。\n-k file   检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。     [ -k $file ] 返回 false。\n-p file   检测文件是否是有名管道，如果是，则返回 true。                  [ -p $file ] 返回 false。\n-u file   检测文件是否设置了 SUID 位，如果是，则返回 true。             [ -u $file ] 返回 false。\n-r file   检测文件是否可读，如果是，则返回 true。                     [ -r $file ] 返回 true。\n-w file   检测文件是否可写，如果是，则返回 true。                     [ -w $file ] 返回 true。\n-x file   检测文件是否可执行，如果是，则返回 true。                    [ -x $file ] 返回 true。\n-s file   检测文件是否为空（文件大小是否大于 0），不为空返回 true。           [ -s $file ] 返回 true。\n-e file   检测文件（包括目录）是否存在，如果是，则返回 true。               [ -e $file ] 返回 true。\n\n其他检查符：\n\n * -S: 判断某文件是否 socket。\n * -L: 检测文件是否存在并且是一个符号链接。\n\n\n\n\n\n\n流程控制（重点）#\n\n\nif else#\n\n\nfi#\n\nif 语句语法格式：\n\n\n\n写成一行（适用于终端命令提示符）：\n\n\n\nTIP\n\n末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。\n\n简单的说就是和JS中的 if() { } 这里的 {} 代表一个区域表示if成立了执行这个区域里面的代码，但在Shell中 {} 有这其他的含义，所以 if\n代表开始 fi 代表结束把中间的代码框起来表示if成立后执行的代码。\n\n其中 if 后的语句成功执行就会跳转到 then 后的语句，否则不跳转，then 表示判断成功后要执行的语句。\n\n\nif else#\n\nif else 语法格式：\n\n\n\n\nif else-if else#\n\nif else-if else 语法格式：\n\n\n\nif else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。\n\n\n\n如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 > 和 <。\n\n\n\n以下实例判断两个变量是否相等：\n\n\n\n输出结果：\n\nif else 语句经常与 test 命令结合使用，如下所示：\n\n\n\n输出结果：\n\n\ncase ... esac#\n\ncase ... esac 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分支选择结构，每个 case\n分支用右圆括号开始，用两个分号 ;; 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。\n\n可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。\n\ncase ... esac 语法格式如下：\n\n\n\ncase 工作方式如上所示，取值后面必须为单词 in，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至\n;;。\n\n取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。\n\n下面的脚本提示输入 1 到 4，与每一种模式进行匹配：\n\n\n\n输入不同的内容，会有不同的结果，例如：\n\n\n\n\nfor 循环#\n\n与其他编程语言类似，Shell支持for循环。\n\n写法一\n\nfor循环一般格式为\n\n\n\n写成一行：\n\n\n\nTIP\n\n这里 do 和 done 就和 { } 一样来确定范围\n\n当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in\n列表可以包含替换、字符串和文件名。\n\nin列表是可选的，如果不用它，for 循环使用命令行的位置参数。\n\n例如，顺序输出当前列表中的数字：\n\n\n\n输出结果：\n\n\n\n顺序输出字符串中的字符：\n\n\n\n输出结果：\n\n写法二\n\n\n\n从 1 加到 100 ,for1.sh\n\n\n\n\n\n\nwhile 语句#\n\nwhile 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：\n\n\n\n以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加\n1。运行上述脚本，返回数字 1 到 5，然后终止。\n\n\n\n运行脚本，输出：\n\n以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令 open in\nnew window。\n\nwhile循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按结束循环。\n\n\n\n\n无限循环#\n\n无限循环语法格式：\n\n或者\n\n\n\n或者\n\n\nuntil 循环#\n\nuntil 循环执行一系列命令直至条件为 true 时停止。\n\nuntil 循环与 while 循环在处理方式上刚好相反。\n\n一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。\n\nuntil 语法格式:\n\n\n\ncondition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。\n\n以下实例我们使用 until 命令来输出 0 ~ 9 的数字：\n\n\n\n输出结果为：\n\n\n跳出循环#\n\n在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell 使用两个命令来实现该功能：break 和 continue。\n\n\nbreak 命令#\n\nbreak 命令允许跳出所有循环（终止执行后面的所有循环）。\n\n下面的例子中，脚本进入死循环直至用户输入数字大于 5。要跳出这个循环，返回到 shell 提示符下，需要使用 break 命令。\n\n\n\n执行以上代码，输出结果为：\n\n\n\n\ncontinue#\n\ncontinue 命令与 break 命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。\n\n对上面的例子进行修改：\n\n\n\n运行代码发现，当输入大于 5 的数字时，该例中的循环不会结束，语句 echo \"游戏结束\" 永远不会被执行。\n\n\n函数#\n\n\n函数定义#\n\nlinux shell 可以用户定义函数，然后在 shell 脚本中可以随便调用。\n\nshell中函数的定义格式如下：\n\n\n\n说明：\n\n * 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。\n * 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255）\n\n下面的例子定义了一个函数并进行调用：\n\n\n\n输出结果：\n\n\n\n下面定义一个带有return语句的函数：\n\n\n\n输出类似下面：\n\n\n\n函数返回值在调用该函数后通过 $? 来获得。\n\nTIP\n\n注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。\n\n\n函数参数#\n\n在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2 表示第二个参数...\n\n带参数的函数示例：\n\n\n\n输出结果：\n\n\n\nTIP\n\n注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。\n\n另外，还有几个特殊字符用来处理参数：\n\n参数处理   说明\n$#     传递到脚本或函数的参数个数\n$*     以一个单字符串显示所有向脚本传递的参数\n$$     脚本运行的当前进程 ID 号\n$!     后台运行的最后一个进程的 ID 号\n$@     与$*相同，但是使用时加引号，并在引号中返回每个参数。\n$-     显示 Shell 使用的当前选项，与 set 命令功能相同。\n$?     显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。\n\n\n获取函数的返回值#\n\n\n\nTIP\n\n函数没有return的时候返回值是最后一行代码的执行结果。\n\n\n正侧表达式#\n\n\n基本正侧表达式#\n\n正则表达式和通配符的区别：\n\n * 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配. grep、awk、sed 等命令可以支持正则表达式。\n * 通配符（ ？[]）是用来匹配符合条件的文件名*，通配符是完全匹配。ls、find、cp 等命令不支持正则表达式，所有只能使用 shell\n   自己的通配符来进行匹配了。\n\n元字符                                           作用\n*                                             前一个字符匹配 0 次或者任意多次\n.                                             匹配除了换行符外任意一个字符\n^                                             匹配行首，\n例如：^hello会匹配以hello开头的行。                       \n$                                             匹配行首，\n例如：hello$会匹配以hello开头的行。                       \n[ ]                                           匹配括号中指定的任意一个字符，只匹配一个字符\n[ ^]                                          匹配除中括号的字符意外的任意一个字符。\n例如：[^0-9]匹配任意一个非数字字符。                         \n\\                                             转义符。用于将特殊符号的含义取消\n{n}                                           表示其前面的字符签好出现 n 次。\n例如：[0-9]{4}匹配 4 位数字，[1][3-8][0-9]{9} 匹配手机号码   \n{n,}                                          表示七千亩的字符出现不小于 n 次。\n例如：[0-9]{2,}表示两位及以上的数字                        \n{n,m}                                         表示其前面的字符至少出现 n 次，最多出现 m 次。\n例如：[a-z]{6,8}匹配 6 到 8 为的小写子母。                 \n\n\n\n\n常用正侧表达式#\n\n| 字符 | 描述 | | --- | --- | --- | --- | | \\ |\n将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。 | |\n例如：“n”匹配字符“n”。“\\n”匹配一个换行符。序列“\\\\”匹配“\\”而“\\(”则匹配“(”。 | | ^ | 匹配输入字符串的开始位置。如果设置了\nRegExp 对象的 Multiline 属性，^也匹配“\\n”或“\\r”之后的位置。 | | $ | 匹配输入字符串的结束位置。如果设置了 RegExp\n对象的 Multiline 属性，$也匹配“\\n”或“\\r”之前的位置。 | | * | 匹配前面的子表达式零次或多次。 | |\n例如：zo*能匹配“z”以及“zoo”。*等价于{0,}。 | | + | 匹配前面的子表达式一次或多次。 | |\n例如：“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 | | ? | 匹配前面的子表达式零次或一次。 | |\n例如：“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 | | {n} | n 是一个非负整数。匹配确定的 n 次。 | |\n例如：“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。 | | {n,} | n 是一个非负整数。至少匹配 n 次。 | |\n例如：“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 | |\n{n,m} | m 和 n 均为非负整数，其中 n<=m。最少匹配 n 次且最多匹配 m 次。 | |\n例如：“o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 | | ? |\n当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式\n则尽可能多的匹配所搜索的字符串。 | | 例如：对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 | | . |\n匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“[.\\n]”的模式。 | | (pattern) | 匹配 pattern\n并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript\n中则使用$0…$9 属性。要匹配圆括号字符，请使用“”或“”或“”。 | | (?:pattern) | 匹配 pattern\n但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“( | )”来组合一个模式的各个部分是很有用。 | |\n例如“industr(?:y | ies)”就是一个比“industry | industries”更简略的表达式。 | | (?=pattern) |\n正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 | |\n例如：“Windows(?=95 | 98 | NT |\n2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹\n配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 | | (?!pattern) | 负向预查，在任何不匹配\npattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 | | 例如“Windows(?!95 | 98 |\nNT |\n2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹\n配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 | | x | y | 匹配 x 或 y。 | | 例如：“z |\nfood”能匹配“z”或“food”。“(z | f)ood”则匹配“zood”或“food”。 | | [xyz] | 字符集合。匹配所包含的任意一个字符。\n| | 例如：“[abc]”可以匹配“plain”中的“a”。 | | [^xyz] | 负值字符集合。匹配未包含的任意字符。 | |\n例如：“[^abc]”可以匹配“plain”中的“p”。 | | [a-z] | 字符范围。匹配指定范围内的任意字符。 | |\n例如：“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 | | [^a-z] | 负值字符范围。匹配任何不在指定范围内的任意字符。 | |\n例如：“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 | | \\b | 匹配一个单词边界，也就是指单词和空格间的位置。 | |\n例如：“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 | | \\B |\n匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 | | \\cx | 匹配由 x 指明的控制字符。 | |\n例如：\\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的“c”字符。 | | \\d |\n匹配一个数字字符。等价于[0-9]。 | | \\D | 匹配一个非数字字符。等价于[^0-9]。 | | \\f | 匹配一个换页符。等价于\\x0c 和\\cL。\n| | \\n | 匹配一个换行符。等价于\\x0a 和\\cJ。 | | \\r | 匹配一个回车符。等价于\\x0d 和\\cM。 | | \\s |\n匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\\f\\n\\r\\t\\v]。 | | \\S | 匹配任何非空白字符。等价于[^\\f\\n\\r\\t\\v]。 |\n| \\t | 匹配一个制表符。等价于\\x09 和\\cI。 | | \\v | 匹配一个垂直制表符。等价于\\x0b 和\\cK。 | | \\w |\n匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 | | \\W | 匹配任何非单词字符。等价于“[^a-za-z0-9_]”。 | | \\xn\n| 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。 | |\n例如：“\\x41”匹配“A”。“\\x041”则等价于“\\x04&1”。正则表达式中可以使用 ASCII 编码。. | | \\num | 匹配 num，其中\nnum 是一个正整数。对所获取的匹配的引用。 | | 例如：“(.)\\1”匹配两个连续的相同字符。 | | \\n |\n标识一个八进制转义值或一个向后引用。如果\\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字（0-7），则 n\n为一个八进制转义值。 | | \\nm | 标识一个八进制转义值或一个向后引用。如果\\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果\\nm\n之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字（0-7），则\\nm 将匹配八进制转义值\nnm。 | | \\nml | 如果 n 为八进制数字（0-3），且 m 和 l 均为八进制数字（0-7），则匹配八进制转义值 nml。 | | \\un | 匹配\nn，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。 | | 例如：\\u00A9 匹配版权符号（?）。 |\n\n\n文本处理工具#\n\n\ncut 命令#\n\n\n语法#\n\n\n\n使用说明:\n\ncut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。\n\n如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。\n\n参数:\n\n * -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n * -c ：以字符为单位进行分割。\n * -d ：自定义分隔符，默认为制表符。\n * -f ：与-d 一起使用，指定显示哪个区域。\n * -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的\n   范围之内，该字符将被写出；否则，该字符将被排除\n\n\n实例#\n\n当你执行 who 命令时，会输出类似如下的内容：\n\n\n\n如果我们想提取每一行的第 3 个字节，就这样：\n\n\nawk 命令#\n\n\n语法#\n\n\n\n选项参数说明：\n\n * -F fs or --field-separator fs 指定输入文件折分隔符，fs 是一个字符串或者是一个正则表达式，如-F:。\n * -v var=value or --asign var=value 赋值一个用户定义变量。\n * -f scripfile or --file scriptfile 从脚本文件中读取awk命令。\n * -mf nnn and -mr nnn 对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是\n   Bell 实验室版awk的扩展功能，在标准awk中不适用。\n * -W compact or --compat, -W traditional or --traditional\n   在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。\n * -W copyleft or --copyleft, -W copyright or --copyright 打印简短的版权信息。\n * -W help or --help, -W usage or --usage 打印全部awk选项和每个选项的简短说明。\n * -W lint or --lint 打印不能向传统unix平台移植的结构的警告。\n * -W lint-old or --lint-old 打印关于不能向传统unix平台移植的结构的警告。\n * -W posix\n   打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符和=不能代替^和^=；ffl\n   ush无效。\n * -W re-interval or --re-inerval\n   允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。\n * -W source program-text or --source program-text 使用 program-text作为源代码，可与-f\n   命令混用。\n * -W version or --version 打印 bug 报告信息的版本。\n\n\n基本用法#\n\nlog.txt 文本内容如下：\n\n\n\n用法一：\n\n\n\n实例：\n\n\n\n用法二：\n\n\n\n实例：\n\n\n\n用法三：\n\n实例：\n\n\n\n用法四：\n\n实例：\n\n\n运算符#\n\n| 运算符 | 描述 | | --------------------------- | -------------------------------- |\n--- | ------ | | = += -= *= /= %= ^= **= | 赋值 | | ?: | C 条件表达式 | | | | | 逻辑或 | |\n&& | 逻辑与 | | ~ 和 !~ | 匹配正则表达式和不匹配正则表达式 | | < <= > >= != == | 关系运算符 | | 空格 | 连接 |\n| + - | 加，减 | | * / % | 乘，除与求余 | | + - ! | 一元加，减和逻辑非 | | ^ *** | 求幂 | | ++ -- |\n增加或减少，作为前缀或后缀 | | $ | 字段引用 | | in | 数组成员 |\n\n过滤第一列大于 2 的行\n\n\n\n过滤第一列等于 2 的行\n\n\n\n过滤第一列大于 2 并且第二列等于'Are'的行\n\n\n\n--------------------------------------------------------------------------------\n\n\n内建变量#\n\n变量            描述\n$n            当前记录的第 n 个字段，字段间由FS分隔\n$0            完整的输入记录\nARGC          命令行参数的数目\nARGIND        命令行中当前文件的位置(从 0 开始算)\nARGV          包含命令行参数的数组\nCONVFMT       数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组\nERRNO         最后一个系统错误的描述\nFIELDWIDTHS   字段宽度列表(用空格键分隔)\nFILENAME      当前文件名\nFNR           各文件分别计数的行号\nFS            字段分隔符(默认是任何空格)\nIGNORECASE    如果为真，则进行忽略大小写的匹配\nNF            一条记录的字段的数目\nNR            已经读出的记录数，就是行号，从 1 开始\nOFMT          数字的输出格式(默认值是%.6g)\nOFS           输出字段分隔符，默认值与输入字段分隔符一致。\nORS           输出记录分隔符(默认值是一个换行符)\nRLENGTH       由match函数所匹配的字符串的长度\nRS            记录分隔符(默认是一个换行符)\nRSTART        由match函数所匹配的字符串的第一个位置\nSUBSEP        数组下标分隔符(默认值是/034)\n\n\n\n--------------------------------------------------------------------------------\n\n\n使用正则，字符串匹配#\n\n\n\n~ 表示模式开始。// 中是模式。\n\n\n\n--------------------------------------------------------------------------------\n\n\n忽略大小写#\n\n\n\n--------------------------------------------------------------------------------\n\n\n模式取反#\n\n\n\n--------------------------------------------------------------------------------\n\n\nawk 脚本#\n\n关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。\n\n * BEGIN{ 这里面放的是执行前的语句 }\n * END {这里面放的是处理完所有的行后要执行的语句 }\n * {这里面放的是处理每一行时要执行的语句}\n\n假设有这么一个文件（学生成绩表）：\n\n\n\n我们的 awk 脚本如下：\n\n\n\n我们来看一下执行结果：\n\n\n\n--------------------------------------------------------------------------------\n\n\n另外一些实例#\n\nAWK 的 hello world 程序为：\n\n\n\n计算文件大小\n\n\n\n从文件中找出长度大于 80 的行：\n\n打印九九乘法表\n\n\n\n\n发送消息案例#\n\n","routePath":"/up/linux/shell","lang":"","toc":[{"text":"Shell","id":"shell","depth":2,"charIndex":-1},{"text":"Shell 概述","id":"shell-概述","depth":2,"charIndex":8},{"text":"Shell 入门","id":"shell-入门","depth":2,"charIndex":95},{"text":"第一个 Shell","id":"第一个-shell","depth":3,"charIndex":113},{"text":"第一种","id":"第一种","depth":4,"charIndex":211},{"text":"第二种","id":"第二种","depth":4,"charIndex":316},{"text":"第三种","id":"第三种","depth":4,"charIndex":498},{"text":"变量","id":"变量","depth":2,"charIndex":850},{"text":"系统预定义变量","id":"系统预定义变量","depth":2,"charIndex":856},{"text":"自定义变量","id":"自定义变量","depth":2,"charIndex":944},{"text":"字符串","id":"字符串","depth":2,"charIndex":1434},{"text":"单引号","id":"单引号","depth":3,"charIndex":1516},{"text":"双引号","id":"双引号","depth":3,"charIndex":1626},{"text":"数组","id":"数组","depth":2,"charIndex":1674},{"text":"定义数组","id":"定义数组","depth":3,"charIndex":1784},{"text":"读取数组","id":"读取数组","depth":3,"charIndex":1896},{"text":"获取数组的长度","id":"获取数组的长度","depth":3,"charIndex":1950},{"text":"特殊变量","id":"特殊变量","depth":2,"charIndex":1991},{"text":"$n","id":"n","depth":3,"charIndex":1999},{"text":"$","id":"","depth":3,"charIndex":2076},{"text":"$*、$@","id":"","depth":3,"charIndex":2128},{"text":"$？","id":"","depth":3,"charIndex":2214},{"text":"运算符","id":"运算符","depth":2,"charIndex":2338},{"text":"算术运算符","id":"算术运算符","depth":2,"charIndex":2393},{"text":"关系运算符","id":"关系运算符","depth":2,"charIndex":3120},{"text":"逻辑运算符","id":"逻辑运算符","depth":2,"charIndex":3678},{"text":"字符串运算符","id":"字符串运算符","depth":2,"charIndex":3996},{"text":"文件测试运算符","id":"文件测试运算符","depth":2,"charIndex":4376},{"text":"流程控制（重点）","id":"流程控制重点","depth":2,"charIndex":5526},{"text":"if else","id":"if-else","depth":2,"charIndex":5538},{"text":"fi","id":"fi","depth":3,"charIndex":5549},{"text":"if else","id":"if-else-1","depth":3,"charIndex":5798},{"text":"if else-if else","id":"if-else-if-else","depth":3,"charIndex":5826},{"text":"case ... esac","id":"case--esac","depth":2,"charIndex":6023},{"text":"for 循环","id":"for-循环","depth":2,"charIndex":6468},{"text":"while 语句","id":"while-语句","depth":2,"charIndex":6768},{"text":"无限循环","id":"无限循环","depth":3,"charIndex":7076},{"text":"until 循环","id":"until-循环","depth":2,"charIndex":7105},{"text":"跳出循环","id":"跳出循环","depth":2,"charIndex":7347},{"text":"break 命令","id":"break-命令","depth":3,"charIndex":7423},{"text":"continue","id":"continue","depth":3,"charIndex":7552},{"text":"函数","id":"函数","depth":2,"charIndex":7687},{"text":"函数定义","id":"函数定义","depth":2,"charIndex":7693},{"text":"函数参数","id":"函数参数","depth":2,"charIndex":8056},{"text":"获取函数的返回值","id":"获取函数的返回值","depth":2,"charIndex":8460},{"text":"正侧表达式","id":"正侧表达式","depth":2,"charIndex":8510},{"text":"基本正侧表达式","id":"基本正侧表达式","depth":2,"charIndex":8519},{"text":"常用正侧表达式","id":"常用正侧表达式","depth":2,"charIndex":9659},{"text":"文本处理工具","id":"文本处理工具","depth":2,"charIndex":13000},{"text":"cut 命令","id":"cut-命令","depth":2,"charIndex":13010},{"text":"语法","id":"语法","depth":3,"charIndex":13020},{"text":"实例","id":"实例","depth":3,"charIndex":13342},{"text":"awk 命令","id":"awk-命令","depth":2,"charIndex":13401},{"text":"语法","id":"语法-1","depth":3,"charIndex":13411},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":14369},{"text":"运算符","id":"运算符-1","depth":3,"charIndex":14450},{"text":"内建变量","id":"内建变量","depth":3,"charIndex":14965},{"text":"使用正则，字符串匹配","id":"使用正则字符串匹配","depth":3,"charIndex":15715},{"text":"忽略大小写","id":"忽略大小写","depth":3,"charIndex":15834},{"text":"模式取反","id":"模式取反","depth":3,"charIndex":15927},{"text":"awk 脚本","id":"awk-脚本","depth":3,"charIndex":16019},{"text":"另外一些实例","id":"另外一些实例","depth":3,"charIndex":16281},{"text":"发送消息案例","id":"发送消息案例","depth":2,"charIndex":16357}],"domain":"","frontmatter":{"icon":"linux","order":1,"date":"2021-06-27T00:00:00.000Z","author":"h7ml","title":"Linux-Shell编程","category":"linux","tag":"linux"},"version":""},{"id":489,"title":"mysql","content":" * 数据库相关概念\n\n * MySQL 安装\n\n * SQL 概述\n\n * DDL:操作数据库\n\n * DDL:操作表\n\n * dml\n\n * 约束\n\n * 数据库设计","routePath":"/up/mysql/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"mysql","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"mysql","index":false,"dir":{"order":1}},"version":""},{"id":490,"title":"事物","content":"事务#\n\n\n概述#\n\n> 数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。\n> \n> 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令==要么同时成功，要么同时失败==。\n> \n> 事务是一个不可分割的工作逻辑单元。\n\n这些概念不好理解，接下来举例说明，如下图有一张表\n\n\n\n张三和李四账户中各有 100 块钱，现李四需要转换 500 块钱给张三，具体的转账操作为\n\n * 第一步：查询李四账户余额\n * 第二步：从李四账户金额 -500\n * 第三步：给张三账户金额 +500\n\n现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了 500，而张三金额并没有多\n500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题\n\n\n\n从上图可以看到在转账前开启事务，如果出现了异常回滚事务，三步正常执行就提交事务，这样就可以完美解决问题。\n\n\n语法#\n\n * 开启事务\n   \n   \n\n * 提交事务\n\n * 回滚事务\n\n\n代码验证#\n\n * 环境准备\n   \n   \n\n * 不加事务演示问题\n   \n   \n   \n   整体执行结果肯定会出问题，我们查询账户表中数据，发现李四账户少了 500。\n   \n   \n\n * 添加事务 sql 如下：\n   \n   \n   \n   上面 sql 中的执行成功进选择执行提交事务，而出现问题则执行回滚事务的语句。以后我们肯定不可能这样操作，而是在 java 中进行操作，在 java\n   中可以抓取异常，没出现异常提交事务，出现异常回滚事务。\n\n\n事务的四大特征#\n\n * 原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败\n\n * 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态\n\n * 隔离性（Isolation） :多个事务之间，操作的可见性\n\n * 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n> ==说明：==\n> \n> mysql 中事务是自动提交的。\n> \n> 也就是说我们不添加事务执行 sql 语句，语句执行完毕会自动的提交事务。\n> \n> 可以通过下面语句查询默认提交方式：\n> \n> 查询到的结果是 1 则表示自动提交，结果是 0 表示手动提交。当然也可以通过下面语句修改提交方式","routePath":"/up/mysql/affair","lang":"","toc":[{"text":"事务","id":"事务","depth":2,"charIndex":-1},{"text":"概述","id":"概述","depth":2,"charIndex":5},{"text":"语法","id":"语法","depth":2,"charIndex":427},{"text":"代码验证","id":"代码验证","depth":2,"charIndex":468},{"text":"事务的四大特征","id":"事务的四大特征","depth":2,"charIndex":705}],"domain":"","frontmatter":{"icon":"mysql","order":10,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"事物"},"version":""},{"id":491,"title":"约束","content":"约束#\n\n\n\n上面表中可以看到表中数据存在一些问题：\n\n * id 列一般是用标示数据的唯一性的，而上述表中的 id 为 1 的有三条数据，并且 马花疼 没有 id 进行标示\n\n * 柳白 这条数据的 age 列的数据是 3000，而人也不可能活到 3000 岁\n\n * 马运 这条数据的 math 数学成绩是-5，而数学学得再不好也不可能出现负分\n\n * 柳青 这条数据的 english 列（英文成绩）值为 null，而成绩即使没考也得是 0 分\n\n针对上述数据问题，我们就可以从数据库层面在添加数据的时候进行限制，这个就是约束。\n\n\n概念#\n\n * 约束是作用于表中列上的规则，用于限制加入表的数据\n   \n   例如：我们可以给 id 列加约束，让其值不能重复，不能为 null 值。\n\n * 约束的存在保证了数据库中数据的正确性、有效性和完整性\n   \n   添加约束可以在添加数据的时候就限制不正确的数据，年龄是 3000，数学成绩是-5 分这样无效的数据，继而保障数据的完整性。\n\n\n分类#\n\n * 非空约束： 关键字是 NOT NULL\n   \n   保证列中所有的数据不能有 null 值。\n   \n   例如：id 列在添加 马花疼 这条数据时就不能添加成功。\n\n * 唯一约束：关键字是 UNIQUE\n   \n   保证列中所有数据各不相同。\n   \n   例如：id 列中三条数据的值都是 1，这样的数据在添加时是绝对不允许的。\n\n * 主键约束： 关键字是 PRIMARY KEY\n   \n   主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给没张表添加一个主键列用来唯一标识数据。\n   \n   例如：上图表中 id 就可以作为主键，来标识每条数据。那么这样就要求数据中 id 的值不能重复，不能为 null 值。\n\n * 检查约束： 关键字是 CHECK\n   \n   保证列中的值满足某一条件。\n   \n   例如：我们可以给 age 列添加一个范围，最低年龄可以设置为 1，最大年龄就可以设置为 300，这样的数据才更合理些。\n   \n   > 注意：MySQL 不支持检查约束。\n   > \n   > 这样是不是就没办法保证年龄在指定的范围内了？从数据库层面不能保证，以后可以在 java 代码中进行限制，一样也可以实现要求。\n\n * 默认约束： 关键字是 DEFAULT\n   \n   保存数据时，未指定值则采用默认值。\n   \n   例如：我们在给 english 列添加该约束，指定默认值是 0，这样在添加数据时没有指定具体值时就会采用默认给定的 0。\n\n * 外键约束： 关键字是 FOREIGN KEY\n   \n   外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\n   \n   外键约束现在可能还不太好理解，后面我们会重点进行讲解。\n\n\n非空约束#\n\n * 概念\n   \n   非空约束用于保证列中所有数据不能有 NULL 值\n\n * 语法\n   \n   * 添加约束\n     \n     \n     \n     \n   \n   * 删除约束\n     \n     \n\n\n唯一约束#\n\n * 概念\n   \n   唯一约束用于保证列中所有数据各不相同\n\n * 语法\n   \n   * 添加约束\n     \n     \n     \n     \n   \n   * 删除约束\n     \n     \n\n\n主键约束#\n\n * 概念\n   \n   主键是一行数据的唯一标识，要求非空且唯一\n   \n   一张表只能有一个主键\n\n * 语法\n   \n   * 添加约束\n     \n     \n     \n     \n   \n   * 删除约束\n     \n     \n\n\n默认约束#\n\n * 概念\n   \n   保存数据时，未指定值则采用默认值\n\n * 语法\n   \n   * 添加约束\n     \n     \n     \n     \n   \n   * 删除约束\n     \n     \n\n\n约束练习#\n\n根据需求，为表添加合适的约束\n\n\n\n上面一定给出了具体的要求，我们可以根据要求创建这张表，并为每一列添加对应的约束。建表语句如下：\n\n\n\n通过上面语句可以创建带有约束的 emp 表，约束能不能发挥作用呢。接下来我们一一进行验证，先添加一条没有问题的数据\n\n\n\n * 验证主键约束，非空且唯一\n\n\n\n执行结果如下：\n\n\n\n从上面的结果可以看到，字段 id 不能为 null。那我们重新添加一条数据，如下：\n\n\n\n执行结果如下：\n\n\n\n从上面结果可以看到，1 这个值重复了。所以主键约束是用来限制数据非空且唯一的。那我们再添加一条符合要求的数据\n\n\n\n执行结果如下：\n\n\n\n * 验证非空约束\n\n\n\n执行结果如下：\n\n\n\n从上面结果可以看到，ename 字段的非空约束生效了。\n\n * 验证唯一约束\n\n\n\n执行结果如下：\n\n\n\n从上面结果可以看到，ename 字段的唯一约束生效了。\n\n * 验证默认约束\n\n\n\n执行完上面语句后查询表中数据，如下图可以看到王五这条数据的 bonus 列就有了默认值 0。\n\n\n\n==注意：默认约束只有在不给值时才会采用默认值。如果给了 null，那值就是 null 值。==\n\n如下：\n\n\n\n执行完上面语句后查询表中数据，如下图可以看到赵六这条数据的 bonus 列的值是 null。\n\n\n\n * 验证自动增长： auto_increment 当列是数字类型 并且唯一约束\n\n重新创建 emp 表，并给 id 列添加自动增长\n\n\n\n接下来给 emp 添加数据，分别验证不给 id 列添加值以及给 id 列添加 null 值，id 列的值会不会自动增长：\n\n\n\n\n外键约束#\n\n\n概述#\n\n外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\n\n如何理解上面的概念呢？如下图有两张表，员工表和部门表：\n\n\n\n员工表中的 dep_id 字段是部门表的 id 字段关联，也就是说 1 号学生张三属于 1 号部门研发部的员工。现在我要删除 1\n号部门，就会出现错误的数据（员工表中属于 1\n号部门的数据）。而我们上面说的两张表的关系只是我们认为它们有关系，此时需要通过外键让这两张表产生数据库层面的关系，这样你要删除部门表中的 1\n号部门的数据将无法删除。\n\n\n语法#\n\n * 添加外键约束\n\n\n\n\n\n * 删除外键约束\n\n\n\n\n练习#\n\n根据上述语法创建员工表和部门表，并添加上外键约束：\n\n\n\n添加数据\n\n\n\n此时删除 研发部 这条数据，会发现无法删除。\n\n删除外键\n\n\n\n重新添加外键\n\n","routePath":"/up/mysql/constraint","lang":"","toc":[{"text":"约束","id":"约束","depth":2,"charIndex":-1},{"text":"概念","id":"概念","depth":2,"charIndex":269},{"text":"分类","id":"分类","depth":2,"charIndex":448},{"text":"非空约束","id":"非空约束","depth":2,"charIndex":1204},{"text":"唯一约束","id":"唯一约束","depth":2,"charIndex":1322},{"text":"主键约束","id":"主键约束","depth":2,"charIndex":1434},{"text":"默认约束","id":"默认约束","depth":2,"charIndex":1566},{"text":"约束练习","id":"约束练习","depth":2,"charIndex":1676},{"text":"外键约束","id":"外键约束","depth":2,"charIndex":2379},{"text":"概述","id":"概述","depth":3,"charIndex":2387},{"text":"语法","id":"语法","depth":3,"charIndex":2630},{"text":"练习","id":"练习","depth":3,"charIndex":2664}],"domain":"","frontmatter":{"icon":"mysql","order":7,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"约束"},"version":""},{"id":492,"title":"DDL:操作数据库","content":"DDL:操作数据库#\n\n我们先来学习 DDL 来操作数据库。而操作数据库主要就是对数据库的增删查操作。\n\n\n查询#\n\n查询所有的数据库\n\n\n\n运行上面语句效果如下：\n\n\n\n上述查询到的是的这些数据库是 mysql 安装好自带的数据库，我们以后不要操作这些数据库。\n\n\n创建数据库#\n\n * 创建数据库：\n\n\n\n运行语句效果如下：\n\n\n\n而在创建数据库的时候，我并不知道 db1 数据库有没有创建，直接再次创建名为 db1 的数据库就会出现错误。\n\n\n\n为了避免上面的错误，在创建数据库的时候先做判断，如果不存在再创建。\n\n * 创建数据库(判断，如果不存在则创建)\n\n\n\n运行语句效果如下：\n\n\n\n从上面的效果可以看到虽然 db1 数据库已经存在，再创建 db1 也没有报错，而创建 db2 数据库则创建成功。\n\n\n删除数据库#\n\n * 删除数据库\n\n\n\n * 删除数据库(判断，如果存在则删除)\n\n\n\n运行语句效果如下：\n\n\n\n\n使用数据库#\n\n数据库创建好了，要在数据库中创建表，得先明确在哪儿个数据库中操作，此时就需要使用数据库。\n\n * 使用数据库\n\n\n\n * 查看当前使用的数据库\n\n\n\n运行语句效果如下：\n\n","routePath":"/up/mysql/ddl","lang":"","toc":[{"text":"DDL:操作数据库","id":"ddl操作数据库","depth":2,"charIndex":-1},{"text":"查询","id":"查询","depth":2,"charIndex":53},{"text":"创建数据库","id":"创建数据库","depth":2,"charIndex":133},{"text":"删除数据库","id":"删除数据库","depth":2,"charIndex":357},{"text":"使用数据库","id":"使用数据库","depth":2,"charIndex":415}],"domain":"","frontmatter":{"icon":"mysql","order":4,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"DDL:操作数据库"},"version":""},{"id":493,"title":"DDL:操作表","content":"DDL:操作表#\n\n操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。\n\n\n查询表#\n\n * 查询当前数据库下所有表名称\n\n我们创建的数据库中没有任何表，因此我们进入 mysql 自带的 mysql 数据库，执行上述语句查看\n\n\n\n * 查询表结构\n\n查看 mysql 数据库中 func 表的结构，运行语句如下：\n\n\n\n\n创建表#\n\n * 创建表\n\n\n\n> 注意：最后一行末尾，不能加逗号\n\n知道了创建表的语句，那么我们创建创建如下结构的表\n\n\n\n\n\n运行语句如下：\n\n\n\n\n数据类型#\n\nMySQL 支持多种类型，可以分为三类：\n\n * 数值\n   \n   \n\n * 日期\n   \n   \n\n * 字符串\n   \n   \n\n> 注意：其他类型参考资料中的《MySQL 数据类型].xlsx》\n\n案例：\n\n\n\n语句设计如下：\n\n\n\n\n删除表#\n\n * 删除表\n\n * 删除表时判断表是否存在\n\n运行语句效果如下：\n\n\n\n\n修改表#\n\n * 修改表名\n\n\n\n * 添加一列\n\n\n\n * 修改数据类型\n\n\n\n * 修改列名和数据类型\n\n\n\n * 删除列\n\n","routePath":"/up/mysql/ddltable","lang":"","toc":[{"text":"DDL:操作表","id":"ddl操作表","depth":2,"charIndex":-1},{"text":"查询表","id":"查询表","depth":2,"charIndex":61},{"text":"创建表","id":"创建表","depth":2,"charIndex":185},{"text":"数据类型","id":"数据类型","depth":2,"charIndex":262},{"text":"删除表","id":"删除表","depth":2,"charIndex":391},{"text":"修改表","id":"修改表","depth":2,"charIndex":435}],"domain":"","frontmatter":{"icon":"mysql","order":5,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"DDL:操作表"},"version":""},{"id":494,"title":"数据库设计","content":"数据库设计#\n\n\n数据库设计简介#\n\n * 软件的研发步骤\n   \n   \n\n * 数据库设计概念\n   \n   * 数据库设计就是根据业务系统的具体需求，结合我们所选用的 DBMS，为这个业务系统构造出最优的数据存储模型。\n   * 建立数据库中的==表结构==以及==表与表之间的关联关系==的过程。\n   * 有哪些表？表里有哪些字段？表和表之间有什么关系？\n\n * 数据库设计的步骤\n   \n   * 需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）\n   \n   * 逻辑分析（通过 ER 图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）\n     \n     如下图就是 ER(Entity/Relation)图：\n     \n     \n   \n   * 物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）\n   \n   * 维护设计（1.对新的需求进行建表；2.表优化）\n\n * 表关系\n   \n   * 一对一\n     \n     * 如：用户 和 用户详情\n     * 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能\n     \n     \n     \n     上图左边是用户的详细信息，而我们真正在展示用户信息时最长用的则是上图右边红框所示，所以我们会将详细信息查分成两周那个表。\n   \n   * 一对多\n     \n     * 如：部门 和 员工\n     \n     * 一个部门对应多个员工，一个员工对应一个部门。如下图：\n       \n       \n   \n   * 多对多\n     \n     * 如：商品 和 订单\n     \n     * 一个商品对应多个订单，一个订单包含多个商品。如下图：\n       \n       \n\n\n表关系(一对多)#\n\n * 一对多\n   \n   * 如：部门 和 员工\n   * 一个部门对应多个员工，一个员工对应一个部门。\n\n * 实现方式\n   \n   ==在多的一方建立外键，指向一的一方的主键==\n\n * 案例\n   \n   我们还是以 员工表 和 部门表 举例:\n   \n   \n   \n   经过分析发现，员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：\n   \n   \n   \n   建表语句如下：\n   \n   \n   \n   查看表结构模型图：\n   \n   \n\n\n表关系(多对多)#\n\n * 多对多\n   \n   * 如：商品 和 订单\n   * 一个商品对应多个订单，一个订单包含多个商品\n\n * 实现方式\n   \n   ==建立第三张中间表，中间表至少包含两个外键，分别关联两方主键==\n\n * 案例\n   \n   我们以 订单表 和 商品表 举例：\n   \n   \n   \n   经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键：\n   \n   \n   \n   建表语句如下：\n   \n   \n\n\n\n\n\n\n\n\n数据库设计案例#\n\n根据下图设计表及表和表之间的关系：\n\n\n\n经过分析，我们分为 专辑表 曲目表 短评表 用户表 4 张表。\n\n\n\n一个专辑可以有多个曲目，一个曲目只能属于某一张专辑，所以专辑表和曲目表的关系是==一对多==。\n\n一个专辑可以被多个用户进行评论，一个用户可以对多个专辑进行评论，所以专辑表和用户表的关系是 ==多对多==。\n\n一个用户可以发多个短评，一个短评只能是某一个人发的，所以用户表和短评表的关系是 ==一对多==。\n\n","routePath":"/up/mysql/design","lang":"","toc":[{"text":"数据库设计","id":"数据库设计","depth":2,"charIndex":-1},{"text":"数据库设计简介","id":"数据库设计简介","depth":2,"charIndex":8},{"text":"表关系(一对多)","id":"表关系一对多","depth":2,"charIndex":789},{"text":"表关系(多对多)","id":"表关系多对多","depth":2,"charIndex":1067},{"text":"数据库设计案例","id":"数据库设计案例","depth":2,"charIndex":1331}],"domain":"","frontmatter":{"icon":"mysql","order":8,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"数据库设计"},"version":""},{"id":495,"title":"DML","content":"DML 主要是对数据进行增（insert）删（delete）改（update）操作。\n\n\n添加数据#\n\n\n给指定列添加数据#\n\n\n\n\n给全部列添加数据#\n\n\n\n\n批量添加数据#\n\n\n\n\n练习#\n\n为了演示以下的增删改操作是否操作成功，故先将查询所有数据的语句介绍给大家：\n\n\n\n-- 给指定列添加数据\n\n\n\n-- 给所有列添加数据，列名的列表可以省略的\n\n\n\n-- 批量添加数据\n\n\n\n\n修改数据#\n\n\n修改表数据#\n\n\n\n注意：\n\n修改语句中如果不加条件，则将所有数据都修改！像上面的语句中的中括号，表示在写 sql 语句中可以省略这部分练习\n\n将张三的性别改为女\n\n\n\n将张三的生日改为 1999-12-12 分数改为 99.99\n\n\n\n\n\n上面语句的执行完后查询到的结果是：\n\n\n\n\n删除数据#\n\n\n\n练习\n\n-- 删除张三记录\n\n\n\n-- 删除 stu 表中所有的数据\n\n","routePath":"/up/mysql/dml","lang":"","toc":[{"text":"添加数据","id":"添加数据","depth":2,"charIndex":44},{"text":"给指定列添加数据","id":"给指定列添加数据","depth":3,"charIndex":52},{"text":"给全部列添加数据","id":"给全部列添加数据","depth":3,"charIndex":66},{"text":"批量添加数据","id":"批量添加数据","depth":3,"charIndex":80},{"text":"练习","id":"练习","depth":3,"charIndex":92},{"text":"修改数据","id":"修改数据","depth":2,"charIndex":193},{"text":"修改表数据","id":"修改表数据","depth":3,"charIndex":201},{"text":"删除数据","id":"删除数据","depth":2,"charIndex":344}],"domain":"","frontmatter":{"icon":"mysql","order":6,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"DML"},"version":""},{"id":496,"title":"mysql","content":" * 数据库相关概念\n\n * MySQL 安装\n\n * SQL 概述\n\n * DDL:操作数据库\n\n * DDL:操作表\n\n * dml\n\n * 约束\n\n * 数据库设计","routePath":"/up/mysql/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"mysql","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"mysql","index":false,"dir":{"order":1}},"version":""},{"id":497,"title":"数据库相关概念","content":"数据库相关概念#\n\n今日目标：\n\n>  * 完成 MySQL 的安装及登陆基本操作\n>  * 能通过 SQL 对数据库进行 CRUD\n>  * 能通过 SQL 对表进行 CRUD\n>  * 能通过 SQL 对数据进行 CRUD\n\n以前我们做系统，数据持久化的存储采用的是文件存储。存储到文件中可以达到系统关闭数据不会丢失的效果，当然文件存储也有它的弊端。\n\n假设在文件中存储以下的数据：\n\n\n\n现要修改李四这条数据的性别数据改为男，我们现学习的 IO\n技术可以通过将所有的数据读取到内存中，然后进行修改再存到该文件中。通过这种方式操作存在很大问题，现在只有三条数据，如果文件中存储 1T\n的数据，那么就会发现内存根本就存储不了。\n\n现需要既能持久化存储数据，也要能避免上述问题的技术使用在我们的系统中。数据库就是这样的一门技术。\n\n\n数据库#\n\n * ==存储和管理数据的仓库，数据是有组织的进行存储。==\n\n * 数据库英文名是 DataBase，简称 DB。\n\n数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。那又是如何解决上述问题的？使用数据库管理系统。\n\n\n数据库管理系统#\n\n * ==管理数据库的大型软件==\n * 英文：DataBase Management System，简称 DBMS\n\n在电脑上安装了数据库管理系统后，就可以通过数据库管理系统创建数据库来存储数据，也可以通过该系统对数据库中的数据进行数据的增删改查相关的操作。我们平时说的\nMySQL 数据库其实是 MySQL 数据库管理系统。\n\n\n\n通过上面的描述，大家应该已经知道了 数据库管理系统 和 数据库 的关系。那么有有哪些常见的数据库管理系统呢？\n\n\n常见的数据库管理系统#\n\n\n\n接下来对上面列举的数据库管理系统进行简单的介绍：\n\n * Oracle：收费的大型数据库，Oracle 公司的产品\n * ==MySQL==： 开源免费的中小型数据库。后来 Sun 公司收购了 MySQL，而 Sun 公司又被 Oracle 收购\n * SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用\n * PostgreSQL：开源免费中小型的数据库\n * DB2：IBM 公司的大型收费数据库产品\n * SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库\n * MariaDB：开源免费中小型的数据库\n\n我们课程上学习的是 MySQL 数据库管理系统，PostgreSQL 在一些公司也有使用，此时大家肯定会想以后在公司中如果使用我们没有学习过程的\nPostgreSQL 数据库管理系统怎么办？这点大家大可不必担心，如下图所示：\n\n\n\n我们可以通过数据库管理系统操作数据库，对数据库中的数据进行增删改查操作，而怎么样让用户跟数据库管理系统打交道呢？就可以通过一门编程语言（SQL）来实现。\n\n\nSQL#\n\n * 英文：Structured Query Language，简称 SQL，结构化查询语言\n * 操作关系型数据库的编程语言\n * 定义操作所有关系型数据库的统一标准，可以使用 SQL 操作所有的关系型数据库管理系统，以后工作中如果使用到了其他的数据库管理系统，也同样的使用 SQL\n   来操作。","routePath":"/up/mysql/init","lang":"","toc":[{"text":"数据库相关概念","id":"数据库相关概念","depth":2,"charIndex":-1},{"text":"数据库","id":"数据库","depth":2,"charIndex":366},{"text":"数据库管理系统","id":"数据库管理系统","depth":2,"charIndex":486},{"text":"常见的数据库管理系统","id":"常见的数据库管理系统","depth":2,"charIndex":721},{"text":"SQL","id":"sql","depth":2,"charIndex":1219}],"domain":"","frontmatter":{"icon":"mysql","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","index":true,"title":"数据库相关概念"},"version":""},{"id":498,"title":"MySQL 安装","content":"MySQL 安装#\n\n\nMySQL 安装#\n\n> 安装环境:Win10 64 位 > 软件版本:MySQL 5.7.24 解压版\n\n\n下载#\n\nhttps://downloads.mysql.com/archives/community/\n\n点开上面的链接就能看到如下界面：\n\n\n\n选择选择和自己系统位数相对应的版本点击右边的Download，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：\n\n\n\n不用理会上面的登录和注册按钮，直接点击 No thanks, just start my download. 就可以下载。\n\n\n\n\n安装(解压)#\n\n下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到 MySQL 5.7.24 的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。\n\n--------------------------------------------------------------------------------\n\n\n\n\nMySQL 卸载#\n\n如果你想卸载 MySQL，也很简单。\n\n右键开始菜单，选择命令提示符(管理员)，打开黑框。\n\n 1. 敲入net stop mysql，回车。\n\n\n\n 2. 再敲入mysqld -remove mysql，回车。\n\n\n\n 3. 最后删除 MySQL 目录及相关的环境变量。\n\n至此，MySQL 卸载完成！\n\n\nMySQL 配置#\n\n\n添加环境变量#\n\n> 环境变量里面有很多选项，这里我们只用到Path这个参数。为什么在初始化的开始要添加环境变量呢？ 在黑框(即\n> CMD)中输入一个可执行程序的名字，Windows\n> 会先在环境变量中的Path所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一\n> 个黑框直接调用 MySQL 中的相关程序而不用总是修改工作目录，大大简化了操作。\n\n右键此电脑→属性，点击高级系统设置\n\n\n\n点击环境变量\n\n\n\n在系统变量中新建 MYSQL_HOME\n\n\n\n在系统变量中找到并双击Path\n\n\n\n点击新建\n\n\n\n最后点击确定。\n\n如何验证是否添加成功？\n\n右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。 如果提示Can't connect to MySQL server\non 'localhost'则证明添加成功； 如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。\n\n\n新建配置文件#\n\n新建一个文本文件，内容如下：\n\n\n\n把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为 MySQL\n的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的 MySQL 目录位置修改)。\n\n\n\n\n\n上面代码意思就是配置数据库的默认编码集为 utf-8 和默认存储引擎为 INNODB。\n\n\n初始化 MySQL#\n\n在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明 data\n目录初始化没有问题，此时再查看 MySQL 目录下已经有 data 目录生成。\n\n\n\n\n\ntips：如果出现如下错误\n\n\n\n是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe\n\n\n\n\n\n\n注册 MySQL 服务#\n\n在黑框里敲入mysqld -install，回车。\n\n\n\n现在你的计算机上已经安装好了 MySQL 服务了。\n\nMySQL 服务器\n\n\n启动 MySQL 服务#\n\n在黑框里敲入net start mysql，回车。\n\n\n\n\n\n\n修改默认账户密码#\n\n在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即 root\n账户)的密码，可以自行修改成你喜欢的。\n\n\n\n\n\n至此，MySQL 5.7 解压版安装完毕！\n\n\n退出#\n\n退出 mysql：\n\n\nMySQL 数据模型#\n\n关系型数据库：\n\n> 关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表 组成的数据库\n\n如下图，订单信息表 和 客户信息表 都是有行有列二维表我们将这样的称为关系型数据库。\n\n\n\n接下来看关系型数据库的优点：\n\n * 都是使用表结构，格式一致，易于维护。\n * 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。\n   * 关系型数据库都可以通过 SQL 进行操作，所以使用方便。\n   * 复杂查询。现在需要查询 001 号订单数据，我们可以看到该订单是 1 号客户的订单，而 1\n     号订单是李聪这个客户。以后也可以在一张表中进行统计分析等操作。\n * 数据存储在磁盘中，安全。\n\n数据模型：\n\n\n\n如上图，我们通过客户端可以通过数据库管理系统创建数据库，在数据库中创建表，在表中添加数据。创建的每一个数据库对应到磁盘上都是一个文件夹。比如可以通过 SQL\n语句创建一个数据库（数据库名称为 db1），语句如下。该语句咱们后面会学习。\n\n\n\n我们可以在数据库安装目录下的 data 目录下看到多了一个 db1 的文件夹。所以，在 MySQL 中一个数据库对应到磁盘上的一个文件夹。\n\n而一个数据库下可以创建多张表，我们到 MySQL 中自带的 mysql 数据库的文件夹目录下：\n\n\n\n而上图中右边的 db.frm 是表文件，db.MYD 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。\n\n小结：\n\n * MySQL 中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹\n * 在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件\n * 每张表可以存储多条数据，数据会被存储到磁盘中 MYD 文件中","routePath":"/up/mysql/install","lang":"","toc":[{"text":"MySQL 安装","id":"mysql-安装","depth":2,"charIndex":11},{"text":"MySQL 安装","id":"mysql-安装-1","depth":2,"charIndex":-1},{"text":"下载","id":"下载","depth":3,"charIndex":66},{"text":"安装(解压)","id":"安装解压","depth":3,"charIndex":275},{"text":"MySQL 卸载","id":"mysql-卸载","depth":3,"charIndex":446},{"text":"MySQL 配置","id":"mysql-配置","depth":2,"charIndex":612},{"text":"添加环境变量","id":"添加环境变量","depth":3,"charIndex":624},{"text":"新建配置文件","id":"新建配置文件","depth":3,"charIndex":1106},{"text":"初始化 MySQL","id":"初始化-mysql","depth":3,"charIndex":1301},{"text":"注册 MySQL 服务","id":"注册-mysql-服务","depth":3,"charIndex":1505},{"text":"启动 MySQL 服务","id":"启动-mysql-服务","depth":3,"charIndex":1587},{"text":"修改默认账户密码","id":"修改默认账户密码","depth":3,"charIndex":1633},{"text":"退出","id":"退出","depth":3,"charIndex":1755},{"text":"MySQL 数据模型","id":"mysql-数据模型","depth":3,"charIndex":1772}],"domain":"","frontmatter":{"icon":"mysql","order":2,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"MySQL 安装"},"version":""},{"id":499,"title":"多表查询","content":"#\n\n多表查询是从多张表中一次性的查询出我们想要的数据","routePath":"/up/mysql/multi-table-queries","lang":"","toc":[],"domain":"","frontmatter":{"icon":"mysql","order":9,"date":"2022-12-14T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"多表查询"},"version":""},{"id":500,"title":"SQL概述","content":"SQL 概述#\n\n了解了数据模型后，接下来我们就学习 SQL 语句，通过 SQL 语句对数据库、表、数据进行增删改查操作。\n\n\nSQL 简介#\n\n * 英文：Structured Query Language，简称 SQL\n * 结构化查询语言，一门操作关系型数据库的编程语言\n * 定义操作所有关系型数据库的统一标准\n * 对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”\n\n\n通用语法#\n\n * SQL 语句可以单行或多行书写，以分号结尾。\n   \n   \n   \n   如上，以分号结尾才是一个完整的 sql 语句。\n\n * MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\n   \n   同样的一条 sql 语句写成下图的样子，一样可以运行处结果。\n   \n   \n\n * 注释\n   \n   * 单行注释: -- 注释内容 或 #注释内容(MySQL 特有)\n     \n     \n     \n     GFDWQ 111111111111111111111\n     \n     > 注意：使用-- 添加单行注释时，--后面一定要加空格，而#没有要求。\n   \n   * 多行注释: /* 注释 */\n\n\nSQL 分类#\n\n * DDL(Data Definition Language) ： 数据定义语言，用来定义数据库对象：数据库，表，列等\n   \n   DDL 简单理解就是用来操作数据库，表等\n   \n   \n\n * DML(Data Manipulation Language) 数据操作语言，用来对数据库中表的数据进行增删改\n   \n   DML 简单理解就对表中数据进行增删改\n   \n   \n\n * DQL(Data Query Language) 数据查询语言，用来查询数据库中表的记录(数据)\n   \n   DQL 简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。\n\n * DCL(Data Control Language) 数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户\n   \n   DML 简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。\n\n> 注意： 以后我们最常操作的是 DML 和 DQL ，因为我们开发中最常操作的就是数据。","routePath":"/up/mysql/sql","lang":"","toc":[{"text":"SQL 概述","id":"sql-概述","depth":2,"charIndex":-1},{"text":"SQL 简介","id":"sql-简介","depth":2,"charIndex":63},{"text":"通用语法","id":"通用语法","depth":2,"charIndex":206},{"text":"SQL 分类","id":"sql-分类","depth":2,"charIndex":536}],"domain":"","frontmatter":{"icon":"mysql","order":3,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"mysql","tag":"mysql","title":"SQL概述"},"version":""},{"id":501,"title":"navicat","content":"navicat 使用#\n\n通过上面的学习，我们发现在命令行中写 sql\n语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。\n\n\nnavicat 概述#\n\n * Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。\n * 这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。\n * 官网： http://www.navicat.com.cnopen in new window\n\n\nnavicat 安装#\n\n\nnavicat 使用#\n\n\n建立和 mysql 服务的连接#\n\n第一步： 点击连接，选择 MySQL\n\n\n\n第二步：填写连接数据库必要的信息\n\n\n\n以上操作没有问题就会出现如下图所示界面：\n\n\n\n\n操作#\n\n连接成功后就能看到如下图界面：\n\n\n\n * 修改表结构\n\n通过下图操作修改表结构：\n\n\n\n点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息：\n\n\n\n * 编写 SQL 语句并执行\n\n按照如下图所示进行操作即可书写 SQL 语句并执行 sql 语句。\n\n","routePath":"/up/navicat/README","lang":"","toc":[{"text":"navicat 使用","id":"navicat-使用","depth":2,"charIndex":281},{"text":"navicat 概述","id":"navicat-概述","depth":2,"charIndex":107},{"text":"navicat 安装","id":"navicat-安装","depth":2,"charIndex":267},{"text":"navicat 使用","id":"navicat-使用-1","depth":2,"charIndex":-1},{"text":"建立和 mysql 服务的连接","id":"建立和-mysql-服务的连接","depth":3,"charIndex":295},{"text":"操作","id":"操作","depth":3,"charIndex":380}],"domain":"","frontmatter":{"icon":"navigate","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"navicat","tag":"navicat","title":"navicat"},"version":""},{"id":502,"title":"navicat","content":"navicat 使用#\n\n通过上面的学习，我们发现在命令行中写 sql\n语句特别不方便，尤其是编写创建表的语句，我们只能在记事本上写好后直接复制到命令行进行执行。那么有没有刚好的工具提供给我们进行使用呢？ 有。\n\n\nnavicat 概述#\n\n * Navicat for MySQL 是管理和开发 MySQL 或 MariaDB 的理想解决方案。\n * 这套全面的前端工具为数据库管理、开发和维护提供了一款直观而强大的图形界面。\n * 官网： http://www.navicat.com.cnopen in new window\n\n\nnavicat 安装#\n\n\nnavicat 使用#\n\n\n建立和 mysql 服务的连接#\n\n第一步： 点击连接，选择 MySQL\n\n\n\n第二步：填写连接数据库必要的信息\n\n\n\n以上操作没有问题就会出现如下图所示界面：\n\n\n\n\n操作#\n\n连接成功后就能看到如下图界面：\n\n\n\n * 修改表结构\n\n通过下图操作修改表结构：\n\n\n\n点击了设计表后即出现如下图所示界面，在图中红框中直接修改字段名，类型等信息：\n\n\n\n * 编写 SQL 语句并执行\n\n按照如下图所示进行操作即可书写 SQL 语句并执行 sql 语句。\n\n","routePath":"/up/navicat/","lang":"","toc":[{"text":"navicat 使用","id":"navicat-使用","depth":2,"charIndex":281},{"text":"navicat 概述","id":"navicat-概述","depth":2,"charIndex":107},{"text":"navicat 安装","id":"navicat-安装","depth":2,"charIndex":267},{"text":"navicat 使用","id":"navicat-使用-1","depth":2,"charIndex":-1},{"text":"建立和 mysql 服务的连接","id":"建立和-mysql-服务的连接","depth":3,"charIndex":295},{"text":"操作","id":"操作","depth":3,"charIndex":380}],"domain":"","frontmatter":{"icon":"navigate","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"navicat","tag":"navicat","title":"navicat"},"version":""},{"id":503,"title":"高可用配置","content":"高可用配置#\n\n\n安装 Keepalived#\n\n\n编译安装#\n\n下载地址 open in new window\n\n使用 ./configure 编译安装\n\n如遇报错提示\n\n\n\n安装依赖\n\n\n\n\nyum 安装#\n\n\n配置#\n\n使用 yum 安装后配置文件在:/etc/keepalived/keepalived.conf\n\n\n最小配置#\n\n * 第一台机器\n\n\n\n * 第二台机器\n\n\n\n * 启动服务\n\n","routePath":"/up/nginx/Keepalived","lang":"","toc":[{"text":"高可用配置","id":"高可用配置","depth":2,"charIndex":-1},{"text":"安装 Keepalived","id":"安装-keepalived","depth":2,"charIndex":8},{"text":"编译安装","id":"编译安装","depth":3,"charIndex":25},{"text":"yum 安装","id":"yum-安装","depth":3,"charIndex":97},{"text":"配置","id":"配置","depth":2,"charIndex":107},{"text":"最小配置","id":"最小配置","depth":3,"charIndex":162}],"domain":"","frontmatter":{"icon":"nginx","order":5,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"高可用配置"},"version":""},{"id":504,"title":"nginx","content":" * 安装\n\n * 目录\n\n * 配置与应用场景\n\n * 反向代理与负载均衡\n\n * 高可用配置\n\n * Https 证书配置\n\n * 多域名转发","routePath":"/up/nginx/README","lang":"","toc":[],"domain":"","frontmatter":{"icon":"nginx","author":"h7ml","category":"nginx","tag":"nginx","title":"nginx","index":false,"dir":{"order":10},"date":"2022-03-20T00:00:00.000Z"},"version":""},{"id":505,"title":"Https 证书配置","content":"Https 证书配置#\n\n\n不安全的 http 协议#\n\nhttp 在传输的过程中都是明文，这导致在客户端到服务器请求的过程中会被拦截数据导致数据泄露。\n\n\n对称加密#\n\n\n\n对称加密可以通过加密算法给数据进行安全一点的加密，但是这样也很容易破解。\n\n * 客户端使用加密算法对数据进行加密\n * 服务端通过相同加密算法对数据进行解密\n\n这样一来就完成了一次加密请求。\n\n但是如果加密算法泄露了，这样一来拦截者就可以对数据进行篡改了，因为客户端的代码都是开源的，他通过去解读加密算法的代码就可以获取到。\n\n\n非对称加密#\n\n\n\n非对称加密就是在客户端中有一把公钥（理解成一窜字符），在服务端有一把私钥。\n\n * 在客户端第一次请求服务器时，服务器会返回一把公钥。\n * 客户端通过公钥给数据加密进行请求数据，服务器通过私钥对数据进行解密**（公钥是公开大家都能看到的）**。\n * 服务端通过私钥解密后在用私钥加密要返回的数据，在返回给客户端，客户端在通过公钥进行解密**（私钥只有服务端知道）**。\n\n> 这种加密一定要满足一个条件，公钥加密公钥解不开，且私钥不能泄露。\n\n但即使是这样也有是有漏洞的：\n\n * 例如我在你客户端请求的过程中让你请求我的服务器（反向代理），然后我带着你请求的参数去请求你的后端服务器。\n * 之后我将服务器返回的公钥存储起来，然后我伪造一个公钥给你。\n * 当你在请求的时候就是用的我给你的公钥加密的，这样一来我就可以通过我的私钥进行解密拿到明文数据。\n * 然后我将拿到的数据在通过存储的服务器返回的公钥进行加密，返回给服务器。\n * 这样一来就完成了数据的拦截。\n\n所有不管是对称加密还是非对称加密都是不安全的。\n\n\nCA 证书#\n\n\n\n通过上述的对称加密和非对称加密，我们知道不管是哪种在网络传输过程中都会被人给拦截篡改，所以都不安全，为了解决这一问题就有了CA 证书这么一个认证机构。\n\n首先他是怎么工作的：\n\n * 在服务器下发公钥时，服务器会提交一些资料（这个资料是在服务器的某个目录下的文件）给 CA 机构来验证身份。\n * 身份验证成功后会CA 机构会将服务器提交的公钥进行加密，通过CA.私钥加算法来生成一个证书。\n * 之后服务器就不会将公钥下发给客户端了，而是把证书给客户端。\n   * 这里在服务器下发证书的过程中，也是可以被拦截者给篡改的，也是可以解开的。\n   * 但如果拦截者解开了证书拿到了公钥，在对公钥进行加密返回给客户端，但这样是无法认证成功的，因为CA 的私钥是一种特殊的私钥，他是操作系统内置的私钥，CA\n     认证机构是不在网络中传输的，所以只要你篡改了，客户端和 CA 机构都是不认的。\n * 客户端拿到证书后通过CA 的公钥进行解密得到服务器的公钥。\n\n操作系统内置的证书：\n\nWindows：cmd 输入 certmgr.msc\n\n\n\n这里有你所有的证书包括第三方下载的证书都在这。\n\n\n证书安装#\n\n腾讯云 open in new window\n\n\n已安装的 Nginx 上开启 SSL 模块并配置 https#\n\n安装目录是 /usr/local/nginx，\n\n源码解压目录是 /usr/local/src/nginx-1.22.0\n\n1、切换到 Nginx 安装目录下的 sbin 目录\n\n\n\n2、将 Nginx 停止运行\n\n3、切换到源码解压目录\n\n\n\n4、查看 Nginx 原有的模块配置\n\n\n\n5、在**configure arguments:**后面显示的原有的 configure 参数如下：\n\n\n\n\n\n6、在已有的配置基础上新增 **--with-http_ssl_module，**形成新的配置命令，并在源码目录运行下面的命令\n\n\n\n7、配置完成后，继续运行命令 make\n\n切记：这里不要进行 make install，否则就是覆盖安装\n\n8、备份原有已安装好的 nginx 文件\n\n\n\n9、将刚刚编译好的 nginx 文件覆盖掉原有的 nginx\n\n\n\n10、查看是否已经加入成功\n\n\n\n此时看到 ssl 模块已经被加载\n\n\n\n\n\n11、配置 https Server\n\n\n\n12、启动 Nginx，访问 https 域名，即可访问成功。\n\n","routePath":"/up/nginx/https","lang":"","toc":[{"text":"Https 证书配置","id":"https-证书配置","depth":2,"charIndex":-1},{"text":"不安全的 http 协议","id":"不安全的-http-协议","depth":2,"charIndex":13},{"text":"对称加密","id":"对称加密","depth":3,"charIndex":78},{"text":"非对称加密","id":"非对称加密","depth":3,"charIndex":253},{"text":"CA 证书","id":"ca-证书","depth":2,"charIndex":727},{"text":"证书安装","id":"证书安装","depth":2,"charIndex":1236},{"text":"已安装的 Nginx 上开启 SSL 模块并配置 https","id":"已安装的-nginx-上开启-ssl-模块并配置-https","depth":2,"charIndex":1268}],"domain":"","frontmatter":{"icon":"nginx","order":6,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"Https 证书配置"},"version":""},{"id":506,"title":"nginx","content":" * 安装\n\n * 目录\n\n * 配置与应用场景\n\n * 反向代理与负载均衡\n\n * 高可用配置\n\n * Https 证书配置\n\n * 多域名转发","routePath":"/up/nginx/","lang":"","toc":[],"domain":"","frontmatter":{"icon":"nginx","author":"h7ml","category":"nginx","tag":"nginx","title":"nginx","index":false,"dir":{"order":10},"date":"2022-03-20T00:00:00.000Z"},"version":""},{"id":507,"title":"安装","content":"安装#\n\n\n版本区别#\n\n常用版本分为四大阵营\n\n * Nginx 开源版 open in new window\n\n * Nginx plus 商业版 open in new window\n\n * openrestyopen in new window\n\n * Tengineopen in new window\n\nNginx 的安装可以选择源码编译的方式也可以使用宝塔面板安装，本文采用的是源码编译安装。\n\n\n下载 Nginx#\n\n\n\n\n使用源码编译安装#\n\n\n\n\n\n\n如果出现警告或报错#\n\n提示：\n\n\n\n安装 gcc\n\n\n\n提示：\n\n\n\n安装 perl 库\n\n\n\n提示：\n\n\n\n安装 zlib 库:\n\n\n\n出现这个代表安装成功\n\n\n\n\n接下来执行#\n\n\n\n\n启动 nginx#\n\n进入安装好的目录 /usr/local/nginx/sbin\n\n\n\n\n关于防火墙#\n\n关闭防火墙\n\n\n\n禁止防火墙开机启动\n\n\n\n放行端口\n\n\n\n重启防火墙\n\n\n\n\n安装成系统服务#\n\n创建服务脚本\n\n\n\n服务脚本内容\n\n\n\n重新加载系统服务\n\n\n\n启动服务\n\n\n\n查看服务是否启动成功\n\n\n\n\n\n开机启动\n\n","routePath":"/up/nginx/install","lang":"","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":-1},{"text":"版本区别","id":"版本区别","depth":2,"charIndex":5},{"text":"下载 Nginx","id":"下载-nginx","depth":2,"charIndex":205},{"text":"使用源码编译安装","id":"使用源码编译安装","depth":2,"charIndex":219},{"text":"如果出现警告或报错","id":"如果出现警告或报错","depth":3,"charIndex":235},{"text":"**接下来执行**","id":"接下来执行","depth":3,"charIndex":-1},{"text":"**启动 nginx**","id":"启动-nginx","depth":3,"charIndex":-1},{"text":"关于防火墙","id":"关于防火墙","depth":3,"charIndex":377},{"text":"安装成系统服务","id":"安装成系统服务","depth":3,"charIndex":425}],"domain":"","frontmatter":{"icon":"nginx","order":1,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"安装"},"version":""},{"id":508,"title":"目录","content":"目录#\n\n\n目录结构#\n\n进入 Nginx 的主目录我们可以看到这些文件夹\n\n\n\n其中这几个文件夹在刚安装后是没有的，主要用来存放运行过程中的临时文件\n\n * client_body_temp\n * fastcgi_temp\n * proxy_temp\n * scgi_temp\n\nconf\n\n * 用来存放配置文件相关\n\nhtml\n\n * 用来存放静态文件的默认目录 html、css 等\n\nsbin\n\n * nginx 的主程序\n\n\n基本运行原理#\n\n","routePath":"/up/nginx/mkdir","lang":"","toc":[{"text":"目录","id":"目录","depth":2,"charIndex":-1},{"text":"目录结构","id":"目录结构","depth":2,"charIndex":5},{"text":"基本运行原理","id":"基本运行原理","depth":2,"charIndex":218}],"domain":"","frontmatter":{"icon":"nginx","order":2,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"目录"},"version":""},{"id":509,"title":"nginx多域名转发配置","content":"Nginx 是一个高性能的 Web\n服务器和反向代理服务器。它可以用来配置多个域名和路由规则，将请求转发到不同的后端服务器或者处理请求本身。在这篇文章中，我们将讨论如何使用 Nginx\n配置多域名转发。\n\n假设我们有两个域名，分别是 example.com 和 example.net。我们希望将这两个域名分别转发到不同的后端服务器上。我们需要进行以下步骤：\n\n\n1. 安装 Nginx#\n\n首先，我们需要在服务器上安装 Nginx。在 Linux 系统中，可以使用 apt-get 或 yum\n等包管理器进行安装。安装完成后，我们可以使用以下命令来检查 Nginx 是否已经启动：\n\n\n\n\n2. 配置 Nginx#\n\n接下来，我们需要配置 Nginx，让它能够转发请求。打开 Nginx 的配置文件，一般在/etc/nginx/nginx.conf 中。在 http\n块中添加以下代码：\n\n\n\n接下来，我们需要配置 Nginx，让它能够转发请求。打开 Nginx 的配置文件，一般在/etc/nginx/nginx.conf 中。在 http\n块中添加以下代码：\n\n\n\n在上面的代码中，我们定义了两个 server 块，分别对应 example.com 和 example.net 的请求。其中 listen 80 表示监听 80\n端口，server_name 表示该 server 块所对应的域名，location /表示处理根路径下的请求。在 location 块中，我们使用了\nproxy_pass 指令将请求转发到对应的后端服务器。\n\n在最后的 upstream 块中，我们定义了两个后端服务器的地址。这些地址可以是 IP 地址或者域名。\n\n\n3. 重启 Nginx#\n\n修改完成配置文件后，我们需要重启 Nginx，使配置生效。使用以下命令重启 Nginx：\n\n\n\n\n4. 测试转发#\n\n现在，我们可以使用浏览器访问 example.com 和 example.net 来测试转发是否生效。如果一切顺利，请求应该会被转发到对应的后端服务器上。\n\n\n总结#\n\n在本文中，我们介绍了如何使用 Nginx 配置多域名转发。通过配置 Nginx 的 server 块和 upstream\n块，我们可以将请求转发到不同的后端服务器上。如果您需要更复杂的路由规则，可以参考 Nginx 官方文档和在线社区的资源。","routePath":"/up/nginx/multiDomainForwarding","lang":"","toc":[{"text":"1. 安装 Nginx","id":"1-安装-nginx","depth":3,"charIndex":181},{"text":"2. 配置 Nginx","id":"2-配置-nginx","depth":3,"charIndex":295},{"text":"3. 重启 Nginx","id":"3-重启-nginx","depth":3,"charIndex":726},{"text":"4. 测试转发","id":"4-测试转发","depth":3,"charIndex":789},{"text":"总结","id":"总结","depth":3,"charIndex":879}],"domain":"","frontmatter":{"icon":"nginx","order":7,"date":"2023-03-04T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"nginx多域名转发配置"},"version":""},{"id":510,"title":"反向代理与负载均衡","content":"反向代理与负载均衡#\n\n\n反向代理#\n\n当用户不能直接访问应用服务器时候，这时候就通过Nginx去带着你的参数去访问应用服务器，之后在把数据返回给网关（路由器），在由网关把数据传输到用户。\n\n\n\n\n正向代理#\n\n如果把外网的Internet想象成一个巨大的资源库，则内网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理，下面是正向代\n理的原理图。\n\n由于工作环境原因，日常工作只能局限于单位的局域网，如果想要访问互联网，怎么办呢？这就需要用到正向代理，本人经常用正向代理来进行上网。\n\n\n\n\n传统公司系统架构#\n\n\n\n\n\n\n\n\n\n\n\n\n反向代理设置#\n\n修改nginx.conf 配置。\n\n> 注意每个{}里面每一行结束都需写;。（坑）\n\n\n\n * proxy_pass: 可以设置具体的主机 ip，也可以设置完整的域名。\n\n * 设置域名时，一定要带上域名前缀\n\n例如www.atguigu.com和atguigu.com,意义就不一样了。\n\nproxy_pass http://www.atguigu.com/\n\n\n\nproxy_pass http://atguigu.com/\n\n\n\n可以发现设置proxy_pass http://atguigu.com/后浏览器的地址拦就变了，不在是我们的 IP 站点而变成了代理的地址。\n\n * Status Code: 302 Moved Temporarily（临时重定向）\n * Location: http://www.atguigu.com/\n\n302 也就是临时重定向到另一个站点，这个站点就是 Location 的值。\n\n还有一点就是在代理 https 的域名如果也这么设置也会重定向，例如www.baidu.com，就是 https 协议的域名。\n\n\n\n这样设置也会重定向，后面会讲到 https 协议代理。\n\n\n负载均衡#\n\n\n什么是负载均衡#\n\n所谓负载均衡，就是 Nginx 把请求均匀的分摊给上游的应用服务器，这样即使某一个服务器宕机也不会影响请求的处理，或者当应用服务器扛不住了，可以随时进行扩容\n\n\n\n\n基于反向代理的负载均衡#\n\n\n\n\n负载均衡策略#\n\n\n轮询#\n\n默认情况下使用轮询方式，逐一转发，这种方式适用于无状态请求。\n\n\nweight(权重)#\n\n指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。\n\n\n\n * down：表示当前的 server 暂时不参与负载\n * weight：默认为 1.weight 越大，负载的权重就越大。\n * backup： 其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。\n\n轮询的弊端：无法保持会话\n\n\nip_hash#\n\n根据客户端的 ip 地址转发同一台服务器，可以保持回话。\n\n\nleast_conn#\n\n最少连接访问\n\n\nurl_hash#\n\n根据用户访问的 url 定向转发请求\n\n\nfair#\n\n根据后端服务器响应时间转发请求\n\n\n动静分离#\n\n配置反向代理#\n\n\n\n增加每一个 location#\n\n\n\n使用一个 location#\n\n使用正则\n\nlocation 前缀#\n\n选项   说明\n/    通用匹配，任何请求都会匹配到\n=    精准匹配，不是以指定模式开头\n~    正则匹配，区分大小写\n~*   正则匹配，不区分大小写\n^~   非正则匹配，匹配以指定模式开头的 location\n\nlocation 匹配顺序#\n\n * 多个正则 location 直接按书写顺序匹配，成功后就不会继续往后面匹配\n * 普通（非正则）location 会一直往下，直到找到匹配度最高的（最大前缀匹配）\n * 当普通 location 与正则 location 同时存在，如果正则匹配成功,则不会再执行普通匹配\n * 所有类型 location 存在时，“=”匹配 > “^~”匹配 > 正则匹配 > 普通（最大前缀匹配）\n\n\n\nalias 与 root#\n\n\n\nroot 用来设置根目录，而 alias 在接受请求的时候在路径上不会加上 location。\n\n * 1）alias 指定的目录是准确的，即 location 匹配访问的 path 目录下的文件直接是在 alias 目录下查找的；\n * 2）root 指定 的目录是 location 匹配访问的 path 目录的上一级目录,这个 path 目录一定要是真实存在 root 指定目录下的；\n * 3）使用 alias 标签的目录块中不能使用 rewrite 的 break（具体原因不明）；另外，alias 指定的目录后面必须要加上\"/\"符 号！！\n * 4）alias 虚拟目录配置中，location 匹配的 path 目录如果后面不带\"/\"，那么访问的 url 地址中这个 path 目录后\n   面加不加\"/\"不影响访问，访问时它会自动加上\"/\"； 但是如果 location 匹配的 path 目录后面加上\"/\"，那么访问的 url 地 址中这个\n   path 目录必须要加上\"/\"，访问时它不会自动加上\"/\"。如果不加上\"/\"，访问就会失败！\n * 5）root 目录配置 中，location 匹配的 path 目录后面带不带\"/\"，都不会影响访问。","routePath":"/up/nginx/proxy","lang":"","toc":[{"text":"反向代理与负载均衡","id":"反向代理与负载均衡","depth":2,"charIndex":-1},{"text":"反向代理","id":"反向代理","depth":2,"charIndex":12},{"text":"正向代理","id":"正向代理","depth":2,"charIndex":98},{"text":"传统公司系统架构","id":"传统公司系统架构","depth":2,"charIndex":265},{"text":"反向代理设置","id":"反向代理设置","depth":2,"charIndex":287},{"text":"负载均衡","id":"负载均衡","depth":2,"charIndex":806},{"text":"什么是负载均衡","id":"什么是负载均衡","depth":3,"charIndex":814},{"text":"基于反向代理的负载均衡","id":"基于反向代理的负载均衡","depth":3,"charIndex":907},{"text":"负载均衡策略","id":"负载均衡策略","depth":2,"charIndex":924},{"text":"轮询","id":"轮询","depth":3,"charIndex":934},{"text":"weight(权重)","id":"weight权重","depth":3,"charIndex":972},{"text":"ip_hash","id":"ip_hash","depth":3,"charIndex":1162},{"text":"least_conn","id":"least_conn","depth":3,"charIndex":1203},{"text":"url_hash","id":"url_hash","depth":3,"charIndex":1225},{"text":"fair","id":"fair","depth":3,"charIndex":1257},{"text":"动静分离","id":"动静分离","depth":3,"charIndex":1282},{"text":"配置反向代理","id":"配置反向代理","depth":4,"charIndex":1289},{"text":"增加每一个 location","id":"增加每一个-location","depth":4,"charIndex":1300},{"text":"使用一个 location","id":"使用一个-location","depth":4,"charIndex":1319}],"domain":"","frontmatter":{"icon":"nginx","order":4,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"反向代理与负载均衡"},"version":""},{"id":511,"title":"配置与应用场景","content":"配置与应用场景#\n\n\n域名解析#\n\n\n\n\n浏览器、Nginx 与 HTTP 协议#\n\n * 电脑拿到 IP 地址、首先会先发送 TCP/IP 协议（HTTP 或 HTTPS 协议在 TCP/IP 协议之上，TCP/IP 协议只能传输二进制数据）。\n * 在宽带（电信、联通、移动）的主干网上会进过很多个网关（也可以理解为路由器）。\n * 从家里的网关=>>小区的网关=>>服务商的网关=>>（电信、联通、移动）的网关=>>区域的网关=>>市里的网关=>>全国的总网关=>>最后才到主干网上。\n * HTTPS 就是在这个过程中给你是数据进行了加密。\n\n\n虚拟主机的原理#\n\n\n\n这样的话一台主机就可以给外界公布一个公网 IP，如果公网 IP 只绑定了一个 IP 地址上，这样就有可能会造成性能过剩，因为这一台主机不会时时的高访问。\n\n如果将多个域名绑定到一台主机上，在通过 Nginx 服务器来判断你访问的是哪一个域名，之后在返回给你对应的资源\n\n\n\n\n本地域名解析#\n\n找到本地主机的 hosts 文件 C:\\Windows\\System32\\drivers\\etc\n\n在最后加上：\n\nIP 地址 域名\n\n\n\n\n公网域名配置与泛域名解析#\n\n首先需要一个域名，购买渠道阿里云、腾讯云，这里已阿里云\n\n\n\n主机记录\n\n * 第一种：指定前缀的，例如 www 之类的。\n * 第二种：不填，例如我现在的域名是 gopeak.cn ,也会匹配到 www.gopeak.cn。\n * 第三种：填 *（通配符），这样所有的二级，三级等域名都会匹配到当前主机上\n\n记录值：也就是主机名\n\n\n配置多个虚拟主机#\n\n域名设置\n\n\n\nNginx 设置\n\n\n\n\n最小配置#\n\nworker_processes#\n\n * worker_processes 1; 默认为 1，表示开启一个业务进程\n\nworker_connections#\n\n * worker_connections 1024; 单个业务进程可接受连接数\n\ninclude mime.types#\n\n * include mime.types; 引入http mime类型，在请求头中标明服务端给客户端返回的文件是什么类型的文件。\n\ndefault_type application/octet-stream#\n\n * default_type application/octet-stream; 如果mime类型没匹配上，默认使用二进制流的方式传输。\n\nsendfile on#\n\n * sendfile on; 使用linux的 sendfile(socket, file, len) 高效网络传输，也就是数据 0 拷贝。\n\n未开启sendfile\n\n\n\n开启sendfile后\n\n\n\nkeepalive_timeout 65#\n\n * keepalive_timeout 65;\n\nserver#\n\n\n\n\n虚拟主机配置#\n\n\n\n虚拟主机#\n\n原本一台服务器只能对应一个站点，通过虚拟主机技术可以虚拟化成多个站点同时对外提供服务\n\nservername 匹配规则#\n\n我们需要注意的是servername匹配分先后顺序，写在前面的匹配上就不会继续往下匹配了。\n\n完整匹配#\n\n我们可以在同一servername中匹配多个域名\n\n\n\n通配符匹配#\n\n通配符结束匹配#\n\n正则匹配#\n\n","routePath":"/up/nginx/virtualhost","lang":"","toc":[{"text":"配置与应用场景","id":"配置与应用场景","depth":2,"charIndex":-1},{"text":"域名解析","id":"域名解析","depth":2,"charIndex":10},{"text":"浏览器、Nginx 与 HTTP 协议","id":"浏览器nginx-与-http-协议","depth":3,"charIndex":20},{"text":"虚拟主机的原理","id":"虚拟主机的原理","depth":2,"charIndex":276},{"text":"本地域名解析","id":"本地域名解析","depth":3,"charIndex":426},{"text":"公网域名配置与泛域名解析","id":"公网域名配置与泛域名解析","depth":3,"charIndex":506},{"text":"配置多个虚拟主机","id":"配置多个虚拟主机","depth":3,"charIndex":689},{"text":"最小配置","id":"最小配置","depth":3,"charIndex":721},{"text":"worker_processes","id":"worker_processes","depth":4,"charIndex":728},{"text":"worker_connections","id":"worker_connections","depth":4,"charIndex":788},{"text":"include mime.types","id":"include-mimetypes","depth":4,"charIndex":851},{"text":"default_type application/octet-stream","id":"default_type-applicationoctet-stream","depth":4,"charIndex":939},{"text":"sendfile on","id":"sendfile-on","depth":4,"charIndex":1050},{"text":"keepalive_timeout 65","id":"keepalive_timeout-65","depth":4,"charIndex":-1},{"text":"server","id":"server","depth":4,"charIndex":1216},{"text":"虚拟主机配置","id":"虚拟主机配置","depth":3,"charIndex":1228},{"text":"虚拟主机","id":"虚拟主机","depth":4,"charIndex":1239},{"text":"servername 匹配规则","id":"servername-匹配规则","depth":4,"charIndex":1290},{"text":"完整匹配","id":"完整匹配","depth":4,"charIndex":1355},{"text":"通配符匹配","id":"通配符匹配","depth":4,"charIndex":1390},{"text":"通配符结束匹配","id":"通配符结束匹配","depth":4,"charIndex":1398},{"text":"正则匹配","id":"正则匹配","depth":4,"charIndex":1408}],"domain":"","frontmatter":{"icon":"nginx","order":3,"date":"2022-03-20T00:00:00.000Z","author":"h7ml","category":"nginx","tag":"nginx","title":"配置与应用场景"},"version":""},{"id":512,"title":"redis","content":"何谓主从复制#\n\n 1. redis 的主从复制就是我们设置一个 master 服务器，然后设置多个 slave\n    从服务器，主服务器存储着最新的数据，每次主服务器的数据出现变化的时候，都会将对应的命令传输到各个 slave\n    服务器，这样，我们就可以实现主服务器和从服务器的数据的同步了。\n 2. 为什么需要？在企业的开发中，主从复制可以避免单机故障导致的数据和服务的丢失，保障了数据安全和服务的稳定运行。\n 3. 一个 master 可以有多个 slave，一个 slave 也可以有多个 slave，这样，最终可以构成一棵树的结构。\n\n\n基本原理#\n\n 1. Redis 的复制分为同步和命令传播阶段。同步操作作用于从服务器将从服务器的数据状态更新为主服务器的数据状态。\n 2. 命令传播则相反，他的命令主要是在主数据库发生数据变化的时候，导致主从服务器的数据不一致的时候，让主从回到一致的过程\n\n\n同步#\n\n 1. 客户端先向从服务器发送 slaveof 命令，判断是否是第一次复制，如果是第一次复制一般都是刚开始组建主从关系\n 2. 如果是第一次复制，从服务器会向主服务器发送 PSYNC 命令，请求主服务器会执行完整的重同步操作。\n 3. 主服务器接到完整的请求之后，将在后台执行 BGSAVE 命令，后台生成一个 RDB 文件，同时会有一个积压缓冲区记录从现在开始执行的所有的写命令。\n 4. BGSAVE 命令执行之后，从服务器会接受到主服务器发送的 RDB 文件，同时主服务器还会向从服务器返回一个偏移量。\n 5. 如果不是第一次复制，那么说明从服务器可能是断线的，导致了主从数据库状态不一样，需要同步主服务器的数据。这个时候从服务器就会向主服务器发送一个之前记录得到\n    的偏移量，这样主服务器就会知道最后一次同步的是在哪个地方，从这个地方开始进行同步即可。\n 6. 由于之前从服务器可能出现断线的情况，所以主服务器需要发送 CONNECT\n    命令，表示将和从服务器执行同步部分数据的操作。但是，假如从服务器将偏移量丢失了呢？那么主服务器将会发起一个全量同步的操作\n 7. 主服务器接到 CONNECT 命令之后，会将积压缓冲区中的命令全部执行，然后将偏移量发送给从服务器，从服务器接到偏移量之后，就会开始执行同步操作。\n\n\n命令传播阶段#\n\n 1. 执行完同步之后，主从并不会一直保持着这个状态，加入主服务器执行了写的命令，那么就会将命令传输给从服务器，从服务器拿到了命令之后就会执行对应的操作。最后保\n    持主从一致的状态。\n 2. 在命令传播阶段，从服务器会以每秒一次的频率，向从服务器发送命令。作用主要是检测主从服务器的网络状态，辅助实现 min-slaves，检测命令丢失。","routePath":"/up/redis/README","lang":"","toc":[{"text":"何谓主从复制","id":"何谓主从复制","depth":2,"charIndex":-1},{"text":"基本原理","id":"基本原理","depth":2,"charIndex":277},{"text":"同步","id":"同步","depth":2,"charIndex":408},{"text":"命令传播阶段","id":"命令传播阶段","depth":2,"charIndex":983}],"domain":"","frontmatter":{"icon":"box","order":4,"author":"h7ml","category":"redis","tag":"redis","title":"redis","index":false,"dir":{"order":2},"date":"2019-07-24T00:00:00.000Z"},"version":""},{"id":513,"title":"redis","content":"何谓主从复制#\n\n 1. redis 的主从复制就是我们设置一个 master 服务器，然后设置多个 slave\n    从服务器，主服务器存储着最新的数据，每次主服务器的数据出现变化的时候，都会将对应的命令传输到各个 slave\n    服务器，这样，我们就可以实现主服务器和从服务器的数据的同步了。\n 2. 为什么需要？在企业的开发中，主从复制可以避免单机故障导致的数据和服务的丢失，保障了数据安全和服务的稳定运行。\n 3. 一个 master 可以有多个 slave，一个 slave 也可以有多个 slave，这样，最终可以构成一棵树的结构。\n\n\n基本原理#\n\n 1. Redis 的复制分为同步和命令传播阶段。同步操作作用于从服务器将从服务器的数据状态更新为主服务器的数据状态。\n 2. 命令传播则相反，他的命令主要是在主数据库发生数据变化的时候，导致主从服务器的数据不一致的时候，让主从回到一致的过程\n\n\n同步#\n\n 1. 客户端先向从服务器发送 slaveof 命令，判断是否是第一次复制，如果是第一次复制一般都是刚开始组建主从关系\n 2. 如果是第一次复制，从服务器会向主服务器发送 PSYNC 命令，请求主服务器会执行完整的重同步操作。\n 3. 主服务器接到完整的请求之后，将在后台执行 BGSAVE 命令，后台生成一个 RDB 文件，同时会有一个积压缓冲区记录从现在开始执行的所有的写命令。\n 4. BGSAVE 命令执行之后，从服务器会接受到主服务器发送的 RDB 文件，同时主服务器还会向从服务器返回一个偏移量。\n 5. 如果不是第一次复制，那么说明从服务器可能是断线的，导致了主从数据库状态不一样，需要同步主服务器的数据。这个时候从服务器就会向主服务器发送一个之前记录得到\n    的偏移量，这样主服务器就会知道最后一次同步的是在哪个地方，从这个地方开始进行同步即可。\n 6. 由于之前从服务器可能出现断线的情况，所以主服务器需要发送 CONNECT\n    命令，表示将和从服务器执行同步部分数据的操作。但是，假如从服务器将偏移量丢失了呢？那么主服务器将会发起一个全量同步的操作\n 7. 主服务器接到 CONNECT 命令之后，会将积压缓冲区中的命令全部执行，然后将偏移量发送给从服务器，从服务器接到偏移量之后，就会开始执行同步操作。\n\n\n命令传播阶段#\n\n 1. 执行完同步之后，主从并不会一直保持着这个状态，加入主服务器执行了写的命令，那么就会将命令传输给从服务器，从服务器拿到了命令之后就会执行对应的操作。最后保\n    持主从一致的状态。\n 2. 在命令传播阶段，从服务器会以每秒一次的频率，向从服务器发送命令。作用主要是检测主从服务器的网络状态，辅助实现 min-slaves，检测命令丢失。","routePath":"/up/redis/","lang":"","toc":[{"text":"何谓主从复制","id":"何谓主从复制","depth":2,"charIndex":-1},{"text":"基本原理","id":"基本原理","depth":2,"charIndex":277},{"text":"同步","id":"同步","depth":2,"charIndex":408},{"text":"命令传播阶段","id":"命令传播阶段","depth":2,"charIndex":983}],"domain":"","frontmatter":{"icon":"box","order":4,"author":"h7ml","category":"redis","tag":"redis","title":"redis","index":false,"dir":{"order":2},"date":"2019-07-24T00:00:00.000Z"},"version":""},{"id":514,"title":"redis实现分布式可重入锁","content":"不可重入锁#\n\n即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到而阻塞，直到当前线程释放锁后才能获取。\n\n\n可重入锁#\n\n可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。 就是同一个线程再次进入同样代码时，可以再次拿到该锁。\n\n\n可重入锁作用#\n\n防止在同一线程中多次获取锁而导致死锁发生\n\n> 在 java 的编程中 synchronized 和 ReentrantLock 都是可重入锁\n\n用一段 Java 代码解释可重入：\n\n\n\n假设 X 线程在 lockA 方法获取锁之后，继续执行 lockB 方法，如果此时不可重入，线程就必须等待锁释放，再次争抢锁。\n\n锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~\n\n\nReentrantLock 可重入锁源码思路#\n\n\n加锁#\n\n\n\n\n解锁#\n\n\n\n\n分布式重入锁（redisson 依然实现，但此处注重原理实现）#\n\n基于 ReentrantLock 的源码我们知道，它是加锁成功了，记录了当前持有锁的线程，并通过一个 int 类型的数字，来记录了加锁次数。我们知道\nReentrantLock 的实现原理了，那么 redis 只要下面两个问题解决，就能实现重入锁了：\n\n\n1.如何保存现有的线程#\n\nReentrantLock 使用的是当前线程内存地址进行对比，那么我们就可以使用线程的 ID 进行比较一样可以的。但是在分布式环境下，这个 ID\n就可能会存在重复，此时，我们需要增加一个全局的唯一 ID + 线程 ID 来做一个分布式线程比较。\n\n\n2.加锁次数（重入了多少次），怎么记录维护#\n\n他能记录下来加锁次数吗？如果 valus 值存的格式是：系进程 id+线程 id+加锁次数，那可以实现存没问题了，但是重入次数要怎么维护了，\n它肯定要保证原子性的，能解决吗？好像用 java 代码或者 lua 脚本都没法解决，因为都是实现都需要两步来维护这个重入次数的\n\n * 第一步：先获取到 valus 值，把取到加锁次数+1\n * 第二步：把新的值再设置进去在执行第二步操作之前，如果这个 key 失效了（设置持有锁超时了），如果还能再设置进去，就会有并发问题了\n\n\nRedisson 是如何实现的#\n\n我们跟一下 lock.lock()的代码，发现它最终调用的是 org.redisson.RedissonLock#tryLockInnerAsync\n的方法,具体如下：\n\n\n\n\n分析一下 redis 命令#\n\n 1. exists 查询一个 key 是否存在\n 2. hincrby ：将 hash 中指定域的值增加给定的数字\n 3. pexpire：设置 key 的有效时间以毫秒为单位\n 4. hexists：判断 field 是否存在于 hash 中\n 5. pttl：获取 key 的有效毫秒数\n 6. KEYS[1] = key 的值\n 7. ARGV[1]) = 持有锁的时间\n 8. ARGV[2] = getLockName(threadId) 下面 id 就算系统在启动的时候会全局生成的 uuid 来作为当前进程的 id，加上线程\n    id 就是 getLockName(threadId)了，可以理解为：进程 ID+系统 ID = ARGV[2] 主要也是使用了 lua\n    脚本来保证多个命令执行的原子性，使用了 hash 来实现了分布式锁\n\n\nlua 脚本的加锁流程#\n\n\n\n1、第一个 if 判断#\n\n\n\n2、下面来看第二个 if 判断#\n\n\n\n注意：分布式锁有过期时间，默认-1 的时候是需要自动续期的（redisson 有看门狗自动续期），当服务 down 机后自然自动释放解锁过程和\nReentrantlock 的解锁逻辑也基本相同没啥好说的了","routePath":"/up/redis/redis-lock","lang":"","toc":[{"text":"不可重入锁","id":"不可重入锁","depth":2,"charIndex":-1},{"text":"可重入锁","id":"可重入锁","depth":2,"charIndex":70},{"text":"可重入锁作用","id":"可重入锁作用","depth":3,"charIndex":155},{"text":"ReentrantLock 可重入锁源码思路","id":"reentrantlock-可重入锁源码思路","depth":2,"charIndex":374},{"text":"加锁","id":"加锁","depth":3,"charIndex":400},{"text":"解锁","id":"解锁","depth":3,"charIndex":408},{"text":"分布式重入锁（redisson 依然实现，但此处注重原理实现）","id":"分布式重入锁redisson-依然实现但此处注重原理实现","depth":2,"charIndex":416},{"text":"1.如何保存现有的线程","id":"1如何保存现有的线程","depth":3,"charIndex":578},{"text":"2.加锁次数（重入了多少次），怎么记录维护","id":"2加锁次数重入了多少次怎么记录维护","depth":3,"charIndex":717},{"text":"Redisson 是如何实现的","id":"redisson-是如何实现的","depth":2,"charIndex":978},{"text":"分析一下 redis 命令","id":"分析一下-redis-命令","depth":3,"charIndex":1085},{"text":"lua 脚本的加锁流程","id":"lua-脚本的加锁流程","depth":3,"charIndex":1485},{"text":"1、第一个 if 判断","id":"1第一个-if-判断","depth":4,"charIndex":1501},{"text":"2、下面来看第二个 if 判断","id":"2下面来看第二个-if-判断","depth":4,"charIndex":1517}],"domain":"","frontmatter":{"icon":"wrap","order":2,"date":"2019-08-05T00:00:00.000Z","author":"h7ml","title":"redis实现分布式可重入锁","category":"redis","tag":"redis","star":false},"version":""},{"id":515,"title":"Rust 基础概念","content":"#\n\n\n前言#\n\nRust 是一门系统编程语言，它的目标是提供一种安全、并发、实用的编程语言。Rust 的设计借鉴了现有的一些编程语言，如 C++、Haskell、OCaml\n等，但是它又有自己的特色，比如内存安全、线程安全等。本文旨在通过类比前端编程知识来解释 Rust 的语法\n\n\n变量和数据类型#\n\nRust 是一门静态类型语言，变量在使用前需声明，数据类型包括基本类型、复合类型和自定义类型。\n\n\n基本类型#\n\n * 整数：有符号和无符号，如 i32 和 u64。\n * 浮点数：单精度 f32 和双精度 f64。\n * 布尔值：bool，取值为 true 或 false。\n * 字符：char，使用单引号表示。\n\n整数#\n\nRust 的整数类型包括有符号和无符号两种类型，分别有 8、16、32、64 和 arch（与机器架构相关）五种位数。\n\n\n\n浮点数#\n\nRust 的浮点数类型包括单精度(f32)和双精度(f64)两种。\n\n\n\n布尔值#\n\nRust 的布尔值类型为 bool，有两个值：true 和 false。\n\n\n\n字符#\n\nRust 的字符类型为 char，使用单引号表示。\n\n\n\n\n复合类型#\n\n * 元组（tuple）：包含多个类型的值的组合。\n * 数组（array）：固定长度的相同类型元素集合。\n\n元组#\n\n元组是一个可以包含多个类型的值的组合，类似 TS 的元组。\n\n\n\n访问元组中的值可以使用模式匹配或者使用点号加索引。\n\n\n\n数组#\n\n数组是具有固定长度的相同类型元素的集合，类似 TS 的数组。\n\n\n\n访问数组中的元素可以使用索引。\n\n\n\n\n自定义类型#\n\n * 结构体（struct）：类似于 JavaScript 的对象。\n * 枚举（enum）：表示多种类型。\n * Trait：定义共享行为。\n\n结构体#\n\nRust 的结构体（struct）类似于 JavaScript 的对象。结构体可以包含多个字段，每个字段需要指定类型。\n\n\n\n枚举#\n\nRust 的枚举（enum）类似于 JavaScript 的类，但它可以表示多种类型。\n\n\n\nTrait#\n\nTrait 是 Rust 中的一种特殊类型，用于定义共享行为。Trait 可以被其他类型实现，从而获得 Trait 中定义的方法。\n\n\n\n\n控制流#\n\nRust 支持常见的控制流结构，如 if、else、while、for 等。\n\n\nif 和 else#\n\nRust 的 if 和 else 语法与 JavaScript 类似。\n\n\n\n\nwhile#\n\nRust 的 while 语法与 JavaScript 类似。\n\n\n\n\nfor#\n\nRust 的 for 语法可以用于遍历集合，如数组和范围。\n\n\n\n使用范围：\n\n\n\n\n函数#\n\nRust 的函数定义使用 fn 关键字，参数和返回值需指定类型。 返回值类型使用 -> 指定。\n\n\n\n这只是 Rust 语言的基本概念和语法，更多的功能和特性需要在实际项目中不断学习和探索。希望本文能为前端开发者提供一个 Rust 入门的参考。\n\n\n错误处理#\n\nRust 提供了一种强大的错误处理机制，可以帮助你编写健壮的代码。Rust 有两种错误类型：可恢复错误（recoverable\nerrors）和不可恢复错误（unrecoverable errors）。Rust 使用 Result 枚举处理可恢复错误；使用 panic!\n宏处理不可恢复错误。\n\n\n可恢复错误#\n\n可恢复错误是那些可以通过返回一个 Result 类型来处理的错误。Result 类型是一个枚举类型，有两个变体：Ok 和\nErr。例如在这个示例中，尝试打开一个文件。如果文件打开成功，将得到一个 Ok 变体，其中包含一个 File 对象。\n\n\n\nResult#\n\nResult 是一个枚举类型，用于表示可能出错的操作的结果。它有两个变体：Ok 和 Err。\n\n\n\n可以使用模式匹配来处理 Result 类型的值。\n\n\n\n\n不可恢复错误#\n\n不可恢复错误是那些无法通过返回一个 Result 类型来处理的错误。这类错误通常表示程序中的严重问题，需要立即终止程序的执行。在 Rust 中，可以使用\npanic! 宏来触发不可恢复错误。例如在这个示例中，使用 panic! 宏来触发一个不可恢复错误。当程序执行到这一行时，它将立即终止，并显示一个错误消息。\n\n\n\npanic!#\n\npanic! 是一个宏，用于在遇到不可恢复错误时终止程序。例如\n\n\n\n\n模块系统#\n\nRust 的模块系统用于组织和管理代码。模块系统包括以下几个部分：模块（module）、包（package）、库（library）和二进制（binary）。\n\n\n模块#\n\n模块是 Rust 中的命名空间，用于将相关的代码组织在一起。可以使用 mod 关键字定义模块。\n\n\n\n在一个模块中，可以使用 pub 关键字将函数、结构体、枚举等声明为公共的，这样它们就可以在其他模块中被访问。\n\n\n\n\n包和库#\n\n包（package）是一个包含一个或多个库（library）的项目。库是一组相关的模块。在 Rust 中，可以使用 Cargo 工具来创建和管理包和库。\n\n要创建一个新的包，可以使用 cargo new 命令\n\n这将创建一个名为 my_package 的新包，其中包含一个名为 my_package 的库。库的源代码位于 src/lib.rs 文件中。\n\n要在包中添加一个新的库，可以在 src 目录下创建一个新的子目录，并在其中创建一个 lib.rs 文件。\n\n\n二进制#\n\n二进制（binary）是一个可执行程序。在 Rust 中，可以使用 Cargo 工具来创建和管理二进制。\n\n要创建一个新的二进制，可以使用 cargo new --bin 命令：\n\ncargo new 这将创建一个名为 my_binary 的新二进制，其中包含一个名为 my_binary 的可执行程序。程序的源代码位于\nsrc/main.rs 文件中。\n\n要在包中添加一个新的二进制，可以在 src/bin 目录下创建一个新的 .rs 文件。\n\n\n所有权与借用#\n\n\n所有权(ownership)#\n\n所有权是 Rust 中的一个核心概念，用于管理内存。在 Rust\n中，每个值都有一个唯一的所有者，当所有者离开作用域时，值将被自动回收。这种机制可以避免内存泄漏和悬垂指针等问题。\n\n\n\n当一个值被赋值给另一个变量时，原变量将失去所有权，值的所有权将转移给新变量。\n\n\n\n\n借用(borrowing)#\n\n借用是 Rust 中的另一个核心概念，用于在不转移所有权的情况下访问值。借用有两种形式：可变借用（mutable\nborrowing）和不可变借用（immutable borrowing）。\n\n不可变借用#\n\n不可变借用是对值的只读访问。可以使用 & 符号创建不可变引用。\n\n\n\n可变借用#\n\n可变借用是对值的可写访问。可以使用 &mut 符号创建可变引用。\n\n\n\n注意：在同一作用域中\n\n\n并发编程#\n\nRust 提供了一些原生的并发编程特性，如线程、通道和互斥锁。这些特性可以编写高效且安全的并发代码。\n\n\n线程#\n\n线程是操作系统中的并发执行单元。在 Rust 中，可以使用 std::thread 模块创建和管理线程。\n\n\n\n\n通道#\n\n通道（channel）是一种用于在线程之间传递消息的同步原语。在 Rust 中，可以使用 std::sync::mpsc 模块创建和管理通道。\n\n\n\n\n互斥锁#\n\n互斥锁（mutex）是一种用于在线程之间同步访问共享资源的同步原语。在 Rust 中，可以使用 std::sync::Mutex 类型创建和管理互斥锁。\n\n\n\n在这个示例中，使用 Arc（原子引用计数）和 Mutex（互斥锁）来同步访问一个共享的 counter 变量。创建了 10 个线程，每个线程都尝试对\ncounter 进行加 1 操作。通过使用互斥锁，确保了在任何时刻只有一个线程可以访问 counter。","routePath":"/up/rust/","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"变量和数据类型","id":"变量和数据类型","depth":2,"charIndex":142},{"text":"基本类型","id":"基本类型","depth":3,"charIndex":202},{"text":"整数","id":"整数","depth":4,"charIndex":312},{"text":"浮点数","id":"浮点数","depth":4,"charIndex":380},{"text":"布尔值","id":"布尔值","depth":4,"charIndex":423},{"text":"字符","id":"字符","depth":4,"charIndex":469},{"text":"复合类型","id":"复合类型","depth":3,"charIndex":504},{"text":"元组","id":"元组","depth":4,"charIndex":566},{"text":"数组","id":"数组","depth":4,"charIndex":633},{"text":"自定义类型","id":"自定义类型","depth":3,"charIndex":692},{"text":"结构体","id":"结构体","depth":4,"charIndex":773},{"text":"枚举","id":"枚举","depth":4,"charIndex":842},{"text":"Trait","id":"trait","depth":4,"charIndex":894},{"text":"控制流","id":"控制流","depth":2,"charIndex":972},{"text":"if 和 else","id":"if-和-else","depth":3,"charIndex":1019},{"text":"while","id":"while","depth":3,"charIndex":1071},{"text":"for","id":"for","depth":3,"charIndex":1115},{"text":"函数","id":"函数","depth":2,"charIndex":1164},{"text":"错误处理","id":"错误处理","depth":2,"charIndex":1294},{"text":"可恢复错误","id":"可恢复错误","depth":3,"charIndex":1450},{"text":"Result","id":"result","depth":4,"charIndex":1581},{"text":"不可恢复错误","id":"不可恢复错误","depth":3,"charIndex":1669},{"text":"panic!","id":"panic","depth":4,"charIndex":1837},{"text":"模块系统","id":"模块系统","depth":2,"charIndex":1882},{"text":"模块","id":"模块","depth":3,"charIndex":1970},{"text":"包和库","id":"包和库","depth":3,"charIndex":2085},{"text":"二进制","id":"二进制","depth":3,"charIndex":2324},{"text":"所有权与借用","id":"所有权与借用","depth":2,"charIndex":2555},{"text":"所有权(ownership)","id":"所有权ownership","depth":3,"charIndex":2565},{"text":"借用(borrowing)","id":"借用borrowing","depth":3,"charIndex":2718},{"text":"不可变借用","id":"不可变借用","depth":4,"charIndex":2831},{"text":"可变借用","id":"可变借用","depth":4,"charIndex":2874},{"text":"并发编程","id":"并发编程","depth":2,"charIndex":2930},{"text":"线程","id":"线程","depth":3,"charIndex":2990},{"text":"通道","id":"通道","depth":3,"charIndex":3052},{"text":"互斥锁","id":"互斥锁","depth":3,"charIndex":3133}],"domain":"","frontmatter":{},"version":""}]